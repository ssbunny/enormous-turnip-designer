(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("numeric"), require("numeral"), require("jStat"));
	else if(typeof define === 'function' && define.amd)
		define(["numeric", "numeral", "jStat"], factory);
	else if(typeof exports === 'object')
		exports["formulajs"] = factory(require("numeric"), require("numeral"), require("jStat"));
	else
		root["formulajs"] = factory(root["numeric"], root["numeral"], root["jStat"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var categories = [
	  __webpack_require__(1),
	  __webpack_require__(15),
	  __webpack_require__(12),
	  __webpack_require__(16),
	  __webpack_require__(2),
	  __webpack_require__(7),
	  __webpack_require__(14),
	  __webpack_require__(17),
	  __webpack_require__(11),
	  __webpack_require__(18),
	  __webpack_require__(6),
	  __webpack_require__(10)
	];

	for (var c in categories) {
	  var category = categories[c];
	  for (var f in category) {
	    exports[f] = exports[f] || category[f];
	  }
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var mathTrig = __webpack_require__(2);
	var statistical = __webpack_require__(6);
	var engineering = __webpack_require__(12);
	var dateTime = __webpack_require__(14);

	function set(fn, root) {
	  if (root) {
	    for (var i in root) {
	      fn[i] = root[i];
	    }
	  }
	  return fn;
	}

	exports.BETADIST = statistical.BETA.DIST;
	exports.BETAINV = statistical.BETA.INV;
	exports.BINOMDIST = statistical.BINOM.DIST;
	exports.CEILING = exports.ISOCEILING = set(mathTrig.CEILING.MATH, mathTrig.CEILING);
	exports.CEILINGMATH = mathTrig.CEILING.MATH;
	exports.CEILINGPRECISE = mathTrig.CEILING.PRECISE;
	exports.CHIDIST = statistical.CHISQ.DIST;
	exports.CHIDISTRT = statistical.CHISQ.DIST.RT;
	exports.CHIINV = statistical.CHISQ.INV;
	exports.CHIINVRT = statistical.CHISQ.INV.RT;
	exports.CHITEST = statistical.CHISQ.TEST;
	exports.CONFIDENCE = set(statistical.CONFIDENCE.NORM, statistical.CONFIDENCE);
	exports.COVAR = statistical.COVARIANCE.P;
	exports.COVARIANCEP = statistical.COVARIANCE.P;
	exports.COVARIANCES = statistical.COVARIANCE.S;
	exports.CRITBINOM = statistical.BINOM.INV;
	exports.EXPONDIST = statistical.EXPON.DIST;
	exports.ERFCPRECISE = engineering.ERFC.PRECISE;
	exports.ERFPRECISE = engineering.ERF.PRECISE;
	exports.FDIST = statistical.F.DIST;
	exports.FDISTRT = statistical.F.DIST.RT;
	exports.FINVRT = statistical.F.INV.RT;
	exports.FINV = statistical.F.INV;
	exports.FLOOR = set(mathTrig.FLOOR.MATH, mathTrig.FLOOR);
	exports.FLOORMATH = mathTrig.FLOOR.MATH;
	exports.FLOORPRECISE = mathTrig.FLOOR.PRECISE;
	exports.FTEST = statistical.F.TEST;
	exports.GAMMADIST = statistical.GAMMA.DIST;
	exports.GAMMAINV = statistical.GAMMA.INV;
	exports.GAMMALNPRECISE = statistical.GAMMALN.PRECISE;
	exports.HYPGEOMDIST = statistical.HYPGEOM.DIST;
	exports.LOGINV = statistical.LOGNORM.INV;
	exports.LOGNORMINV = statistical.LOGNORM.INV;
	exports.LOGNORMDIST = statistical.LOGNORM.DIST;
	exports.MODE = set(statistical.MODE.SNGL, statistical.MODE);
	exports.MODEMULT = statistical.MODE.MULT;
	exports.MODESNGL = statistical.MODE.SNGL;
	exports.NEGBINOMDIST = statistical.NEGBINOM.DIST;
	exports.NETWORKDAYSINTL = dateTime.NETWORKDAYS.INTL;
	exports.NORMDIST = statistical.NORM.DIST;
	exports.NORMINV = statistical.NORM.INV;
	exports.NORMSDIST = statistical.NORM.S.DIST;
	exports.NORMSINV = statistical.NORM.S.INV;
	exports.PERCENTILE = set(statistical.PERCENTILE.EXC, statistical.PERCENTILE);
	exports.PERCENTILEEXC = statistical.PERCENTILE.EXC;
	exports.PERCENTILEINC = statistical.PERCENTILE.INC;
	exports.PERCENTRANK = set(statistical.PERCENTRANK.INC, statistical.PERCENTRANK);
	exports.PERCENTRANKEXC = statistical.PERCENTRANK.EXC;
	exports.PERCENTRANKINC = statistical.PERCENTRANK.INC;
	exports.POISSON = set(statistical.POISSON.DIST, statistical.POISSON);
	exports.POISSONDIST = statistical.POISSON.DIST;
	exports.QUARTILE = set(statistical.QUARTILE.INC, statistical.QUARTILE);
	exports.QUARTILEEXC = statistical.QUARTILE.EXC;
	exports.QUARTILEINC = statistical.QUARTILE.INC;
	exports.RANK = set(statistical.RANK.EQ, statistical.RANK);
	exports.RANKAVG = statistical.RANK.AVG;
	exports.RANKEQ = statistical.RANK.EQ;
	exports.SKEWP = statistical.SKEW.P;
	exports.STDEV = set(statistical.STDEV.S, statistical.STDEV);
	exports.STDEVP = statistical.STDEV.P;
	exports.STDEVS = statistical.STDEV.S;
	exports.TDIST = statistical.T.DIST;
	exports.TDISTRT = statistical.T.DIST.RT;
	exports.TINV = statistical.T.INV;
	exports.TTEST = statistical.T.TEST;
	exports.VAR = set(statistical.VAR.S, statistical.VAR);
	exports.VARP = statistical.VAR.P;
	exports.VARS = statistical.VAR.S;
	exports.WEIBULL = set(statistical.WEIBULL.DIST, statistical.WEIBULL);
	exports.WEIBULLDIST = statistical.WEIBULL.DIST;
	exports.WORKDAYINTL = dateTime.WORKDAY.INTL;
	exports.ZTEST = statistical.Z.TEST;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var numeric = __webpack_require__(3);
	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var statistical = __webpack_require__(6);
	var information = __webpack_require__(11);

	exports.ABS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.abs(utils.parseNumber(number));
	};

	exports.ACOS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.acos(number);
	};

	exports.ACOSH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number + Math.sqrt(number * number - 1));
	};

	exports.ACOT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.atan(1 / number);
	};

	exports.ACOTH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 0.5 * Math.log((number + 1) / (number - 1));
	};

	//TODO: use options
	exports.AGGREGATE = function(function_num, options, ref1, ref2) {
	  function_num = utils.parseNumber(function_num);
	  options = utils.parseNumber(function_num);
	  if (utils.anyIsError(function_num, options)) {
	    return error.value;
	  }
	  switch (function_num) {
	    case 1:
	      return statistical.AVERAGE(ref1);
	    case 2:
	      return statistical.COUNT(ref1);
	    case 3:
	      return statistical.COUNTA(ref1);
	    case 4:
	      return statistical.MAX(ref1);
	    case 5:
	      return statistical.MIN(ref1);
	    case 6:
	      return exports.PRODUCT(ref1);
	    case 7:
	      return statistical.STDEV.S(ref1);
	    case 8:
	      return statistical.STDEV.P(ref1);
	    case 9:
	      return exports.SUM(ref1);
	    case 10:
	      return statistical.VAR.S(ref1);
	    case 11:
	      return statistical.VAR.P(ref1);
	    case 12:
	      return statistical.MEDIAN(ref1);
	    case 13:
	      return statistical.MODE.SNGL(ref1);
	    case 14:
	      return statistical.LARGE(ref1, ref2);
	    case 15:
	      return statistical.SMALL(ref1, ref2);
	    case 16:
	      return statistical.PERCENTILE.INC(ref1, ref2);
	    case 17:
	      return statistical.QUARTILE.INC(ref1, ref2);
	    case 18:
	      return statistical.PERCENTILE.EXC(ref1, ref2);
	    case 19:
	      return statistical.QUARTILE.EXC(ref1, ref2);
	  }
	};

	exports.ARABIC = function(text) {
	  // Credits: Rafa? Kukawski
	  if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
	    return error.value;
	  }
	  var r = 0;
	  text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i) {
	    r += {
	      M: 1000,
	      CM: 900,
	      D: 500,
	      CD: 400,
	      C: 100,
	      XC: 90,
	      L: 50,
	      XL: 40,
	      X: 10,
	      IX: 9,
	      V: 5,
	      IV: 4,
	      I: 1
	    }[i];
	  });
	  return r;
	};

	exports.ASIN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.asin(number);
	};

	exports.ASINH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number + Math.sqrt(number * number + 1));
	};

	exports.ATAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.atan(number);
	};

	exports.ATAN2 = function(number_x, number_y) {
	  number_x = utils.parseNumber(number_x);
	  number_y = utils.parseNumber(number_y);
	  if (utils.anyIsError(number_x, number_y)) {
	    return error.value;
	  }
	  return Math.atan2(number_x, number_y);
	};

	exports.ATANH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log((1 + number) / (1 - number)) / 2;
	};

	exports.BASE = function(number, radix, min_length) {
	  min_length = min_length || 0;

	  number = utils.parseNumber(number);
	  radix = utils.parseNumber(radix);
	  min_length = utils.parseNumber(min_length);
	  if (utils.anyIsError(number, radix, min_length)) {
	    return error.value;
	  }
	  min_length = (min_length === undefined) ? 0 : min_length;
	  var result = number.toString(radix);
	  return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;
	};

	exports.CEILING = function(number, significance, mode) {
	  significance = (significance === undefined) ? 1 : Math.abs(significance);
	  mode = mode || 0;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.anyIsError(number, significance, mode)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.ceil(number / significance) * significance, precision);
	  } else {
	    if (mode === 0) {
	      return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	    } else {
	      return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	    }
	  }
	};

	exports.CEILING.MATH = exports.CEILING;

	exports.CEILING.PRECISE = exports.CEILING;

	exports.COMBIN = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return exports.FACT(number) / (exports.FACT(number_chosen) * exports.FACT(number - number_chosen));
	};

	exports.COMBINA = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return (number === 0 && number_chosen === 0) ? 1 : exports.COMBIN(number + number_chosen - 1, number - 1);
	};

	exports.COS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.cos(number);
	};

	exports.COSH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return (Math.exp(number) + Math.exp(-number)) / 2;
	};

	exports.COT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.tan(number);
	};

	exports.COTH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var e2 = Math.exp(2 * number);
	  return (e2 + 1) / (e2 - 1);
	};

	exports.CSC = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.sin(number);
	};

	exports.CSCH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 2 / (Math.exp(number) - Math.exp(-number));
	};

	exports.DECIMAL = function(number, radix) {
	  if (arguments.length < 1) {
	    return error.value;
	  }


	  return parseInt(number, radix);
	};

	exports.DEGREES = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return number * 180 / Math.PI;
	};

	exports.EVEN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return exports.CEILING(number, -2, -1);
	};

	exports.EXP = Math.exp;

	var MEMOIZED_FACT = [];
	exports.FACT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var n = Math.floor(number);
	  if (n === 0 || n === 1) {
	    return 1;
	  } else if (MEMOIZED_FACT[n] > 0) {
	    return MEMOIZED_FACT[n];
	  } else {
	    MEMOIZED_FACT[n] = exports.FACT(n - 1) * n;
	    return MEMOIZED_FACT[n];
	  }
	};

	exports.FACTDOUBLE = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var n = Math.floor(number);
	  if (n <= 0) {
	    return 1;
	  } else {
	    return n * exports.FACTDOUBLE(n - 2);
	  }
	};

	exports.FLOOR = function(number, significance) {
	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(number, significance)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }

	  if (!(number > 0 && significance > 0) && !(number < 0 && significance < 0)) {
	    return error.num;
	  }

	  significance = Math.abs(significance);
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.floor(number / significance) * significance, precision);
	  } else {
	    return -exports.ROUND(Math.ceil(Math.abs(number) / significance), precision);
	  }
	};

	//TODO: Verify
	exports.FLOOR.MATH = function(number, significance, mode) {
	  significance = (significance === undefined) ? 1 : significance;
	  mode = (mode === undefined) ? 0 : mode;

	  number = utils.parseNumber(number);
	  significance = utils.parseNumber(significance);
	  mode = utils.parseNumber(mode);
	  if (utils.anyIsError(number, significance, mode)) {
	    return error.value;
	  }
	  if (significance === 0) {
	    return 0;
	  }

	  significance = significance ? Math.abs(significance) : 1;
	  var precision = -Math.floor(Math.log(significance) / Math.log(10));
	  if (number >= 0) {
	    return exports.ROUND(Math.floor(number / significance) * significance, precision);
	  } else if (mode === 0 || mode === undefined) {
	    return -exports.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
	  }
	  return -exports.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
	};

	// Deprecated
	exports.FLOOR.PRECISE = exports.FLOOR.MATH;

	// adapted http://rosettacode.org/wiki/Greatest_common_divisor#JavaScript
	exports.GCD = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var r0 = range[0];
	  var x = r0 < 0 ? -r0 : r0;
	  for (var i = 1; i < n; i++) {
	    var ri = range[i];
	    var y = ri < 0 ? -ri : ri;
	    while (x && y) {
	      if (x > y) {
	        x %= y;
	      } else {
	        y %= x;
	      }
	    }
	    x += y;
	  }
	  return x;
	};


	exports.INT = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.floor(number);
	};

	//TODO: verify
	exports.ISO = {
	  CEILING: exports.CEILING
	};

	exports.LCM = function() {
	  // Credits: Jonas Raoni Soares Silva
	  var o = utils.parseNumberArray(utils.flatten(arguments));
	  if (o instanceof Error) {
	    return o;
	  }
	  for (var i, j, n, d, r = 1;
	    (n = o.pop()) !== undefined;) {
	    while (n > 1) {
	      if (n % 2) {
	        for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
	          //empty
	        }
	        d = (i <= j) ? i : n;
	      } else {
	        d = 2;
	      }
	      for (n /= d, r *= d, i = o.length; i;
	        (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
	        //empty
	      }
	    }
	  }
	  return r;
	};

	exports.LN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number);
	};

	exports.LOG = function(number, base) {
	  number = utils.parseNumber(number);
	  base = utils.parseNumber(base);
	  if (utils.anyIsError(number, base)) {
	    return error.value;
	  }
	  base = (base === undefined) ? 10 : base;
	  return Math.log(number) / Math.log(base);
	};

	exports.LOG10 = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.log(number) / Math.log(10);
	};

	exports.MDETERM = function(matrix) {
	  matrix = utils.parseMatrix(matrix);
	  if (matrix instanceof Error) {
	    return matrix;
	  }
	  return numeric.det(matrix);
	};

	exports.MINVERSE = function(matrix) {
	  matrix = utils.parseMatrix(matrix);
	  if (matrix instanceof Error) {
	    return matrix;
	  }
	  return numeric.inv(matrix);
	};

	exports.MMULT = function(matrix1, matrix2) {
	  matrix1 = utils.parseMatrix(matrix1);
	  matrix2 = utils.parseMatrix(matrix2);
	  if (utils.anyIsError(matrix1, matrix2)) {
	    return error.value;
	  }
	  return numeric.dot(matrix1, matrix2);
	};

	exports.MOD = function(dividend, divisor) {
	  dividend = utils.parseNumber(dividend);
	  divisor = utils.parseNumber(divisor);
	  if (utils.anyIsError(dividend, divisor)) {
	    return error.value;
	  }
	  if (divisor === 0) {
	    return error.div0;
	  }
	  var modulus = Math.abs(dividend % divisor);
	  return (divisor > 0) ? modulus : -modulus;
	};

	  exports.MROUND = function(number, multiple) {
	  number = utils.parseNumber(number);
	  multiple = utils.parseNumber(multiple);
	  if (utils.anyIsError(number, multiple)) {
	    return error.value;
	  }
	  if (number * multiple < 0) {
	    return error.num;
	  }

	  return Math.round(number / multiple) * multiple;
	};

	exports.MULTINOMIAL = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  var sum = 0;
	  var divisor = 1;
	  for (var i = 0; i < args.length; i++) {
	    sum += args[i];
	    divisor *= exports.FACT(args[i]);
	  }
	  return exports.FACT(sum) / divisor;
	};

	exports.MUNIT = function(dimension) {
	  dimension = utils.parseNumber(dimension);
	  if (dimension instanceof Error) {
	    return dimension;
	  }
	  return numeric.identity(dimension);
	};

	exports.ODD = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var temp = Math.ceil(Math.abs(number));
	  temp = (temp & 1) ? temp : temp + 1;
	  return (number > 0) ? temp : -temp;
	};

	exports.PI = function() {
	  return Math.PI;
	};

	exports.POWER = function(number, power) {
	  number = utils.parseNumber(number);
	  power = utils.parseNumber(power);
	  if (utils.anyIsError(number, power)) {
	    return error.value;
	  }
	  var result = Math.pow(number, power);
	  if (isNaN(result)) {
	    return error.num;
	  }

	  return result;
	};

	exports.PRODUCT = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  var result = 1;
	  for (var i = 0; i < args.length; i++) {
	    result *= args[i];
	  }
	  return result;
	};

	exports.QUOTIENT = function(numerator, denominator) {
	  numerator = utils.parseNumber(numerator);
	  denominator = utils.parseNumber(denominator);
	  if (utils.anyIsError(numerator, denominator)) {
	    return error.value;
	  }
	  return parseInt(numerator / denominator, 10);
	};

	exports.RADIANS = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return number * Math.PI / 180;
	};

	exports.RAND = function() {
	  return Math.random();
	};

	exports.RANDBETWEEN = function(bottom, top) {
	  bottom = utils.parseNumber(bottom);
	  top = utils.parseNumber(top);
	  if (utils.anyIsError(bottom, top)) {
	    return error.value;
	  }
	  // Creative Commons Attribution 3.0 License
	  // Copyright (c) 2012 eqcode
	  return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
	};

	// TODO
	exports.ROMAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  // The MIT License
	  // Copyright (c) 2008 Steven Levithan
	  var digits = String(number).split('');
	  var key = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
	  var roman = '';
	  var i = 3;
	  while (i--) {
	    roman = (key[+digits.pop() + (i * 10)] || '') + roman;
	  }
	  return new Array(+digits.join('') + 1).join('M') + roman;
	};

	exports.ROUND = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
	};

	exports.ROUNDDOWN = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

	exports.ROUNDUP = function(number, digits) {
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.ceil(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

	exports.SEC = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 1 / Math.cos(number);
	};

	exports.SECH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return 2 / (Math.exp(number) + Math.exp(-number));
	};

	exports.SERIESSUM = function(x, n, m, coefficients) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  m = utils.parseNumber(m);
	  coefficients = utils.parseNumberArray(coefficients);
	  if (utils.anyIsError(x, n, m, coefficients)) {
	    return error.value;
	  }
	  var result = coefficients[0] * Math.pow(x, n);
	  for (var i = 1; i < coefficients.length; i++) {
	    result += coefficients[i] * Math.pow(x, n + i * m);
	  }
	  return result;
	};

	exports.SIGN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  if (number < 0) {
	    return -1;
	  } else if (number === 0) {
	    return 0;
	  } else {
	    return 1;
	  }
	};

	exports.SIN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.sin(number);
	};

	  exports.SINH = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    return (Math.exp(number) - Math.exp(-number)) / 2;
	  };

	  exports.SQRT = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    if (number < 0) {
	      return error.num;
	    }
	    return Math.sqrt(number);
	  };

	  exports.SQRTPI = function(number) {
	    number = utils.parseNumber(number);
	    if (number instanceof Error) {
	      return number;
	    }
	    return Math.sqrt(number * Math.PI);
	  };

	exports.SUBTOTAL = function(function_code, ref1) {
	  function_code = utils.parseNumber(function_code);
	  if (function_code instanceof Error) {
	    return function_code;
	  }
	  switch (function_code) {
	    case 1:
	      return statistical.AVERAGE(ref1);
	    case 2:
	      return statistical.COUNT(ref1);
	    case 3:
	      return statistical.COUNTA(ref1);
	    case 4:
	      return statistical.MAX(ref1);
	    case 5:
	      return statistical.MIN(ref1);
	    case 6:
	      return exports.PRODUCT(ref1);
	    case 7:
	      return statistical.STDEV.S(ref1);
	    case 8:
	      return statistical.STDEV.P(ref1);
	    case 9:
	      return exports.SUM(ref1);
	    case 10:
	      return statistical.VAR.S(ref1);
	    case 11:
	      return statistical.VAR.P(ref1);
	      // no hidden values for us
	    case 101:
	      return statistical.AVERAGE(ref1);
	    case 102:
	      return statistical.COUNT(ref1);
	    case 103:
	      return statistical.COUNTA(ref1);
	    case 104:
	      return statistical.MAX(ref1);
	    case 105:
	      return statistical.MIN(ref1);
	    case 106:
	      return exports.PRODUCT(ref1);
	    case 107:
	      return statistical.STDEV.S(ref1);
	    case 108:
	      return statistical.STDEV.P(ref1);
	    case 109:
	      return exports.SUM(ref1);
	    case 110:
	      return statistical.VAR.S(ref1);
	    case 111:
	      return statistical.VAR.P(ref1);

	  }
	};

	exports.ADD = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.value;
	  }

	  return num1 + num2;
	};

	exports.MINUS = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.value;
	  }

	  return num1 - num2;
	};

	exports.DIVIDE = function (dividend, divisor) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  dividend = utils.parseNumber(dividend);
	  divisor = utils.parseNumber(divisor);
	  if (utils.anyIsError(dividend, divisor)) {
	    return error.value;
	  }

	  if (divisor === 0) {
	    return error.div0;
	  }

	  return dividend / divisor;
	};

	exports.MULTIPLY = function (factor1, factor2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  factor1 = utils.parseNumber(factor1);
	  factor2 = utils.parseNumber(factor2);
	  if (utils.anyIsError(factor1, factor2)) {
	    return error.value;
	  }

	  return factor1 * factor2;
	};

	exports.GTE = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 >= num2;
	};

	exports.LT = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 < num2;
	};


	exports.LTE = function (num1, num2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  num1 = utils.parseNumber(num1);
	  num2 = utils.parseNumber(num2);
	  if (utils.anyIsError(num1, num2)) {
	    return error.error;
	  }

	  return num1 <= num2;
	};

	exports.EQ = function (value1, value2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  return value1 === value2;
	};

	exports.NE = function (value1, value2) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  return value1 !== value2;
	};

	exports.POW = function (base, exponent) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  base = utils.parseNumber(base);
	  exponent = utils.parseNumber(exponent);
	  if (utils.anyIsError(base, exponent)) {
	    return error.error;
	  }

	  return exports.POWER(base, exponent);
	};

	exports.SUM = function() {
	  var result = 0;
	  var argsKeys = Object.keys(arguments);
	  for (var i = 0; i < argsKeys.length; ++i) {
	    var elt = arguments[argsKeys[i]];
	    if (typeof elt === 'number') {
	      result += elt;
	    } else if (typeof elt === 'string') {
	      var parsed = parseFloat(elt);
	      !isNaN(parsed) && (result += parsed);
	    } else if (Array.isArray(elt)) {
	      result += exports.SUM.apply(null, elt);
	    }
	  }
	  return result;
	};

	exports.SUMIF = function(range, criteria) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (range instanceof Error) {
	    return range;
	  }
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    result += (eval(range[i] + criteria)) ? range[i] : 0; // jshint ignore:line
	  }
	  return result;
	};

	exports.SUMIFS = function() {
	  var args = utils.argsToArray(arguments);
	  var range = utils.parseNumberArray(utils.flatten(args.shift()));
	  if (range instanceof Error) {
	    return range;
	  }
	  var criteria = args;

	  var n_range_elements = range.length;
	  var n_criterias = criteria.length;

	  var result = 0;
	  for (var i = 0; i < n_range_elements; i++) {
	    var el = range[i];
	    var condition = '';
	    for (var c = 0; c < n_criterias; c++) {
	      condition += el + criteria[c];
	      if (c !== n_criterias - 1) {
	        condition += '&&';
	      }
	    }
	    if (eval(condition)) { // jshint ignore:line
	      result += el;
	    }
	  }
	  return result;
	};

	exports.SUMPRODUCT = function() {
	  if (!arguments || arguments.length === 0) {
	    return error.value;
	  }
	  var arrays = arguments.length + 1;
	  var result = 0;
	  var product;
	  var k;
	  var _i;
	  var _ij;
	  for (var i = 0; i < arguments[0].length; i++) {
	    if (!(arguments[0][i] instanceof Array)) {
	      product = 1;
	      for (k = 1; k < arrays; k++) {
	        _i = utils.parseNumber(arguments[k - 1][i]);
	        if (_i instanceof Error) {
	          return _i;
	        }
	        product *= _i;
	      }
	      result += product;
	    } else {
	      for (var j = 0; j < arguments[0][i].length; j++) {
	        product = 1;
	        for (k = 1; k < arrays; k++) {
	          _ij = utils.parseNumber(arguments[k - 1][i][j]);
	          if (_ij instanceof Error) {
	            return _ij;
	          }
	          product *= _ij;
	        }
	        result += product;
	      }
	    }
	  }
	  return result;
	};

	exports.SUMSQ = function() {
	  var numbers = utils.parseNumberArray(utils.flatten(arguments));
	  if (numbers instanceof Error) {
	    return numbers;
	  }
	  var result = 0;
	  var length = numbers.length;
	  for (var i = 0; i < length; i++) {
	    result += (information.ISNUMBER(numbers[i])) ? numbers[i] * numbers[i] : 0;
	  }
	  return result;
	};

	exports.SUMX2MY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  for (var i = 0; i < array_x.length; i++) {
	    result += array_x[i] * array_x[i] - array_y[i] * array_y[i];
	  }
	  return result;
	};

	exports.SUMX2PY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  for (var i = 0; i < array_x.length; i++) {
	    result += array_x[i] * array_x[i] + array_y[i] * array_y[i];
	  }
	  return result;
	};

	exports.SUMXMY2 = function(array_x, array_y) {
	  array_x = utils.parseNumberArray(utils.flatten(array_x));
	  array_y = utils.parseNumberArray(utils.flatten(array_y));
	  if (utils.anyIsError(array_x, array_y)) {
	    return error.value;
	  }
	  var result = 0;
	  array_x = utils.flatten(array_x);
	  array_y = utils.flatten(array_y);
	  for (var i = 0; i < array_x.length; i++) {
	    result += Math.pow(array_x[i] - array_y[i], 2);
	  }
	  return result;
	};

	exports.TAN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return Math.tan(number);
	};

	exports.TANH = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  var e2 = Math.exp(2 * number);
	  return (e2 - 1) / (e2 + 1);
	};

	exports.TRUNC = function(number, digits) {
	  digits = (digits === undefined) ? 0 : digits;
	  number = utils.parseNumber(number);
	  digits = utils.parseNumber(digits);
	  if (utils.anyIsError(number, digits)) {
	    return error.value;
	  }
	  var sign = (number > 0) ? 1 : -1;
	  return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
	};

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	function flattenShallow(array) {
	  if (!array || !array.reduce) { return array; }
	  return array.reduce(function(a, b) {
	    var aIsArray = Array.isArray(a);
	    var bIsArray = Array.isArray(b);
	    if (aIsArray && bIsArray ) {
	      return a.concat(b);
	    }
	    if (aIsArray) {
	      a.push(b);
	      return a;
	    }
	    if (bIsArray) {
	      return [a].concat(b);
	    }
	    return [a, b];
	  });
	}

	function isFlat(array) {
	  if (!array) { return false; }
	  for (var i = 0; i < array.length; ++i) {
	    if (Array.isArray(array[i])) {
	      return false;
	    }
	  }
	  return true;
	}

	exports.flatten = function() {
	  var result = exports.argsToArray.apply(null, arguments);
	  while (!isFlat(result)) {
	    result = flattenShallow(result);
	  }
	  return result;
	};

	exports.argsToArray = function(args) {
	  return Array.prototype.slice.call(args, 0);
	};

	exports.numbers = function() {
	  var possibleNumbers = this.flatten.apply(null, arguments);
	  return possibleNumbers.filter(function(el) {
	    return typeof el === 'number';
	  });
	};

	exports.cleanFloat = function(number) {
	  var power = 1e14;
	  return Math.round(number * power) / power;
	};

	exports.parseBool = function(bool) {
	  if (typeof bool === 'boolean') {
	    return bool;
	  }

	  if (bool instanceof Error) {
	    return bool;
	  }

	  if (typeof bool === 'number') {
	    return bool !== 0;
	  }

	  if (typeof bool === 'string') {
	    var up = bool.toUpperCase();
	    if (up === 'TRUE') {
	      return true;
	    }

	    if (up === 'FALSE') {
	      return false;
	    }
	  }

	  if (bool instanceof Date && !isNaN(bool)) {
	    return true;
	  }

	  return error.value;
	};

	exports.parseNumber = function(string) {
	  if (string === undefined || string === '') {
	    return error.value;
	  }
	  if (!isNaN(string)) {
	    return parseFloat(string);
	  }
	  return error.value;
	};

	exports.parseNumberArray = function(arr) {
	  var len;
	  if (!arr || (len = arr.length) === 0) {
	    return error.value;
	  }
	  var parsed;
	  while (len--) {
	    parsed = exports.parseNumber(arr[len]);
	    if (parsed === error.value) {
	      return parsed;
	    }
	    arr[len] = parsed;
	  }
	  return arr;
	};

	exports.parseMatrix = function(matrix) {
	  var n;
	  if (!matrix || (n = matrix.length) === 0) {
	    return error.value;
	  }
	  var pnarr;
	  for (var i = 0; i < matrix.length; i++) {
	    pnarr = exports.parseNumberArray(matrix[i]);
	    matrix[i] = pnarr;
	    if (pnarr instanceof Error) {
	      return pnarr;
	    }
	  }
	  return matrix;
	};

	var d1900 = new Date(1900, 0, 1);
	exports.parseDate = function(date) {
	  if (!isNaN(date)) {
	    if (date instanceof Date) {
	      return new Date(date);
	    }
	    var d = parseInt(date, 10);
	    if (d < 0) {
	      return error.num;
	    }
	    if (d <= 60) {
	      return new Date(d1900.getTime() + (d - 1) * 86400000);
	    }
	    return new Date(d1900.getTime() + (d - 2) * 86400000);
	  }
	  if (typeof date === 'string') {
	    date = new Date(date);
	    if (!isNaN(date)) {
	      return date;
	    }
	  }
	  return error.value;
	};

	exports.parseDateArray = function(arr) {
	  var len = arr.length;
	  var parsed;
	  while (len--) {
	    parsed = this.parseDate(arr[len]);
	    if (parsed === error.value) {
	      return parsed;
	    }
	    arr[len] = parsed;
	  }
	  return arr;
	};

	exports.anyIsError = function() {
	  var n = arguments.length;
	  while (n--) {
	    if (arguments[n] instanceof Error) {
	      return true;
	    }
	  }
	  return false;
	};

	exports.arrayValuesToNumbers = function(arr) {
	  var n = arr.length;
	  var el;
	  while (n--) {
	    el = arr[n];
	    if (typeof el === 'number') {
	      continue;
	    }
	    if (el === true) {
	      arr[n] = 1;
	      continue;
	    }
	    if (el === false) {
	      arr[n] = 0;
	      continue;
	    }
	    if (typeof el === 'string') {
	      var number = this.parseNumber(el);
	      if (number instanceof Error) {
	        arr[n] = 0;
	      } else {
	        arr[n] = number;
	      }
	    }
	  }
	  return arr;
	};

	exports.rest = function(array, idx) {
	  idx = idx || 1;
	  if (!array || typeof array.slice !== 'function') {
	    return array;
	  }
	  return array.slice(idx);
	};

	exports.initial = function(array, idx) {
	  idx = idx || 1;
	  if (!array || typeof array.slice !== 'function') {
	    return array;
	  }
	  return array.slice(0, array.length - idx);
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	exports.nil = new Error('#NULL!');
	exports.div0 = new Error('#DIV/0!');
	exports.value = new Error('#VALUE?');
	exports.ref = new Error('#REF!');
	exports.name = new Error('#NAME?');
	exports.num = new Error('#NUM!');
	exports.na = new Error('#N/A');
	exports.error = new Error('#ERROR!');
	exports.data = new Error('#GETTING_DATA');


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var mathTrig = __webpack_require__(2);
	var text = __webpack_require__(7);
	var jStat = __webpack_require__(9).jStat;
	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var misc = __webpack_require__(10);

	var SQRT2PI = 2.5066282746310002;

	exports.AVEDEV = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  return jStat.sum(jStat(range).subtract(jStat.mean(range)).abs()[0]) / range.length;
	};

	exports.AVERAGE = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sum = 0;
	  var count = 0;
	  for (var i = 0; i < n; i++) {
	    sum += range[i];
	    count += 1;
	  }
	  return sum / count;
	};

	exports.AVERAGEA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sum = 0;
	  var count = 0;
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sum += el;
	    }
	    if (el === true) {
	      sum++;
	    }
	    if (el !== null) {
	      count++;
	    }
	  }
	  return sum / count;
	};

	exports.AVERAGEIF = function(range, criteria, average_range) {
	  average_range = average_range || range;
	  range = utils.flatten(range);
	  average_range = utils.parseNumberArray(utils.flatten(average_range));
	  if (average_range instanceof Error) {
	    return average_range;
	  }
	  var average_count = 0;
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (eval(range[i] + criteria)) { // jshint ignore:line
	      result += average_range[i];
	      average_count++;
	    }
	  }
	  return result / average_count;
	};

	exports.AVERAGEIFS = function() {
	  // Does not work with multi dimensional ranges yet!
	  //http://office.microsoft.com/en-001/excel-help/averageifs-function-HA010047493.aspx
	  var args = utils.argsToArray(arguments);
	  var criteria = (args.length - 1) / 2;
	  var range = utils.flatten(args[0]);
	  var count = 0;
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    var condition = '';
	    for (var j = 0; j < criteria; j++) {
	      condition += args[2 * j + 1][i] + args[2 * j + 2];
	      if (j !== criteria - 1) {
	        condition += '&&';
	      }
	    }
	    if (eval(condition)) { // jshint ignore:line
	      result += range[i];
	      count++;
	    }
	  }

	  var average = result / count;
	  if (isNaN(average)) {
	    return 0;
	  } else {
	    return average;
	  }
	};

	exports.BETA = {};

	exports.BETA.DIST = function(x, alpha, beta, cumulative, A, B) {
	  if (arguments.length < 4) {
	    return error.value;
	  }

	  A = (A === undefined) ? 0 : A;
	  B = (B === undefined) ? 1 : B;

	  x = utils.parseNumber(x);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  A = utils.parseNumber(A);
	  B = utils.parseNumber(B);
	  if (utils.anyIsError(x, alpha, beta, A, B)) {
	    return error.value;
	  }

	  x = (x - A) / (B - A);
	  return (cumulative) ? jStat.beta.cdf(x, alpha, beta) : jStat.beta.pdf(x, alpha, beta);
	};

	exports.BETA.INV = function(probability, alpha, beta, A, B) {
	  A = (A === undefined) ? 0 : A;
	  B = (B === undefined) ? 1 : B;

	  probability = utils.parseNumber(probability);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  A = utils.parseNumber(A);
	  B = utils.parseNumber(B);
	  if (utils.anyIsError(probability, alpha, beta, A, B)) {
	    return error.value;
	  }

	  return jStat.beta.inv(probability, alpha, beta) * (B - A) + A;
	};

	exports.BINOM = {};

	exports.BINOM.DIST = function(successes, trials, probability, cumulative) {
	  successes = utils.parseNumber(successes);
	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  cumulative = utils.parseNumber(cumulative);
	  if (utils.anyIsError(successes, trials, probability, cumulative)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.binomial.cdf(successes, trials, probability) : jStat.binomial.pdf(successes, trials, probability);
	};

	exports.BINOM.DIST.RANGE = function(trials, probability, successes, successes2) {
	  successes2 = (successes2 === undefined) ? successes : successes2;

	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  successes = utils.parseNumber(successes);
	  successes2 = utils.parseNumber(successes2);
	  if (utils.anyIsError(trials, probability, successes, successes2)) {
	    return error.value;
	  }

	  var result = 0;
	  for (var i = successes; i <= successes2; i++) {
	    result += mathTrig.COMBIN(trials, i) * Math.pow(probability, i) * Math.pow(1 - probability, trials - i);
	  }
	  return result;
	};

	exports.BINOM.INV = function(trials, probability, alpha) {
	  trials = utils.parseNumber(trials);
	  probability = utils.parseNumber(probability);
	  alpha = utils.parseNumber(alpha);
	  if (utils.anyIsError(trials, probability, alpha)) {
	    return error.value;
	  }

	  var x = 0;
	  while (x <= trials) {
	    if (jStat.binomial.cdf(x, trials, probability) >= alpha) {
	      return x;
	    }
	    x++;
	  }
	};

	exports.CHISQ = {};

	exports.CHISQ.DIST = function(x, k, cumulative) {
	  x = utils.parseNumber(x);
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(x, k)) {
	    return error.value;
	  }

	  return (cumulative) ? jStat.chisquare.cdf(x, k) : jStat.chisquare.pdf(x, k);
	};

	exports.CHISQ.DIST.RT = function(x, k) {
	  if (!x | !k) {
	    return error.na;
	  }

	  if (x < 1 || k > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof k !== 'number')) {
	    return error.value;
	  }

	  return 1 -  jStat.chisquare.cdf(x, k);
	};

	exports.CHISQ.INV = function(probability, k) {
	  probability = utils.parseNumber(probability);
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(probability, k)) {
	    return error.value;
	  }
	  return jStat.chisquare.inv(probability, k);
	};

	exports.CHISQ.INV.RT = function(p, k) {
	  if (!p | !k) {
	    return error.na;
	  }

	  if (p < 0 || p > 1 || k < 1 || k > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof p !== 'number') || (typeof k !== 'number')) {
	    return error.value;
	  }

	  return jStat.chisquare.inv(1.0 - p, k);
	};

	exports.CHISQ.TEST = function(observed, expected) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if ((!(observed instanceof Array)) || (!(expected instanceof Array))) {
	    return error.value;
	  }

	  if (observed.length !== expected.length) {
	    return error.value;
	  }

	  if (observed[0] && expected[0] &&
	      observed[0].length !== expected[0].length) {
	    return error.value;
	  }

	  var row = observed.length;
	  var tmp, i, j;

	  // Convert single-dimension array into two-dimension array
	  for (i = 0; i < row; i ++) {
	    if (!(observed[i] instanceof Array)) {
	      tmp = observed[i];
	      observed[i] = [];
	      observed[i].push(tmp);
	    }
	    if (!(expected[i] instanceof Array)) {
	      tmp = expected[i];
	      expected[i] = [];
	      expected[i].push(tmp);
	    }
	  }

	  var col = observed[0].length;
	  var dof = (col === 1) ? row-1 : (row-1)*(col-1);
	  var xsqr = 0;
	  var Pi =Math.PI;

	  for (i = 0; i < row; i ++) {
	    for (j = 0; j < col; j ++) {
	      xsqr += Math.pow((observed[i][j] - expected[i][j]), 2) / expected[i][j];
	    }
	  }

	  // Get independency by X square and its degree of freedom
	  function ChiSq(xsqr, dof) {
	    var p = Math.exp(-0.5 * xsqr);
	    if((dof%2) === 1) {
	      p = p * Math.sqrt(2 * xsqr/Pi);
	    }
	    var k = dof;
	    while(k >= 2) {
	      p = p * xsqr/k;
	      k = k - 2;
	    }
	    var t = p;
	    var a = dof;
	    while (t > 0.0000000001*p) {
	      a = a + 2;
	      t = t * xsqr/a;
	      p = p + t;
	    }
	    return 1-p;
	  }

	  return Math.round(ChiSq(xsqr, dof) * 1000000) / 1000000;
	};

	exports.COLUMN = function(matrix, index) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (index < 0) {
	    return error.num;
	  }

	  if (!(matrix instanceof Array) || (typeof index !== 'number')) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return undefined;
	  }

	  return jStat.col(matrix, index);
	};

	exports.COLUMNS = function(matrix) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (!(matrix instanceof Array)) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return 0;
	  }

	  return jStat.cols(matrix);
	};

	exports.CONFIDENCE = {};

	exports.CONFIDENCE.NORM = function(alpha, sd, n) {
	  alpha = utils.parseNumber(alpha);
	  sd = utils.parseNumber(sd);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(alpha, sd, n)) {
	    return error.value;
	  }
	  return jStat.normalci(1, alpha, sd, n)[1] - 1;
	};

	exports.CONFIDENCE.T = function(alpha, sd, n) {
	  alpha = utils.parseNumber(alpha);
	  sd = utils.parseNumber(sd);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(alpha, sd, n)) {
	    return error.value;
	  }
	  return jStat.tci(1, alpha, sd, n)[1] - 1;
	};

	exports.CORREL = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  return jStat.corrcoeff(array1, array2);
	};

	exports.COUNT = function() {
	  return utils.numbers(utils.flatten(arguments)).length;
	};

	exports.COUNTA = function() {
	  var range = utils.flatten(arguments);
	  return range.length - exports.COUNTBLANK(range);
	};

	exports.COUNTIN = function (range, value) {
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (range[i] === value) {
	      result++;
	    }
	  }
	  return result;
	};


	exports.COUNTBLANK = function() {
	  var range = utils.flatten(arguments);
	  var blanks = 0;
	  var element;
	  for (var i = 0; i < range.length; i++) {
	    element = range[i];
	    if (element === null || element === '') {
	      blanks++;
	    }
	  }
	  return blanks;
	};

	exports.COUNTIF = function(range, criteria) {
	  range = utils.flatten(range);
	  if (!/[<>=!]/.test(criteria)) {
	    criteria = '=="' + criteria + '"';
	  }
	  var matches = 0;
	  for (var i = 0; i < range.length; i++) {
	    if (typeof range[i] !== 'string') {
	      if (eval(range[i] + criteria)) { // jshint ignore:line
	        matches++;
	      }
	    } else {
	      if (eval('"' + range[i] + '"' + criteria)) { // jshint ignore:line
	        matches++;
	      }
	    }
	  }
	  return matches;
	};

	exports.COUNTIFS = function() {
	  var args = utils.argsToArray(arguments);
	  var results = new Array(utils.flatten(args[0]).length);
	  for (var i = 0; i < results.length; i++) {
	    results[i] = true;
	  }
	  for (i = 0; i < args.length; i += 2) {
	    var range = utils.flatten(args[i]);
	    var criteria = args[i + 1];
	    if (!/[<>=!]/.test(criteria)) {
	      criteria = '=="' + criteria + '"';
	    }
	    for (var j = 0; j < range.length; j++) {
	      if (typeof range[j] !== 'string') {
	        results[j] = results[j] && eval(range[j] + criteria); // jshint ignore:line
	      } else {
	        results[j] = results[j] && eval('"' + range[j] + '"' + criteria); // jshint ignore:line
	      }
	    }
	  }
	  var result = 0;
	  for (i = 0; i < results.length; i++) {
	    if (results[i]) {
	      result++;
	    }
	  }
	  return result;
	};

	exports.COUNTUNIQUE = function () {
	  return misc.UNIQUE.apply(null, utils.flatten(arguments)).length;
	};

	exports.COVARIANCE = {};

	exports.COVARIANCE.P = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  var mean1 = jStat.mean(array1);
	  var mean2 = jStat.mean(array2);
	  var result = 0;
	  var n = array1.length;
	  for (var i = 0; i < n; i++) {
	    result += (array1[i] - mean1) * (array2[i] - mean2);
	  }
	  return result / n;
	};

	exports.COVARIANCE.S = function(array1, array2) {
	  array1 = utils.parseNumberArray(utils.flatten(array1));
	  array2 = utils.parseNumberArray(utils.flatten(array2));
	  if (utils.anyIsError(array1, array2)) {
	    return error.value;
	  }
	  return jStat.covariance(array1, array2);
	};

	exports.DEVSQ = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var result = 0;
	  for (var i = 0; i < range.length; i++) {
	    result += Math.pow((range[i] - mean), 2);
	  }
	  return result;
	};

	exports.EXPON = {};

	exports.EXPON.DIST = function(x, lambda, cumulative) {
	  x = utils.parseNumber(x);
	  lambda = utils.parseNumber(lambda);
	  if (utils.anyIsError(x, lambda)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.exponential.cdf(x, lambda) : jStat.exponential.pdf(x, lambda);
	};

	exports.F = {};

	exports.F.DIST = function(x, d1, d2, cumulative) {
	  x = utils.parseNumber(x);
	  d1 = utils.parseNumber(d1);
	  d2 = utils.parseNumber(d2);
	  if (utils.anyIsError(x, d1, d2)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.centralF.cdf(x, d1, d2) : jStat.centralF.pdf(x, d1, d2);
	};

	exports.F.DIST.RT = function(x, d1, d2) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (x < 0 || d1 < 1 || d2 < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {
	    return error.value;
	  }

	  return 1 - jStat.centralF.cdf(x, d1, d2);
	};

	exports.F.INV = function(probability, d1, d2) {
	  probability = utils.parseNumber(probability);
	  d1 = utils.parseNumber(d1);
	  d2 = utils.parseNumber(d2);
	  if (utils.anyIsError(probability, d1, d2)) {
	    return error.value;
	  }
	  if (probability <= 0.0 || probability > 1.0) {
	    return error.num;
	  }

	  return jStat.centralF.inv(probability, d1, d2);
	};

	exports.F.INV.RT = function(p, d1, d2) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (p < 0 || p > 1 || d1 < 1 || d1 > Math.pow(10, 10) || d2 < 1 || d2 > Math.pow(10, 10)) {
	    return error.num;
	  }

	  if ((typeof p !== 'number') || (typeof d1 !== 'number') || (typeof d2 !== 'number')) {
	    return error.value;
	  }

	  return jStat.centralF.inv(1.0 - p, d1, d2);
	};

	exports.F.TEST = function(array1, array2) {
	  if (!array1 || !array2) {
	    return error.na;
	  }

	  if (!(array1 instanceof Array) || !(array2 instanceof Array)) {
	    return error.na;
	  }

	  if (array1.length < 2 || array2.length < 2) {
	    return error.div0;
	  }

	  var sumOfSquares = function(values, x1) {
	    var sum = 0;
	    for (var i = 0; i < values.length; i++) {
	      sum +=Math.pow((values[i] - x1), 2);
	    }
	    return sum;
	  };

	  var x1 = mathTrig.SUM(array1) / array1.length;
	  var x2 = mathTrig.SUM(array2) / array2.length;
	  var sum1 = sumOfSquares(array1, x1) / (array1.length - 1);
	  var sum2 = sumOfSquares(array2, x2) / (array2.length - 1);

	  return sum1 / sum2;
	};

	exports.FISHER = function(x) {
	  x = utils.parseNumber(x);
	  if (x instanceof Error) {
	    return x;
	  }
	  return Math.log((1 + x) / (1 - x)) / 2;
	};

	exports.FISHERINV = function(y) {
	  y = utils.parseNumber(y);
	  if (y instanceof Error) {
	    return y;
	  }
	  var e2y = Math.exp(2 * y);
	  return (e2y - 1) / (e2y + 1);
	};

	exports.FORECAST = function(x, data_y, data_x) {
	  x = utils.parseNumber(x);
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(x, data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  var b = num / den;
	  var a = ymean - b * xmean;
	  return a + b * x;
	};

	exports.FREQUENCY = function(data, bins) {
	  data = utils.parseNumberArray(utils.flatten(data));
	  bins = utils.parseNumberArray(utils.flatten(bins));
	  if (utils.anyIsError(data, bins)) {
	    return error.value;
	  }
	  var n = data.length;
	  var b = bins.length;
	  var r = [];
	  for (var i = 0; i <= b; i++) {
	    r[i] = 0;
	    for (var j = 0; j < n; j++) {
	      if (i === 0) {
	        if (data[j] <= bins[0]) {
	          r[0] += 1;
	        }
	      } else if (i < b) {
	        if (data[j] > bins[i - 1] && data[j] <= bins[i]) {
	          r[i] += 1;
	        }
	      } else if (i === b) {
	        if (data[j] > bins[b - 1]) {
	          r[b] += 1;
	        }
	      }
	    }
	  }
	  return r;
	};


	exports.GAMMA = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  if (number === 0) {
	    return error.num;
	  }

	  if (parseInt(number, 10) === number && number < 0) {
	    return error.num;
	  }

	  return jStat.gammafn(number);
	};

	exports.GAMMA.DIST = function(value, alpha, beta, cumulative) {
	  if (arguments.length !== 4) {
	    return error.na;
	  }

	  if (value < 0 || alpha <= 0 || beta <= 0) {
	    return error.value;
	  }

	  if ((typeof value !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {
	    return error.value;
	  }

	  return cumulative ? jStat.gamma.cdf(value, alpha, beta, true) : jStat.gamma.pdf(value, alpha, beta, false);
	};

	exports.GAMMA.INV = function(probability, alpha, beta) {
	  if (arguments.length !== 3) {
	    return error.na;
	  }

	  if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {
	    return error.num;
	  }

	  if ((typeof probability !== 'number') || (typeof alpha !== 'number') || (typeof beta !== 'number')) {
	    return error.value;
	  }

	  return jStat.gamma.inv(probability, alpha, beta);
	};

	exports.GAMMALN = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return jStat.gammaln(number);
	};

	exports.GAMMALN.PRECISE = function(x) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (x <= 0) {
	    return error.num;
	  }

	  if (typeof x !== 'number') {
	    return error.value;
	  }

	  return jStat.gammaln(x);
	};

	exports.GAUSS = function(z) {
	  z = utils.parseNumber(z);
	  if (z instanceof Error) {
	    return z;
	  }
	  return jStat.normal.cdf(z, 0, 1) - 0.5;
	};

	exports.GEOMEAN = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }
	  return jStat.geomean(args);
	};

	exports.GROWTH = function(known_y, known_x, new_x, use_const) {
	  // Credits: Ilmari Karonen (http://stackoverflow.com/questions/14161990/how-to-implement-growth-function-in-javascript)

	  known_y = utils.parseNumberArray(known_y);
	  if (known_y instanceof Error) {
	    return known_y;
	  }

	  // Default values for optional parameters:
	  var i;
	  if (known_x === undefined) {
	    known_x = [];
	    for (i = 1; i <= known_y.length; i++) {
	      known_x.push(i);
	    }
	  }
	  if (new_x === undefined) {
	    new_x = [];
	    for (i = 1; i <= known_y.length; i++) {
	      new_x.push(i);
	    }
	  }

	  known_x = utils.parseNumberArray(known_x);
	  new_x = utils.parseNumberArray(new_x);
	  if (utils.anyIsError(known_x, new_x)) {
	    return error.value;
	  }


	  if (use_const === undefined) {
	    use_const = true;
	  }

	  // Calculate sums over the data:
	  var n = known_y.length;
	  var avg_x = 0;
	  var avg_y = 0;
	  var avg_xy = 0;
	  var avg_xx = 0;
	  for (i = 0; i < n; i++) {
	    var x = known_x[i];
	    var y = Math.log(known_y[i]);
	    avg_x += x;
	    avg_y += y;
	    avg_xy += x * y;
	    avg_xx += x * x;
	  }
	  avg_x /= n;
	  avg_y /= n;
	  avg_xy /= n;
	  avg_xx /= n;

	  // Compute linear regression coefficients:
	  var beta;
	  var alpha;
	  if (use_const) {
	    beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);
	    alpha = avg_y - beta * avg_x;
	  } else {
	    beta = avg_xy / avg_xx;
	    alpha = 0;
	  }

	  // Compute and return result array:
	  var new_y = [];
	  for (i = 0; i < new_x.length; i++) {
	    new_y.push(Math.exp(alpha + beta * new_x[i]));
	  }
	  return new_y;
	};

	exports.HARMEAN = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    den += 1 / range[i];
	  }
	  return n / den;
	};

	exports.HYPGEOM = {};

	exports.HYPGEOM.DIST = function(x, n, M, N, cumulative) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  M = utils.parseNumber(M);
	  N = utils.parseNumber(N);
	  if (utils.anyIsError(x, n, M, N)) {
	    return error.value;
	  }

	  function pdf(x, n, M, N) {
	    return mathTrig.COMBIN(M, x) * mathTrig.COMBIN(N - M, n - x) / mathTrig.COMBIN(N, n);
	  }

	  function cdf(x, n, M, N) {
	    var result = 0;
	    for (var i = 0; i <= x; i++) {
	      result += pdf(i, n, M, N);
	    }
	    return result;
	  }

	  return (cumulative) ? cdf(x, n, M, N) : pdf(x, n, M, N);
	};

	exports.INTERCEPT = function(known_y, known_x) {
	  known_y = utils.parseNumberArray(known_y);
	  known_x = utils.parseNumberArray(known_x);
	  if (utils.anyIsError(known_y, known_x)) {
	    return error.value;
	  }
	  if (known_y.length !== known_x.length) {
	    return error.na;
	  }
	  return exports.FORECAST(0, known_y, known_x);
	};

	exports.KURT = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var sigma = 0;
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 4);
	  }
	  sigma = sigma / Math.pow(jStat.stdev(range, true), 4);
	  return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sigma - 3 * (n - 1) * (n - 1) / ((n - 2) * (n - 3));
	};

	exports.LARGE = function(range, k) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(range, k)) {
	    return range;
	  }
	  return range.sort(function(a, b) {
	    return b - a;
	  })[k - 1];
	};

	exports.LINEST = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var ymean = jStat.mean(data_y);
	  var xmean = jStat.mean(data_x);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  var m = num / den;
	  var b = ymean - m * xmean;
	  return [m, b];
	};

	// According to Microsoft:
	// http://office.microsoft.com/en-us/starter-help/logest-function-HP010342665.aspx
	// LOGEST returns are based on the following linear model:
	// ln y = x1 ln m1 + ... + xn ln mn + ln b
	exports.LOGEST = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  for (var i = 0; i < data_y.length; i ++) {
	    data_y[i] = Math.log(data_y[i]);
	  }

	  var result = exports.LINEST(data_y, data_x);
	  result[0] = Math.round(Math.exp(result[0])*1000000)/1000000;
	  result[1] = Math.round(Math.exp(result[1])*1000000)/1000000;
	  return result;
	};

	exports.LOGNORM = {};

	exports.LOGNORM.DIST = function(x, mean, sd, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.lognormal.cdf(x, mean, sd) : jStat.lognormal.pdf(x, mean, sd);
	};

	exports.LOGNORM.INV = function(probability, mean, sd) {
	  probability = utils.parseNumber(probability);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(probability, mean, sd)) {
	    return error.value;
	  }
	  return jStat.lognormal.inv(probability, mean, sd);
	};

	exports.MAX = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.max.apply(Math, range);
	};

	exports.MAXA = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.max.apply(Math, range);
	};

	exports.MEDIAN = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return jStat.median(range);
	};

	exports.MIN = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.min.apply(Math, range);
	};

	exports.MINA = function() {
	  var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
	  return (range.length === 0) ? 0 : Math.min.apply(Math, range);
	};

	exports.MODE = {};

	exports.MODE.MULT = function() {
	  // Credits: Ronan
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var n = range.length;
	  var count = {};
	  var maxItems = [];
	  var max = 0;
	  var currentItem;

	  for (var i = 0; i < n; i++) {
	    currentItem = range[i];
	    count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
	    if (count[currentItem] > max) {
	      max = count[currentItem];
	      maxItems = [];
	    }
	    if (count[currentItem] === max) {
	      maxItems[maxItems.length] = currentItem;
	    }
	  }
	  return maxItems;
	};

	exports.MODE.SNGL = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  return exports.MODE.MULT(range).sort(function(a, b) {
	    return a - b;
	  })[0];
	};

	exports.NEGBINOM = {};

	exports.NEGBINOM.DIST = function(k, r, p, cumulative) {
	  k = utils.parseNumber(k);
	  r = utils.parseNumber(r);
	  p = utils.parseNumber(p);
	  if (utils.anyIsError(k, r, p)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.negbin.cdf(k, r, p) : jStat.negbin.pdf(k, r, p);
	};

	exports.NORM = {};

	exports.NORM.DIST = function(x, mean, sd, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  if (sd <= 0) {
	    return error.num;
	  }

	  // Return normal distribution computed by jStat [http://jstat.org]
	  return (cumulative) ? jStat.normal.cdf(x, mean, sd) : jStat.normal.pdf(x, mean, sd);
	};

	exports.NORM.INV = function(probability, mean, sd) {
	  probability = utils.parseNumber(probability);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(probability, mean, sd)) {
	    return error.value;
	  }
	  return jStat.normal.inv(probability, mean, sd);
	};

	exports.NORM.S = {};

	exports.NORM.S.DIST = function(z, cumulative) {
	  z = utils.parseNumber(z);
	  if (z instanceof Error) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.normal.cdf(z, 0, 1) : jStat.normal.pdf(z, 0, 1);
	};

	exports.NORM.S.INV = function(probability) {
	  probability = utils.parseNumber(probability);
	  if (probability instanceof Error) {
	    return error.value;
	  }
	  return jStat.normal.inv(probability, 0, 1);
	};

	exports.PEARSON = function(data_x, data_y) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den1 = 0;
	  var den2 = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den1 += Math.pow(data_x[i] - xmean, 2);
	    den2 += Math.pow(data_y[i] - ymean, 2);
	  }
	  return num / Math.sqrt(den1 * den2);
	};

	exports.PERCENTILE = {};

	exports.PERCENTILE.EXC = function(array, k) {
	  array = utils.parseNumberArray(utils.flatten(array));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(array, k)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    {
	      return a - b;
	    }
	  });
	  var n = array.length;
	  if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
	    return error.num;
	  }
	  var l = k * (n + 1) - 1;
	  var fl = Math.floor(l);
	  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
	};

	exports.PERCENTILE.INC = function(array, k) {
	  array = utils.parseNumberArray(utils.flatten(array));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(array, k)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var n = array.length;
	  var l = k * (n - 1);
	  var fl = Math.floor(l);
	  return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
	};

	exports.PERCENTRANK = {};

	exports.PERCENTRANK.EXC = function(array, x, significance) {
	  significance = (significance === undefined) ? 3 : significance;
	  array = utils.parseNumberArray(utils.flatten(array));
	  x = utils.parseNumber(x);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(array, x, significance)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var uniques = misc.UNIQUE.apply(null, array);
	  var n = array.length;
	  var m = uniques.length;
	  var power = Math.pow(10, significance);
	  var result = 0;
	  var match = false;
	  var i = 0;
	  while (!match && i < m) {
	    if (x === uniques[i]) {
	      result = (array.indexOf(uniques[i]) + 1) / (n + 1);
	      match = true;
	    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
	      result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);
	      match = true;
	    }
	    i++;
	  }
	  return Math.floor(result * power) / power;
	};

	exports.PERCENTRANK.INC = function(array, x, significance) {
	  significance = (significance === undefined) ? 3 : significance;
	  array = utils.parseNumberArray(utils.flatten(array));
	  x = utils.parseNumber(x);
	  significance = utils.parseNumber(significance);
	  if (utils.anyIsError(array, x, significance)) {
	    return error.value;
	  }
	  array = array.sort(function(a, b) {
	    return a - b;
	  });
	  var uniques = misc.UNIQUE.apply(null, array);
	  var n = array.length;
	  var m = uniques.length;
	  var power = Math.pow(10, significance);
	  var result = 0;
	  var match = false;
	  var i = 0;
	  while (!match && i < m) {
	    if (x === uniques[i]) {
	      result = array.indexOf(uniques[i]) / (n - 1);
	      match = true;
	    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
	      result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);
	      match = true;
	    }
	    i++;
	  }
	  return Math.floor(result * power) / power;
	};

	exports.PERMUT = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return mathTrig.FACT(number) / mathTrig.FACT(number - number_chosen);
	};

	exports.PERMUTATIONA = function(number, number_chosen) {
	  number = utils.parseNumber(number);
	  number_chosen = utils.parseNumber(number_chosen);
	  if (utils.anyIsError(number, number_chosen)) {
	    return error.value;
	  }
	  return Math.pow(number, number_chosen);
	};

	exports.PHI = function(x) {
	  x = utils.parseNumber(x);
	  if (x instanceof Error) {
	    return error.value;
	  }
	  return Math.exp(-0.5 * x * x) / SQRT2PI;
	};

	exports.POISSON = {};

	exports.POISSON.DIST = function(x, mean, cumulative) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  if (utils.anyIsError(x, mean)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.poisson.cdf(x, mean) : jStat.poisson.pdf(x, mean);
	};

	exports.PROB = function(range, probability, lower, upper) {
	  if (lower === undefined) {
	    return 0;
	  }
	  upper = (upper === undefined) ? lower : upper;

	  range = utils.parseNumberArray(utils.flatten(range));
	  probability = utils.parseNumberArray(utils.flatten(probability));
	  lower = utils.parseNumber(lower);
	  upper = utils.parseNumber(upper);
	  if (utils.anyIsError(range, probability, lower, upper)) {
	    return error.value;
	  }

	  if (lower === upper) {
	    return (range.indexOf(lower) >= 0) ? probability[range.indexOf(lower)] : 0;
	  }

	  var sorted = range.sort(function(a, b) {
	    return a - b;
	  });
	  var n = sorted.length;
	  var result = 0;
	  for (var i = 0; i < n; i++) {
	    if (sorted[i] >= lower && sorted[i] <= upper) {
	      result += probability[range.indexOf(sorted[i])];
	    }
	  }
	  return result;
	};

	exports.QUARTILE = {};

	exports.QUARTILE.EXC = function(range, quart) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  quart = utils.parseNumber(quart);
	  if (utils.anyIsError(range, quart)) {
	    return error.value;
	  }
	  switch (quart) {
	    case 1:
	      return exports.PERCENTILE.EXC(range, 0.25);
	    case 2:
	      return exports.PERCENTILE.EXC(range, 0.5);
	    case 3:
	      return exports.PERCENTILE.EXC(range, 0.75);
	    default:
	      return error.num;
	  }
	};

	exports.QUARTILE.INC = function(range, quart) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  quart = utils.parseNumber(quart);
	  if (utils.anyIsError(range, quart)) {
	    return error.value;
	  }
	  switch (quart) {
	    case 1:
	      return exports.PERCENTILE.INC(range, 0.25);
	    case 2:
	      return exports.PERCENTILE.INC(range, 0.5);
	    case 3:
	      return exports.PERCENTILE.INC(range, 0.75);
	    default:
	      return error.num;
	  }
	};

	exports.RANK = {};

	exports.RANK.AVG = function(number, range, order) {
	  number = utils.parseNumber(number);
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (utils.anyIsError(number, range)) {
	    return error.value;
	  }
	  range = utils.flatten(range);
	  order = order || false;
	  var sort = (order) ? function(a, b) {
	    return a - b;
	  } : function(a, b) {
	    return b - a;
	  };
	  range = range.sort(sort);

	  var length = range.length;
	  var count = 0;
	  for (var i = 0; i < length; i++) {
	    if (range[i] === number) {
	      count++;
	    }
	  }

	  return (count > 1) ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;
	};

	exports.RANK.EQ = function(number, range, order) {
	  number = utils.parseNumber(number);
	  range = utils.parseNumberArray(utils.flatten(range));
	  if (utils.anyIsError(number, range)) {
	    return error.value;
	  }
	  order = order || false;
	  var sort = (order) ? function(a, b) {
	    return a - b;
	  } : function(a, b) {
	    return b - a;
	  };
	  range = range.sort(sort);
	  return range.indexOf(number) + 1;
	};

	exports.ROW = function(matrix, index) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (index < 0) {
	    return error.num;
	  }

	  if (!(matrix instanceof Array) || (typeof index !== 'number')) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return undefined;
	  }

	  return jStat.row(matrix, index);
	};

	exports.ROWS = function(matrix) {
	  if (arguments.length !== 1) {
	    return error.na;
	  }

	  if (!(matrix instanceof Array)) {
	    return error.value;
	  }

	  if (matrix.length === 0) {
	    return 0;
	  }

	  return jStat.rows(matrix);
	};

	exports.RSQ = function(data_x, data_y) { // no need to flatten here, PEARSON will take care of that
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  if (utils.anyIsError(data_x, data_y)) {
	    return error.value;
	  }
	  return Math.pow(exports.PEARSON(data_x, data_y), 2);
	};

	exports.SKEW = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var sigma = 0;
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 3);
	  }
	  return n * sigma / ((n - 1) * (n - 2) * Math.pow(jStat.stdev(range, true), 3));
	};

	exports.SKEW.P = function() {
	  var range = utils.parseNumberArray(utils.flatten(arguments));
	  if (range instanceof Error) {
	    return range;
	  }
	  var mean = jStat.mean(range);
	  var n = range.length;
	  var m2 = 0;
	  var m3 = 0;
	  for (var i = 0; i < n; i++) {
	    m3 += Math.pow(range[i] - mean, 3);
	    m2 += Math.pow(range[i] - mean, 2);
	  }
	  m3 = m3 / n;
	  m2 = m2 / n;
	  return m3 / Math.pow(m2, 3 / 2);
	};

	exports.SLOPE = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  return num / den;
	};

	exports.SMALL = function(range, k) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  k = utils.parseNumber(k);
	  if (utils.anyIsError(range, k)) {
	    return range;
	  }
	  return range.sort(function(a, b) {
	    return a - b;
	  })[k - 1];
	};

	exports.STANDARDIZE = function(x, mean, sd) {
	  x = utils.parseNumber(x);
	  mean = utils.parseNumber(mean);
	  sd = utils.parseNumber(sd);
	  if (utils.anyIsError(x, mean, sd)) {
	    return error.value;
	  }
	  return (x - mean) / sd;
	};

	exports.STDEV = {};

	exports.STDEV.P = function() {
	  var v = exports.VAR.P.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEV.S = function() {
	  var v = exports.VAR.S.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEVA = function() {
	  var v = exports.VARA.apply(this, arguments);
	  return Math.sqrt(v);
	};

	exports.STDEVPA = function() {
	  var v = exports.VARPA.apply(this, arguments);
	  return Math.sqrt(v);
	};


	exports.STEYX = function(data_y, data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  if (utils.anyIsError(data_y, data_x)) {
	    return error.value;
	  }
	  var xmean = jStat.mean(data_x);
	  var ymean = jStat.mean(data_y);
	  var n = data_x.length;
	  var lft = 0;
	  var num = 0;
	  var den = 0;
	  for (var i = 0; i < n; i++) {
	    lft += Math.pow(data_y[i] - ymean, 2);
	    num += (data_x[i] - xmean) * (data_y[i] - ymean);
	    den += Math.pow(data_x[i] - xmean, 2);
	  }
	  return Math.sqrt((lft - num * num / den) / (n - 2));
	};

	exports.TRANSPOSE = function(matrix) {
	  if (!matrix) {
	    return error.na;
	  }
	  return jStat.transpose(matrix);
	};

	exports.T = text.T;

	exports.T.DIST = function(x, df, cumulative) {
	  x = utils.parseNumber(x);
	  df = utils.parseNumber(df);
	  if (utils.anyIsError(x, df)) {
	    return error.value;
	  }
	  return (cumulative) ? jStat.studentt.cdf(x, df) : jStat.studentt.pdf(x, df);
	};

	exports.T.DIST['2T'] = function(x, df) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (x < 0 || df < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof df !== 'number')) {
	    return error.value;
	  }

	  return (1 - jStat.studentt.cdf(x , df)) * 2;
	};

	exports.T.DIST.RT = function(x, df) {
	  if (arguments.length !== 2) {
	    return error.na;
	  }

	  if (x < 0 || df < 1) {
	    return error.num;
	  }

	  if ((typeof x !== 'number') || (typeof df !== 'number')) {
	    return error.value;
	  }

	  return 1 - jStat.studentt.cdf(x , df);
	};

	exports.T.INV = function(probability, df) {
	  probability = utils.parseNumber(probability);
	  df = utils.parseNumber(df);
	  if (utils.anyIsError(probability, df)) {
	    return error.value;
	  }
	  return jStat.studentt.inv(probability, df);
	};

	exports.T.INV['2T'] = function(probability, df) {
	  probability = utils.parseNumber(probability);
	  df = utils.parseNumber(df);
	  if (probability <= 0 || probability > 1 || df < 1) {
	    return error.num;
	  }
	  if (utils.anyIsError(probability, df)) {
	    return error.value;
	  }
	  return Math.abs(jStat.studentt.inv(probability/2, df));
	};

	// The algorithm can be found here:
	// http://www.chem.uoa.gr/applets/AppletTtest/Appl_Ttest2.html
	exports.T.TEST = function(data_x, data_y) {
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  if (utils.anyIsError(data_x, data_y)) {
	    return error.value;
	  }

	  var mean_x = jStat.mean(data_x);
	  var mean_y = jStat.mean(data_y);
	  var s_x = 0;
	  var s_y = 0;
	  var i;

	  for (i = 0; i < data_x.length; i++) {
	    s_x += Math.pow(data_x[i] - mean_x, 2);
	  }
	  for (i = 0; i < data_y.length; i++) {
	    s_y += Math.pow(data_y[i] - mean_y, 2);
	  }

	  s_x = s_x / (data_x.length-1);
	  s_y = s_y / (data_y.length-1);

	  var t = Math.abs(mean_x - mean_y) / Math.sqrt(s_x/data_x.length + s_y/data_y.length);

	  return exports.T.DIST['2T'](t, data_x.length+data_y.length-2);
	};

	exports.TREND = function(data_y, data_x, new_data_x) {
	  data_y = utils.parseNumberArray(utils.flatten(data_y));
	  data_x = utils.parseNumberArray(utils.flatten(data_x));
	  new_data_x = utils.parseNumberArray(utils.flatten(new_data_x));
	  if (utils.anyIsError(data_y, data_x, new_data_x)) {
	    return error.value;
	  }
	  var linest = exports.LINEST(data_y, data_x);
	  var m = linest[0];
	  var b = linest[1];
	  var result = [];

	  new_data_x.forEach(function(x) {
	    result.push(m * x + b);
	  });

	  return result;
	};

	exports.TRIMMEAN = function(range, percent) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  percent = utils.parseNumber(percent);
	  if (utils.anyIsError(range, percent)) {
	    return error.value;
	  }
	  var trim = mathTrig.FLOOR(range.length * percent, 2) / 2;
	  return jStat.mean(utils.initial(utils.rest(range.sort(function(a, b) {
	    return a - b;
	  }), trim), trim));
	};

	exports.VAR = {};

	exports.VAR.P = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sigma = 0;
	  var mean = exports.AVERAGE(range);
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 2);
	  }
	  return sigma / n;
	};

	exports.VAR.S = function() {
	  var range = utils.numbers(utils.flatten(arguments));
	  var n = range.length;
	  var sigma = 0;
	  var mean = exports.AVERAGE(range);
	  for (var i = 0; i < n; i++) {
	    sigma += Math.pow(range[i] - mean, 2);
	  }
	  return sigma / (n - 1);
	};

	exports.VARA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sigma = 0;
	  var count = 0;
	  var mean = exports.AVERAGEA(range);
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sigma += Math.pow(el - mean, 2);
	    } else if (el === true) {
	      sigma += Math.pow(1 - mean, 2);
	    } else {
	      sigma += Math.pow(0 - mean, 2);
	    }

	    if (el !== null) {
	      count++;
	    }
	  }
	  return sigma / (count - 1);
	};

	exports.VARPA = function() {
	  var range = utils.flatten(arguments);
	  var n = range.length;
	  var sigma = 0;
	  var count = 0;
	  var mean = exports.AVERAGEA(range);
	  for (var i = 0; i < n; i++) {
	    var el = range[i];
	    if (typeof el === 'number') {
	      sigma += Math.pow(el - mean, 2);
	    } else if (el === true) {
	      sigma += Math.pow(1 - mean, 2);
	    } else {
	      sigma += Math.pow(0 - mean, 2);
	    }

	    if (el !== null) {
	      count++;
	    }
	  }
	  return sigma / count;
	};

	exports.WEIBULL = {};

	exports.WEIBULL.DIST = function(x, alpha, beta, cumulative) {
	  x = utils.parseNumber(x);
	  alpha = utils.parseNumber(alpha);
	  beta = utils.parseNumber(beta);
	  if (utils.anyIsError(x, alpha, beta)) {
	    return error.value;
	  }
	  return (cumulative) ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);
	};

	exports.Z = {};

	exports.Z.TEST = function(range, x, sd) {
	  range = utils.parseNumberArray(utils.flatten(range));
	  x = utils.parseNumber(x);
	  if (utils.anyIsError(range, x)) {
	    return error.value;
	  }

	  sd = sd || exports.STDEV.S(range);
	  var n = range.length;
	  return 1 - exports.NORM.S.DIST((exports.AVERAGE(range) - x) / (sd / Math.sqrt(n)), true);
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(4);
	var error = __webpack_require__(5);
	var numeral = __webpack_require__(8);

	//TODO
	exports.ASC = function() {
	 throw new Error('ASC is not implemented');
	};

	//TODO
	exports.BAHTTEXT = function() {
	 throw new Error('BAHTTEXT is not implemented');
	};

	exports.CHAR = function(number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return String.fromCharCode(number);
	};

	exports.CLEAN = function(text) {
	  text = text || '';
	  var re = /[\0-\x1F]/g;
	  return text.replace(re, "");
	};

	exports.CODE = function(text) {
	  text = text || '';
	  return text.charCodeAt(0);
	};

	exports.CONCATENATE = function() {
	  var args = utils.flatten(arguments);

	  var trueFound = 0;
	  while ((trueFound = args.indexOf(true)) > -1) {
	    args[trueFound] = 'TRUE';
	  }

	  var falseFound = 0;
	  while ((falseFound = args.indexOf(false)) > -1) {
	    args[falseFound] = 'FALSE';
	  }

	  return args.join('');
	};

	//TODO
	exports.DBCS = function() {
	 throw new Error('DBCS is not implemented');
	};

	exports.DOLLAR = function(number, decimals) {
	  decimals = (decimals === undefined) ? 2 : decimals;

	  number = utils.parseNumber(number);
	  decimals = utils.parseNumber(decimals);
	  if (utils.anyIsError(number, decimals)) {
	    return error.value;
	  }
	  var format = '';
	  if (decimals <= 0) {
	    number = Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	    format = '($0,0)';
	  } else if (decimals > 0) {
	    format = '($0,0.' + new Array(decimals + 1).join('0') + ')';
	  }
	  return numeral(number).format(format);
	};

	exports.EXACT = function(text1, text2) {
	  return text1 === text2;
	};

	exports.FIND = function(find_text, within_text, position) {
	  position = (position === undefined) ? 0 : position;
	  return within_text ? within_text.indexOf(find_text, position - 1) + 1 : null;
	};

	exports.FIXED = function(number, decimals, no_commas) {
	  decimals = (decimals === undefined) ? 2 : decimals;
	  no_commas = (no_commas === undefined) ? false : no_commas;

	  number = utils.parseNumber(number);
	  decimals = utils.parseNumber(decimals);
	  if (utils.anyIsError(number, decimals)) {
	    return error.value;
	  }

	  var format = no_commas ? '0' : '0,0';
	  if (decimals <= 0) {
	    number = Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
	  } else if (decimals > 0) {
	    format += '.' + new Array(decimals + 1).join('0');
	  }
	  return numeral(number).format(format);
	};

	exports.HTML2TEXT = function (value) {
	  var result = '';

	  if (value) {
	    if (value instanceof Array) {
	      value.forEach(function (line) {
	        if (result !== '') {
	          result += '\n';
	        }
	        result += (line.replace(/<(?:.|\n)*?>/gm, ''));
	      });
	    } else {
	      result = value.replace(/<(?:.|\n)*?>/gm, '');
	    }
	  }

	  return result;
	};

	exports.LEFT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = utils.parseNumber(number);
	  if (number instanceof Error || typeof text !== 'string') {
	    return error.value;
	  }
	  return text ? text.substring(0, number) : null;
	};

	exports.LEN = function(text) {
	  if (arguments.length === 0) {
	    return error.error;
	  }

	  if (typeof text === 'string') {
	    return text ? text.length : 0;
	  }

	  if (text.length) {
	    return text.length;
	  }

	  return error.value;
	};

	exports.LOWER = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text ? text.toLowerCase() : text;
	};

	exports.MID = function(text, start, number) {
	  start = utils.parseNumber(start);
	  number = utils.parseNumber(number);
	  if (utils.anyIsError(start, number) || typeof text !== 'string') {
	    return number;
	  }

	  var begin = start - 1;
	  var end = begin + number;

	  return text.substring(begin, end);
	};

	// TODO
	exports.NUMBERVALUE = function (text, decimal_separator, group_separator)  {
	  decimal_separator = (typeof decimal_separator === 'undefined') ? '.' : decimal_separator;
	  group_separator = (typeof group_separator === 'undefined') ? ',' : group_separator;
	  return Number(text.replace(decimal_separator, '.').replace(group_separator, ''));
	};

	// TODO
	exports.PRONETIC = function() {
	 throw new Error('PRONETIC is not implemented');
	};

	exports.PROPER = function(text) {
	  if (text === undefined || text.length === 0) {
	    return error.value;
	  }
	  if (text === true) {
	    text = 'TRUE';
	  }
	  if (text === false) {
	    text = 'FALSE';
	  }
	  if (isNaN(text) && typeof text === 'number') {
	    return error.value;
	  }
	  if (typeof text === 'number') {
	    text = '' + text;
	  }

	  return text.replace(/\w\S*/g, function(txt) {
	    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
	  });
	};

	exports.REGEXEXTRACT = function (text, regular_expression) {
	  var match = text.match(new RegExp(regular_expression));
	  return match ? (match[match.length > 1 ? match.length - 1 : 0]) : null;
	};

	exports.REGEXMATCH = function (text, regular_expression, full) {
	  var match = text.match(new RegExp(regular_expression));
	  return full ? match : !!match;
	};

	exports.REGEXREPLACE = function (text, regular_expression, replacement) {
	  return text.replace(new RegExp(regular_expression), replacement);
	};

	exports.REPLACE = function(text, position, length, new_text) {
	  position = utils.parseNumber(position);
	  length = utils.parseNumber(length);
	  if (utils.anyIsError(position, length) ||
	    typeof text !== 'string' ||
	    typeof new_text !== 'string') {
	    return error.value;
	  }
	  return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
	};

	exports.REPT = function(text, number) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return new Array(number + 1).join(text);
	};

	exports.RIGHT = function(text, number) {
	  number = (number === undefined) ? 1 : number;
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }
	  return text ? text.substring(text.length - number) : null;
	};

	exports.SEARCH = function(find_text, within_text, position) {
	  var foundAt;
	  if (typeof find_text !== 'string' || typeof within_text !== 'string') {
	    return error.value;
	  }
	  position = (position === undefined) ? 0 : position;
	  foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1)+1;
	  return (foundAt === 0)?error.value:foundAt;
	};

	exports.SPLIT = function (text, separator) {
	  return text.split(separator);
	};

	exports.SUBSTITUTE = function(text, old_text, new_text, occurrence) {
	  if (!text || !old_text || !new_text) {
	    return text;
	  } else if (occurrence === undefined) {
	    return text.replace(new RegExp(old_text, 'g'), new_text);
	  } else {
	    var index = 0;
	    var i = 0;
	    while (text.indexOf(old_text, index) > 0) {
	      index = text.indexOf(old_text, index + 1);
	      i++;
	      if (i === occurrence) {
	        return text.substring(0, index) + new_text + text.substring(index + old_text.length);
	      }
	    }
	  }
	};

	exports.T = function(value) {
	  return (typeof value === "string") ? value : '';
	};

	// TODO incomplete implementation
	exports.TEXT = function(value, format) {
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(value)) {
	    return error.na;
	  }

	  return numeral(value).format(format);
	};

	exports.TRIM = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text.replace(/ +/g, ' ').trim();
	};

	exports.UNICHAR = this.CHAR;

	exports.UNICODE = this.CODE;

	exports.UPPER = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return text.toUpperCase();
	};

	exports.VALUE = function(text) {
	  if (typeof text !== 'string') {
	    return error.value;
	  }
	  return numeral().unformat(text);
	};


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var utils   = __webpack_require__(4);
	var numeral = __webpack_require__(8);

	exports.UNIQUE = function () {
	  var result = [];
	  for (var i = 0; i < arguments.length; ++i) {
	    var hasElement = false;
	    var element    = arguments[i];

	    // Check if we've already seen this element.
	    for (var j = 0; j < result.length; ++j) {
	      hasElement = result[j] === element;
	      if (hasElement) { break; }
	    }

	    // If we did not find it, add it to the result.
	    if (!hasElement) {
	      result.push(element);
	    }
	  }
	  return result;
	};

	exports.FLATTEN = utils.flatten;

	exports.ARGS2ARRAY = function () {
	  return Array.prototype.slice.call(arguments, 0);
	};

	exports.REFERENCE = function (context, reference) {
	  try {
	    var path = reference.split('.');
	    var result = context;
	    for (var i = 0; i < path.length; ++i) {
	      var step = path[i];
	      if (step[step.length - 1] === ']') {
	        var opening = step.indexOf('[');
	        var index = step.substring(opening + 1, step.length - 1);
	        result = result[step.substring(0, opening)][index];
	      } else {
	        result = result[step];
	      }
	    }
	    return result;
	  } catch (error) {}
	};

	exports.JOIN = function (array, separator) {
	  return array.join(separator);
	};

	exports.NUMBERS = function () {
	  var possibleNumbers = utils.flatten(arguments);
	  return possibleNumbers.filter(function (el) {
	    return typeof el === 'number';
	  });
	};

	exports.NUMERAL = function (number, format) {
	  return numeral(number).format(format);
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	// TODO
	exports.CELL = function() {
	 throw new Error('CELL is not implemented');
	};

	exports.ERROR = {};
	exports.ERROR.TYPE = function(error_val) {
	  switch (error_val) {
	    case error.nil: return 1;
	    case error.div0: return 2;
	    case error.value: return 3;
	    case error.ref: return 4;
	    case error.name: return 5;
	    case error.num: return 6;
	    case error.na: return 7;
	    case error.data: return 8;
	  }
	  return error.na;
	};

	// TODO
	exports.INFO = function() {
	 throw new Error('INFO is not implemented');
	};

	exports.ISBLANK = function(value) {
	  return value === null;
	};

	exports.ISBINARY = function (number) {
	  return (/^[01]{1,10}$/).test(number);
	};

	exports.ISERR = function(value) {
	  return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||
	    (typeof value === 'number' && (isNaN(value) || !isFinite(value)));
	};

	exports.ISERROR = function(value) {
	  return exports.ISERR(value) || value === error.na;
	};

	exports.ISEVEN = function(number) {
	  return (Math.floor(Math.abs(number)) & 1) ? false : true;
	};

	// TODO
	exports.ISFORMULA = function() {
	  throw new Error('ISFORMULA is not implemented');
	};

	exports.ISLOGICAL = function(value) {
	  return value === true || value === false;
	};

	exports.ISNA = function(value) {
	  return value === error.na;
	};

	exports.ISNONTEXT = function(value) {
	  return typeof(value) !== 'string';
	};

	exports.ISNUMBER = function(value) {
	  return typeof(value) === 'number' && !isNaN(value) && isFinite(value);
	};

	exports.ISODD = function(number) {
	  return (Math.floor(Math.abs(number)) & 1) ? true : false;
	};

	// TODO
	exports.ISREF = function() {
	  throw new Error('ISREF is not implemented');
	};

	exports.ISTEXT = function(value) {
	  return typeof(value) === 'string';
	};

	exports.N = function(value) {
	  if (this.ISNUMBER(value)) {
	    return value;
	  }
	  if (value instanceof Date) {
	    return value.getTime();
	  }
	  if (value === true) {
	    return 1;
	  }
	  if (value === false) {
	    return 0;
	  }
	  if (this.ISERROR(value)) {
	    return value;
	  }
	  return 0;
	};

	exports.NA = function() {
	  return error.na;
	};


	// TODO
	exports.SHEET = function() {
	  throw new Error('SHEET is not implemented');
	};

	// TODO
	exports.SHEETS = function() {
	  throw new Error('SHEETS is not implemented');
	};

	exports.TYPE = function(value) {
	  if (this.ISNUMBER(value)) {
	    return 1;
	  }
	  if (this.ISTEXT(value)) {
	    return 2;
	  }
	  if (this.ISLOGICAL(value)) {
	    return 4;
	  }
	  if (this.ISERROR(value)) {
	    return 16;
	  }
	  if (Array.isArray(value)) {
	    return 64;
	  }
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var jStat = __webpack_require__(9).jStat;
	var text = __webpack_require__(7);
	var utils = __webpack_require__(4);
	var bessel = __webpack_require__(13);

	function isValidBinaryNumber(number) {
	  return (/^[01]{1,10}$/).test(number);
	}

	exports.BESSELI = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besseli(x, n);
	};

	exports.BESSELJ = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besselj(x, n);
	};

	exports.BESSELK = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.besselk(x, n);
	};

	exports.BESSELY = function(x, n) {
	  x = utils.parseNumber(x);
	  n = utils.parseNumber(n);
	  if (utils.anyIsError(x, n)) {
	    return error.value;
	  }
	  return bessel.bessely(x, n);
	};

	exports.BIN2DEC = function(number) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Convert binary number to decimal
	  var result = parseInt(number, 2);

	  // Handle negative numbers
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return parseInt(stringified.substring(1), 2) - 512;
	  } else {
	    return result;
	  }
	};


	exports.BIN2HEX = function(number, places) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character hexadecimal number if number is negative
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
	  }

	  // Convert binary number to hexadecimal
	  var result = parseInt(number, 2).toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.BIN2OCT = function(number, places) {
	  // Return error if number is not binary or contains more than 10 characters (10 digits)
	  if (!isValidBinaryNumber(number)) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  var stringified = number.toString();
	  if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
	    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
	  }

	  // Convert binary number to octal
	  var result = parseInt(number, 2).toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.BITAND = function(number1, number2) {
	  // Return error if either number is a non-numeric value
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise AND of two numbers
	  return number1 & number2;
	};

	exports.BITLSHIFT = function(number, shift) {
	  number = utils.parseNumber(number);
	  shift = utils.parseNumber(shift);
	  if (utils.anyIsError(number, shift)) {
	    return error.value;
	  }

	  // Return error if number is less than 0
	  if (number < 0) {
	    return error.num;
	  }

	  // Return error if number is a non-integer
	  if (Math.floor(number) !== number) {
	    return error.num;
	  }

	  // Return error if number is greater than (2^48)-1
	  if (number > 281474976710655) {
	    return error.num;
	  }

	  // Return error if the absolute value of shift is greater than 53
	  if (Math.abs(shift) > 53) {
	    return error.num;
	  }

	  // Return number shifted by shift bits to the left or to the right if shift is negative
	  return (shift >= 0) ? number << shift : number >> -shift;
	};

	exports.BITOR = function(number1, number2) {
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise OR of two numbers
	  return number1 | number2;
	};

	exports.BITRSHIFT = function(number, shift) {
	  number = utils.parseNumber(number);
	  shift = utils.parseNumber(shift);
	  if (utils.anyIsError(number, shift)) {
	    return error.value;
	  }

	  // Return error if number is less than 0
	  if (number < 0) {
	    return error.num;
	  }

	  // Return error if number is a non-integer
	  if (Math.floor(number) !== number) {
	    return error.num;
	  }

	  // Return error if number is greater than (2^48)-1
	  if (number > 281474976710655) {
	    return error.num;
	  }

	  // Return error if the absolute value of shift is greater than 53
	  if (Math.abs(shift) > 53) {
	    return error.num;
	  }

	  // Return number shifted by shift bits to the right or to the left if shift is negative
	  return (shift >= 0) ? number >> shift : number << -shift;
	};

	exports.BITXOR = function(number1, number2) {
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return error if either number is less than 0
	  if (number1 < 0 || number2 < 0) {
	    return error.num;
	  }

	  // Return error if either number is a non-integer
	  if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
	    return error.num;
	  }

	  // Return error if either number is greater than (2^48)-1
	  if (number1 > 281474976710655 || number2 > 281474976710655) {
	    return error.num;
	  }

	  // Return bitwise XOR of two numbers
	  return number1 ^ number2;
	};

	exports.COMPLEX = function(real, imaginary, suffix) {
	  real = utils.parseNumber(real);
	  imaginary = utils.parseNumber(imaginary);
	  if (utils.anyIsError(real, imaginary)) {
	    return real;
	  }

	  // Set suffix
	  suffix = (suffix === undefined) ? 'i' : suffix;

	  // Return error if suffix is neither "i" nor "j"
	  if (suffix !== 'i' && suffix !== 'j') {
	    return error.value;
	  }

	  // Return complex number
	  if (real === 0 && imaginary === 0) {
	    return 0;
	  } else if (real === 0) {
	    return (imaginary === 1) ? suffix : imaginary.toString() + suffix;
	  } else if (imaginary === 0) {
	    return real.toString();
	  } else {
	    var sign = (imaginary > 0) ? '+' : '';
	    return real.toString() + sign + ((imaginary === 1) ? suffix : imaginary.toString() + suffix);
	  }
	};

	exports.CONVERT = function(number, from_unit, to_unit) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // List of units supported by CONVERT and units defined by the International System of Units
	  // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]
	  var units = [
	    ["a.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
	    ["a.u. of charge", "e", null, "electric_charge", false, false, 1.60217653141414e-19],
	    ["a.u. of energy", "Eh", null, "energy", false, false, 4.35974417757576e-18],
	    ["a.u. of length", "a?", null, "length", false, false, 5.29177210818182e-11],
	    ["a.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
	    ["a.u. of time", "?/Eh", null, "time", false, false, 2.41888432650516e-17],
	    ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
	    ["ampere", "A", null, "electric_current", true, false, 1],
	    ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
	    ["ngstrm", "", ["ang"], "length", false, true, 1e-10],
	    ["are", "ar", null, "area", false, true, 100],
	    ["astronomical unit", "ua", null, "length", false, false, 1.49597870691667e-11],
	    ["bar", "bar", null, "pressure", false, false, 100000],
	    ["barn", "b", null, "area", false, false, 1e-28],
	    ["becquerel", "Bq", null, "radioactivity", true, false, 1],
	    ["bit", "bit", ["b"], "information", false, true, 1],
	    ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
	    ["byte", "byte", null, "information", false, true, 8],
	    ["candela", "cd", null, "luminous_intensity", true, false, 1],
	    ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
	    ["coulomb", "C", null, "electric_charge", true, false, 1],
	    ["cubic ngstrm", "ang3", ["ang^3"], "volume", false, true, 1e-30],
	    ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
	    ["cubic inch", "in3", ["in^3"], "volume", false, true, 0.000016387064],
	    ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 8.46786664623715e-47],
	    ["cubic metre", "m?", null, "volume", true, true, 1],
	    ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 4168181825.44058],
	    ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
	    ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 7.58660370370369e-8],
	    ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
	    ["cup", "cup", null, "volume", false, true, 0.0002365882365],
	    ["dalton", "Da", ["u"], "mass", false, false, 1.66053886282828e-27],
	    ["day", "d", ["day"], "time", false, true, 86400],
	    ["degree", "", null, "angle", false, false, 0.0174532925199433],
	    ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
	    ["dyne", "dyn", ["dy"], "force", false, true, 0.00001],
	    ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
	    ["ell", "ell", null, "length", false, true, 1.143],
	    ["erg", "erg", ["e"], "energy", false, true, 1e-7],
	    ["farad", "F", null, "electric_capacitance", true, false, 1],
	    ["fluid ounce", "oz", null, "volume", false, true, 0.0000295735295625],
	    ["foot", "ft", null, "length", false, true, 0.3048],
	    ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
	    ["gal", "Gal", null, "acceleration", false, false, 0.01],
	    ["gallon", "gal", null, "volume", false, true, 0.003785411784],
	    ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
	    ["grain", "grain", null, "mass", false, true, 0.0000647989],
	    ["gram", "g", null, "mass", false, true, 0.001],
	    ["gray", "Gy", null, "absorbed_dose", true, false, 1],
	    ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
	    ["hectare", "ha", null, "area", false, true, 10000],
	    ["henry", "H", null, "inductance", true, false, 1],
	    ["hertz", "Hz", null, "frequency", true, false, 1],
	    ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
	    ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519.538],
	    ["hour", "h", ["hr"], "time", false, true, 3600],
	    ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 0.00454609],
	    ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
	    ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
	    ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
	    ["inch", "in", null, "length", false, true, 0.0254],
	    ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
	    ["IT calorie", "cal", null, "energy", false, true, 4.1868],
	    ["joule", "J", null, "energy", true, true, 1],
	    ["katal", "kat", null, "catalytic_activity", true, false, 1],
	    ["kelvin", "K", ["kel"], "temperature", true, true, 1],
	    ["kilogram", "kg", null, "mass", true, true, 1],
	    ["knot", "kn", null, "speed", false, true, 0.514444444444444],
	    ["light-year", "ly", null, "length", false, true, 9460730472580800],
	    ["litre", "L", ["l", "lt"], "volume", false, true, 0.001],
	    ["lumen", "lm", null, "luminous_flux", true, false, 1],
	    ["lux", "lx", null, "illuminance", true, false, 1],
	    ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
	    ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
	    ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 0.00027777777777778],
	    ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
	    ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
	    ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
	    ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
	    ["metre", "m", null, "length", true, true, 1],
	    ["miles per hour", "mph", null, "speed", false, true, 0.44704],
	    ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
	    ["minute", "?", null, "angle", false, false, 0.000290888208665722],
	    ["minute", "min", ["mn"], "time", false, true, 60],
	    ["modern teaspoon", "tspm", null, "volume", false, true, 0.000005],
	    ["mole", "mol", null, "amount_of_substance", true, false, 1],
	    ["morgen", "Morgen", null, "area", false, true, 2500],
	    ["n.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
	    ["n.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
	    ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
	    ["n.u. of time", "?/(me?c??)", null, "time", false, false, 1.28808866778687e-21],
	    ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
	    ["newton", "N", null, "force", true, true, 1],
	    ["rsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
	    ["ohm", "", null, "electric_resistance", true, false, 1],
	    ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
	    ["pascal", "Pa", null, "pressure", true, false, 1],
	    ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
	    ["pferdestrke", "PS", null, "power", false, true, 735.49875],
	    ["phot", "ph", null, "illuminance", false, false, 0.0001],
	    ["pica (1/6 inch)", "pica", null, "length", false, true, 0.00035277777777778],
	    ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
	    ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
	    ["pond", "pond", null, "force", false, true, 0.00980665],
	    ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
	    ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
	    ["quart", "qt", null, "volume", false, true, 0.000946352946],
	    ["radian", "rad", null, "angle", true, false, 1],
	    ["second", "?", null, "angle", false, false, 0.00000484813681109536],
	    ["second", "s", ["sec"], "time", true, true, 1],
	    ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
	    ["siemens", "S", null, "electrical_conductance", true, false, 1],
	    ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
	    ["slug", "sg", null, "mass", false, true, 14.59390294],
	    ["square ngstrm", "ang2", ["ang^2"], "area", false, true, 1e-20],
	    ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
	    ["square inch", "in2", ["in^2"], "area", false, true, 0.00064516],
	    ["square light-year", "ly2", ["ly^2"], "area", false, true, 8.95054210748189e+31],
	    ["square meter", "m?", null, "area", true, true, 1],
	    ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988.110336],
	    ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
	    ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 0.00001792111111111],
	    ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
	    ["statute mile", "mi", null, "length", false, true, 1609.344],
	    ["steradian", "sr", null, "solid_angle", true, false, 1],
	    ["stilb", "sb", null, "luminance", false, false, 0.0001],
	    ["stokes", "St", null, "kinematic_viscosity", false, false, 0.0001],
	    ["stone", "stone", null, "mass", false, true, 6.35029318],
	    ["tablespoon", "tbs", null, "volume", false, true, 0.0000147868],
	    ["teaspoon", "tsp", null, "volume", false, true, 0.00000492892],
	    ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
	    ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
	    ["ton", "ton", null, "mass", false, true, 907.18474],
	    ["tonne", "t", null, "mass", false, false, 1000],
	    ["U.K. pint", "uk_pt", null, "volume", false, true, 0.00056826125],
	    ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
	    ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
	    ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 0.000473176473],
	    ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
	    ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
	    ["volt", "V", null, "voltage", true, false, 1],
	    ["watt", "W", null, "power", true, true, 1],
	    ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
	    ["weber", "Wb", null, "magnetic_flux", true, false, 1],
	    ["yard", "yd", null, "length", false, true, 0.9144],
	    ["year", "yr", null, "time", false, true, 31557600]
	  ];

	  // Binary prefixes
	  // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]
	  var binary_prefixes = {
	    Yi: ["yobi", 80, 1208925819614629174706176, "Yi", "yotta"],
	    Zi: ["zebi", 70, 1180591620717411303424, "Zi", "zetta"],
	    Ei: ["exbi", 60, 1152921504606846976, "Ei", "exa"],
	    Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
	    Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
	    Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
	    Mi: ["mebi", 20, 1048576, "Mi", "mega"],
	    ki: ["kibi", 10, 1024, "ki", "kilo"]
	  };

	  // Unit prefixes
	  // [Name, Multiplier, Abbreviation]
	  var unit_prefixes = {
	    Y: ["yotta", 1e+24, "Y"],
	    Z: ["zetta", 1e+21, "Z"],
	    E: ["exa", 1e+18, "E"],
	    P: ["peta", 1e+15, "P"],
	    T: ["tera", 1e+12, "T"],
	    G: ["giga", 1e+09, "G"],
	    M: ["mega", 1e+06, "M"],
	    k: ["kilo", 1e+03, "k"],
	    h: ["hecto", 1e+02, "h"],
	    e: ["dekao", 1e+01, "e"],
	    d: ["deci", 1e-01, "d"],
	    c: ["centi", 1e-02, "c"],
	    m: ["milli", 1e-03, "m"],
	    u: ["micro", 1e-06, "u"],
	    n: ["nano", 1e-09, "n"],
	    p: ["pico", 1e-12, "p"],
	    f: ["femto", 1e-15, "f"],
	    a: ["atto", 1e-18, "a"],
	    z: ["zepto", 1e-21, "z"],
	    y: ["yocto", 1e-24, "y"]
	  };

	  // Initialize units and multipliers
	  var from = null;
	  var to = null;
	  var base_from_unit = from_unit;
	  var base_to_unit = to_unit;
	  var from_multiplier = 1;
	  var to_multiplier = 1;
	  var alt;

	  // Lookup from and to units
	  for (var i = 0; i < units.length; i++) {
	    alt = (units[i][2] === null) ? [] : units[i][2];
	    if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
	      from = units[i];
	    }
	    if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
	      to = units[i];
	    }
	  }

	  // Lookup from prefix
	  if (from === null) {
	    var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
	    var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];

	    // Handle dekao unit prefix (only unit prefix with two characters)
	    if (from_unit.substring(0, 2) === 'da') {
	      from_unit_prefix = ["dekao", 1e+01, "da"];
	    }

	    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
	    if (from_binary_prefix) {
	      from_multiplier = from_binary_prefix[2];
	      base_from_unit = from_unit.substring(2);
	    } else if (from_unit_prefix) {
	      from_multiplier = from_unit_prefix[1];
	      base_from_unit = from_unit.substring(from_unit_prefix[2].length);
	    }

	    // Lookup from unit
	    for (var j = 0; j < units.length; j++) {
	      alt = (units[j][2] === null) ? [] : units[j][2];
	      if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
	        from = units[j];
	      }
	    }
	  }

	  // Lookup to prefix
	  if (to === null) {
	    var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
	    var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];

	    // Handle dekao unit prefix (only unit prefix with two characters)
	    if (to_unit.substring(0, 2) === 'da') {
	      to_unit_prefix = ["dekao", 1e+01, "da"];
	    }

	    // Handle binary prefixes first (so that 'Yi' is processed before 'Y')
	    if (to_binary_prefix) {
	      to_multiplier = to_binary_prefix[2];
	      base_to_unit = to_unit.substring(2);
	    } else if (to_unit_prefix) {
	      to_multiplier = to_unit_prefix[1];
	      base_to_unit = to_unit.substring(to_unit_prefix[2].length);
	    }

	    // Lookup to unit
	    for (var k = 0; k < units.length; k++) {
	      alt = (units[k][2] === null) ? [] : units[k][2];
	      if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
	        to = units[k];
	      }
	    }
	  }

	  // Return error if a unit does not exist
	  if (from === null || to === null) {
	    return error.na;
	  }

	  // Return error if units represent different quantities
	  if (from[3] !== to[3]) {
	    return error.na;
	  }

	  // Return converted number
	  return number * from[6] * from_multiplier / (to[6] * to_multiplier);
	};

	exports.DEC2BIN = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -512, or is greater than 511
	  if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (number < 0) {
	    return '1' + text.REPT('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = parseInt(number, 10).toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DEC2HEX = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
	  if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character hexadecimal number if number is negative
	  if (number < 0) {
	    return (1099511627776 + number).toString(16);
	  }

	  // Convert decimal number to hexadecimal
	  var result = parseInt(number, 10).toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DEC2OCT = function(number, places) {
	  number = utils.parseNumber(number);
	  if (number instanceof Error) {
	    return number;
	  }

	  // Return error if number is not decimal, is lower than -549755813888, or is greater than 549755813887
	  if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  if (number < 0) {
	    return (1073741824 + number).toString(8);
	  }

	  // Convert decimal number to octal
	  var result = parseInt(number, 10).toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.DELTA = function(number1, number2) {
	  // Set number2 to zero if undefined
	  number2 = (number2 === undefined) ? 0 : number2;
	  number1 = utils.parseNumber(number1);
	  number2 = utils.parseNumber(number2);
	  if (utils.anyIsError(number1, number2)) {
	    return error.value;
	  }

	  // Return delta
	  return (number1 === number2) ? 1 : 0;
	};

	// TODO: why is upper_bound not used ? The excel documentation has no examples with upper_bound
	exports.ERF = function(lower_bound, upper_bound) {
	  // Set number2 to zero if undefined
	  upper_bound = (upper_bound === undefined) ? 0 : upper_bound;

	  lower_bound = utils.parseNumber(lower_bound);
	  upper_bound = utils.parseNumber(upper_bound);
	  if (utils.anyIsError(lower_bound, upper_bound)) {
	    return error.value;
	  }

	  return jStat.erf(lower_bound);
	};

	// TODO
	exports.ERF.PRECISE = function() {
	 throw new Error('ERF.PRECISE is not implemented');
	};

	exports.ERFC = function(x) {
	  // Return error if x is not a number
	  if (isNaN(x)) {
	    return error.value;
	  }

	  return jStat.erfc(x);
	};

	// TODO
	exports.ERFC.PRECISE = function() {
	 throw new Error('ERFC.PRECISE is not implemented');
	};

	exports.GESTEP = function(number, step) {
	  step = step || 0;
	  number = utils.parseNumber(number);
	  if (utils.anyIsError(step, number)) {
	    return number;
	  }

	  // Return delta
	  return (number >= step) ? 1 : 0;
	};

	exports.HEX2BIN = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Check if number is negative
	  var negative = (number.length === 10 && number.substring(0, 1).toLowerCase() === 'f') ? true : false;

	  // Convert hexadecimal number to decimal
	  var decimal = (negative) ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);

	  // Return error if number is lower than -512 or greater than 511
	  if (decimal < -512 || decimal > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (negative) {
	    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = decimal.toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.HEX2DEC = function(number) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert hexadecimal number to decimal
	  var decimal = parseInt(number, 16);

	  // Return decimal number
	  return (decimal >= 549755813888) ? decimal - 1099511627776 : decimal;
	};

	exports.HEX2OCT = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert hexadecimal number to decimal
	  var decimal = parseInt(number, 16);

	  // Return error if number is positive and greater than 0x1fffffff (536870911)
	  if (decimal > 536870911 && decimal < 1098974756864) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character octal number if number is negative
	  if (decimal >= 1098974756864) {
	    return (decimal - 1098437885952).toString(8);
	  }

	  // Convert decimal number to octal
	  var result = decimal.toString(8);

	  // Return octal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.IMABS = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return absolute value of complex number
	  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
	};

	exports.IMAGINARY = function(inumber) {
	  if (inumber === undefined || inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') {
	    return 0;
	  }

	  // Handle special cases
	  if (['i', 'j'].indexOf(inumber) >= 0) {
	    return 1;
	  }

	  // Normalize imaginary coefficient
	  inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');

	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) {
	    plus = inumber.indexOf('+', 1);
	  }

	  if (minus === 0) {
	    minus = inumber.indexOf('-', 1);
	  }

	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');

	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) {
	      return error.num;
	    }

	    // Return imaginary coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(plus + 1, inumber.length - 1));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        error.num :
	        -Number(inumber.substring(minus + 1, inumber.length - 1));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : inumber.substring(0, inumber.length - 1);
	    } else {
	      return (isNaN(inumber)) ? error.num : 0;
	    }
	  }
	};

	exports.IMARGUMENT = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return error if inumber is equal to zero
	  if (x === 0 && y === 0) {
	    return error.div0;
	  }

	  // Return PI/2 if x is equal to zero and y is positive
	  if (x === 0 && y > 0) {
	    return Math.PI / 2;
	  }

	  // Return -PI/2 if x is equal to zero and y is negative
	  if (x === 0 && y < 0) {
	    return -Math.PI / 2;
	  }

	  // Return zero if x is negative and y is equal to zero
	  if (y === 0 && x > 0) {
	    return 0;
	  }

	  // Return zero if x is negative and y is equal to zero
	  if (y === 0 && x < 0) {
	    return -Math.PI;
	  }

	  // Return argument of complex number
	  if (x > 0) {
	    return Math.atan(y / x);
	  } else if (x < 0 && y >= 0) {
	    return Math.atan(y / x) + Math.PI;
	  } else {
	    return Math.atan(y / x) - Math.PI;
	  }
	};

	exports.IMCONJUGATE = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return conjugate of complex number
	  return (y !== 0) ? exports.COMPLEX(x, -y, unit) : inumber;
	};

	exports.IMCOS = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return cosine of complex number
	  return exports.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
	};

	exports.IMCOSH = function(inumber) {
	  // Lookup real and imaginary coefficients using exports.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return hyperbolic cosine of complex number
	  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
	};

	exports.IMCOT = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return cotangent of complex number
	  return exports.IMDIV(exports.IMCOS(inumber), exports.IMSIN(inumber));
	};

	exports.IMDIV = function(inumber1, inumber2) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var a = exports.IMREAL(inumber1);
	  var b = exports.IMAGINARY(inumber1);
	  var c = exports.IMREAL(inumber2);
	  var d = exports.IMAGINARY(inumber2);

	  if (utils.anyIsError(a, b, c, d)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit1 = inumber1.substring(inumber1.length - 1);
	  var unit2 = inumber2.substring(inumber2.length - 1);
	  var unit = 'i';
	  if (unit1 === 'j') {
	    unit = 'j';
	  } else if (unit2 === 'j') {
	    unit = 'j';
	  }

	  // Return error if inumber2 is null
	  if (c === 0 && d === 0) {
	    return error.num;
	  }

	  // Return exponential of complex number
	  var den = c * c + d * d;
	  return exports.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
	};

	exports.IMEXP = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  var e = Math.exp(x);
	  return exports.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
	};

	exports.IMLN = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
	};

	exports.IMLOG10 = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
	};

	exports.IMLOG2 = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return exponential of complex number
	  return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);
	};

	exports.IMPOWER = function(inumber, number) {
	  number = utils.parseNumber(number);
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);
	  if (utils.anyIsError(number, x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Calculate power of modulus
	  var p = Math.pow(exports.IMABS(inumber), number);

	  // Calculate argument
	  var t = exports.IMARGUMENT(inumber);

	  // Return exponential of complex number
	  return exports.COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit);
	};

	exports.IMPRODUCT = function() {
	  // Initialize result
	  var result = arguments[0];

	  // Loop on all numbers
	  for (var i = 1; i < arguments.length; i++) {
	    // Lookup coefficients of two complex numbers
	    var a = exports.IMREAL(result);
	    var b = exports.IMAGINARY(result);
	    var c = exports.IMREAL(arguments[i]);
	    var d = exports.IMAGINARY(arguments[i]);

	    if (utils.anyIsError(a, b, c, d)) {
	      return error.value;
	    }

	    // Complute product of two complex numbers
	    result = exports.COMPLEX(a * c - b * d, a * d + b * c);
	  }

	  // Return product of complex numbers
	  return result;
	};

	exports.IMREAL = function(inumber) {
	  if (inumber === undefined || inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Return 0 if inumber is equal to 0
	  if (inumber === 0 || inumber === '0') {
	    return 0;
	  }

	  // Handle special cases
	  if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) {
	    return 0;
	  }

	  // Lookup sign
	  var plus = inumber.indexOf('+');
	  var minus = inumber.indexOf('-');
	  if (plus === 0) {
	    plus = inumber.indexOf('+', 1);
	  }
	  if (minus === 0) {
	    minus = inumber.indexOf('-', 1);
	  }

	  // Lookup imaginary unit
	  var last = inumber.substring(inumber.length - 1, inumber.length);
	  var unit = (last === 'i' || last === 'j');

	  if (plus >= 0 || minus >= 0) {
	    // Return error if imaginary unit is neither i nor j
	    if (!unit) {
	      return error.num;
	    }

	    // Return real coefficient of complex number
	    if (plus >= 0) {
	      return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(0, plus));
	    } else {
	      return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
	        error.num :
	        Number(inumber.substring(0, minus));
	    }
	  } else {
	    if (unit) {
	      return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : 0;
	    } else {
	      return (isNaN(inumber)) ? error.num : inumber;
	    }
	  }
	};

	exports.IMSEC = function(inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return secant of complex number
	  return exports.IMDIV('1', exports.IMCOS(inumber));
	};

	exports.IMSECH = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return hyperbolic secant of complex number
	  return exports.IMDIV('1', exports.IMCOSH(inumber));
	};

	exports.IMSIN = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return sine of complex number
	  return exports.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
	};

	exports.IMSINH = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Return hyperbolic sine of complex number
	  return exports.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
	};

	exports.IMSQRT = function(inumber) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit = inumber.substring(inumber.length - 1);
	  unit = (unit === 'i' || unit === 'j') ? unit : 'i';

	  // Calculate power of modulus
	  var s = Math.sqrt(exports.IMABS(inumber));

	  // Calculate argument
	  var t = exports.IMARGUMENT(inumber);

	  // Return exponential of complex number
	  return exports.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
	};

	exports.IMCSC = function (inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.num;
	  }

	  // Return cosecant of complex number
	  return exports.IMDIV('1', exports.IMSIN(inumber));
	};

	exports.IMCSCH = function (inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  // Return error if either coefficient is not a number
	  if (utils.anyIsError(x, y)) {
	    return error.num;
	  }

	  // Return hyperbolic cosecant of complex number
	  return exports.IMDIV('1', exports.IMSINH(inumber));
	};

	exports.IMSUB = function(inumber1, inumber2) {
	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var a = this.IMREAL(inumber1);
	  var b = this.IMAGINARY(inumber1);
	  var c = this.IMREAL(inumber2);
	  var d = this.IMAGINARY(inumber2);

	  if (utils.anyIsError(a, b, c, d)) {
	    return error.value;
	  }

	  // Lookup imaginary unit
	  var unit1 = inumber1.substring(inumber1.length - 1);
	  var unit2 = inumber2.substring(inumber2.length - 1);
	  var unit = 'i';
	  if (unit1 === 'j') {
	    unit = 'j';
	  } else if (unit2 === 'j') {
	    unit = 'j';
	  }

	  // Return _ of two complex numbers
	  return this.COMPLEX(a - c, b - d, unit);
	};

	exports.IMSUM = function() {
	  var args = utils.flatten(arguments);

	  // Initialize result
	  var result = args[0];

	  // Loop on all numbers
	  for (var i = 1; i < args.length; i++) {
	    // Lookup coefficients of two complex numbers
	    var a = this.IMREAL(result);
	    var b = this.IMAGINARY(result);
	    var c = this.IMREAL(args[i]);
	    var d = this.IMAGINARY(args[i]);

	    if (utils.anyIsError(a, b, c, d)) {
	      return error.value;
	    }

	    // Complute product of two complex numbers
	    result = this.COMPLEX(a + c, b + d);
	  }

	  // Return sum of complex numbers
	  return result;
	};

	exports.IMTAN = function(inumber) {
	  // Return error if inumber is a logical value
	  if (inumber === true || inumber === false) {
	    return error.value;
	  }

	  // Lookup real and imaginary coefficients using Formula.js [http://formulajs.org]
	  var x = exports.IMREAL(inumber);
	  var y = exports.IMAGINARY(inumber);

	  if (utils.anyIsError(x, y)) {
	    return error.value;
	  }

	  // Return tangent of complex number
	  return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
	};

	exports.OCT2BIN = function(number, places) {
	  // Return error if number is not hexadecimal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Check if number is negative
	  var negative = (number.length === 10 && number.substring(0, 1) === '7') ? true : false;

	  // Convert octal number to decimal
	  var decimal = (negative) ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);

	  // Return error if number is lower than -512 or greater than 511
	  if (decimal < -512 || decimal > 511) {
	    return error.num;
	  }

	  // Ignore places and return a 10-character binary number if number is negative
	  if (negative) {
	    return '1' + text.REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
	  }

	  // Convert decimal number to binary
	  var result = decimal.toString(2);

	  // Return binary number using the minimum number of characters necessary if places is undefined
	  if (typeof places === 'undefined') {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

	exports.OCT2DEC = function(number) {
	  // Return error if number is not octal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert octal number to decimal
	  var decimal = parseInt(number, 8);

	  // Return decimal number
	  return (decimal >= 536870912) ? decimal - 1073741824 : decimal;
	};

	exports.OCT2HEX = function(number, places) {
	  // Return error if number is not octal or contains more than ten characters (10 digits)
	  if (!/^[0-7]{1,10}$/.test(number)) {
	    return error.num;
	  }

	  // Convert octal number to decimal
	  var decimal = parseInt(number, 8);

	  // Ignore places and return a 10-character octal number if number is negative
	  if (decimal >= 536870912) {
	    return 'ff' + (decimal + 3221225472).toString(16);
	  }

	  // Convert decimal number to hexadecimal
	  var result = decimal.toString(16);

	  // Return hexadecimal number using the minimum number of characters necessary if places is undefined
	  if (places === undefined) {
	    return result;
	  } else {
	    // Return error if places is nonnumeric
	    if (isNaN(places)) {
	      return error.value;
	    }

	    // Return error if places is negative
	    if (places < 0) {
	      return error.num;
	    }

	    // Truncate places in case it is not an integer
	    places = Math.floor(places);

	    // Pad return value with leading 0s (zeros) if necessary (using Underscore.string)
	    return (places >= result.length) ? text.REPT('0', places - result.length) + result : error.num;
	  }
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var M = Math;
	function _horner(arr, v) { return arr.reduce(function(z,w){return v * z + w;},0); };
	function _bessel_iter(x, n, f0, f1, sign) {
	  if(!sign) sign = -1;
	  var tdx = 2 / x, f2;
	  if(n === 0) return f0;
	  if(n === 1) return f1;
	  for(var o = 1; o != n; ++o) {
	    f2 = f1 * o * tdx + sign * f0;
	    f0 = f1; f1 = f2;
	  }
	  return f1;
	}
	function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
	  return function bessel(x,n) {
	    if(n === 0) return bessel0(x);
	    if(n === 1) return bessel1(x);
	    if(n < 0) throw name + ': Order (' + n + ') must be nonnegative';
	    if(nonzero == 1 && x === 0) throw name + ': Undefined when x == 0';
	    if(nonzero == 2 && x <= 0) throw name + ': Undefined when x <= 0';
	    var b0 = bessel0(x), b1 = bessel1(x);
	    return _bessel_iter(x, n, b0, b1, sign);
	  };
	}
	var besselj = (function() {
	  var b0_a1a = [57568490574.0,-13362590354.0,651619640.7,-11214424.18,77392.33017,-184.9052456].reverse();
	  var b0_a2a = [57568490411.0,1029532985.0,9494680.718,59272.64853,267.8532712,1.0].reverse();
	  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
	  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934935152e-7].reverse();
	  var W = 0.636619772; // 2 / Math.PI

	  function bessel0(x) {
	    var a, a1, a2, y = x * x, xx = M.abs(x) - 0.785398164;
	    if(M.abs(x) < 8) {
	      a1 = _horner(b0_a1a, y);
	      a2 = _horner(b0_a2a, y);
	      a = a1/a2;
	    }
	    else {
	      y = 64 / y;
	      a1 = _horner(b0_a1b, y);
	      a2 = _horner(b0_a2b, y);
	      a = M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));
	    }
	    return a;
	  }
	  var b1_a1a = [72362614232.0,-7895059235.0,242396853.1,-2972611.439, 15704.48260, -30.16036606].reverse();
	  var b1_a2a = [144725228442.0, 2300535178.0, 18583304.74, 99447.43394, 376.9991397, 1.0].reverse();
	  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
	  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
	  function bessel1(x) {
	    var a, a1, a2, y = x*x, xx = M.abs(x) - 2.356194491;
	    if(Math.abs(x)< 8) {
	      a1 = x*_horner(b1_a1a, y);
	      a2 = _horner(b1_a2a, y);
	      a = a1 / a2;
	    } else {
	      y = 64 / y;
	      a1=_horner(b1_a1b, y);
	      a2=_horner(b1_a2b, y);
	      a=M.sqrt(W/M.abs(x))*(M.cos(xx)*a1-M.sin(xx)*a2*8/M.abs(x));
	      if(x < 0) a = -a;
	    }
	    return a;
	  }
	  return function besselj(x, n) {
	    n = Math.round(n);
	    if(n === 0) return bessel0(M.abs(x));
	    if(n === 1) return bessel1(M.abs(x));
	    if(n < 0) throw 'BESSELJ: Order (' + n + ') must be nonnegative';
	    if(M.abs(x) === 0) return 0;

	    var ret, j, tox = 2 / M.abs(x), m, jsum, sum, bjp, bj, bjm;
	    if(M.abs(x) > n) {
	      ret = _bessel_iter(x, n, bessel0(M.abs(x)), bessel1(M.abs(x)),-1);
	    } else {
	      m=2*M.floor((n+M.floor(M.sqrt(40*n)))/2);
	      jsum=0;
	      bjp=ret=sum=0.0;
	      bj=1.0;
	      for (j=m;j>0;j--) {
	        bjm=j*tox*bj-bjp;
	        bjp=bj;
	        bj=bjm;
	        if (M.abs(bj) > 1E10) {
	          bj *= 1E-10;
	          bjp *= 1E-10;
	          ret *= 1E-10;
	          sum *= 1E-10;
	        }
	        if (jsum) sum += bj;
	        jsum=!jsum;
	        if (j == n) ret=bjp;
	      }
	      sum=2.0*sum-bj;
	      ret /= sum;
	    }
	    return x < 0 && (n%2) ? -ret : ret;
	  };
	})();
	var bessely = (function() {
	  var b0_a1a = [-2957821389.0, 7062834065.0, -512359803.6, 10879881.29, -86327.92757, 228.4622733].reverse();
	  var b0_a2a = [40076544269.0, 745249964.8, 7189466.438, 47447.26470, 226.1030244, 1.0].reverse();
	  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
	  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934945152e-7].reverse();

	  var W = 0.636619772;
	  function bessel0(x) {
	    var a, a1, a2, y = x * x, xx = x - 0.785398164;
	    if(x < 8) {
	      a1 = _horner(b0_a1a, y);
	      a2 = _horner(b0_a2a, y);
	      a = a1/a2 + W * besselj(x,0) * M.log(x);
	    } else {
	      y = 64 / y;
	      a1 = _horner(b0_a1b, y);
	      a2 = _horner(b0_a2b, y);
	      a = M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);
	    }
	    return a;
	  }

	  var b1_a1a = [-0.4900604943e13, 0.1275274390e13, -0.5153438139e11, 0.7349264551e9, -0.4237922726e7, 0.8511937935e4].reverse();
	  var b1_a2a = [0.2499580570e14, 0.4244419664e12, 0.3733650367e10, 0.2245904002e8, 0.1020426050e6, 0.3549632885e3, 1].reverse();
	  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
	  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
	  function bessel1(x) {
	    var a, a1, a2, y = x*x, xx = x - 2.356194491;
	    if(x < 8) {
	      a1 = x*_horner(b1_a1a, y);
	      a2 = _horner(b1_a2a, y);
	      a = a1/a2 + W * (besselj(x,1) * M.log(x) - 1 / x);
	    } else {
	      y = 64 / y;
	      a1=_horner(b1_a1b, y);
	      a2=_horner(b1_a2b, y);
	      a=M.sqrt(W/x)*(M.sin(xx)*a1+M.cos(xx)*a2*8/x);
	    }
	    return a;
	  }

	  return _bessel_wrap(bessel0, bessel1, 'BESSELY', 1, -1);
	})();
	var besseli = (function() {
	  var b0_a = [1.0, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.360768e-1, 0.45813e-2].reverse();
	  var b0_b = [0.39894228, 0.1328592e-1, 0.225319e-2, -0.157565e-2, 0.916281e-2, -0.2057706e-1, 0.2635537e-1, -0.1647633e-1, 0.392377e-2].reverse();
	  function bessel0(x) {
	    if(x <= 3.75) return _horner(b0_a, x*x/(3.75*3.75));
	    return M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b0_b, 3.75/M.abs(x));
	  }

	  var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.2658733e-1, 0.301532e-2, 0.32411e-3].reverse();
	  var b1_b = [0.39894228, -0.3988024e-1, -0.362018e-2, 0.163801e-2, -0.1031555e-1, 0.2282967e-1, -0.2895312e-1, 0.1787654e-1, -0.420059e-2].reverse();
	  function bessel1(x) {
	    if(x < 3.75) return x * _horner(b1_a, x*x/(3.75*3.75));
	    return (x < 0 ? -1 : 1) * M.exp(M.abs(x))/M.sqrt(M.abs(x))*_horner(b1_b, 3.75/M.abs(x));
	  }

	  return function besseli(x, n) {
	    n = Math.round(n);
	    if(n === 0) return bessel0(x);
	    if(n == 1) return bessel1(x);
	    if(n < 0) throw 'BESSELI Order (' + n + ') must be nonnegative';
	    if(M.abs(x) === 0) return 0;

	    var ret, j, tox = 2 / M.abs(x), m, bip, bi, bim;
	    m=2*M.round((n+M.round(M.sqrt(40*n)))/2);
	    bip=ret=0.0;
	    bi=1.0;
	    for (j=m;j>0;j--) {
	      bim=j*tox*bi + bip;
	      bip=bi; bi=bim;
	      if (M.abs(bi) > 1E10) {
	        bi *= 1E-10;
	        bip *= 1E-10;
	        ret *= 1E-10;
	      }
	      if(j == n) ret = bip;
	    }
	    ret *= besseli(x, 0) / bi;
	    return x < 0 && (n%2) ? -ret : ret;
	  };

	})();

	var besselk = (function() {
	  var b0_a = [-0.57721566, 0.42278420, 0.23069756, 0.3488590e-1, 0.262698e-2, 0.10750e-3, 0.74e-5].reverse();
	  var b0_b = [1.25331414, -0.7832358e-1, 0.2189568e-1, -0.1062446e-1, 0.587872e-2, -0.251540e-2, 0.53208e-3].reverse();
	  function bessel0(x) {
	    if(x <= 2) return -M.log(x/2)*besseli(x,0) + _horner(b0_a, x*x/4);
	    return M.exp(-x)/M.sqrt(x)*_horner(b0_b, 2/x);
	  }

	  var b1_a = [1.0, 0.15443144, -0.67278579, -0.18156897, -0.1919402e-1, -0.110404e-2, -0.4686e-4].reverse();
	  var b1_b = [1.25331414, 0.23498619, -0.3655620e-1, 0.1504268e-1, -0.780353e-2, 0.325614e-2, -0.68245e-3].reverse();
	  function bessel1(x) {
	    if(x <= 2) return M.log(x/2)*besseli(x,1) + (1/x)*_horner(b1_a, x*x/4);
	    return M.exp(-x)/M.sqrt(x)*_horner(b1_b, 2/x);
	  }

	  return _bessel_wrap(bessel0, bessel1, 'BESSELK', 2, 1);
	})();
	if(true) {
	  exports.besselj = besselj;
	  exports.bessely = bessely;
	  exports.besseli = besseli;
	  exports.besselk = besselk;
	}



/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var utils = __webpack_require__(4);

	var d1900 = new Date(1900, 0, 1);
	var WEEK_STARTS = [
	  undefined,
	  0,
	  1,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  undefined,
	  1,
	  2,
	  3,
	  4,
	  5,
	  6,
	  0
	];
	var WEEK_TYPES = [
	  [],
	  [1, 2, 3, 4, 5, 6, 7],
	  [7, 1, 2, 3, 4, 5, 6],
	  [6, 0, 1, 2, 3, 4, 5],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [],
	  [7, 1, 2, 3, 4, 5, 6],
	  [6, 7, 1, 2, 3, 4, 5],
	  [5, 6, 7, 1, 2, 3, 4],
	  [4, 5, 6, 7, 1, 2, 3],
	  [3, 4, 5, 6, 7, 1, 2],
	  [2, 3, 4, 5, 6, 7, 1],
	  [1, 2, 3, 4, 5, 6, 7]
	];
	var WEEKEND_TYPES = [
	  [],
	  [6, 0],
	  [0, 1],
	  [1, 2],
	  [2, 3],
	  [3, 4],
	  [4, 5],
	  [5, 6],
	  undefined,
	  undefined,
	  undefined, [0, 0],
	  [1, 1],
	  [2, 2],
	  [3, 3],
	  [4, 4],
	  [5, 5],
	  [6, 6]
	];

	exports.DATE = function(year, month, day) {
	  year = utils.parseNumber(year);
	  month = utils.parseNumber(month);
	  day = utils.parseNumber(day);
	  if (utils.anyIsError(year, month, day)) {
	    return error.value;
	  }
	  if (year < 0 || month < 0 || day < 0) {
	    return error.num;
	  }
	  var date = new Date(year, month - 1, day);
	  return date;
	};

	exports.DATEVALUE = function(date_text) {
	  if (typeof date_text !== 'string') {
	    return error.value;
	  }
	  var date = Date.parse(date_text);
	  if (isNaN(date)) {
	    return error.value;
	  }
	  if (date <= -2203891200000) {
	    return (date - d1900) / 86400000 + 1;
	  }
	  return (date - d1900) / 86400000 + 2;
	};

	exports.DAY = function(serial_number) {
	  var date = utils.parseDate(serial_number);
	  if (date instanceof Error) {
	    return date;
	  }
	  return date.getDate();
	};

	exports.DAYS = function(end_date, start_date) {
	  end_date = utils.parseDate(end_date);
	  start_date = utils.parseDate(start_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  return serial(end_date) - serial(start_date);
	};

	exports.DAYS360 = function(start_date, end_date, method) {
	  method = utils.parseBool(method);
	  start_date = utils.parseDate(start_date);
	  end_date = utils.parseDate(end_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (method instanceof Error) {
	    return method;
	  }
	  var sm = start_date.getMonth();
	  var em = end_date.getMonth();
	  var sd, ed;
	  if (method) {
	    sd = start_date.getDate() === 31 ? 30 : start_date.getDate();
	    ed = end_date.getDate() === 31 ? 30 : end_date.getDate();
	  } else {
	    var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
	    var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
	    sd = start_date.getDate() === smd ? 30 : start_date.getDate();
	    if (end_date.getDate() === emd) {
	      if (sd < 30) {
	        em++;
	        ed = 1;
	      } else {
	        ed = 30;
	      }
	    } else {
	      ed = end_date.getDate();
	    }
	  }
	  return 360 * (end_date.getFullYear() - start_date.getFullYear()) +
	    30 * (em - sm) + (ed - sd);
	};

	exports.EDATE = function(start_date, months) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (isNaN(months)) {
	    return error.value;
	  }
	  months = parseInt(months, 10);
	  start_date.setMonth(start_date.getMonth() + months);
	  return serial(start_date);
	};

	exports.EOMONTH = function(start_date, months) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  if (isNaN(months)) {
	    return error.value;
	  }
	  months = parseInt(months, 10);
	  return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));
	};

	exports.HOUR = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getHours();
	};

	exports.INTERVAL = function (second) {
	  if (typeof second !== 'number' && typeof second !== 'string') {
	    return error.value;
	  } else {
	    second = parseInt(second, 10);
	  }

	  var year  = Math.floor(second/946080000);
	  second    = second%946080000;
	  var month = Math.floor(second/2592000);
	  second    = second%2592000;
	  var day   = Math.floor(second/86400);
	  second    = second%86400;

	  var hour  = Math.floor(second/3600);
	  second    = second%3600;
	  var min   = Math.floor(second/60);
	  second    = second%60;
	  var sec   = second;

	  year  = (year  > 0) ? year  + 'Y' : '';
	  month = (month > 0) ? month + 'M' : '';
	  day   = (day   > 0) ? day   + 'D' : '';
	  hour  = (hour  > 0) ? hour  + 'H' : '';
	  min   = (min   > 0) ? min   + 'M' : '';
	  sec   = (sec   > 0) ? sec   + 'S' : '';

	  return 'P' + year + month + day +
	  'T' + hour + min + sec;
	};

	exports.ISOWEEKNUM = function(date) {
	  date = utils.parseDate(date);
	  if (date instanceof Error) {
	    return date;
	  }

	  date.setHours(0, 0, 0);
	  date.setDate(date.getDate() + 4 - (date.getDay() || 7));
	  var yearStart = new Date(date.getFullYear(), 0, 1);
	  return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
	};

	exports.MINUTE = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getMinutes();
	};

	exports.MONTH = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getMonth() + 1;
	};

	exports.NETWORKDAYS = function(start_date, end_date, holidays) {
	  return this.NETWORKDAYS.INTL(start_date, end_date, 1, holidays);
	};

	exports.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  end_date = utils.parseDate(end_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }
	  if (weekend === undefined) {
	    weekend = WEEKEND_TYPES[1];
	  } else {
	    weekend = WEEKEND_TYPES[weekend];
	  }
	  if (!(weekend instanceof Array)) {
	    return error.value;
	  }
	  if (holidays === undefined) {
	    holidays = [];
	  } else if (!(holidays instanceof Array)) {
	    holidays = [holidays];
	  }
	  for (var i = 0; i < holidays.length; i++) {
	    var h = utils.parseDate(holidays[i]);
	    if (h instanceof Error) {
	      return h;
	    }
	    holidays[i] = h;
	  }
	  var days = (end_date - start_date) / (1000 * 60 * 60 * 24) + 1;
	  var total = days;
	  var day = start_date;
	  for (i = 0; i < days; i++) {
	    var d = (new Date().getTimezoneOffset() > 0) ? day.getUTCDay() : day.getDay();
	    var dec = false;
	    if (d === weekend[0] || d === weekend[1]) {
	      dec = true;
	    }
	    for (var j = 0; j < holidays.length; j++) {
	      var holiday = holidays[j];
	      if (holiday.getDate() === day.getDate() &&
	        holiday.getMonth() === day.getMonth() &&
	        holiday.getFullYear() === day.getFullYear()) {
	        dec = true;
	        break;
	      }
	    }
	    if (dec) {
	      total--;
	    }
	    day.setDate(day.getDate() + 1);
	  }
	  return total;
	};

	exports.NOW = function() {
	  return new Date();
	};

	exports.SECOND = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getSeconds();
	};

	exports.TIME = function(hour, minute, second) {
	  hour = utils.parseNumber(hour);
	  minute = utils.parseNumber(minute);
	  second = utils.parseNumber(second);
	  if (utils.anyIsError(hour, minute, second)) {
	    return error.value;
	  }
	  if (hour < 0 || minute < 0 || second < 0) {
	    return error.num;
	  }
	  return (3600 * hour + 60 * minute + second) / 86400;
	};

	exports.TIMEVALUE = function(time_text) {
	  time_text = utils.parseDate(time_text);
	  if (time_text instanceof Error) {
	    return time_text;
	  }
	  return (3600 * time_text.getHours() +
	    60 * time_text.getMinutes() +
	    time_text.getSeconds()) / 86400;
	};

	exports.TODAY = function() {
	  return new Date();
	};

	exports.WEEKDAY = function(serial_number, return_type) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  if (return_type === undefined) {
	    return_type = 1;
	  }
	  var day = serial_number.getDay();
	  return WEEK_TYPES[return_type][day];
	};

	exports.WEEKNUM = function(serial_number, return_type) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  if (return_type === undefined) {
	    return_type = 1;
	  }
	  if (return_type === 21) {
	    return this.ISOWEEKNUM(serial_number);
	  }
	  var week_start = WEEK_STARTS[return_type];
	  var jan = new Date(serial_number.getFullYear(), 0, 1);
	  var inc = jan.getDay() < week_start ? 1 : 0;
	  jan -= Math.abs(jan.getDay() - week_start) * 24 * 60 * 60 * 1000;
	  return Math.floor(((serial_number - jan) / (1000 * 60 * 60 * 24)) / 7 + 1) + inc;
	};

	exports.WORKDAY = function(start_date, days, holidays) {
	  return this.WORKDAY.INTL(start_date, days, 1, holidays);
	};

	exports.WORKDAY.INTL = function(start_date, days, weekend, holidays) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  days = utils.parseNumber(days);
	  if (days instanceof Error) {
	    return days;
	  }
	  if (days < 0) {
	    return error.num;
	  }
	  if (weekend === undefined) {
	    weekend = WEEKEND_TYPES[1];
	  } else {
	    weekend = WEEKEND_TYPES[weekend];
	  }
	  if (!(weekend instanceof Array)) {
	    return error.value;
	  }
	  if (holidays === undefined) {
	    holidays = [];
	  } else if (!(holidays instanceof Array)) {
	    holidays = [holidays];
	  }
	  for (var i = 0; i < holidays.length; i++) {
	    var h = utils.parseDate(holidays[i]);
	    if (h instanceof Error) {
	      return h;
	    }
	    holidays[i] = h;
	  }
	  var d = 0;
	  while (d < days) {
	    start_date.setDate(start_date.getDate() + 1);
	    var day = start_date.getDay();
	    if (day === weekend[0] || day === weekend[1]) {
	      continue;
	    }
	    for (var j = 0; j < holidays.length; j++) {
	      var holiday = holidays[j];
	      if (holiday.getDate() === start_date.getDate() &&
	        holiday.getMonth() === start_date.getMonth() &&
	        holiday.getFullYear() === start_date.getFullYear()) {
	        d--;
	        break;
	      }
	    }
	    d++;
	  }
	  return start_date;
	};

	exports.YEAR = function(serial_number) {
	  serial_number = utils.parseDate(serial_number);
	  if (serial_number instanceof Error) {
	    return serial_number;
	  }
	  return serial_number.getFullYear();
	};

	function isLeapYear(year) {
	  return new Date(year, 1, 29).getMonth() === 1;
	}

	// TODO : Use DAYS ?
	function daysBetween(start_date, end_date) {
	  return Math.ceil((end_date - start_date) / 1000 / 60 / 60 / 24);
	}

	exports.YEARFRAC = function(start_date, end_date, basis) {
	  start_date = utils.parseDate(start_date);
	  if (start_date instanceof Error) {
	    return start_date;
	  }
	  end_date = utils.parseDate(end_date);
	  if (end_date instanceof Error) {
	    return end_date;
	  }

	  basis = basis || 0;
	  var sd = start_date.getDate();
	  var sm = start_date.getMonth() + 1;
	  var sy = start_date.getFullYear();
	  var ed = end_date.getDate();
	  var em = end_date.getMonth() + 1;
	  var ey = end_date.getFullYear();

	  switch (basis) {
	    case 0:
	      // US (NASD) 30/360
	      if (sd === 31 && ed === 31) {
	        sd = 30;
	        ed = 30;
	      } else if (sd === 31) {
	        sd = 30;
	      } else if (sd === 30 && ed === 31) {
	        ed = 30;
	      }
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	    case 1:
	      // Actual/actual
	      var feb29Between = function(date1, date2) {
	        var year1 = date1.getFullYear();
	        var mar1year1 = new Date(year1, 2, 1);
	        if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
	          return true;
	        }
	        var year2 = date2.getFullYear();
	        var mar1year2 = new Date(year2, 2, 1);
	        return (isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2);
	      };
	      var ylength = 365;
	      if (sy === ey || ((sy + 1) === ey) && ((sm > em) || ((sm === em) && (sd >= ed)))) {
	        if ((sy === ey && isLeapYear(sy)) ||
	            feb29Between(start_date, end_date) ||
	            (em === 1 && ed === 29)) {
	          ylength = 366;
	        }
	        return daysBetween(start_date, end_date) / ylength;
	      }
	      var years = (ey - sy) + 1;
	      var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1000 / 60 / 60 / 24;
	      var average = days / years;
	      return daysBetween(start_date, end_date) / average;
	    case 2:
	      // Actual/360
	      return daysBetween(start_date, end_date) / 360;
	    case 3:
	      // Actual/365
	      return daysBetween(start_date, end_date) / 365;
	    case 4:
	      // European 30/360
	      return ((ed + em * 30 + ey * 360) - (sd + sm * 30 + sy * 360)) / 360;
	  }
	};

	function serial(date) {
	  var addOn = (date > -2203891200000)?2:1;
	  return (date - d1900) / 86400000 + addOn;
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var stats = __webpack_require__(6);
	var maths = __webpack_require__(2);
	var utils = __webpack_require__(4);

	function compact(array) {
	  if (!array) { return array; }
	  var result = [];
	  for (var i = 0; i < array.length; ++i) {
	    if (!array[i]) { continue; }
	    result.push(array[i]);
	  }
	  return result;
	}

	exports.FINDFIELD = function(database, title) {
	  var index = null;
	  for (var i = 0; i < database.length; i++) {
	    if (database[i][0] === title) {
	      index = i;
	      break;
	    }
	  }

	  // Return error if the input field title is incorrect
	  if (index == null) {
	    return error.value;
	  }
	  return index;
	};

	function findResultIndex(database, criterias) {
	  var matches = {};
	  for (var i = 1; i < database[0].length; ++i) {
	    matches[i] = true;
	  }
	  var maxCriteriaLength = criterias[0].length;
	  for (i = 1; i < criterias.length; ++i) {
	    if (criterias[i].length > maxCriteriaLength) {
	      maxCriteriaLength = criterias[i].length;
	    }
	  }

	  for (var k = 1; k < database.length; ++k) {
	    for (var l = 1; l < database[k].length; ++l) {
	      var currentCriteriaResult = false;
	      var hasMatchingCriteria   = false;
	      for (var j = 0; j < criterias.length; ++j) {
	        var criteria = criterias[j];
	        if (criteria.length < maxCriteriaLength) {
	          continue;
	        }

	        var criteriaField = criteria[0];
	        if (database[k][0] !== criteriaField) {
	          continue;
	        }
	        hasMatchingCriteria = true;
	        for (var p = 1; p < criteria.length; ++p) {
	          currentCriteriaResult = currentCriteriaResult || eval(database[k][l] + criteria[p]);  // jshint ignore:line
	        }
	      }
	      if (hasMatchingCriteria) {
	        matches[l] = matches[l] && currentCriteriaResult;
	      }
	    }
	  }

	  var result = [];
	  for (var n = 0; n < database[0].length; ++n) {
	    if (matches[n]) {
	      result.push(n - 1);
	    }
	  }
	  return result;
	}

	// Database functions
	exports.DAVERAGE = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var sum = 0;
	  for (var i = 0; i < resultIndexes.length; i++) {
	    sum += targetFields[resultIndexes[i]];
	  }
	  return resultIndexes.length === 0 ? error.div0 : sum / resultIndexes.length;
	};

	exports.DCOUNT = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.COUNT(targetValues);
	};

	exports.DCOUNTA = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.COUNTA(targetValues);
	};

	exports.DGET = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  // Return error if no record meets the criteria
	  if (resultIndexes.length === 0) {
	    return error.value;
	  }
	  // Returns the #NUM! error value because more than one record meets the
	  // criteria
	  if (resultIndexes.length > 1) {
	    return error.num;
	  }

	  return targetFields[resultIndexes[0]];
	};

	exports.DMAX = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var maxValue = targetFields[resultIndexes[0]];
	  for (var i = 1; i < resultIndexes.length; i++) {
	    if (maxValue < targetFields[resultIndexes[i]]) {
	      maxValue = targetFields[resultIndexes[i]];
	    }
	  }
	  return maxValue;
	};

	exports.DMIN = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var minValue = targetFields[resultIndexes[0]];
	  for (var i = 1; i < resultIndexes.length; i++) {
	    if (minValue > targetFields[resultIndexes[i]]) {
	      minValue = targetFields[resultIndexes[i]];
	    }
	  }
	  return minValue;
	};

	exports.DPRODUCT = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  var result = 1;
	  for (i = 0; i < targetValues.length; i++) {
	    result *= targetValues[i];
	  }
	  return result;
	};

	exports.DSTDEV = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  return stats.STDEV.S(targetValues);
	};

	exports.DSTDEVP = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  targetValues = compact(targetValues);
	  return stats.STDEV.P(targetValues);
	};

	exports.DSUM = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return maths.SUM(targetValues);
	};

	exports.DVAR = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.VAR.S(targetValues);
	};

	exports.DVARP = function(database, field, criteria) {
	  // Return error if field is not a number and not a string
	  if (isNaN(field) && (typeof field !== "string")) {
	    return error.value;
	  }
	  var resultIndexes = findResultIndex(database, criteria);
	  var targetFields = [];
	  if (typeof field === "string") {
	    var index = exports.FINDFIELD(database, field);
	    targetFields = utils.rest(database[index]);
	  } else {
	    targetFields = utils.rest(database[field]);
	  }
	  var targetValues = [];
	  for (var i = 0; i < resultIndexes.length; i++) {
	    targetValues[i] = targetFields[resultIndexes[i]];
	  }
	  return stats.VAR.P(targetValues);
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var utils = __webpack_require__(4);
	var information = __webpack_require__(11);

	exports.AND = function() {
	  var args = utils.flatten(arguments);
	  var result = true;
	  for (var i = 0; i < args.length; i++) {
	    if (!args[i]) {
	      result = false;
	    }
	  }
	  return result;
	};

	exports.CHOOSE = function() {
	  if (arguments.length < 2) {
	    return error.na;
	  }

	  var index = arguments[0];
	  if (index < 1 || index > 254) {
	    return error.value;
	  }

	  if (arguments.length < index + 1) {
	    return error.value;
	  }

	  return arguments[index];
	};

	exports.FALSE = function() {
	  return false;
	};

	exports.IF = function(test, then_value, otherwise_value) {
	  return test ? then_value : otherwise_value;
	};

	exports.IFERROR = function(value, valueIfError) {
	  if (information.ISERROR(value)) {
	    return valueIfError;
	  }
	  return value;
	};

	exports.IFNA = function(value, value_if_na) {
	  return value === error.na ? value_if_na : value;
	};

	exports.NOT = function(logical) {
	  return !logical;
	};

	exports.OR = function() {
	  var args = utils.flatten(arguments);
	  var result = false;
	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      result = true;
	    }
	  }
	  return result;
	};

	exports.TRUE = function() {
	  return true;
	};

	exports.XOR = function() {
	  var args = utils.flatten(arguments);
	  var result = 0;
	  for (var i = 0; i < args.length; i++) {
	    if (args[i]) {
	      result++;
	    }
	  }
	  return (Math.floor(Math.abs(result)) & 1) ? true : false;
	};

	exports.SWITCH = function () {
	  var result;
	  if (arguments.length > 0)  {
	    var targetValue = arguments[0];
	    var argc = arguments.length - 1;
	    var switchCount = Math.floor(argc / 2);
	    var switchSatisfied = false;
	    var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];

	    if (switchCount) {
	      for (var index = 0; index < switchCount; index++) {
	        if (targetValue === arguments[index * 2 + 1]) {
	          result = arguments[index * 2 + 2];
	          switchSatisfied = true;
	          break;
	        }
	      }
	    }

	    if (!switchSatisfied && defaultClause) {
	      result = defaultClause;
	    }
	  }

	  return result;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);
	var dateTime = __webpack_require__(14);
	var utils = __webpack_require__(4);

	function validDate(d) {
	  return d && d.getTime && !isNaN(d.getTime());
	}

	function ensureDate(d) {
	  return (d instanceof Date)?d:new Date(d);
	}

	exports.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
	  // Return error if either date is invalid
	  issue      = ensureDate(issue);
	  first      = ensureDate(first);
	  settlement = ensureDate(settlement);
	  if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
	    return '#VALUE!';
	  }

	  // Return error if either rate or par are lower than or equal to zero
	  if (rate <= 0 || par <= 0) {
	    return '#NUM!';
	  }

	  // Return error if frequency is neither 1, 2, or 4
	  if ([1, 2, 4].indexOf(frequency) === -1) {
	    return '#NUM!';
	  }

	  // Return error if basis is neither 0, 1, 2, 3, or 4
	  if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
	    return '#NUM!';
	  }

	  // Return error if settlement is before or equal to issue
	  if (settlement <= issue) {
	    return '#NUM!';
	  }

	  // Set default values
	  par   = par   || 0;
	  basis = basis || 0;

	  // Compute accrued interest
	  return par * rate * dateTime.YEARFRAC(issue, settlement, basis);
	};

	// TODO
	exports.ACCRINTM = function() {
	 throw new Error('ACCRINTM is not implemented');
	};

	// TODO
	exports.AMORDEGRC = function() {
	 throw new Error('AMORDEGRC is not implemented');
	};

	// TODO
	exports.AMORLINC = function() {
	 throw new Error('AMORLINC is not implemented');
	};

	// TODO
	exports.COUPDAYBS = function() {
	 throw new Error('COUPDAYBS is not implemented');
	};

	// TODO
	exports.COUPDAYS = function() {
	 throw new Error('COUPDAYS is not implemented');
	};

	// TODO
	exports.COUPDAYSNC = function() {
	 throw new Error('COUPDAYSNC is not implemented');
	};

	// TODO
	exports.COUPNCD = function() {
	 throw new Error('COUPNCD is not implemented');
	};

	// TODO
	exports.COUPNUM = function() {
	 throw new Error('COUPNUM is not implemented');
	};

	// TODO
	exports.COUPPCD = function() {
	 throw new Error('COUPPCD is not implemented');
	};

	exports.CUMIPMT = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names
	  // Requires exports.FV() and exports.PMT() from exports.js [http://stoic.com/exports/]

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, periods, value)) {
	    return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	    return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	    return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	    return error.num;
	  }

	  // Compute cumulative interest
	  var payment = exports.PMT(rate, periods, value, 0, type);
	  var interest = 0;

	  if (start === 1) {
	    if (type === 0) {
	      interest = -value;
	      start++;
	    }
	  }

	  for (var i = start; i <= end; i++) {
	    if (type === 1) {
	      interest += exports.FV(rate, i - 2, payment, value, 1) - payment;
	    } else {
	      interest += exports.FV(rate, i - 1, payment, value, 0);
	    }
	  }
	  interest *= rate;

	  // Return cumulative interest
	  return interest;
	};

	exports.CUMPRINC = function(rate, periods, value, start, end, type) {
	  // Credits: algorithm inspired by Apache OpenOffice
	  // Credits: Hannes Stiebitzhofer for the translations of function and variable names

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, periods, value)) {
	    return error.value;
	  }

	  // Return error if either rate, periods, or value are lower than or equal to zero
	  if (rate <= 0 || periods <= 0 || value <= 0) {
	    return error.num;
	  }

	  // Return error if start < 1, end < 1, or start > end
	  if (start < 1 || end < 1 || start > end) {
	    return error.num;
	  }

	  // Return error if type is neither 0 nor 1
	  if (type !== 0 && type !== 1) {
	    return error.num;
	  }

	  // Compute cumulative principal
	  var payment = exports.PMT(rate, periods, value, 0, type);
	  var principal = 0;
	  if (start === 1) {
	    if (type === 0) {
	      principal = payment + value * rate;
	    } else {
	      principal = payment;
	    }
	    start++;
	  }
	  for (var i = start; i <= end; i++) {
	    if (type > 0) {
	      principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;
	    } else {
	      principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;
	    }
	  }

	  // Return cumulative principal
	  return principal;
	};

	exports.DB = function(cost, salvage, life, period, month) {
	  // Initialize month
	  month = (month === undefined) ? 12 : month;

	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  month = utils.parseNumber(month);
	  if (utils.anyIsError(cost, salvage, life, period, month)) {
	    return error.value;
	  }

	  // Return error if any of the parameters is negative
	  if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
	    return error.num;
	  }

	  // Return error if month is not an integer between 1 and 12
	  if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
	    return error.num;
	  }

	  // Return error if period is greater than life
	  if (period > life) {
	    return error.num;
	  }

	  // Return 0 (zero) if salvage is greater than or equal to cost
	  if (salvage >= cost) {
	    return 0;
	  }

	  // Rate is rounded to three decimals places
	  var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);

	  // Compute initial depreciation
	  var initial = cost * rate * month / 12;

	  // Compute total depreciation
	  var total = initial;
	  var current = 0;
	  var ceiling = (period === life) ? life - 1 : period;
	  for (var i = 2; i <= ceiling; i++) {
	    current = (cost - total) * rate;
	    total += current;
	  }

	  // Depreciation for the first and last periods are special cases
	  if (period === 1) {
	    // First period
	    return initial;
	  } else if (period === life) {
	    // Last period
	    return (cost - total) * rate;
	  } else {
	    return current;
	  }
	};

	exports.DDB = function(cost, salvage, life, period, factor) {
	  // Initialize factor
	  factor = (factor === undefined) ? 2 : factor;

	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  factor = utils.parseNumber(factor);
	  if (utils.anyIsError(cost, salvage, life, period, factor)) {
	    return error.value;
	  }

	  // Return error if any of the parameters is negative or if factor is null
	  if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
	    return error.num;
	  }

	  // Return error if period is greater than life
	  if (period > life) {
	    return error.num;
	  }

	  // Return 0 (zero) if salvage is greater than or equal to cost
	  if (salvage >= cost) {
	    return 0;
	  }

	  // Compute depreciation
	  var total = 0;
	  var current = 0;
	  for (var i = 1; i <= period; i++) {
	    current = Math.min((cost - total) * (factor / life), (cost - salvage - total));
	    total += current;
	  }

	  // Return depreciation
	  return current;
	};

	// TODO
	exports.DISC = function() {
	 throw new Error('DISC is not implemented');
	};

	exports.DOLLARDE = function(dollar, fraction) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  dollar = utils.parseNumber(dollar);
	  fraction = utils.parseNumber(fraction);
	  if (utils.anyIsError(dollar, fraction)) {
	    return error.value;
	  }

	  // Return error if fraction is negative
	  if (fraction < 0) {
	    return error.num;
	  }

	  // Return error if fraction is greater than or equal to 0 and less than 1
	  if (fraction >= 0 && fraction < 1) {
	    return error.div0;
	  }

	  // Truncate fraction if it is not an integer
	  fraction = parseInt(fraction, 10);

	  // Compute integer part
	  var result = parseInt(dollar, 10);

	  // Add decimal part
	  result += (dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;

	  // Round result
	  var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
	  result = Math.round(result * power) / power;

	  // Return converted dollar price
	  return result;
	};

	exports.DOLLARFR = function(dollar, fraction) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  dollar = utils.parseNumber(dollar);
	  fraction = utils.parseNumber(fraction);
	  if (utils.anyIsError(dollar, fraction)) {
	    return error.value;
	  }

	  // Return error if fraction is negative
	  if (fraction < 0) {
	    return error.num;
	  }

	  // Return error if fraction is greater than or equal to 0 and less than 1
	  if (fraction >= 0 && fraction < 1) {
	    return error.div0;
	  }

	  // Truncate fraction if it is not an integer
	  fraction = parseInt(fraction, 10);

	  // Compute integer part
	  var result = parseInt(dollar, 10);

	  // Add decimal part
	  result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;

	  // Return converted dollar price
	  return result;
	};

	// TODO
	exports.DURATION = function() {
	 throw new Error('DURATION is not implemented');
	};

	exports.EFFECT = function(rate, periods) {
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  if (utils.anyIsError(rate, periods)) {
	    return error.value;
	  }

	  // Return error if rate <=0 or periods < 1
	  if (rate <= 0 || periods < 1) {
	    return error.num;
	  }

	  // Truncate periods if it is not an integer
	  periods = parseInt(periods, 10);

	  // Return effective annual interest rate
	  return Math.pow(1 + rate / periods, periods) - 1;
	};

	exports.FV = function(rate, periods, payment, value, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  value = value || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  value = utils.parseNumber(value);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, payment, value, type)) {
	    return error.value;
	  }

	  // Return future value
	  var result;
	  if (rate === 0) {
	    result = value + payment * periods;
	  } else {
	    var term = Math.pow(1 + rate, periods);
	    if (type === 1) {
	      result = value * term + payment * (1 + rate) * (term - 1) / rate;
	    } else {
	      result = value * term + payment * (term - 1) / rate;
	    }
	  }
	  return -result;
	};

	exports.FVSCHEDULE = function(principal, schedule) {
	  principal = utils.parseNumber(principal);
	  schedule = utils.parseNumberArray(utils.flatten(schedule));
	  if (utils.anyIsError(principal, schedule)) {
	    return error.value;
	  }

	  var n = schedule.length;
	  var future = principal;

	  // Apply all interests in schedule
	  for (var i = 0; i < n; i++) {
	    // Apply scheduled interest
	    future *= 1 + schedule[i];
	  }

	  // Return future value
	  return future;
	};

	// TODO
	exports.INTRATE = function() {
	 throw new Error('INTRATE is not implemented');
	};

	exports.IPMT = function(rate, period, periods, present, future, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  period = utils.parseNumber(period);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, period, periods, present, future, type)) {
	    return error.value;
	  }

	  // Compute payment
	  var payment = exports.PMT(rate, periods, present, future, type);

	  // Compute interest
	  var interest;
	  if (period === 1) {
	    if (type === 1) {
	      interest = 0;
	    } else {
	      interest = -present;
	    }
	  } else {
	    if (type === 1) {
	      interest = exports.FV(rate, period - 2, payment, present, 1) - payment;
	    } else {
	      interest = exports.FV(rate, period - 1, payment, present, 0);
	    }
	  }

	  // Return interest
	  return interest * rate;
	};

	exports.IRR = function(values, guess) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  guess = guess || 0;

	  values = utils.parseNumberArray(utils.flatten(values));
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(values, guess)) {
	    return error.value;
	  }

	  // Calculates the resulting amount
	  var irrResult = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = values[0];
	    for (var i = 1; i < values.length; i++) {
	      result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);
	    }
	    return result;
	  };

	  // Calculates the first derivation
	  var irrResultDeriv = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = 0;
	    for (var i = 1; i < values.length; i++) {
	      var frac = (dates[i] - dates[0]) / 365;
	      result -= frac * values[i] / Math.pow(r, frac + 1);
	    }
	    return result;
	  };

	  // Initialize dates and check that values contains at least one positive value and one negative value
	  var dates = [];
	  var positive = false;
	  var negative = false;
	  for (var i = 0; i < values.length; i++) {
	    dates[i] = (i === 0) ? 0 : dates[i - 1] + 365;
	    if (values[i] > 0) {
	      positive = true;
	    }
	    if (values[i] < 0) {
	      negative = true;
	    }
	  }

	  // Return error if values does not contain at least one positive value and one negative value
	  if (!positive || !negative) {
	    return error.num;
	  }

	  // Initialize guess and resultRate
	  guess = (guess === undefined) ? 0.1 : guess;
	  var resultRate = guess;

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-10;

	  // Implement Newton's method
	  var newRate, epsRate, resultValue;
	  var contLoop = true;
	  do {
	    resultValue = irrResult(values, dates, resultRate);
	    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
	    epsRate = Math.abs(newRate - resultRate);
	    resultRate = newRate;
	    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
	  } while (contLoop);

	  // Return internal rate of return
	  return resultRate;
	};

	exports.ISPMT = function(rate, period, periods, value) {
	  rate = utils.parseNumber(rate);
	  period = utils.parseNumber(period);
	  periods = utils.parseNumber(periods);
	  value = utils.parseNumber(value);
	  if (utils.anyIsError(rate, period, periods, value)) {
	    return error.value;
	  }

	  // Return interest
	  return value * rate * (period / periods - 1);
	};

	// TODO
	exports.MDURATION = function() {
	 throw new Error('MDURATION is not implemented');
	};

	exports.MIRR = function(values, finance_rate, reinvest_rate) {
	  values = utils.parseNumberArray(utils.flatten(values));
	  finance_rate = utils.parseNumber(finance_rate);
	  reinvest_rate = utils.parseNumber(reinvest_rate);
	  if (utils.anyIsError(values, finance_rate, reinvest_rate)) {
	    return error.value;
	  }

	  // Initialize number of values
	  var n = values.length;

	  // Lookup payments (negative values) and incomes (positive values)
	  var payments = [];
	  var incomes = [];
	  for (var i = 0; i < n; i++) {
	    if (values[i] < 0) {
	      payments.push(values[i]);
	    } else {
	      incomes.push(values[i]);
	    }
	  }

	  // Return modified internal rate of return
	  var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);
	  var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);
	  return Math.pow(num / den, 1 / (n - 1)) - 1;
	};

	exports.NOMINAL = function(rate, periods) {
	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  if (utils.anyIsError(rate, periods)) {
	    return error.value;
	  }

	  // Return error if rate <=0 or periods < 1
	  if (rate <= 0 || periods < 1) {
	    return error.num;
	  }

	  // Truncate periods if it is not an integer
	  periods = parseInt(periods, 10);

	  // Return nominal annual interest rate
	  return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
	};

	exports.NPER = function(rate, payment, present, future, type) {
	  type = (type === undefined) ? 0 : type;
	  future = (future === undefined) ? 0 : future;

	  rate = utils.parseNumber(rate);
	  payment = utils.parseNumber(payment);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, payment, present, future, type)) {
	    return error.value;
	  }

	  // Return number of periods
	  var num = payment * (1 + rate * type) - future * rate;
	  var den = (present * rate + payment * (1 + rate * type));
	  return Math.log(num / den) / Math.log(1 + rate);
	};

	exports.NPV = function() {
	  var args = utils.parseNumberArray(utils.flatten(arguments));
	  if (args instanceof Error) {
	    return args;
	  }

	  // Lookup rate
	  var rate = args[0];

	  // Initialize net present value
	  var value = 0;

	  // Loop on all values
	  for (var j = 1; j < args.length; j++) {
	    value += args[j] / Math.pow(1 + rate, j);
	  }

	  // Return net present value
	  return value;
	};

	// TODO
	exports.ODDFPRICE = function() {
	 throw new Error('ODDFPRICE is not implemented');
	};

	// TODO
	exports.ODDFYIELD = function() {
	 throw new Error('ODDFYIELD is not implemented');
	};

	// TODO
	exports.ODDLPRICE = function() {
	 throw new Error('ODDLPRICE is not implemented');
	};

	// TODO
	exports.ODDLYIELD = function() {
	 throw new Error('ODDLYIELD is not implemented');
	};

	exports.PDURATION = function(rate, present, future) {
	  rate = utils.parseNumber(rate);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  if (utils.anyIsError(rate, present, future)) {
	    return error.value;
	  }

	  // Return error if rate <=0
	  if (rate <= 0) {
	    return error.num;
	  }

	  // Return number of periods
	  return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
	};

	exports.PMT = function(rate, periods, present, future, type) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, present, future, type)) {
	    return error.value;
	  }

	  // Return payment
	  var result;
	  if (rate === 0) {
	    result = (present + future) / periods;
	  } else {
	    var term = Math.pow(1 + rate, periods);
	    if (type === 1) {
	      result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
	    } else {
	      result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
	    }
	  }
	  return -result;
	};

	exports.PPMT = function(rate, period, periods, present, future, type) {
	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, present, future, type)) {
	    return error.value;
	  }

	  return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);
	};

	// TODO
	exports.PRICE = function() {
	 throw new Error('PRICE is not implemented');
	};

	// TODO
	exports.PRICEDISC = function() {
	 throw new Error('PRICEDISC is not implemented');
	};

	// TODO
	exports.PRICEMAT = function() {
	 throw new Error('PRICEMAT is not implemented');
	};

	exports.PV = function(rate, periods, payment, future, type) {
	  future = future || 0;
	  type = type || 0;

	  rate = utils.parseNumber(rate);
	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  if (utils.anyIsError(rate, periods, payment, future, type)) {
	    return error.value;
	  }

	  // Return present value
	  if (rate === 0) {
	    return -payment * periods - future;
	  } else {
	    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
	  }
	};

	exports.RATE = function(periods, payment, present, future, type, guess) {
	  // Credits: rabugento

	  guess = (guess === undefined) ? 0.01 : guess;
	  future = (future === undefined) ? 0 : future;
	  type = (type === undefined) ? 0 : type;

	  periods = utils.parseNumber(periods);
	  payment = utils.parseNumber(payment);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  type = utils.parseNumber(type);
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(periods, payment, present, future, type, guess)) {
	    return error.value;
	  }

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-6;

	  // Set maximum number of iterations
	  var iterMax = 100;
	  var iter = 0;
	  var close = false;
	  var rate = guess;

	  while (iter < iterMax && !close) {
	    var t1 = Math.pow(rate + 1, periods);
	    var t2 = Math.pow(rate + 1, periods - 1);

	    var f1 = future + t1 * present + payment * (t1 - 1) * (rate * type + 1) / rate;
	    var f2 = periods * t2 * present - payment * (t1 - 1) *(rate * type + 1) / Math.pow(rate,2);
	    var f3 = periods * payment * t2 * (rate * type + 1) / rate + payment * (t1 - 1) * type / rate;

	    var newRate = rate - f1 / (f2 + f3);

	    if (Math.abs(newRate - rate) < epsMax) close = true;
	    iter++
	    rate = newRate;
	  }

	  if (!close) return Number.NaN + rate;
	  return rate;
	};

	// TODO
	exports.RECEIVED = function() {
	 throw new Error('RECEIVED is not implemented');
	};

	exports.RRI = function(periods, present, future) {
	  periods = utils.parseNumber(periods);
	  present = utils.parseNumber(present);
	  future = utils.parseNumber(future);
	  if (utils.anyIsError(periods, present, future)) {
	    return error.value;
	  }

	  // Return error if periods or present is equal to 0 (zero)
	  if (periods === 0 || present === 0) {
	    return error.num;
	  }

	  // Return equivalent interest rate
	  return Math.pow(future / present, 1 / periods) - 1;
	};

	exports.SLN = function(cost, salvage, life) {
	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  if (utils.anyIsError(cost, salvage, life)) {
	    return error.value;
	  }

	  // Return error if life equal to 0 (zero)
	  if (life === 0) {
	    return error.num;
	  }

	  // Return straight-line depreciation
	  return (cost - salvage) / life;
	};

	exports.SYD = function(cost, salvage, life, period) {
	  // Return error if any of the parameters is not a number
	  cost = utils.parseNumber(cost);
	  salvage = utils.parseNumber(salvage);
	  life = utils.parseNumber(life);
	  period = utils.parseNumber(period);
	  if (utils.anyIsError(cost, salvage, life, period)) {
	    return error.value;
	  }

	  // Return error if life equal to 0 (zero)
	  if (life === 0) {
	    return error.num;
	  }

	  // Return error if period is lower than 1 or greater than life
	  if (period < 1 || period > life) {
	    return error.num;
	  }

	  // Truncate period if it is not an integer
	  period = parseInt(period, 10);

	  // Return straight-line depreciation
	  return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1));
	};

	exports.TBILLEQ = function(settlement, maturity, discount) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  discount = utils.parseNumber(discount);
	  if (utils.anyIsError(settlement, maturity, discount)) {
	    return error.value;
	  }

	  // Return error if discount is lower than or equal to zero
	  if (discount <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return (365 * discount) / (360 - discount * dateTime.DAYS360(settlement, maturity, false));
	};

	exports.TBILLPRICE = function(settlement, maturity, discount) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  discount = utils.parseNumber(discount);
	  if (utils.anyIsError(settlement, maturity, discount)) {
	    return error.value;
	  }

	  // Return error if discount is lower than or equal to zero
	  if (discount <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return 100 * (1 - discount * dateTime.DAYS360(settlement, maturity, false) / 360);
	};

	exports.TBILLYIELD = function(settlement, maturity, price) {
	  settlement = utils.parseDate(settlement);
	  maturity = utils.parseDate(maturity);
	  price = utils.parseNumber(price);
	  if (utils.anyIsError(settlement, maturity, price)) {
	    return error.value;
	  }

	  // Return error if price is lower than or equal to zero
	  if (price <= 0) {
	    return error.num;
	  }

	  // Return error if settlement is greater than maturity
	  if (settlement > maturity) {
	    return error.num;
	  }

	  // Return error if maturity is more than one year after settlement
	  if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
	    return error.num;
	  }

	  // Return bond-equivalent yield
	  return (100 - price) * 360 / (price * dateTime.DAYS360(settlement, maturity, false));
	};

	// TODO
	exports.VDB = function() {
	 throw new Error('VDB is not implemented');
	};


	exports.XIRR = function(values, dates, guess) {
	  // Credits: algorithm inspired by Apache OpenOffice

	  values = utils.parseNumberArray(utils.flatten(values));
	  dates = utils.parseDateArray(utils.flatten(dates));
	  guess = utils.parseNumber(guess);
	  if (utils.anyIsError(values, dates, guess)) {
	    return error.value;
	  }

	  // Calculates the resulting amount
	  var irrResult = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = values[0];
	    for (var i = 1; i < values.length; i++) {
	      result += values[i] / Math.pow(r, dateTime.DAYS(dates[i], dates[0]) / 365);
	    }
	    return result;
	  };

	  // Calculates the first derivation
	  var irrResultDeriv = function(values, dates, rate) {
	    var r = rate + 1;
	    var result = 0;
	    for (var i = 1; i < values.length; i++) {
	      var frac = dateTime.DAYS(dates[i], dates[0]) / 365;
	      result -= frac * values[i] / Math.pow(r, frac + 1);
	    }
	    return result;
	  };

	  // Check that values contains at least one positive value and one negative value
	  var positive = false;
	  var negative = false;
	  for (var i = 0; i < values.length; i++) {
	    if (values[i] > 0) {
	      positive = true;
	    }
	    if (values[i] < 0) {
	      negative = true;
	    }
	  }

	  // Return error if values does not contain at least one positive value and one negative value
	  if (!positive || !negative) {
	    return error.num;
	  }

	  // Initialize guess and resultRate
	  guess = guess || 0.1;
	  var resultRate = guess;

	  // Set maximum epsilon for end of iteration
	  var epsMax = 1e-10;

	  // Implement Newton's method
	  var newRate, epsRate, resultValue;
	  var contLoop = true;
	  do {
	    resultValue = irrResult(values, dates, resultRate);
	    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
	    epsRate = Math.abs(newRate - resultRate);
	    resultRate = newRate;
	    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
	  } while (contLoop);

	  // Return internal rate of return
	  return resultRate;
	};

	exports.XNPV = function(rate, values, dates) {
	  rate = utils.parseNumber(rate);
	  values = utils.parseNumberArray(utils.flatten(values));
	  dates = utils.parseDateArray(utils.flatten(dates));
	  if (utils.anyIsError(rate, values, dates)) {
	    return error.value;
	  }

	  var result = 0;
	  for (var i = 0; i < values.length; i++) {
	    result += values[i] / Math.pow(1 + rate, dateTime.DAYS(dates[i], dates[0]) / 365);
	  }
	  return result;
	};

	// TODO
	exports.YIELD = function() {
	 throw new Error('YIELD is not implemented');
	};

	// TODO
	exports.YIELDDISC = function() {
	 throw new Error('YIELDDISC is not implemented');
	};

	// TODO
	exports.YIELDMAT = function() {
	 throw new Error('YIELDMAT is not implemented');
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var error = __webpack_require__(5);

	exports.MATCH = function(lookupValue, lookupArray, matchType) {
	  if (!lookupValue && !lookupArray) {
	    return error.na;
	  }

	  if (arguments.length === 2) {
	    matchType = 1;
	  }
	  if (!(lookupArray instanceof Array)) {
	    return error.na;
	  }

	  if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
	    return error.na;
	  }
	  var index;
	  var indexValue;
	  for (var idx = 0; idx < lookupArray.length; idx++) {
	    if (matchType === 1) {
	      if (lookupArray[idx] === lookupValue) {
	        return idx + 1;
	      } else if (lookupArray[idx] < lookupValue) {
	        if (!indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        } else if (lookupArray[idx] > indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        }
	      }
	    } else if (matchType === 0) {
	      if (typeof lookupValue === 'string') {
	        lookupValue = lookupValue.replace(/\?/g, '.');
	        if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
	          return idx + 1;
	        }
	      } else {
	        if (lookupArray[idx] === lookupValue) {
	          return idx + 1;
	        }
	      }
	    } else if (matchType === -1) {
	      if (lookupArray[idx] === lookupValue) {
	        return idx + 1;
	      } else if (lookupArray[idx] > lookupValue) {
	        if (!indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        } else if (lookupArray[idx] < indexValue) {
	          index = idx + 1;
	          indexValue = lookupArray[idx];
	        }
	      }
	    }
	  }

	  return index ? index : error.na;
	};

/***/ }
/******/ ])
});
;
},{"jStat":2,"numeral":3,"numeric":4}],2:[function(require,module,exports){
this.j$ = this.jStat = (function(Math, undefined) {

// For quick reference.
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

// Calculate correction for IEEE error
// TODO: This calculation can be improved.
function calcRdx(n, m) {
  var val = n > m ? n : m;
  return Math.pow(10,
                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));
}


var isArray = Array.isArray || function isArray(arg) {
  return toString.call(arg) === '[object Array]';
};


function isFunction(arg) {
  return toString.call(arg) === '[object Function]';
}


function isNumber(arg) {
  return typeof arg === 'number' && arg === arg;
}


// Converts the jStat matrix to vector.
function toVector(arr) {
  return concat.apply([], arr);
}


// The one and only jStat constructor.
function jStat() {
  return new jStat._init(arguments);
}


// TODO: Remove after all references in src files have been removed.
jStat.fn = jStat.prototype;


// By separating the initializer from the constructor it's easier to handle
// always returning a new instance whether "new" was used or not.
jStat._init = function _init(args) {
  var i;

  // If first argument is an array, must be vector or matrix.
  if (isArray(args[0])) {
    // Check if matrix.
    if (isArray(args[0][0])) {
      // See if a mapping function was also passed.
      if (isFunction(args[1]))
        args[0] = jStat.map(args[0], args[1]);
      // Iterate over each is faster than this.push.apply(this, args[0].
      for (i = 0; i < args[0].length; i++)
        this[i] = args[0][i];
      this.length = args[0].length;

    // Otherwise must be a vector.
    } else {
      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
      this.length = 1;
    }

  // If first argument is number, assume creation of sequence.
  } else if (isNumber(args[0])) {
    this[0] = jStat.seq.apply(null, args);
    this.length = 1;

  // Handle case when jStat object is passed to jStat.
  } else if (args[0] instanceof jStat) {
    // Duplicate the object and pass it back.
    return jStat(args[0].toArray());

  // Unexpected argument value, return empty jStat object.
  // TODO: This is strange behavior. Shouldn't this throw or some such to let
  // the user know they had bad arguments?
  } else {
    this[0] = [];
    this.length = 1;
  }

  return this;
};
jStat._init.prototype = jStat.prototype;
jStat._init.constructor = jStat;


// Utility functions.
// TODO: for internal use only?
jStat.utils = {
  calcRdx: calcRdx,
  isArray: isArray,
  isFunction: isFunction,
  isNumber: isNumber,
  toVector: toVector
};


// Easily extend the jStat object.
// TODO: is this seriously necessary?
jStat.extend = function extend(obj) {
  var i, j;

  if (arguments.length === 1) {
    for (j in obj)
      jStat[j] = obj[j];
    return this;
  }

  for (i = 1; i < arguments.length; i++) {
    for (j in arguments[i])
      obj[j] = arguments[i][j];
  }

  return obj;
};


// Returns the number of rows in the matrix.
jStat.rows = function rows(arr) {
  return arr.length || 1;
};


// Returns the number of columns in the matrix.
jStat.cols = function cols(arr) {
  return arr[0].length || 1;
};


// Returns the dimensions of the object { rows: i, cols: j }
jStat.dimensions = function dimensions(arr) {
  return {
    rows: jStat.rows(arr),
    cols: jStat.cols(arr)
  };
};


// Returns a specified row as a vector
jStat.row = function row(arr, index) {
  return arr[index];
};


// Returns the specified column as a vector
jStat.col = function cols(arr, index) {
  var column = new Array(arr.length);
  for (var i = 0; i < arr.length; i++)
    column[i] = [arr[i][index]];
  return column;
};


// Returns the diagonal of the matrix
jStat.diag = function diag(arr) {
  var nrow = jStat.rows(arr);
  var res = new Array(nrow);
  for (var row = 0; row < nrow; row++)
    res[row] = [arr[row][row]];
  return res;
};


// Returns the anti-diagonal of the matrix
jStat.antidiag = function antidiag(arr) {
  var nrow = jStat.rows(arr) - 1;
  var res = new Array(nrow);
  for (var i = 0; nrow >= 0; nrow--, i++)
    res[i] = [arr[i][nrow]];
  return res;
};

// Transpose a matrix or array.
jStat.transpose = function transpose(arr) {
  var obj = [];
  var objArr, rows, cols, j, i;

  // Make sure arr is in matrix format.
  if (!isArray(arr[0]))
    arr = [arr];

  rows = arr.length;
  cols = arr[0].length;

  for (i = 0; i < cols; i++) {
    objArr = new Array(rows);
    for (j = 0; j < rows; j++)
      objArr[j] = arr[j][i];
    obj.push(objArr);
  }

  // If obj is vector, return only single array.
  return obj.length === 1 ? obj[0] : obj;
};


// Map a function to an array or array of arrays.
// "toAlter" is an internal variable.
jStat.map = function map(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    for (col = 0; col < ncol; col++)
      res[row][col] = func(arr[row][col], row, col);
  }

  return res.length === 1 ? res[0] : res;
};


// Destructively alter an array.
jStat.alter = function alter(arr, func) {
  return jStat.map(arr, func, true);
};


// Generate a rows x cols matrix according to the supplied function.
jStat.create = function  create(rows, cols, func) {
  var res = new Array(rows);
  var i, j;

  if (isFunction(cols)) {
    func = cols;
    cols = rows;
  }

  for (i = 0; i < rows; i++) {
    res[i] = new Array(cols);
    for (j = 0; j < cols; j++)
      res[i][j] = func(i, j);
  }

  return res;
};


function retZero() { return 0; }


// Generate a rows x cols matrix of zeros.
jStat.zeros = function zeros(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retZero);
};


function retOne() { return 1; }


// Generate a rows x cols matrix of ones.
jStat.ones = function ones(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retOne);
};


// Generate a rows x cols matrix of uniformly random numbers.
jStat.rand = function rand(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, Math.random);
};


function retIdent(i, j) { return i === j ? 1 : 0; }


// Generate an identity matrix of size row x cols.
jStat.identity = function identity(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retIdent);
};


// Tests whether a matrix is symmetric
jStat.symmetric = function symmetric(arr) {
  var issymmetric = true;
  var size = arr.length;
  var row, col;

  if (arr.length !== arr[0].length)
    return false;

  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++)
      if (arr[col][row] !== arr[row][col])
        return false;
  }

  return true;
};


// Set all values to zero.
jStat.clear = function clear(arr) {
  return jStat.alter(arr, retZero);
};


// Generate sequence.
jStat.seq = function seq(min, max, length, func) {
  if (!isFunction(func))
    func = false;

  var arr = [];
  var hival = calcRdx(min, max);
  var step = (max * hival - min * hival) / ((length - 1) * hival);
  var current = min;
  var cnt;

  // Current is assigned using a technique to compensate for IEEE error.
  // TODO: Needs better implementation.
  for (cnt = 0;
       current <= max;
       cnt++, current = (min * hival + step * hival * cnt) / hival) {
    arr.push((func ? func(current, cnt) : current));
  }

  return arr;
};


// TODO: Go over this entire implementation. Seems a tragic waste of resources
// doing all this work. Instead, and while ugly, use new Function() to generate
// a custom function for each static method.

// Quick reference.
var jProto = jStat.prototype;

// Default length.
jProto.length = 0;

// For internal use only.
// TODO: Check if they're actually used, and if they are then rename them
// to _*
jProto.push = Array.prototype.push;
jProto.sort = Array.prototype.sort;
jProto.splice = Array.prototype.splice;
jProto.slice = Array.prototype.slice;


// Return a clean array.
jProto.toArray = function toArray() {
  return this.length > 1 ? slice.call(this) : slice.call(this)[0];
};


// Map a function to a matrix or vector.
jProto.map = function map(func, toAlter) {
  return jStat(jStat.map(this, func, toAlter));
};


// Destructively alter an array.
jProto.alter = function alter(func) {
  jStat.alter(this, func);
  return this;
};


// Extend prototype with methods that have no argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(func) {
      var self = this,
      results;
      // Check for callback.
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self));
        });
        return this;
      }
      results = jStat[passfunc](this);
      return isArray(results) ? jStat(results) : results;
    };
  })(funcs[i]);
})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));


// Extend prototype with methods that have one argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(index, func) {
      var self = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self, index));
        });
        return this;
      }
      return jStat(jStat[passfunc](this, index));
    };
  })(funcs[i]);
})('row col'.split(' '));


// Extend prototype with simple shortcut methods.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = new Function(
        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');
  })(funcs[i]);
})('create zeros ones rand identity'.split(' '));


// Exposing jStat.
return jStat;

}(Math));
(function(jStat, Math) {

var isFunction = jStat.utils.isFunction;

// Ascending functions for sort
function ascNum(a, b) { return a - b; }

function clip(arg, min, max) {
  return Math.max(min, Math.min(arg, max));
}


// sum of an array
jStat.sum = function sum(arr) {
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};


// sum squared
jStat.sumsqrd = function sumsqrd(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i] * arr[i];
  return sum;
};


// sum of squared errors of prediction (SSE)
jStat.sumsqerr = function sumsqerr(arr) {
  var mean = jStat.mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - mean;
    sum += tmp * tmp;
  }
  return sum;
};


// product of an array
jStat.product = function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0)
    prod *= arr[i];
  return prod;
};


// minimum value of an array
jStat.min = function min(arr) {
  var low = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] < low)
      low = arr[i];
  return low;
};


// maximum value of an array
jStat.max = function max(arr) {
  var high = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] > high)
      high = arr[i];
  return high;
};


// mean value of an array
jStat.mean = function mean(arr) {
  return jStat.sum(arr) / arr.length;
};


// mean squared error (MSE)
jStat.meansqerr = function meansqerr(arr) {
  return jStat.sumsqerr(arr) / arr.length;
};


// geometric mean of an array
jStat.geomean = function geomean(arr) {
  return Math.pow(jStat.product(arr), 1 / arr.length);
};


// median of an array
jStat.median = function median(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  // check if array is even or odd, then return the appropriate
  return !(arrlen & 1)
    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2
    : _arr[(arrlen / 2) | 0 ];
};


// cumulative sum of an array
jStat.cumsum = function cumsum(arr) {
  var len = arr.length;
  var sums = new Array(len);
  var i;
  sums[0] = arr[0];
  for (i = 1; i < len; i++)
    sums[i] = sums[i - 1] + arr[i];
  return sums;
};


// successive differences of a sequence
jStat.diff = function diff(arr) {
  var diffs = [];
  var arrLen = arr.length;
  var i;
  for (i = 1; i < arrLen; i++)
    diffs.push(arr[i] - arr[i - 1]);
  return diffs;
};


// mode of an array
// if there are multiple modes of an array, return all of them
// is this the appropriate way of handling it?
jStat.mode = function mode(arr) {
  var arrLen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  var count = 1;
  var maxCount = 0;
  var numMaxCount = 0;
  var mode_arr = [];
  var i;

  for (i = 0; i < arrLen; i++) {
    if (_arr[i] === _arr[i + 1]) {
      count++;
    } else {
      if (count > maxCount) {
        mode_arr = [_arr[i]];
        maxCount = count;
        numMaxCount = 0;
      }
      // are there multiple max counts
      else if (count === maxCount) {
        mode_arr.push(_arr[i]);
        numMaxCount++;
      }
      // resetting count for new value in array
      count = 1;
    }
  }

  return numMaxCount === 0 ? mode_arr[0] : mode_arr;
};


// range of an array
jStat.range = function range(arr) {
  return jStat.max(arr) - jStat.min(arr);
};

// variance of an array
// flag indicates population vs sample
jStat.variance = function variance(arr, flag) {
  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
};


// standard deviation of an array
// flag indicates population vs sample
jStat.stdev = function stdev(arr, flag) {
  return Math.sqrt(jStat.variance(arr, flag));
};


// mean deviation (mean absolute deviation) of an array
jStat.meandev = function meandev(arr) {
  var devSum = 0;
  var mean = jStat.mean(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - mean);
  return devSum / arr.length;
};


// median deviation (median absolute deviation) of an array
jStat.meddev = function meddev(arr) {
  var devSum = 0;
  var median = jStat.median(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - median);
  return devSum / arr.length;
};


// coefficient of variation
jStat.coeffvar = function coeffvar(arr) {
  return jStat.stdev(arr) / jStat.mean(arr);
};


// quartiles of an array
jStat.quartiles = function quartiles(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  return [
    _arr[ Math.round((arrlen) / 4) - 1 ],
    _arr[ Math.round((arrlen) / 2) - 1 ],
    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]
  ];
};


// Arbitary quantiles of an array. Direct port of the scipy.stats
// implementation by Pierre GF Gerard-Marchant.
jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
  var sortedArray = arr.slice().sort(ascNum);
  var quantileVals = [quantilesArray.length];
  var n = arr.length;
  var i, p, m, aleph, k, gamma;

  if (typeof alphap === 'undefined')
    alphap = 3 / 8;
  if (typeof betap === 'undefined')
    betap = 3 / 8;

  for (i = 0; i < quantilesArray.length; i++) {
    p = quantilesArray[i];
    m = alphap + p * (1 - alphap - betap);
    aleph = n * p + m;
    k = Math.floor(clip(aleph, 1, n - 1));
    gamma = clip(aleph - k, 0, 1);
    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
  }

  return quantileVals;
};

// The percentile rank of score in a given array. Returns the percentage
// of all values in the input array that are less than (kind='strict') or
// less or equal than (kind='weak') score. Default is weak.
jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
  var counter = 0;
  var len = arr.length;
  var strict = false;
  var value, i;

  if (kind === 'strict')
    strict = true;

  for (i = 0; i < len; i++) {
    value = arr[i];
    if ((strict && value < score) ||
        (!strict && value <= score)) {
      counter++;
    }
  }

  return counter / len;
};

// covariance of two arrays
jStat.covariance = function covariance(arr1, arr2) {
  var u = jStat.mean(arr1);
  var v = jStat.mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;

  for (i = 0; i < arr1Len; i++)
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);

  return jStat.sum(sq_dev) / (arr1Len - 1);
};


// (pearson's) population correlation coefficient, rho
jStat.corrcoeff = function corrcoeff(arr1, arr2) {
  return jStat.covariance(arr1, arr2) /
      jStat.stdev(arr1, 1) /
      jStat.stdev(arr2, 1);
};


var jProto = jStat.prototype;


// Extend jProto with method for calculating cumulative sums, as it does not
// run again in case of true.
// If a matrix is passed, automatically assume operation should be done on the
// columns.
jProto.cumsum = function(fullbool, func) {
  var arr = [];
  var i = 0;
  var tmpthis = this;

  // Assignment reassignation depending on how parameters were passed in.
  if (isFunction(fullbool)) {
    func = fullbool;
    fullbool = false;
  }

  // Check if a callback was passed with the function.
  if (func) {
    setTimeout(function() {
      func.call(tmpthis, jProto.cumsum.call(tmpthis, fullbool));
    });
    return this;
  }

  // Check if matrix and run calculations.
  if (this.length > 1) {
    tmpthis = fullbool === true ? this : this.transpose();
    for (; i < tmpthis.length; i++)
      arr[i] = jStat.cumsum(tmpthis[i]);
    return arr;
  }

  return jStat.cumsum(this[0], fullbool);
};


// Extend jProto with methods which don't require arguments and work on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return fullbool === true
            ? jStat[passfunc](jStat.utils.toVector(arr))
            : arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('sum sumsqrd sumsqerr product min max mean meansqerr geomean median diff ' +
    'mode range variance stdev meandev meddev coeffvar quartiles').split(' '));


// Extend jProto with functions that take arguments. Operations on matrices are
// done on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function() {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      var args = Array.prototype.slice.call(arguments);

      // If the last argument is a function, we assume it's a callback; we
      // strip the callback out and call the function again.
      if (isFunction(args[args.length - 1])) {
        var callbackFunction = args[args.length - 1];
        var argsToPass = args.slice(0, args.length - 1);

        setTimeout(function() {
          callbackFunction.call(tmpthis,
                                jProto[passfunc].apply(tmpthis, argsToPass));
        });
        return this;

      // Otherwise we curry the function args and call normally.
      } else {
        var callbackFunction = undefined;
        var curriedFunction = function curriedFunction(vector) {
          return jStat[passfunc].apply(tmpthis, [vector].concat(args));
        }
      }

      // If this is a matrix, run column-by-column.
      if (this.length > 1) {
        tmpthis = tmpthis.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = curriedFunction(tmpthis[i]);
        return arr;
      }

      // Otherwise run on the vector.
      return curriedFunction(this[0]);
    };
  })(funcs[i]);
})('quantiles percentileOfScore'.split(' '));

}(this.jStat, Math));
// Special functions //
(function(jStat, Math) {

// Log-gamma function
jStat.gammaln = function gammaln(x) {
  var j = 0;
  var cof = [
    76.18009172947146, -86.50532032941677, 24.01409824083091,
    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
  ];
  var ser = 1.000000000190015;
  var xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++)
    ser += cof[j] / ++y;
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
};


// gamma of x
jStat.gammafn = function gammafn(x) {
  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,
           629.3311553128184, 866.9662027904133, -31451.272968848367,
           -36144.413418691176, 66456.14382024054
  ];
  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,
           -3107.771671572311, 22538.118420980151, 4755.8462775278811,
           -134659.9598649693, -115132.2596755535];
  var fact = false;
  var n = 0;
  var xden = 0;
  var xnum = 0;
  var y = x;
  var i, z, yi, res, sum, ysq;
  if (y <= 0) {
    res = y % 1 + 3.6e-16;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
};


// lower incomplete gamma function P(a,x)
jStat.gammap = function gammap(a, x) {
  var aln = jStat.gammaln(a);
  var ap = a;
  var sum = 1 / a;
  var del = sum;
  var b = x + 1 - a;
  var c = 1 / 1.0e-30;
  var d = 1 / b;
  var h = d;
  var i = 1;
  // calculate maximum number of itterations required for a
  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  var an, endval;

  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return sum * Math.exp(-x + a * Math.log(x) - (aln));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }

  return 1 - h * Math.exp(-x + a * Math.log(x) - (aln));
};


// natural log factorial of n
jStat.factorialln = function factorialln(n) {
  return n < 0 ? NaN : jStat.gammaln(n + 1);
};

// factorial of n
jStat.factorial = function factorial(n) {
  return n < 0 ? NaN : jStat.gammafn(n + 1);
};

// combinations of n, m
jStat.combination = function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return (n > 170 || m > 170)
      ? Math.exp(jStat.combinationln(n, m))
      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);
};


jStat.combinationln = function combinationln(n, m){
  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
};


// permutations of n, m
jStat.permutation = function permutation(n, m) {
  return jStat.factorial(n) / jStat.factorial(n - m);
};


// beta function
jStat.betafn = function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0)
    return undefined;
  // make sure x + y doesn't exceed the upper limit of usable values
  return (x + y > 170)
      ? Math.exp(jStat.betaln(x, y))
      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
};


// natural logarithm of beta function
jStat.betaln = function betaln(x, y) {
  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
};


// Evaluates the continued fraction for incomplete beta function by modified
// Lentz's method.
jStat.betacf = function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h = d;

  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7)
      break;
  }

  return h;
};


// Returns the inverse incomplte gamma function
jStat.gammapinv = function gammapinv(p, a) {
  var j = 0;
  var a1 = a - 1;
  var EPS = 1e-8;
  var gln = jStat.gammaln(a);
  var x, err, t, u, pp, lna1, afac;

  if (p >= 1)
    return Math.max(100, a + 100 * Math.sqrt(a));
  if (p <= 0)
    return 0;
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    x = Math.max(1e-3,
                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t)
      x = Math.pow(p / t, 1 / a);
    else
      x = 1 - Math.log(1 - (p - t) / (1 - t));
  }

  for(; j < 12; j++) {
    if (x <= 0)
      return 0;
    err = jStat.gammap(a, x) - p;
    if (a > 1)
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    else
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (Math.abs(t) < EPS * x)
      break;
  }

  return x;
};


// Returns the error function erf(x)
jStat.erf = function erf(x) {
  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,
             -6.886027e-12, 8.94487e-13, 3.13092e-13,
             -1.12708e-13, 3.81e-16, 7.106e-15,
             -1.523e-15, -9.4e-17, 1.21e-16,
             -2.8e-17];
  var j = cof.length - 1;
  var isneg = false;
  var d = 0;
  var dd = 0;
  var t, ty, tmp, res;

  if (x < 0) {
    x = -x;
    isneg = true;
  }

  t = 2 / (2 + x);
  ty = 4 * t - 2;

  for(; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }

  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
};


// Returns the complmentary error function erfc(x)
jStat.erfc = function erfc(x) {
  return 1 - jStat.erf(x);
};


// Returns the inverse of the complementary error function
jStat.erfcinv = function erfcinv(p) {
  var j = 0;
  var x, err, t, pp;
  if (p >= 2)
    return -100;
  if (p <= 0)
    return 100;
  pp = (p < 1) ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) /
                  (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = jStat.erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return (p < 1) ? x : -x;
};


// Returns the inverse of the incomplete beta function
jStat.ibetainv = function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0)
    return 0;
  if (p >= 1)
    return 1;
  if (a >= 1 && b >= 1) {
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));
    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *
        (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w)
      x = Math.pow(a * w * p, 1 / a);
    else
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
  for(; j < 10; j++) {
    if (x === 0 || x === 1)
      return x;
    err = jStat.ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (x >= 1)
      x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0)
      break;
  }
  return x;
};


// Returns the incomplete beta function I_x(a,b)
jStat.ibeta = function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = (x === 0 || x === 1) ?  0 :
    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -
             jStat.gammaln(b) + a * Math.log(x) + b *
             Math.log(1 - x));
  if (x < 0 || x > 1)
    return false;
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    return bt * jStat.betacf(x, a, b) / a;
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * jStat.betacf(1 - x, b, a) / b;
};


// Returns a normal deviate (mu=0, sigma=1).
// If n and m are specified it returns a object of normal deviates.
jStat.randn = function randn(n, m) {
  var u, v, x, y, q, mat;
  if (!m)
    m = n;
  if (n)
    return jStat.create(n, m, function() { return jStat.randn(); });
  do {
    u = Math.random();
    v = 1.7156 * (Math.random() - 0.5);
    x = u - 0.449871;
    y = Math.abs(v) + 0.386595;
    q = x * x + y * (0.19600 * y - 0.25472 * x);
  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));
  return v / u;
};


// Returns a gamma deviate by the method of Marsaglia and Tsang.
jStat.randg = function randg(shape, n, m) {
  var oalph = shape;
  var a1, a2, u, v, x, mat;
  if (!m)
    m = n;
  if (!shape)
    shape = 1;
  if (n) {
    mat = jStat.zeros(n,m);
    mat.alter(function() { return jStat.randg(shape); });
    return mat;
  }
  if (shape < 1)
    shape += 1;
  a1 = shape - 1 / 3;
  a2 = 1 / Math.sqrt(9 * a1);
  do {
    do {
      x = jStat.randn();
      v = 1 + a2 * x;
    } while(v <= 0);
    v = v * v * v;
    u = Math.random();
  } while(u > 1 - 0.331 * Math.pow(x, 4) &&
          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));
  // alpha > 1
  if (shape == oalph)
    return a1 * v;
  // alpha < 1
  do {
    u = Math.random();
  } while(u === 0);
  return Math.pow(u, 1 / oalph) * a1 * v;
};


// making use of static methods on the instance
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(
          jStat.map(this, function(value) { return jStat[passfunc](value); }));
    }
  })(funcs[i]);
})('gammaln gammafn factorial factorialln'.split(' '));


(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(jStat[passfunc].apply(null, arguments));
    };
  })(funcs[i]);
})('randn'.split(' '));

}(this.jStat, Math));
(function(jStat, Math) {

// generate all distribution instance methods
(function(list) {
  for (var i = 0; i < list.length; i++) (function(func) {
    // distribution instance method
    jStat[func] = function(a, b, c) {
      if (!(this instanceof arguments.callee))
        return new arguments.callee(a, b, c);
      this._a = a;
      this._b = b;
      this._c = c;
      return this;
    };
    // distribution method to be used on a jStat instance
    jStat.fn[func] = function(a, b, c) {
      var newthis = jStat[func](a, b, c);
      newthis.data = this;
      return newthis;
    };
    // sample instance method
    jStat[func].prototype.sample = function(arr) {
      var a = this._a;
      var b = this._b;
      var c = this._c;
      if (arr)
        return jStat.alter(arr, function() {
          return jStat[func].sample(a, b, c);
        });
      else
        return jStat[func].sample(a, b, c);
    };
    // generate the pdf, cdf and inv instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function(x) {
          var a = this._a;
          var b = this._b;
          var c = this._c;
          if (!x && x !== 0)
            x = this.data;
          if (typeof x !== 'number') {
            return jStat.fn.map.call(x, function(x) {
              return jStat[func][fnfunc](x, a, b, c);
            });
          }
          return jStat[func][fnfunc](x, a, b, c);
        };
      })(vals[i]);
    })('pdf cdf inv'.split(' '));
    // generate the mean, median, mode and variance instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function() {
          return jStat[func][fnfunc](this._a, this._b, this._c);
        };
      })(vals[i]);
    })('mean median mode variance'.split(' '));
  })(list[i]);
})((
  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +
  'lognormal normal pareto studentt weibull uniform  binomial negbin hypgeom ' +
  'poisson triangular'
).split(' '));



// extend beta function with static methods
jStat.extend(jStat.beta, {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0)
      return 0;
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1)
      return 1;

    if (alpha < 512 || beta < 512) {
      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /
          jStat.betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) +
                      (beta - 1) * Math.log(1 - x) -
                      jStat.betaln(alpha, beta));
    }
  },

  cdf: function cdf(x, alpha, beta) {
    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
  },

  inv: function inv(x, alpha, beta) {
    return jStat.ibetainv(x, alpha, beta);
  },

  mean: function mean(alpha, beta) {
    return alpha / (alpha + beta);
  },

  median: function median(alpha, beta) {
    throw new Error('median not yet implemented');
  },

  mode: function mode(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  },

  // return a random sample
  sample: function sample(alpha, beta) {
    var u = jStat.randg(alpha);
    return u / (u + jStat.randg(beta));
  },

  variance: function variance(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  }
});

// extend F function with static methods
jStat.extend(jStat.centralF, {
  pdf: function pdf(x, df1, df2) {
    if (x < 0)
      return undefined;
    return Math.sqrt((Math.pow(df1 * x, df1) * Math.pow(df2, df2)) /
                     (Math.pow(df1 * x + df2, df1 + df2))) /
                     (x * jStat.betafn(df1/2, df2/2));

  },

  cdf: function cdf(x, df1, df2) {
    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
  },

  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
  },

  mean: function mean(df1, df2) {
    return (df2 > 2) ? df2 / (df2 - 2) : undefined;
  },

  mode: function mode(df1, df2) {
    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;
  },

  // return a random sample
  sample: function sample(df1, df2) {
    var x1 = jStat.randg(df1 / 2) * 2;
    var x2 = jStat.randg(df2 / 2) * 2;
    return (x1 / df1) / (x2 / df2);
  },

  variance: function variance(df1, df2) {
    if (df2 <= 4)
      return undefined;
    return 2 * df2 * df2 * (df1 + df2 - 2) /
        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
  }
});


// extend cauchy function with static methods
jStat.extend(jStat.cauchy, {
  pdf: function pdf(x, local, scale) {
    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;
  },

  cdf: function cdf(x, local, scale) {
    return Math.atan((x - local) / scale) / Math.PI + 0.5;
  },

  inv: function(p, local, scale) {
    return local + scale * Math.tan(Math.PI * (p - 0.5));
  },

  median: function median(local, scale) {
    return local;
  },

  mode: function mode(local, scale) {
    return local;
  },

  sample: function sample(local, scale) {
    return jStat.randn() *
        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
  }
});



// extend chisquare function with static methods
jStat.extend(jStat.chisquare, {
  pdf: function pdf(x, dof) {
    return Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *
                    Math.log(2) - jStat.gammaln(dof / 2));
  },

  cdf: function cdf(x, dof) {
    return jStat.gammap(dof / 2, x / 2);
  },

  inv: function(p, dof) {
    return 2 * jStat.gammapinv(p, 0.5 * dof);
  },

  mean : function(dof) {
    return dof;
  },

  // TODO: this is an approximation (is there a better way?)
  median: function median(dof) {
    return dof * Math.pow(1 - (2 / (9 * dof)), 3);
  },

  mode: function mode(dof) {
    return (dof - 2 > 0) ? dof - 2 : 0;
  },

  sample: function sample(dof) {
    return jStat.randg(dof / 2) * 2;
  },

  variance: function variance(dof) {
    return 2 * dof;
  }
});



// extend exponential function with static methods
jStat.extend(jStat.exponential, {
  pdf: function pdf(x, rate) {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },

  cdf: function cdf(x, rate) {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  },

  inv: function(p, rate) {
    return -Math.log(1 - p) / rate;
  },

  mean : function(rate) {
    return 1 / rate;
  },

  median: function (rate) {
    return (1 / rate) * Math.log(2);
  },

  mode: function mode(rate) {
    return 0;
  },

  sample: function sample(rate) {
    return -1 / rate * Math.log(Math.random());
  },

  variance : function(rate) {
    return Math.pow(rate, -2);
  }
});



// extend gamma function with static methods
jStat.extend(jStat.gamma, {
  pdf: function pdf(x, shape, scale) {
    return Math.exp((shape - 1) * Math.log(x) - x / scale -
                    jStat.gammaln(shape) - shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    return jStat.gammap(shape, x / scale);
  },

  inv: function(p, shape, scale) {
    return jStat.gammapinv(p, shape) * scale;
  },

  mean : function(shape, scale) {
    return shape * scale;
  },

  mode: function mode(shape, scale) {
    if(shape > 1) return (shape - 1) * scale;
    return undefined;
  },

  sample: function sample(shape, scale) {
    return jStat.randg(shape) * scale;
  },

  variance: function variance(shape, scale) {
    return shape * scale * scale;
  }
});

// extend inverse gamma function with static methods
jStat.extend(jStat.invgamma, {
  pdf: function pdf(x, shape, scale) {
    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -
                    jStat.gammaln(shape) + shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    return 1 - jStat.gammap(shape, scale / x);
  },

  inv: function(p, shape, scale) {
    return scale / jStat.gammapinv(1 - p, shape);
  },

  mean : function(shape, scale) {
    return (shape > 1) ? scale / (shape - 1) : undefined;
  },

  mode: function mode(shape, scale) {
    return scale / (shape + 1);
  },

  sample: function sample(shape, scale) {
    return scale / jStat.randg(shape);
  },

  variance: function variance(shape, scale) {
    if (shape <= 2)
      return undefined;
    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
  }
});


// extend kumaraswamy function with static methods
jStat.extend(jStat.kumaraswamy, {
  pdf: function pdf(x, alpha, beta) {
    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *
                    Math.log(x) + (beta - 1) *
                    Math.log(1 - Math.pow(x, alpha)));
  },

  cdf: function cdf(x, alpha, beta) {
    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));
  },

  mean : function(alpha, beta) {
    return (beta * jStat.gammafn(1 + 1 / alpha) *
            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));
  },

  median: function median(alpha, beta) {
    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);
  },

  mode: function mode(alpha, beta) {
    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
      return undefined;
    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
  },

  variance: function variance(alpha, beta) {
    throw new Error('variance not yet implemented');
    // TODO: complete this
  }
});



// extend lognormal function with static methods
jStat.extend(jStat.lognormal, {
  pdf: function pdf(x, mu, sigma) {
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -
                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /
                    (2 * sigma * sigma));
  },

  cdf: function cdf(x, mu, sigma) {
    return 0.5 +
        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));
  },

  inv: function(p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);
  },

  mean: function mean(mu, sigma) {
    return Math.exp(mu + sigma * sigma / 2);
  },

  median: function median(mu, sigma) {
    return Math.exp(mu);
  },

  mode: function mode(mu, sigma) {
    return Math.exp(mu - sigma * sigma);
  },

  sample: function sample(mu, sigma) {
    return Math.exp(jStat.randn() * sigma + mu);
  },

  variance: function variance(mu, sigma) {
    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
  }
});



// extend normal function with static methods
jStat.extend(jStat.normal, {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) -
                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },

  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));
  },

  inv: function(p, mean, std) {
    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;
  },

  mean : function(mean, std) {
    return mean;
  },

  median: function median(mean, std) {
    return mean;
  },

  mode: function (mean, std) {
    return mean;
  },

  sample: function sample(mean, std) {
    return jStat.randn() * std + mean;
  },

  variance : function(mean, std) {
    return std * std;
  }
});



// extend pareto function with static methods
jStat.extend(jStat.pareto, {
  pdf: function pdf(x, scale, shape) {
    if (x <= scale)
      return undefined;
    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);
  },

  cdf: function cdf(x, scale, shape) {
    return 1 - Math.pow(scale / x, shape);
  },

  mean: function mean(scale, shape) {
    if (shape <= 1)
      return undefined;
    return (shape * Math.pow(scale, shape)) / (shape - 1);
  },

  median: function median(scale, shape) {
    return scale * (shape * Math.SQRT2);
  },

  mode: function mode(scale, shape) {
    return scale;
  },

  variance : function(scale, shape) {
    if (shape <= 2)
      return undefined;
    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));
  }
});



// extend studentt function with static methods
jStat.extend(jStat.studentt, {
  pdf: function pdf(x, dof) {
    return (jStat.gammafn((dof + 1) / 2) / (Math.sqrt(dof * Math.PI) *
        jStat.gammafn(dof / 2))) *
        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));
  },

  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /
                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },

  inv: function(p, dof) {
    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return (p > 0.5) ? x : -x;
  },

  mean: function mean(dof) {
    return (dof > 1) ? 0 : undefined;
  },

  median: function median(dof) {
    return 0;
  },

  mode: function mode(dof) {
    return 0;
  },

  sample: function sample(dof) {
    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));
  },

  variance: function variance(dof) {
    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;
  }
});



// extend weibull function with static methods
jStat.extend(jStat.weibull, {
  pdf: function pdf(x, scale, shape) {
    if (x < 0)
      return 0;
    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *
        Math.exp(-(Math.pow((x / scale), shape)));
  },

  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));
  },

  inv: function(p, scale, shape) {
    return scale * Math.pow(-Math.log(1 - p), 1 / shape);
  },

  mean : function(scale, shape) {
    return scale * jStat.gammafn(1 + 1 / shape);
  },

  median: function median(scale, shape) {
    return scale * Math.pow(Math.log(2), 1 / shape);
  },

  mode: function mode(scale, shape) {
    if (shape <= 1)
      return undefined;
    return scale * Math.pow((shape - 1) / shape, 1 / shape);
  },

  sample: function sample(scale, shape) {
    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);
  },

  variance: function variance(scale, shape) {
    return scale * scale * jStat.gammafn(1 + 2 / shape) -
        Math.pow(this.mean(scale, shape), 2);
  }
});



// extend uniform function with static methods
jStat.extend(jStat.uniform, {
  pdf: function pdf(x, a, b) {
    return (x < a || x > b) ? 0 : 1 / (b - a);
  },

  cdf: function cdf(x, a, b) {
    if (x < a)
      return 0;
    else if (x < b)
      return (x - a) / (b - a);
    return 1;
  },

  mean: function mean(a, b) {
    return 0.5 * (a + b);
  },

  median: function median(a, b) {
    return jStat.mean(a, b);
  },

  mode: function mode(a, b) {
    throw new Error('mode is not yet implemented');
  },

  sample: function sample(a, b) {
    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);
  },

  variance: function variance(a, b) {
    return Math.pow(b - a, 2) / 12;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.binomial, {
  pdf: function pdf(k, n, p) {
    return (p === 0 || p === 1) ?
      ((n * p) === k ? 1 : 0) :
      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },

  cdf: function cdf(x, n, p) {
    var binomarr = [],
    k = 0;
    if (x < 0) {
      return 0;
    }
    if (x < n) {
      for (; k <= x; k++) {
        binomarr[ k ] = jStat.binomial.pdf(k, n, p);
      }
      return jStat.sum(binomarr);
    }
    return 1;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.negbin, {
  pdf: function pdf(k, r, p) {
    return k !== k | 0
      ? false
      : k < 0
        ? 0
        : jStat.combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);
  },

  cdf: function cdf(x, r, p) {
    var sum = 0,
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sum += jStat.negbin.pdf(k, r, p);
    }
    return sum;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.hypgeom, {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.

    // A simplification of the CDF algorithm below.

    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(k !== k | 0) {
      return false;
    } else if(k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if(k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return jStat.hypgeom.pdf(n - k, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return jStat.hypgeom.pdf(m - k, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...

        while(scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          scaledPDF *= 1 - (m / (N - samplesDone));

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },

  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.

    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.

    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if(x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...

        while(scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          var factor = 1 - (m / (N - samplesDone));

          scaledPDF *= factor;
          scaledCDF *= factor;

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));

        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
});



// extend uniform function with static methods
jStat.extend(jStat.poisson, {
  pdf: function pdf(k, l) {
    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);
  },

  cdf: function cdf(x, l) {
    var sumarr = [],
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sumarr.push(jStat.poisson.pdf(k, l));
    }
    return jStat.sum(sumarr);
  },

  mean : function(l) {
    return l;
  },

  variance : function(l) {
    return l;
  },

  sample: function sample(l) {
    var p = 1, k = 0, L = Math.exp(-l);
    do {
      k++;
      p *= Math.random();
    } while (p > L);
    return k - 1;
  }
});

// extend triangular function with static methods
jStat.extend(jStat.triangular, {
  pdf: function pdf(x, a, b, c) {
    return (b <= a || c < a || c > b)
      ? undefined
      : (x < a || x > b)
        ? 0
        : (x <= c)
          ? (2 * (x - a)) / ((b - a) * (c - a))
          : (2 * (b - x)) / ((b - a) * (b - c));
  },

  cdf: function cdf(x, a, b, c) {
    if (b <= a || c < a || c > b)
      return undefined;
    if (x < a) {
      return 0;
    } else {
      if (x <= c)
        return Math.pow(x - a, 2) / ((b - a) * (c - a));
      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));
    }
    // never reach this
    return 1;
  },

  mean: function mean(a, b, c) {
    return (a + b + c) / 3;
  },

  median: function median(a, b, c) {
    if (c <= (a + b) / 2) {
      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);
    } else if (c > (a + b) / 2) {
      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);
    }
  },

  mode: function mode(a, b, c) {
    return c;
  },

  sample: function sample(a, b, c) {
    var u = Math.random();
    if (u < ((c - a) / (b - a)))
      return a + Math.sqrt(u * (b - a) * (c - a))
    return b - Math.sqrt((1 - u) * (b - a) * (b - c));
  },

  variance: function variance(a, b, c) {
    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
  }
});

}(this.jStat, Math));
/* Provides functions for the solution of linear system of equations, integration, extrapolation,
 * interpolation, eigenvalue problems, differential equations and PCA analysis. */

(function(jStat, Math) {

var push = Array.prototype.push;
var isArray = jStat.utils.isArray;

jStat.extend({

  // add a vector/matrix to a vector/matrix or scalar
  add: function add(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value + arg[row][col];
      });
    }
    return jStat.map(arr, function(value) { return value + arg; });
  },

  // subtract a vector or scalar from the vector
  subtract: function subtract(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value - arg[row][col] || 0;
      });
    }
    return jStat.map(arr, function(value) { return value - arg; });
  },

  // matrix division
  divide: function divide(arr, arg) {
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.multiply(arr, jStat.inv(arg));
    }
    return jStat.map(arr, function(value) { return value / arg; });
  },

  // matrix multiplication
  multiply: function multiply(arr, arg) {
    var row, col, nrescols, sum,
    nrow = arr.length,
    ncol = arr[0].length,
    res = jStat.zeros(nrow, nrescols = (isArray(arg)) ? arg[0].length : ncol),
    rescols = 0;
    if (isArray(arg)) {
      for (; rescols < nrescols; rescols++) {
        for (row = 0; row < nrow; row++) {
          sum = 0;
          for (col = 0; col < ncol; col++)
          sum += arr[row][col] * arg[col][rescols];
          res[row][rescols] = sum;
        }
      }
      return (nrow === 1 && rescols === 1) ? res[0][0] : res;
    }
    return jStat.map(arr, function(value) { return value * arg; });
  },

  // Returns the dot product of two matricies
  dot: function dot(arr, arg) {
    if (!isArray(arr[0])) arr = [ arr ];
    if (!isArray(arg[0])) arg = [ arg ];
    // convert column to row vector
    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,
    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,
    res = [],
    row = 0,
    nrow = left.length,
    ncol = left[0].length,
    sum, col;
    for (; row < nrow; row++) {
      res[row] = [];
      sum = 0;
      for (col = 0; col < ncol; col++)
      sum += left[row][col] * right[row][col];
      res[row] = sum;
    }
    return (res.length === 1) ? res[0] : res;
  },

  // raise every element by a scalar
  pow: function pow(arr, arg) {
    return jStat.map(arr, function(value) { return Math.pow(value, arg); });
  },

  // generate the absolute values of the vector
  abs: function abs(arr) {
    return jStat.map(arr, function(value) { return Math.abs(value); });
  },

  // computes the p-norm of the vector
  // In the case that a matrix is passed, uses the first row as the vector
  norm: function norm(arr, p) {
    var nnorm = 0,
    i = 0;
    // check the p-value of the norm, and set for most common case
    if (isNaN(p)) p = 2;
    // check if multi-dimensional array, and make vector correction
    if (isArray(arr[0])) arr = arr[0];
    // vector norm
    for (; i < arr.length; i++) {
      nnorm += Math.pow(Math.abs(arr[i]), p);
    }
    return Math.pow(nnorm, 1 / p);
  },

  // TODO: make compatible with matrices
  // computes the angle between two vectors in rads
  angle: function angle(arr, arg) {
    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
  },

  // augment one matrix by another
  aug: function aug(a, b) {
    var newarr = a.slice(),
    i = 0;
    for (; i < newarr.length; i++) {
      push.apply(newarr[i], b[i]);
    }
    return newarr;
  },

  inv: function inv(a) {
    var rows = a.length,
    cols = a[0].length,
    b = jStat.identity(rows, cols),
    c = jStat.gauss_jordan(a, b),
    obj = [],
    i = 0,
    j;
    for (; i < rows; i++) {
      obj[i] = [];
      for (j = cols - 1; j < c[0].length; j++)
      obj[i][j - cols] = c[i][j];
    }
    return obj;
  },

  // calculate the determinant of a matrix
  det: function det(a) {
    var alen = a.length,
    alend = alen * 2,
    vals = new Array(alend),
    rowshift = alen - 1,
    colshift = alend - 1,
    mrow = rowshift - alen + 1,
    mcol = colshift,
    i = 0,
    result = 0,
    j;
    // check for special 2x2 case
    if (alen === 2) {
      return a[0][0] * a[1][1] - a[0][1] * a[1][0];
    }
    for (; i < alend; i++) {
      vals[i] = 1;
    }
    for (i = 0; i < alen; i++) {
      for (j = 0; j < alen; j++) {
        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];
        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];
        mrow++;
        mcol--;
      }
      mrow = --rowshift - alen + 1;
      mcol = --colshift;
    }
    for (i = 0; i < alen; i++) {
      result += vals[i];
    }
    for (; i < alend; i++) {
      result -= vals[i];
    }
    return result;
  },

  gauss_elimination: function gauss_elimination(a, b) {
    var i = 0,
    j = 0,
    n = a.length,
    m = a[0].length,
    factor = 1,
    sum = 0,
    x = [],
    maug, pivot, temp, k;
    a = jStat.aug(a, b);
    maug = a[0].length;
    for(; i < n; i++) {
      pivot = a[i][i];
      j = i;
      for (k = i + 1; k < m; k++) {
        if (pivot < Math.abs(a[k][i])) {
          pivot = a[k][i];
          j = k;
        }
      }
      if (j != i) {
        for(k = 0; k < maug; k++) {
          temp = a[i][k];
          a[i][k] = a[j][k];
          a[j][k] = temp;
        }
      }
      for (j = i + 1; j < n; j++) {
        factor = a[j][i] / a[i][i];
        for(k = i; k < maug; k++) {
          a[j][k] = a[j][k] - factor * a[i][k];
        }
      }
    }
    for (i = n - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j<= n - 1; j++) {
        sum = x[j] * a[i][j];
      }
      x[i] =(a[i][maug - 1] - sum) / a[i][i];
    }
    return x;
  },

  gauss_jordan: function gauss_jordan(a, b) {
    var m = jStat.aug(a, b),
    h = m.length,
    w = m[0].length;
    // find max pivot
    for (var y = 0; y < h; y++) {
      var maxrow = y;
      for (var y2 = y+1; y2 < h; y2++) {
        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
          maxrow = y2;
      }
      var tmp = m[y];
      m[y] = m[maxrow];
      m[maxrow] = tmp
      for (var y2 = y+1; y2 < h; y2++) {
        c = m[y2][y] / m[y][y];
        for (var x = y; x < w; x++) {
          m[y2][x] -= m[y][x] * c;
        }
      }
    }
    // backsubstitute
    for (var y = h-1; y >= 0; y--) {
      c = m[y][y];
      for (var y2 = 0; y2 < y; y2++) {
        for (var x = w-1; x > y-1; x--) {
          m[y2][x] -= m[y][x] * m[y2][y] / c;
        }
      }
      m[y][y] /= c;
      for (var x = h; x < w; x++) {
        m[y][x] /= c;
      }
    }
    return m;
  },

  lu: function lu(a, b) {
    throw new Error('lu not yet implemented');
  },

  cholesky: function cholesky(a, b) {
    throw new Error('cholesky not yet implemented');
  },

  gauss_jacobi: function gauss_jacobi(a, b, x, r) {
    var i = 0;
    var j = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
    c = jStat.multiply(jStat.inv(d), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  gauss_seidel: function gauss_seidel(a, b, x, r) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i = i + 1;
    }
    return xk;
  },

  SOR: function SOR(a, b, x, r, w) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),
                       jStat.subtract(jStat.multiply(d, 1 - w),
                                      jStat.multiply(u, w)));
    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,
        jStat.multiply(l, w))), b), w);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  householder: function householder(a) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var alpha, r, k, j, factor;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
      alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, jStat.multiply(a, p));
    }
    return a;
  },

  // TODO: not working properly.
  QR: function QR(a, b) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var x = [];
    var j, alpha, r, k, factor, sum;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
        alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++)
        w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, a);
      b = jStat.multiply(p, b);
    }
    for (i = m - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j <= n - 1; j++)
      sum = x[j] * a[i][j];
      x[i] = b[i][0] / a[i][i];
    }
    return x;
  },

  jacobi: function jacobi(a) {
    var condition = 1;
    var count = 0;
    var n = a.length;
    var e = jStat.identity(n, n);
    var ev = [];
    var b, i, j, p, q, maxim, theta, s;
    // condition === 1 only if tolerance is not reached
    while (condition === 1) {
      count++;
      maxim = a[0][1];
      p = 0;
      q = 1;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i != j) {
            if (maxim < Math.abs(a[i][j])) {
              maxim = Math.abs(a[i][j]);
              p = i;
              q = j;
            }
          }
        }
      }
      if (a[p][p] === a[q][q])
        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;
      else
        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
      s = jStat.identity(n, n);
      s[p][p] = Math.cos(theta);
      s[p][q] = -Math.sin(theta);
      s[q][p] = Math.sin(theta);
      s[q][q] = Math.cos(theta);
      // eigen vector matrix
      e = jStat.multiply(e, s);
      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
      a = b;
      condition = 0;
      for (i = 1; i < n; i++) {
        for (j = 1; j < n; j++) {
          if (i != j && Math.abs(a[i][j]) > 0.001) {
            condition = 1;
          }
        }
      }
    }
    for (i = 0; i < n; i++) ev.push(a[i][i]);
    //returns both the eigenvalue and eigenmatrix
    return [e, ev];
  },

  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
    var k1, k2, u_j1, k3, k4;
    if (order === 2) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h, u_j + k1);
        u_j1 = u_j + (k1 + k2) / 2;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    if (order === 4) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
        k4 = h * f(t_j +h, u_j + k3);
        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    return u_j;
  },

  romberg: function romberg(f, a, b, order) {
    var i = 0;
    var h = (b - a) / 2;
    var x = [];
    var h1 = [];
    var g = [];
    var m, a1, j, k, I, d;
    while (i < order / 2) {
      I = f(a);
      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
      m = x.length;
      for (j = 1; j < m - 1; j++) {
        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);
      }
      I = (h / 3) * (I + f(b));
      g[i] = I;
      h /= 2;
      i++;
    }
    a1 = g.length;
    m = 1;
    while (a1 !== 1) {
      for (j = 0; j < a1 - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a1 = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  richardson: function richardson(X, f, x, h) {
    function pos(X, x) {
      var i = 0;
      var n = X.length;
      var p;
      for (; i < n; i++)
        if (X[i] === x) p = i;
      return p;
    }
    var n = X.length,
    h_min = Math.abs(x - X[pos(X, x) + 1]),
    i = 0,
    g = [],
    h1 = [],
    y1, y2, m, a, j;
    while (h >= h_min) {
      y1 = pos(X, x + h);
      y2 = pos(X, x);
      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
      h /= 2;
      i++;
    }
    a = g.length;
    m = 1;
    while (a != 1) {
      for (j = 0; j < a - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  simpson: function simpson(f, a, b, n) {
    var h = (b - a) / n;
    var I = f(a);
    var x = [];
    var j = a;
    var k = 0;
    var i = 1;
    var m;
    for (; j <= b; j = j + h, k++)
      x[k] = j;
    m = x.length;
    for (; i < m - 1; i++) {
      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);
    }
    return (h / 3) * (I + f(b));
  },

  hermite: function hermite(X, F, dF, value) {
    var n = X.length;
    var p = 0;
    var i = 0;
    var l = [];
    var dl = [];
    var A = [];
    var B = [];
    var j;
    for (; i < n; i++) {
      l[i] = 1;
      for (j = 0; j < n; j++) {
        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
      }
      dl[i] = 0;
      for (j = 0; j < n; j++) {
        if (i != j) dl[i] += 1 / (X [i] - X[j]);
      }
      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
      B[i] = (value - X[i]) * (l[i] * l[i]);
      p += (A[i] * F[i] + B[i] * dF[i]);
    }
    return p;
  },

  lagrange: function lagrange(X, F, value) {
    var p = 0;
    var i = 0;
    var j, l;
    var n = X.length;
    for (; i < n; i++) {
      l = F[i];
      for (j = 0; j < n; j++) {
        // calculating the lagrange polynomial L_i
        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
      }
      // adding the lagrange polynomials found above
      p += l;
    }
    return p;
  },

  cubic_spline: function cubic_spline(X, F, value) {
    var n = X.length;
    var i = 0, j;
    var A = [];
    var B = [];
    var alpha = [];
    var c = [];
    var h = [];
    var b = [];
    var d = [];
    for (; i < n - 1; i++)
      h[i] = X[i + 1] - X[i];
    alpha[0] = 0;
    for (i = 1; i < n - 1; i++) {
      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -
          (3 / h[i-1]) * (F[i] - F[i-1]);
    }
    for (i = 1; i < n - 1; i++) {
      A[i] = [];
      B[i] = [];
      A[i][i-1] = h[i-1];
      A[i][i] = 2 * (h[i - 1] + h[i]);
      A[i][i+1] = h[i];
      B[i][0] = alpha[i];
    }
    c = jStat.multiply(jStat.inv(A), B);
    for (j = 0; j < n - 1; j++) {
      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
    }
    for (j = 0; j < n; j++) {
      if (X[j] > value) break;
    }
    j -= 1;
    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *
        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
  },

  gauss_quadrature: function gauss_quadrature() {
    throw new Error('gauss_quadrature not yet implemented');
  },

  PCA: function PCA(X) {
    var m = X.length;
    var n = X[0].length;
    var flag = false;
    var i = 0;
    var j, temp1;
    var u = [];
    var D = [];
    var result = [];
    var temp2 = [];
    var Y = [];
    var Bt = [];
    var B = [];
    var C = [];
    var V = [];
    var Vt = [];
    for (i = 0; i < m; i++) {
      u[i] = jStat.sum(X[i]) / n;
    }
    for (i = 0; i < n; i++) {
      B[i] = [];
      for(j = 0; j < m; j++) {
        B[i][j] = X[j][i] - u[j];
      }
    }
    B = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      C[i] = [];
      for (j = 0; j < m; j++) {
        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);
      }
    }
    result = jStat.jacobi(C);
    V = result[0];
    D = result[1];
    Vt = jStat.transpose(V);
    for (i = 0; i < D.length; i++) {
      for (j = i; j < D.length; j++) {
        if(D[i] < D[j])  {
          temp1 = D[i];
          D[i] = D[j];
          D[j] = temp1;
          temp2 = Vt[i];
          Vt[i] = Vt[j];
          Vt[j] = temp2;
        }
      }
    }
    Bt = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      Y[i] = [];
      for (j = 0; j < Bt.length; j++) {
        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);
      }
    }
    return [X, D, Vt, Y];
  }
});

// extend jStat.fn with methods that require one argument
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function(arg, func) {
      var tmpthis = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
        }, 15);
        return this;
      }
      if (typeof jStat[passfunc](this, arg) === 'number')
        return jStat[passfunc](this, arg);
      else
        return jStat(jStat[passfunc](this, arg));
    };
  }(funcs[i]));
}('add divide multiply subtract dot pow abs norm angle'.split(' ')));

}(this.jStat, Math));
(function(jStat, Math) {

var slice = [].slice;
var isNumber = jStat.utils.isNumber;

// flag==true denotes use of sample standard deviation
// Z Statistics
jStat.extend({
  // 2 different parameter lists:
  // (value, mean, sd)
  // (value, array, flag)
  zscore: function zscore() {
    var args = slice.call(arguments);
    if (isNumber(args[1])) {
      return (args[0] - args[1]) / args[2];
    }
    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
  },

  // 3 different paramter lists:
  // (value, mean, sd, sides)
  // (zscore, sides)
  // (value, array, sides, flag)
  ztest: function ztest() {
    var args = slice.call(arguments);
    if (args.length === 4) {
      if(isNumber(args[1])) {
        var z = jStat.zscore(args[0],args[1],args[2])
        return (args[3] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);
      }
      var z = args[0]
      return (args[2] === 1) ?
        (jStat.normal.cdf(-Math.abs(z),0,1)) :
        (jStat.normal.cdf(-Math.abs(z),0,1)*2);
    }
    var z = jStat.zscore(args[0],args[1],args[3])
    return (args[1] === 1) ?
      (jStat.normal.cdf(-Math.abs(z), 0, 1)) :
      (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);
  }
});

jStat.extend(jStat.fn, {
  zscore: function zscore(value, flag) {
    return (value - this.mean()) / this.stdev(flag);
  },

  ztest: function ztest(value, sides, flag) {
    var zscore = Math.abs(this.zscore(value, flag));
    return (sides === 1) ?
      (jStat.normal.cdf(-zscore, 0, 1)) :
      (jStat.normal.cdf(-zscore, 0, 1) * 2);
  }
});

// T Statistics
jStat.extend({
  // 2 parameter lists
  // (value, mean, sd, n)
  // (value, array)
  tscore: function tscore() {
    var args = slice.call(arguments);
    return (args.length === 4) ?
      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :
      ((args[0] - jStat.mean(args[1])) /
       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));
  },

  // 3 different paramter lists:
  // (value, mean, sd, n, sides)
  // (tscore, n, sides)
  // (value, array, sides)
  ttest: function ttest() {
    var args = slice.call(arguments);
    var tscore;
    if (args.length === 5) {
      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
      return (args[4] === 1) ?
        (jStat.studentt.cdf(-tscore, args[3]-1)) :
        (jStat.studentt.cdf(-tscore, args[3]-1)*2);
    }
    if (isNumber(args[1])) {
      tscore = Math.abs(args[0])
      return (args[2] == 1) ?
        (jStat.studentt.cdf(-tscore, args[1]-1)) :
        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);
    }
    tscore = Math.abs(jStat.tscore(args[0], args[1]))
    return (args[2] == 1) ?
      (jStat.studentt.cdf(-tscore, args[1].length-1)) :
      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);
  }
});

jStat.extend(jStat.fn, {
  tscore: function tscore(value) {
    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));
  },

  ttest: function ttest(value, sides) {
    return (sides === 1) ?
      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :
      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);
  }
});

// F Statistics
jStat.extend({
  // Paramter list is as follows:
  // (array1, array2, array3, ...)
  // or it is an array of arrays
  // array of arrays conversion
  anovafscore: function anovafscore() {
    var args = slice.call(arguments),
    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
    if (args.length === 1) {
      tmpargs = new Array(args[0].length);
      for (i = 0; i < args[0].length; i++) {
        tmpargs[i] = args[0][i];
      }
      args = tmpargs;
    }
    // 2 sample case
    if (args.length === 2) {
      return jStat.variance(args[0]) / jStat.variance(args[1]);
    }
    // Builds sample array
    sample = new Array();
    for (i = 0; i < args.length; i++) {
      sample = sample.concat(args[i]);
    }
    sampMean = jStat.mean(sample);
    // Computes the explained variance
    expVar = 0;
    for (i = 0; i < args.length; i++) {
      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);
    }
    expVar /= (args.length - 1);
    // Computes unexplained variance
    unexpVar = 0;
    for (i = 0; i < args.length; i++) {
      sampSampMean = jStat.mean(args[i]);
      for (j = 0; j < args[i].length; j++) {
        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);
      }
    }
    unexpVar /= (sample.length - args.length);
    return expVar / unexpVar;
  },

  // 2 different paramter setups
  // (array1, array2, array3, ...)
  // (anovafscore, df1, df2)
  anovaftest: function anovaftest() {
    var args = slice.call(arguments),
    df1, df2, n, i;
    if (isNumber(args[0])) {
      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
    }
    anovafscore = jStat.anovafscore(args);
    df1 = args.length - 1;
    n = 0;
    for (i = 0; i < args.length; i++) {
      n = n + args[i].length;
    }
    df2 = n - df1 - 1;
    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
  },

  ftest: function ftest(fscore, df1, df2) {
    return 1 - jStat.centralF.cdf(fscore, df1, df2);
  }
});

jStat.extend(jStat.fn, {
  anovafscore: function anovafscore() {
    return jStat.anovafscore(this.toArray());
  },

  anovaftes: function anovaftes() {
    var n = 0;
    var i;
    for (i = 0; i < this.length; i++) {
      n = n + this[i].length;
    }
    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
  }
});

// Error Bounds
jStat.extend({
  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  normalci: function normalci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  tci: function tci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *
                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  significant: function significant(pvalue, alpha) {
    return pvalue < alpha;
  }
});

jStat.extend(jStat.fn, {
  normalci: function normalci(value, alpha) {
    return jStat.normalci(value, alpha, this.toArray());
  },

  tci: function tci(value, alpha) {
    return jStat.tci(value, alpha, this.toArray());
  }
});

}(this.jStat, Math));

},{}],3:[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

},{}],4:[function(require,module,exports){
(function (global){
"use strict";

var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sbastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
function SpreadSheetError() {
    this.name = 'SpreadSheetError';
    this.message = '';
}

SpreadSheetError.prototype = new Error();
SpreadSheetError.prototype.constructor = SpreadSheetError;
SpreadSheetError.prototype.toString = function () {
    return this.name + ' => ' + this.message;
};

exports.SpreadSheetError = SpreadSheetError;

},{}],6:[function(require,module,exports){
'use strict';

var _settings = require('./settings');

var _core = require('./core');

var _core2 = _interopRequireDefault(_core);

var _polyfill = require('./polyfill');

var _polyfill2 = _interopRequireDefault(_polyfill);

var _XFormulas = require('./plugins/xformulas/XFormulas');

var _XFormulas2 = _interopRequireDefault(_XFormulas);

var _Plugin = require('./plugins/Plugin');

var _Persistent = require('./plugins/persistent/Persistent');

var _Persistent2 = _interopRequireDefault(_Persistent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_core2.default.globalSettings = _settings.globalSettings;
//noinspection ES6UnusedImports 

_core2.default.defaultSettings = _settings.defaultSettings;
_core2.default.version = '@@_version_@@';

_core2.default.plugins = {
    Plugin: _Plugin.Plugin,
    registerPlugin: _Plugin.registerPlugin
};

// 
(0, _Plugin.registerPlugin)('persistent', _Persistent2.default);

// 
window.BrickSpreadSheet = _core2.default;
window._UIProvider = {};
(0, _polyfill2.default)(window);

// TODO 

},{"./core":7,"./plugins/Plugin":22,"./plugins/persistent/Persistent":24,"./plugins/xformulas/XFormulas":34,"./polyfill":56,"./settings":57}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Frame = require('./designer/Frame');

var _Frame2 = _interopRequireDefault(_Frame);

var _Workbook = require('./designer/Workbook');

var _Workbook2 = _interopRequireDefault(_Workbook);

var _common = require('./utils/common');

var _Plugin = require('./plugins/Plugin');

var _Emitter2 = require('./utils/Emitter');

var _Emitter3 = _interopRequireDefault(_Emitter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AUTO_ID = 1;

var SpreadSheet = function (_Emitter) {
    _inherits(SpreadSheet, _Emitter);

    /**
     *  Excel 
     *
     * @constructor
     * @param rootElement
     * @param {object} userSettings - 
     * @param {object} userSettings.workbook - Workbook 
     * @param {object[]} userSettings.sheets -  Sheet 
     * @param {boolean=} [displayMode=false] - 
     */
    function SpreadSheet(rootElement, userSettings) {
        var displayMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        _classCallCheck(this, SpreadSheet);

        var _this = _possibleConstructorReturn(this, (SpreadSheet.__proto__ || Object.getPrototypeOf(SpreadSheet)).call(this));

        _this.rootElement = rootElement;
        _this.getUserSettings(userSettings);

        _this.settings = {};
        (0, _common.extend)(_this.settings, SpreadSheet.defaultSettings);
        (0, _common.extend)(_this.settings, _this.userSettings);

        _this.id = _this.settings.id || _this.getId();
        _this.displayMode = displayMode;

        _this._initPlugin();
        _this.frame = new _Frame2.default(_this, _this.settings.frame);
        _this.workbook = new _Workbook2.default(_this, _this.settings.workbook);
        _this._enablePlugin();
        return _this;
    }

    _createClass(SpreadSheet, [{
        key: 'getId',
        value: function getId() {
            //  id  id iframe 
            return this.id || SpreadSheet.globalSettings.idPrefix + AUTO_ID++ + '-' + (0, _common.randomString)();
        }
    }, {
        key: 'getRootElement',
        value: function getRootElement() {
            return this.rootElement;
        }
    }, {
        key: 'getDisplayMode',
        value: function getDisplayMode() {
            return this.displayMode;
        }

        /**
         * 
         * @param {string=} s -  JSON 
         * @returns {Object}
         */

    }, {
        key: 'getUserSettings',
        value: function getUserSettings(s) {
            if (this.userSettings) {
                return this.userSettings;
            }
            if (s && typeof s === 'string') {
                this.userSettings = JSON.parse(s);
            } else {
                this.userSettings = s;
            }
            return this.userSettings;
        }

        /**
         *  SpreadSheet 
         * @returns {Object}
         */

    }, {
        key: 'getSettings',
        value: function getSettings() {
            return this.settings;
        }

        /**
         * 
         * @param {boolean} [oragin=false] -  `true`  JavaScript 
         * @returns
         */

    }, {
        key: 'getExchangeData',
        value: function getExchangeData() {
            var oragin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var w = this.workbook._getExchange();
            var f = this.frame._getExchange(); // TODO frame
            var o = {
                workbook: w,
                frame: f,
                id: this.getId()
            };
            return oragin ? o : JSON.stringify(o);
        }

        /**
         *  SpreadSheet  Workbook 
         * @returns {Workbook}
         */

    }, {
        key: 'getWorkbookInstance',
        value: function getWorkbookInstance() {
            return this.workbook;
        }

        /**
         *  SpreadSheet  Frame 
         * @returns {Frame}
         */

    }, {
        key: 'getFrameInstance',
        value: function getFrameInstance() {
            return this.frame;
        }
    }, {
        key: '_initPlugin',
        value: function _initPlugin() {
            var _this2 = this;

            this.plugins = new Map();
            (0, _Plugin.getAllPlugins)().forEach(function (P) {
                var p = new P(_this2);
                (0, _Plugin.validatePlugin)(p);
                _this2.plugins.set(p.__name__, p);
            });
        }
    }, {
        key: '_enablePlugin',
        value: function _enablePlugin() {
            this.plugins.forEach(function (p) {
                if (p.isEnable()) {
                    p.enable();
                }
            });
        }
    }]);

    return SpreadSheet;
}(_Emitter3.default);

exports.default = SpreadSheet;

},{"./designer/Frame":9,"./designer/Workbook":13,"./plugins/Plugin":22,"./utils/Emitter":58,"./utils/common":59}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 
 * 
 *
 * @private
 */
var ConfigTranslator = function () {

    /**
     * 
     *
     * @param {object} config
     * @param {Sheet} sheet
     */
    function ConfigTranslator(config, sheet) {
        _classCallCheck(this, ConfigTranslator);

        this.initialConfig = config;
        this.sheet = sheet;
    }

    /**
     * 
     *  Excel  Web 
     *  Web 
     * 
     *
     * @returns {object}
     */


    _createClass(ConfigTranslator, [{
        key: 'translate',
        value: function translate() {
            var settings = {};
            var proto = Object.getPrototypeOf(this);
            var property = Object.getOwnPropertyNames(proto);

            for (var i = 0; i < property.length; ++i) {
                if (property[i].startsWith('_trans')) {
                    this[property[i]].call(this, settings);
                }
            }
            return settings;
        }

        /**
         * handsontable 
         * 
         * 
         */

    }, {
        key: 'initSheetState',
        value: function initSheetState() {
            var proto = Object.getPrototypeOf(this);
            var property = Object.getOwnPropertyNames(proto);

            for (var i = 0; i < property.length; ++i) {
                if (property[i].startsWith('_init')) {
                    this[property[i]].call(this);
                }
            }
        }

        // ------------------------ translate ------------------------------

    }, {
        key: '_transCell',
        value: function _transCell(settings) {
            var m = this.initialConfig.cellMetas;
            if (m) {
                settings.cell = [];
                for (var i = 0; i < m.length; ++i) {
                    var row = m[i];
                    for (var j = 0; j < row.length; ++j) {
                        var cellMeta = row[j];
                        if (cellMeta) {
                            var cell = {};
                            cell.row = cellMeta.row;
                            cell.col = cellMeta.col;

                            // dataType
                            if (cellMeta.dataType) {
                                for (var dt in cellMeta.dataType) {
                                    if (cellMeta.dataType.hasOwnProperty(dt)) {
                                        cell[dt] = cellMeta.dataType[dt];
                                    }
                                }
                                cell.type = cellMeta.dataType.typeName;
                                delete cell.typeName;
                            }

                            // styles
                            if (cellMeta.styles) {
                                if (cellMeta.styles.alignments) {
                                    var c = cellMeta.styles.alignments.join(' ht');
                                    cell.className = cell.className ? cell.className += ' ht' + c : 'ht' + c;
                                }
                                if (cellMeta.styles.fontFamily) {
                                    cell._style_fontFamily = cellMeta.styles.fontFamily;
                                }
                                if (cellMeta.styles.fontSize) {
                                    cell._style_fontSize = cellMeta.styles.fontSize;
                                }
                                if (cellMeta.styles.color) {
                                    cell._style_color = cellMeta.styles.color;
                                }
                                if (cellMeta.styles.backgroundColor) {
                                    cell._style_backgroundColor = cellMeta.styles.backgroundColor;
                                }
                                if (cellMeta.styles.fontStyle) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-' + cellMeta.styles.fontStyle : 'ssd-font-' + cellMeta.styles.fontStyle;
                                }
                                if (cellMeta.styles.fontWeight) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-bold' : 'ssd-font-bold';
                                }
                                if (cellMeta.styles.textDecoration) {
                                    cell.className = cell.className ? cell.className += ' ssd-font-underline' : 'ssd-font-underline';
                                }
                            }
                            settings.cell.push(cell);
                        }
                    }
                }
            }
        }
    }, {
        key: '_transData',
        value: function _transData(settings) {
            var s = this.initialConfig.data;
            if (s) {
                // hotTable  data 
                //  initRows * initCols 
                //    if (s.length < this.sheet.initRows) {
                //        let formerCol = s.length;
                //        s.length = this.sheet.initRows;
                //        s.fill([], formerCol);
                //    }
                //    for (let i = 0; i < s.length; ++i) {
                //        let row = s[i];
                //        if (row.length < this.sheet.initCols) {
                //            let formerRow = row.length;
                //            row.length = this.sheet.initCols;
                //            row.fill('', formerRow);
                //        }
                //    }

                //  hot API 
                settings.minRows = this.sheet.initRows;
                settings.minCols = this.sheet.initCols;

                settings.data = s;
            }
        }

        // 

    }, {
        key: '_transColWidths',
        value: function _transColWidths(settings) {
            var w = this.initialConfig.colWidths;
            if (w) {
                settings.colWidths = w;
            }
        }

        // 

    }, {
        key: '_transRowHeights',
        value: function _transRowHeights(settings) {
            var h = this.initialConfig.rowHeights;
            if (h) {
                settings.rowHeights = h;
            }
        }

        // 

    }, {
        key: '_transBorders',
        value: function _transBorders(settings) {
            var s = this.initialConfig.borders;
            if (s) {
                settings.customBorders = s;
            }
        }

        // 

    }, {
        key: '_transMergeCells',
        value: function _transMergeCells(settings) {
            var s = this.initialConfig.mergeCells;
            if (s) {
                settings.mergeCells = s;
            }
        }

        // ------------------------ initState ------------------------------

        // 

    }, {
        key: '_initSelection',
        value: function _initSelection() {
            var s = this.initialConfig.selection;
            if (s) {
                this.sheet.select(s.row, s.col, s.endRow, s.endCol);
            } else {
                this.sheet.select(0, 0);
            }
        }
    }]);

    return ConfigTranslator;
}();

exports.default = ConfigTranslator;

},{}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ContextMenu = require('./frame/ContextMenu');

var _ContextMenu2 = _interopRequireDefault(_ContextMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  Workbook 
 * 
 */
var Frame = function () {
  function Frame(instance, config) {
    _classCallCheck(this, Frame);

    this.spreadSheet = instance;
    /**
     *
     * @type {ContextMenu}
     */
    this.contextMenu = new _ContextMenu2.default(instance);
  }

  _createClass(Frame, [{
    key: '_getExchange',
    value: function _getExchange() {}
  }]);

  return Frame;
}();

exports.default = Frame;

},{"./frame/ContextMenu":16}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _common = require('../utils/common.js');

var _ConfigTranslator = require('./ConfigTranslator.js');

var _ConfigTranslator2 = _interopRequireDefault(_ConfigTranslator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Handsontable 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var HotTableAdaptor = function (_Handsontable) {
    _inherits(HotTableAdaptor, _Handsontable);

    /**
     *
     * @param {HTMLElement} rootElement
     * @param {object} config - 
     * @param {object} extConfig - 
     * @param {Sheet} sheet -  sheet 
     */
    function HotTableAdaptor(rootElement, config, extConfig, sheet) {
        _classCallCheck(this, HotTableAdaptor);

        var hotSettings = {};
        var translator = new _ConfigTranslator2.default(config, sheet);
        var settings = translator.translate();

        var frame = sheet.workbook.spreadSheet.getFrameInstance();
        var displayMode = sheet.workbook.spreadSheet.getDisplayMode();
        var menuItems = frame.contextMenu.menuItems;
        var contextMenu = {};
        contextMenu.items = frame.contextMenu.getMenuItems4HotTable();
        contextMenu.callback = function (sheet) {
            return function (key, options) {
                if (menuItems.has(key)) {
                    var item = menuItems.get(key);
                    if (item.handler) {
                        item.handler.call(this, sheet, options.start, options.end, options);
                    }
                }
            };
        }(sheet);
        HotTableAdaptor._preference.contextMenu = contextMenu;

        (0, _common.extend)(hotSettings, HotTableAdaptor._preference);
        (0, _common.extend)(hotSettings, settings);
        (0, _common.extend)(hotSettings, extConfig);

        if (displayMode) {
            hotSettings.colHeaders = false;
            hotSettings.rowHeaders = false;
        }

        var _this = _possibleConstructorReturn(this, (HotTableAdaptor.__proto__ || Object.getPrototypeOf(HotTableAdaptor)).call(this, rootElement, hotSettings));

        _this._translator = translator;

        // handontable  render  td 
        //noinspection ES6ModulesDependencies
        Handsontable.hooks.add('beforeRenderer', function (TD, row, col, prop, value, cellProperties) {
            TD.style.color = cellProperties._style_color || '';
            TD.style.fontFamily = cellProperties._style_fontFamily || '';
            TD.style.fontSize = cellProperties._style_fontSize || '';
            TD.style.backgroundColor = cellProperties._style_backgroundColor || '';
        }, _this);

        /*
         *  Handsontable  SpreadSheet 
         *  Handsontable.hooks.getRegistered()  ECP 
         */
        ['afterSelectionEnd'].forEach(function (hook) {
            //noinspection ES6ModulesDependencies
            Handsontable.hooks.add(hook, function () {
                var args = [];
                args.push(hook);
                args.push(sheet);
                args.push.apply(args, [].slice.call(arguments));
                var cxt = sheet.workbook.spreadSheet;
                cxt.emit.apply(cxt, args);
            }, _this);
        });
        return _this;
    }

    _createClass(HotTableAdaptor, [{
        key: 'destroy',
        value: function destroy() {
            _get(HotTableAdaptor.prototype.__proto__ || Object.getPrototypeOf(HotTableAdaptor.prototype), 'destroy', this).call(this);
            delete this._translator;
        }
    }]);

    return HotTableAdaptor;
}(Handsontable);

/**
 * 
 * @private
 */


HotTableAdaptor._preference = {
    outsideClickDeselects: false,
    contextMenu: true,

    rowHeaders: true,
    colHeaders: true,

    manualColumnResize: true,
    manualRowResize: true,

    tableClassName: 'ssd-handsontable',

    customBorders: true,

    xFormulas: true
};

exports.default = HotTableAdaptor;

},{"../utils/common.js":59,"./ConfigTranslator.js":8}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _HotTableAdaptor = require('./HotTableAdaptor');

var _HotTableAdaptor2 = _interopRequireDefault(_HotTableAdaptor);

var _SheetError = require('./SheetError');

var _Sheet_exchange = require('./ext/Sheet_exchange');

var _Sheet_helper = require('./ext/Sheet_helper');

var _common = require('../utils/common');

var _Emitter = require('../utils/Emitter');

var _Emitter2 = _interopRequireDefault(_Emitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var INIT_ROWS = 150; // Sheet 
var INIT_COLS = 50; // Sheet 

// Webstorm IDE  souremap  extends 
var Mixin = (0, _Sheet_helper.SheetHelper)((0, _Sheet_exchange.Exchange)(_Emitter2.default));

/**
 * 
 *
 * @fires Sheet#afterRename
 * @fires Sheet#afterRenameCancel
 */

var Sheet = function (_Mixin) {
    _inherits(Sheet, _Mixin);

    /**
     *  Sheet 
     *  Workbook.createSheet() 
     *
     * @param {Workbook} workbook
     * @param {object} config
     * @private
     */
    function Sheet(workbook, config) {
        _classCallCheck(this, Sheet);

        /**
         * sheet 
         * @type {Workbook}
         */
        var _this = _possibleConstructorReturn(this, (Sheet.__proto__ || Object.getPrototypeOf(Sheet)).call(this));

        _this.workbook = workbook;
        _this.$$view = workbook.$$view;
        _this.settings = config;
        _this.sheetName = config.name;

        _this.initRows = INIT_ROWS;
        _this.initCols = INIT_COLS;

        _this.fx = {}; // TODO

        _this._render();
        return _this;
    }

    /**
     * @private
     */


    _createClass(Sheet, [{
        key: '_render',
        value: function _render() {
            this.$$view.appendTab(this.sheetName);

            var _$$view$_hotTables$ge = this.$$view._hotTables.get(this.sheetName),
                container = _$$view$_hotTables$ge.container,
                width = _$$view$_hotTables$ge.width,
                height = _$$view$_hotTables$ge.height;

            /**
             * @type {Handsontable}
             */

            this.handsontable = new _HotTableAdaptor2.default(container, this.settings, {
                width: width,
                height: height,
                readOnly: this.workbook.spreadSheet.getDisplayMode(),
                startRows: this.initRows,
                startCols: this.initCols,
                _isHotTableAdaptor: true,
                _sheet: this
            }, this);
            this.handsontable._translator.initSheetState();
            this.$$view.hideContent(this.getName());
        }

        /**
         *  sheet 
         * @returns {string}
         */

    }, {
        key: 'getName',
        value: function getName() {
            return this.sheetName;
        }

        /**
         *  sheet 
         */

    }, {
        key: 'active',
        value: function active() {
            this.workbook.activeSheet = this.getName();
            this.$$view.activeTab(this.getName());
            this.handsontable.render();
        }

        /**
         *  sheet 
         * @returns {boolean}
         */

    }, {
        key: 'isActive',
        value: function isActive() {
            return this.workbook.activeSheet === this.getName();
        }

        /**
         *  sheet 
         */

    }, {
        key: 'close',
        value: function close() {
            this.workbook.closeSheet(this.getName());
        }

        /**
         *  sheet
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.handsontable.destroy();
            this.workbook.sheets.delete(this.getName());
            delete this.workbook;
            delete this.$$view;
        }

        /**
         *  sheet 
         * @param name - 
         */

    }, {
        key: 'rename',
        value: function rename(name) {
            this.workbook.renameSheet(this.getName(), name);
        }

        /**
         *  sheet 
         *  toRow toCol 
         * @param {int} fromRow - 
         * @param {int} fromCol - 
         * @param {int} [toRow] - 
         * @param {int} [toCol] - 
         */

    }, {
        key: 'select',
        value: function select(fromRow, fromCol, toRow, toCol) {
            toRow = toRow || fromRow;
            toCol = toCol || fromCol;
            this.handsontable.selectCell(fromRow, fromCol, toRow, toCol, false);
        }

        /**
         *  sheet 
         * @returns {{row, col, endRow, endCol}}
         */

    }, {
        key: 'getSelection',
        value: function getSelection() {
            var selection = this.handsontable.getSelected();
            return {
                row: selection[0],
                col: selection[1],
                endRow: selection[2],
                endCol: selection[3]
            };
        }

        /**
         * 
         * TIP: handsontable 
         * @param {int} row - 
         * @param {int} col - 
         * @param {int} rowspan - 
         * @param {int} colspan - 
         */
        // TODO 

    }, {
        key: 'mergeCells',
        value: function mergeCells(row, col, rowspan, colspan) {
            var r = 0;
            var cover = [];
            var mergeCells = this.handsontable.getSettings().mergeCells;

            var r1 = [row, col, row + rowspan - 1, col + colspan - 1];

            for (var i = mergeCells.length; i; --i) {
                var f = mergeCells[i - 1];
                var r2 = [f.row, f.col, f.row + f.rowspan - 1, f.col + f.colspan - 1];

                // 
                if (_common.Coordinate.isEqual(r1, r2)) {
                    r = 1;
                    break;
                }
                // 
                if (_common.Coordinate.isSubset(r1, r2)) {
                    r = 2;
                    break;
                }
                // 
                if (_common.Coordinate.isSuperset(r1, r2)) {
                    cover.push(i - 1);
                    r = 3;
                    continue;
                }
                // ()
                if (_common.Coordinate.intersection(r1, r2)) {
                    r = 4;
                }
            }

            if (r === 0 || r === 3) {
                if (r === 3) {
                    // 
                    for (var _i = 0; _i < cover.length; ++_i) {
                        mergeCells.splice(cover[_i], 1);
                    }
                }
                mergeCells = mergeCells || [];
                mergeCells.push({
                    row: row,
                    col: col,
                    rowspan: rowspan,
                    colspan: colspan
                });
                this.handsontable.updateSettings({
                    mergeCells: mergeCells
                });
            } else if (r === 2 || r === 4) {
                throw new _SheetError.SheetError('\u7ED9\u5B9A\u7684\u5408\u5E76\u533A\u57DF\u4E0D\u5408\u6CD5: [' + row + ', ' + col + ', ' + rowspan + ', ' + colspan + ']');
            }
        }

        /**
         * 
         * @param {int} row - 
         * @param {int} col - 
         * @param {int} rowspan - 
         * @param {int} colspan - 
         */

    }, {
        key: 'unMergeCells',
        value: function unMergeCells(row, col, rowspan, colspan) {
            var merged = this.handsontable.getSettings().mergeCells;
            var mergeCells = [];
            if (merged && merged.length) {
                for (var i = 0; i < merged.length; ++i) {
                    if (_common.Coordinate.isSubset([merged[i].row, merged[i].col, merged[i].row + merged[i].rowspan - 1, merged[i].col + merged[i].colspan - 1], [row, col, row + rowspan - 1, col + colspan - 1])) {
                        continue;
                    }
                    mergeCells.push(merged[i]);
                }
            }
            this.handsontable.updateSettings({
                mergeCells: mergeCells.length === 0 ? false : mergeCells
            });
        }
    }, {
        key: 'spliceClass',
        value: function spliceClass(selection, newClassName) {
            for (var _len = arguments.length, classNames = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                classNames[_key - 2] = arguments[_key];
            }

            var _this2 = this;

            this._walkonCellMetas(selection, function (row, col, cellMeta) {
                return {
                    className: (_this2._removeFormerClass(cellMeta.className, classNames) + ' ' + newClassName).trim()
                };
            }, { className: newClassName });
        }

        /**
         * 
         * @param {boolean} [value=true] `true` `false` 
         * @param {object} selection - 
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontBold',
        value: function setFontBold() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-bold', 'ssd-font-bold');
            } else {
                this.spliceClass(selection, '', 'ssd-font-bold');
            }
            this.handsontable.render();
        }

        /**
         * 
         * @param {boolean} [value=true]
         * @param {object} selection - 
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontItalic',
        value: function setFontItalic() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-italic', 'ssd-font-italic');
            } else {
                this.spliceClass(selection, '', 'ssd-font-italic');
            }
            this.handsontable.render();
        }

        /**
         * 
         * @param {boolean} [value=true]
         * @param selection - 
         * @param {int} selection.row
         * @param {int} selection.col
         * @param {int} [selection.endRow]
         * @param {int} [selection.endCol]
         */

    }, {
        key: 'setFontUnderline',
        value: function setFontUnderline() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            if (value) {
                this.spliceClass(selection, 'ssd-font-underline', 'ssd-font-underline');
            } else {
                this.spliceClass(selection, '', 'ssd-font-underline');
            }
            this.handsontable.render();
        }

        /**
         * 
         * TIP  handontable  getCell  TD  render 
         * @param value
         * @param selection
         */

    }, {
        key: 'setFontColor',
        value: function setFontColor() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_color: value
                };
            }, { _style_color: value });
            this.handsontable.render();
        }

        /**
         * 
         * @param value
         * @param selection
         */

    }, {
        key: 'setFontFamily',
        value: function setFontFamily() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_fontFamily: value
                };
            }, { _style_fontFamily: value });
            this.handsontable.render();
        }

        /**
         * 
         * @param value -  12px
         * @param selection
         */

    }, {
        key: 'setFontSize',
        value: function setFontSize(value) {
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_fontSize: value
                };
            }, { _style_fontSize: value });
            this.handsontable.render();
        }

        /**
         * 
         * @param value
         * @param selection
         */

    }, {
        key: 'setBackgroundColor',
        value: function setBackgroundColor() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelection();

            this._walkonCellMetas(selection, function () {
                return {
                    _style_backgroundColor: value
                };
            }, { _style_backgroundColor: value });
            this.handsontable.render();
        }

        /**
         * FIXME handsontable  BUG 
         * 
         * @param range -  `{form: {row: 1, col: 1}, to: {row: 3, col: 4}}` 
         * @param top -  `{width: 2, color: '#5292F7'}` 
         * @param [right]
         * @param [bottom]
         * @param [left]
         */

    }, {
        key: 'setBorder',
        value: function setBorder(range, top, right, bottom, left) {
            var config = {
                range: range,
                top: top
            };
            config.right = right || top;
            config.bottom = bottom || top;
            config.left = left || config.right;

            var formerBorders = this.handsontable.getSettings().customBorders;
            if (formerBorders === true) {
                formerBorders = [];
            }
            formerBorders.push(config);

            // TODO customBorders cannot be updated via updateSettings
            // @see {@link https://github.com/handsontable/handsontable/issues/2002}
            this.handsontable.updateSettings({
                customBorders: formerBorders
            });
            //this.handsontable.runHooks('afterInit');
        }

        /**
         * 
         *
         * @param type - `text` | `date` | `numeric`
         * @param settings
         * @param selection
         */

    }, {
        key: 'setDataFormat',
        value: function setDataFormat() {
            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'text';
            var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var selection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getSelection();

            this._walkonCellMetas(selection, function (row, col, cellMeta) {
                var fType = cellMeta.type;

                if (fType === 'date') {
                    delete cellMeta.dateFormat;
                    delete cellMeta.defaultDate;
                    delete cellMeta.correctFormat;
                } else if (fType === 'numeric') {
                    delete cellMeta.format;
                    delete cellMeta.language;
                }
                cellMeta.type = type;

                // https://github.com/handsontable/handsontable/issues/4360
                delete cellMeta.renderer;
                delete cellMeta.editor;
                delete cellMeta.validator;
                return (0, _common.extend)(cellMeta, settings);
            }, { type: type });
            this.handsontable.render();
        }
    }]);

    return Sheet;
}(Mixin);

exports.default = Sheet;

/**
 * afterRename 
 *
 * @event Sheet#afterRename
 * @type {Sheet}
 * @type {string}
 * @type {string}
 */

/**
 * afterRenameCancel 
 *
 * @event Sheet#afterRenameCancel
 * @type {Sheet}
 * @type {string}
 * @type {string}
 */

},{"../utils/Emitter":58,"../utils/common":59,"./HotTableAdaptor":10,"./SheetError":12,"./ext/Sheet_exchange":14,"./ext/Sheet_helper":15}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SheetError = SheetError;

var _SpreadSheetError = require('../SpreadSheetError');

function SheetError(value) {
    this.name = 'SheetError';
    this.message = value;
}
SheetError.prototype = new _SpreadSheetError.SpreadSheetError();
SheetError.prototype.constructor = SheetError;

},{"../SpreadSheetError":5}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Tabs = require('./views/Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

var _Sheet = require('./Sheet');

var _Sheet2 = _interopRequireDefault(_Sheet);

var _SheetError = require('./SheetError');

var _dataStructure = require('../utils/dataStructure');

var _common = require('../utils/common');

var _settings = require('../settings');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var regExp = _settings.globalSettings.sheet.sheetName;

/**
 *  Workbook  Sheet .
 */

var Workbook = function () {

    /**
     * Workbook 
     * @param {SpreadSheet} instance
     * @param {object} config
     */
    function Workbook(instance, config) {
        var _this = this;

        _classCallCheck(this, Workbook);

        /**
         * @type {SpreadSheet}
         */
        this.spreadSheet = instance;
        /**
         * @type {CaseInsensitiveMap}
         */
        this.sheets = new _dataStructure.CaseInsensitiveMap();
        this.settings = config;

        this._initSettings(config);
        this.$$view = new _Tabs2.default(this);

        config.sheets.forEach(function (v) {
            return _this.createSheet(v);
        });

        //  sheet 
        var toActive = this.getSheet(this.activeSheet);
        if (!toActive) {
            throw new _SheetError.SheetError('\u6307\u5B9A\u7684 activeSheet \u4E0D\u5B58\u5728: ' + this.activeSheet);
        }
        toActive.active();
    }

    /**
     *
     * @param settings
     * @private
     */


    _createClass(Workbook, [{
        key: '_initSettings',
        value: function _initSettings(settings) {
            var keys = Object.keys(settings);
            for (var i = 0, len = keys.length; i < len; ++i) {
                if (keys[i] === 'sheets') {
                    continue;
                }
                this[keys[i]] = settings[keys[i]];
            }
        }

        /**
         *  Workbook 
         * @returns {Object}
         */

    }, {
        key: 'getSettings',
        value: function getSettings() {
            return this.spreadSheet.getSettings();
        }

        /**
         *  Workbook  id
         * @returns {string}
         */

    }, {
        key: 'getId',
        value: function getId() {
            return this.id || (this.id = this.spreadSheet.getId() + _settings.globalSettings.idSuffix4Workbook);
        }

        /**
         *  sheet  sheet 
         * @param name
         * @returns {Sheet}
         */

    }, {
        key: 'getSheet',
        value: function getSheet(name) {
            return this.sheets.get(name);
        }

        /**
         *  Workbook  sheet 
         * @returns {CaseInsensitiveMap}
         */

    }, {
        key: 'getSheets',
        value: function getSheets() {
            return this.sheets;
        }

        /**
         *  sheet 
         * @returns {Iterator.<string>}
         */

    }, {
        key: 'getSheetNames',
        value: function getSheetNames() {
            return this.sheets.keys();
        }

        /**
         *  sheet 
         * @param name
         * @param {boolean} [exactly=false] -  name
         * @returns {boolean}
         */

    }, {
        key: 'isSheetExist',
        value: function isSheetExist(name, exactly) {
            if (exactly) {
                return this.sheets.hasExact(name);
            }
            // return !!this.getSheet(name);
            return this.sheets.has(name);
        }

        /**
         *  sheet 
         * @private
         * @returns {number}
         */

    }, {
        key: '_getAutoSheetIndex',
        value: function _getAutoSheetIndex() {
            if (!this.$$autoSheetIndex) {
                this.$$autoSheetIndex = 0;
            }
            return ++this.$$autoSheetIndex; //  1 
        }

        /**
         *  sheet 
         * @returns {string}
         * @private
         */

    }, {
        key: '_getAutoSheetName',
        value: function _getAutoSheetName() {
            var prefix = _settings.globalSettings.sheet.autoPrefix + ''; // 
            var name = prefix + this._getAutoSheetIndex();
            if (this.isSheetExist(name)) {
                return this._getAutoSheetName();
            }
            return name;
        }

        /**
         *  sheet 
         * @returns {Sheet}
         */

    }, {
        key: 'getActiveSheet',
        value: function getActiveSheet() {
            return this.sheets.get(this.activeSheet);
        }

        /**
         *  sheet 
         * @param {object} [config] - sheet 
         * @returns {Sheet} 
         */

    }, {
        key: 'createSheet',
        value: function createSheet(config) {
            if (config) {
                // name 
                this._validateSheetName(config.name);
            } else {
                //  name
                config = {};
                config.name = this._getAutoSheetName();
            }
            var newOne = new _Sheet2.default(this, config);
            this.sheets.set(config.name, newOne);
            return newOne;
        }

        /**
         *  sheet 
         * @param {string | Sheet} sheet - sheet 
         */

    }, {
        key: 'destroySheet',
        value: function destroySheet(sheet) {
            if (typeof sheet === 'string') {
                sheet = this.getSheet(sheet);
            }
            sheet.destroy();
        }

        /**
         *  sheet 
         * @param {string} name1 -  sheet 
         * @param {string} name2 - 
         */
        // FIXME 
        // handsontable  document  keydown 
        //  sheet 
        //  input  select  focussheet

    }, {
        key: 'renameSheet',
        value: function renameSheet(name1, name2) {
            var sheet = this.getSheet(name1);
            if (!sheet) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name1 + '" \u4E0D\u5B58\u5728');
            }
            if (name1 !== name2) {
                this._validateSheetName(name2, (0, _common.upperCase)(name1) === (0, _common.upperCase)(name2));
                sheet.sheetName = name2;
                if (this.activeSheet === name1) {
                    this.activeSheet = name2;
                }
                this.getSheets().delete(name1);
                this.getSheets().set(name2, sheet);
                this.$$view.tabRename(name1, name2);
            } else {
                this.$$view.tabRenameCancel(name1, name2);
            }
        }

        /**
         *  sheet 
         */

    }, {
        key: 'closeSheet',
        value: function closeSheet(name) {
            var sheet = this.getSheet(name);
            if (!sheet) {
                throw new _SheetError.SheetError('\u65E0\u6CD5\u5173\u95ED\u4E0D\u5B58\u5728\u7684\u5DE5\u4F5C\u8868 "' + name + '" \u3002');
            }
            if (this.sheets.size() === 1) {
                throw new _SheetError.SheetError('\u65E0\u6CD5\u5173\u95ED\u4EC5\u6709\u7684\u4E00\u4E2A\u5DE5\u4F5C\u8868 "' + name + '" \u3002');
            }
            if (sheet.isActive()) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.sheets.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var k = _step.value;

                        if (k && k !== name) {
                            this.activeSheet = k;
                            this.getSheet(k).active();
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            this.sheets.delete(name);
            this.$$view.removeTab(name);
            this.destroySheet(sheet);
        }

        /**
         *  workbook
         */

    }, {
        key: 'active',
        value: function active() {
            this.getActiveSheet().active();
        }

        /**
         *  sheet
         * @param {string} sheetName
         */

    }, {
        key: 'activeSheet',
        value: function activeSheet(sheetName) {
            var sheet = this.getSheet(sheetName);
            if (sheet) {
                sheet.active();
            }
        }

        /**
         *  sheet 
         * @param {string} name
         * @param {boolean} exactly
         * @private
         */

    }, {
        key: '_validateSheetName',
        value: function _validateSheetName(name, exactly) {
            if (!name) {
                throw new _SheetError.SheetError('');
            }
            //  
            if (regExp.test(name)) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name + '" \u5305\u542B\u975E\u6CD5\u5B57\u7B26');
            }
            if (this.isSheetExist(name, exactly)) {
                throw new _SheetError.SheetError('\u5DE5\u4F5C\u8868 "' + name + '" \u5DF2\u5B58\u5728');
            }
        }
    }, {
        key: '_getExchange',
        value: function _getExchange() {
            var sheets = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.getSheets().toMap()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _step2$value = _slicedToArray(_step2.value, 2),
                        sheet = _step2$value[1];

                    sheet && sheets.push(sheet._getExchange());
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return {
                activeSheet: this.activeSheet,
                sheets: sheets
            };
        }
    }]);

    return Workbook;
}();

exports.default = Workbook;

},{"../settings":57,"../utils/common":59,"../utils/dataStructure":60,"./Sheet":11,"./SheetError":12,"./views/Tabs":20}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Exchange = exports.Exchange = function Exchange(Sup) {
    return function (_Sup) {
        _inherits(_class, _Sup);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: '_getExchange',
            value: function _getExchange() {
                var _getDataMeta2 = this._getDataMeta(),
                    data = _getDataMeta2.data,
                    cells = _getDataMeta2.cells;

                var _getSizeEx2 = this._getSizeEx(),
                    heights = _getSizeEx2.heights,
                    widths = _getSizeEx2.widths;

                var mergeCells = this.handsontable.getSettings().mergeCells;

                if (mergeCells === false) {
                    mergeCells = null; // 
                }

                return {
                    name: this.getName(),
                    selection: this.getSelection(),
                    data: data.length ? data : []._,
                    rowHeights: heights,
                    colWidths: widths,
                    mergeCells: mergeCells,
                    cellMetas: cells
                };
            }
        }, {
            key: '_getStylesEx',
            value: function _getStylesEx(meta) {
                var ret = {};
                var alignments = this._getAlignmentEx(meta.className);
                if (alignments) {
                    ret.alignments = alignments;
                }
                this._getFontEx(meta, ret);
                this._getBgColorEx(meta, ret);
                return ret;
            }
        }, {
            key: '_getBgColorEx',
            value: function _getBgColorEx(meta, ret) {
                if (meta._style_backgroundColor) {
                    ret.backgroundColor = meta._style_backgroundColor;
                }
            }
        }, {
            key: '_getFontEx',
            value: function _getFontEx(meta, ret) {
                if (meta._style_fontFamily) {
                    ret.fontFamily = meta._style_fontFamily;
                }
                if (meta._style_fontSize) {
                    ret.fontSize = meta._style_fontSize;
                }
                if (meta.className && meta.className.contains('ssd-font-italic')) {
                    ret.fontStyle = 'italic';
                }
                if (meta.className && meta.className.contains('ssd-font-bold')) {
                    ret.fontWeight = 'bold';
                }
                if (meta.className && meta.className.contains('ssd-font-underline')) {
                    ret.textDecoration = 'underline';
                }
                if (meta._style_color) {
                    ret.color = meta._style_color;
                }
            }
        }, {
            key: '_getAlignmentEx',
            value: function _getAlignmentEx(className) {
                var alignment = [];
                if (className) {
                    className.contains('htLeft') && alignment.push('Left');
                    className.contains('htCenter') && alignment.push('Center');
                    className.contains('htRight') && alignment.push('Right');
                    className.contains('htJustify') && alignment.push('Justify');
                    className.contains('htTop') && alignment.push('Top');
                    className.contains('htMiddle') && alignment.push('Middle');
                    className.contains('htBottom') && alignment.push('Bottom');
                }
                return alignment.length ? alignment : false;
            }
        }, {
            key: '_getSizeEx',
            value: function _getSizeEx() {
                var hot = this.handsontable;
                var cols = Math.max(hot.countCols() - hot.countEmptyCols(true), 20);
                var rows = Math.max(hot.countRows() - hot.countEmptyRows(true), 50);
                var heights = [];
                var widths = [];

                for (var i = 0; i < rows; ++i) {
                    var h = hot.getRowHeight(i);
                    if (i === 0 && !h) {
                        // handsontable bug
                        h = 24;
                    }
                    heights.push(h);
                }
                for (var _i = 0; _i < cols; ++_i) {
                    widths.push(hot.getColWidth(_i));
                }
                return { heights: heights, widths: widths };
            }
        }, {
            key: '_getDataMeta',
            value: function _getDataMeta() {
                var hot = this.handsontable;
                var cols = hot.countCols() - hot.countEmptyCols(true);
                var rows = hot.countRows() - hot.countEmptyRows(true);
                var data = [];
                var cells = [];

                for (var i = 0; i < rows; ++i) {
                    var rowResult = [];
                    var rowCellMeta = [];

                    for (var j = 0; j < cols; ++j) {
                        var _sourceData = hot.getSourceDataAtCell(i, j);
                        var _meta = hot.getCellMeta(i, j);
                        var _data = hot.getDataAtCell(i, j);
                        var _cellMata = {};

                        _cellMata.row = i;
                        _cellMata.col = j;
                        _cellMata.isFormula = !!(_sourceData && (_sourceData + '').charAt(0) === '=');
                        _cellMata.sourceValue = _sourceData;
                        _cellMata.value = _data;

                        (function (o, m) {
                            //noinspection JSUnusedLocalSymbols,LoopStatementThatDoesntLoopJS
                            for (var x in o) {
                                m.styles = o;
                                return;
                            }
                        })(this._getStylesEx(_meta), _cellMata);

                        this._getDataType(_meta, _cellMata);

                        rowResult.push(_sourceData);
                        rowCellMeta.push(_cellMata);
                    }
                    data.push(rowResult);
                    cells.push(rowCellMeta);
                }
                return { data: data, cells: cells };
            }

            // TODO

        }, {
            key: '_getBordersEx',
            value: function _getBordersEx() {}

            //  numericdate 

        }, {
            key: '_getDataType',
            value: function _getDataType(_meta, _cellMata) {
                var t = _meta.type;
                _cellMata.dataType = {};
                _cellMata.dataType.typeName = t;

                if (t === 'date') {
                    _cellMata.dataType.dateFormat = _meta.dateFormat;
                    _meta.defaultDate && (_cellMata.dataType.defaultDate = _meta.defaultDate);
                    _meta.correctFormat && (_cellMata.dataType.correctFormat = _meta.correctFormat);
                } else if (t === 'numeric') {
                    _cellMata.dataType.format = _meta.format;
                    _meta.language && (_cellMata.dataType.language = _meta.language);
                }
            }
        }]);

        return _class;
    }(Sup);
};

},{}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SheetHelper = exports.SheetHelper = function SheetHelper(Sup) {
    return function (_Sup) {
        _inherits(_class, _Sup);

        function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
        }

        _createClass(_class, [{
            key: '_defaultSelection',


            // 
            //   1.  row > endRow
            //   2. endRow  endCol 
            //
            value: function _defaultSelection(s) {
                s.row > s.endRow && (s.row = [s.endRow, s.endRow = s.row][0]);
                s.col > s.endCol && (s.col = [s.endCol, s.endCol = s.col][0]);

                return {
                    startRow: s.row,
                    endRow: s.endRow || s.row,
                    startCol: s.col,
                    endCol: s.endCol || s.col
                };
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_removeFormerClass',
            value: function _removeFormerClass(current) {
                if (!current) {
                    return '';
                }

                for (var _len = arguments.length, supported = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    supported[_key - 1] = arguments[_key];
                }

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = supported[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var clazz = _step.value;

                        current = current.split(clazz).join('');
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return current.trim();
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_walkonCellMetas',
            value: function _walkonCellMetas(selection, callback, unhold) {
                var _defaultSelection2 = this._defaultSelection(selection),
                    startRow = _defaultSelection2.startRow,
                    endRow = _defaultSelection2.endRow,
                    startCol = _defaultSelection2.startCol,
                    endCol = _defaultSelection2.endCol;

                for (var i = startRow; i <= endRow; ++i) {
                    for (var j = startCol; j <= endCol; ++j) {
                        var cellMeta = this.handsontable.getCellMeta(i, j);
                        if (cellMeta) {
                            var newMeta = callback.call(this, i, j, cellMeta);
                            newMeta && this.handsontable.setCellMetaObject(i, j, newMeta);
                        } else {
                            unhold && this.handsontable.setCellMetaObject(i, j, unhold);
                        }
                    }
                }
            }

            //noinspection JSUnusedGlobalSymbols

        }, {
            key: '_walkonCells',
            value: function _walkonCells(selection, callback) {
                var _defaultSelection3 = this._defaultSelection(selection),
                    startRow = _defaultSelection3.startRow,
                    endRow = _defaultSelection3.endRow,
                    startCol = _defaultSelection3.startCol,
                    endCol = _defaultSelection3.endCol;

                for (var i = startRow; i <= endRow; ++i) {
                    for (var j = startCol; j <= endCol; ++j) {
                        var cellTD = this.handsontable.getCell(i, j, true);
                        if (cellTD) {
                            callback.call(this, i, j, cellTD);
                        }
                    }
                }
            }
        }, {
            key: '_walkonSelection',
            value: function _walkonSelection(selection, callback) {
                var _defaultSelection4 = this._defaultSelection(selection),
                    startRow = _defaultSelection4.startRow,
                    endRow = _defaultSelection4.endRow,
                    startCol = _defaultSelection4.startCol,
                    endCol = _defaultSelection4.endCol;

                for (var i = startRow; i <= endRow; ++i) {
                    for (var j = startCol; j <= endCol; ++j) {
                        callback.call(this, i, j);
                    }
                }
            }
        }]);

        return _class;
    }(Sup);
};

},{}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ContextMenu_alignment = require('./ContextMenu_alignment');

var _ContextMenu_mergeCells = require('./ContextMenu_mergeCells');

var _ContextMenu_rowOrColumnResize = require('./ContextMenu_rowOrColumnResize');

/**
 * 
 */
function ContextMenu(spreadSheet) {
    this.spreadSheet = spreadSheet;
    /**
     *
     * @type {Map}
     */
    this.menuItems = new Map();
    this._init();
}

exports.default = ContextMenu;


ContextMenu.prototype.register = function (key, config, handler) {
    this.menuItems.set(key, {
        config: config,
        handler: handler
    });
};

/**
 *  handsontable 
 */
ContextMenu.prototype.getMenuItems4HotTable = function () {
    var _this = this;

    if (!this._hotTableItems) {
        this._hotTableItems = {};
        this.menuItems.forEach(function (_ref, key) {
            var config = _ref.config;
            return _this._hotTableItems[key] = config;
        });
    }
    return this._hotTableItems;
};

/*
 ### handsontable ###
 row_above
 row_below
 hsep1
 col_left
 col_right
 hsep2
 remove_row
 remove_col
 hsep3
 undo
 redo
 make_read_only
 alignment
 borders
 */
ContextMenu.prototype._init = function () {
    var SEP = '---------';

    this.register('row_above', {
        name: '',
        disabled: function disabled() {
            //  this   hotTable 
            // TODO 
            return false;
        }
    });

    this.register('row_below', {
        name: ''
    });

    this.register('col_left', {
        name: ''
    });

    this.register('col_right', {
        name: ''
    });

    this.register('hsep_bt_insert', SEP);

    // FIXME handsontable BUG
    this.register('remove_row', {
        name: '',
        disabled: function disabled() {
            // TODO 
            return false;
        }
    });
    this.register('remove_col', {
        name: ''
    });

    this.register('hsep_bt_remove', SEP);

    this.register('alignment', (0, _ContextMenu_alignment.alignmentItem)());
    this.register('row_resize', _ContextMenu_rowOrColumnResize.rowResize, _ContextMenu_rowOrColumnResize.rowResizeHandler);
    this.register('col_resize', _ContextMenu_rowOrColumnResize.colResize, _ContextMenu_rowOrColumnResize.colResizeHandler);

    this.register('hsep_bt_format', SEP);

    this.register('q_merge_cells', _ContextMenu_mergeCells.mergeCells, _ContextMenu_mergeCells.mergeCellsHandler);
    this.register('q_cancel_merge_cells', _ContextMenu_mergeCells.cancelMergeCells, _ContextMenu_mergeCells.cancelMergeCellsHandler);
};

},{"./ContextMenu_alignment":17,"./ContextMenu_mergeCells":18,"./ContextMenu_rowOrColumnResize":19}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.alignmentItem = alignmentItem;

var _i18n = require('../../i18n');

// https://github.com/handsontable/handsontable/issues/3807
function alignmentItem() {
    return {
        name: _i18n.MENU.S5,
        disabled: function disabled() {
            return !(this.getSelectedRange() && !this.selection.selectedHeader.corner);
        },
        submenu: {
            items: [{
                key: 'alignment:left',
                name: function name() {
                    var _this = this;

                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this.getCellMeta(row, col).className;
                        if (className && className.indexOf('htLeft') !== -1) {
                            return true;
                        }
                    });
                    return hasClass ? markLabelAsSelected(_i18n.MENU.S6) : _i18n.MENU.S6;
                },
                callback: function callback() {
                    var _this2 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this2.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htLeft';
                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this2.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:center',
                name: function name() {
                    var _this3 = this;

                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this3.getCellMeta(row, col).className;
                        if (className && className.indexOf('htCenter') !== -1) {
                            return true;
                        }
                    });
                    return hasClass ? markLabelAsSelected(_i18n.MENU.S7) : _i18n.MENU.S7;
                },
                callback: function callback() {
                    var _this4 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this4.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htCenter';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this4.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:right',
                name: function name() {
                    var _this5 = this;

                    var label = _i18n.MENU.S8;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this5.getCellMeta(row, col).className;

                        if (className && className.indexOf('htRight') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this6 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this6.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htRight';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this6.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:justify',
                name: function name() {
                    var _this7 = this;

                    var label = _i18n.MENU.S9;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this7.getCellMeta(row, col).className;

                        if (className && className.indexOf('htJustify') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this8 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this8.getCellMeta(row, col).className;
                    });
                    var type = 'horizontal';
                    var alignment = 'htJustify';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this8.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                name: '---------'
            }, {
                key: 'alignment:top',
                name: function name() {
                    var _this9 = this;

                    var label = _i18n.MENU.S10;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this9.getCellMeta(row, col).className;
                        if (className && className.indexOf('htTop') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }
                    return label;
                },
                callback: function callback() {
                    var _this10 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this10.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htTop';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this10.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:middle',
                name: function name() {
                    var _this11 = this;

                    var label = _i18n.MENU.S11;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this11.getCellMeta(row, col).className;

                        if (className && className.indexOf('htMiddle') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this12 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this12.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htMiddle';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this12.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }, {
                key: 'alignment:bottom',
                name: function name() {
                    var _this13 = this;

                    var label = _i18n.MENU.S12;
                    var hasClass = checkSelectionConsistency(this.getSelectedRange(), function (row, col) {
                        var className = _this13.getCellMeta(row, col).className;

                        if (className && className.indexOf('htBottom') !== -1) {
                            return true;
                        }
                    });

                    if (hasClass) {
                        label = markLabelAsSelected(label);
                    }

                    return label;
                },
                callback: function callback() {
                    var _this14 = this;

                    var range = this.getSelectedRange();
                    var stateBefore = getAlignmentClasses(range, function (row, col) {
                        return _this14.getCellMeta(row, col).className;
                    });
                    var type = 'vertical';
                    var alignment = 'htBottom';

                    this.runHooks('beforeCellAlignment', stateBefore, range, type, alignment);
                    align(range, type, alignment, function (row, col) {
                        return _this14.getCellMeta(row, col);
                    });
                    this.render();
                },
                disabled: false
            }]
        }
    };
}

function checkSelectionConsistency(range, comparator) {
    var result = false;
    if (range) {
        range.forAll(function (row, col) {
            if (comparator(row, col)) {
                result = true;
                return false;
            }
        });
    }
    return result;
}

function markLabelAsSelected(label) {
    return '<span class="selected">' + String.fromCharCode(10003) + '</span>' + label;
}

function getAlignmentClasses(range, callback) {
    var classes = {};
    for (var row = range.from.row; row <= range.to.row; row++) {
        for (var col = range.from.col; col <= range.to.col; col++) {
            if (!classes[row]) {
                classes[row] = [];
            }
            classes[row][col] = callback(row, col);
        }
    }
    return classes;
}

function align(range, type, alignment, cellDescriptor) {
    if (range.from.row === range.to.row && range.from.col === range.to.col) {
        applyAlignClassName(range.from.row, range.from.col, type, alignment, cellDescriptor);
    } else {
        for (var row = range.from.row; row <= range.to.row; row++) {
            for (var col = range.from.col; col <= range.to.col; col++) {
                applyAlignClassName(row, col, type, alignment, cellDescriptor);
            }
        }
    }
}

function applyAlignClassName(row, col, type, alignment, cellDescriptor) {
    var cellMeta = cellDescriptor(row, col);
    var className = alignment;

    if (cellMeta.className) {
        if (type === 'vertical') {
            className = prepareVerticalAlignClass(cellMeta.className, alignment);
        } else {
            className = prepareHorizontalAlignClass(cellMeta.className, alignment);
        }
    }
    cellMeta.className = className;
}

function prepareVerticalAlignClass(className, alignment) {
    if (className.indexOf(alignment) !== -1) {
        return className;
    }
    className = className.replace('htTop', '').replace('htMiddle', '').replace('htBottom', '').replace('  ', '');

    className += ' ' + alignment;
    return className;
}

function prepareHorizontalAlignClass(className, alignment) {
    if (className.indexOf(alignment) !== -1) {
        return className;
    }
    className = className.replace('htLeft', '').replace('htCenter', '').replace('htRight', '').replace('htJustify', '').replace('  ', '');

    className += ' ' + alignment;

    return className;
}

},{"../../i18n":21}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cancelMergeCells = exports.mergeCells = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.mergeCellsHandler = mergeCellsHandler;
exports.cancelMergeCellsHandler = cancelMergeCellsHandler;

var _common = require('../../utils/common');

var _i18n = require('../../i18n');

var mergeCells = exports.mergeCells = {
    name: _i18n.MENU.S3,
    disabled: function disabled() {
        var _getSelected = this.getSelected(),
            _getSelected2 = _slicedToArray(_getSelected, 4),
            r1 = _getSelected2[0],
            c1 = _getSelected2[1],
            r2 = _getSelected2[2],
            c2 = _getSelected2[3];

        if (r1 === r2 && c1 === c2) {
            return true;
        }
        return !mergeCompare.call(this, 'isEqual');
    }
};

function mergeCellsHandler(sheet, start, end) {
    sheet.mergeCells(start.row, start.col, end.row - start.row + 1, end.col - start.col + 1);
}

var cancelMergeCells = exports.cancelMergeCells = {
    name: _i18n.MENU.S4,
    disabled: function disabled() {
        return mergeCompare.call(this, 'isSubset');
    }
};

function cancelMergeCellsHandler(sheet, start, end) {
    sheet.unMergeCells(start.row, start.col, end.row - start.row + 1, end.col - start.col + 1);
}

function mergeCompare(type) {
    var merged = this.getSettings().mergeCells;
    if (merged && merged.length) {
        for (var i = 0; i < merged.length; ++i) {
            var _merged$i = merged[i],
                row = _merged$i.row,
                col = _merged$i.col,
                rowspan = _merged$i.rowspan,
                colspan = _merged$i.colspan;

            if (_common.Coordinate[type]([row, col, row + rowspan - 1, col + colspan - 1], convertSelection(this.getSelected()))) {
                return false;
            }
        }
    }
    return true;
}

function convertSelection(s) {
    s[0] > s[2] && (s[0] = [s[2], s[2] = s[0]][0]);
    s[1] > s[3] && (s[1] = [s[3], s[3] = s[1]][0]);
    return s;
}

},{"../../i18n":21,"../../utils/common":59}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.colResize = exports.rowResize = undefined;
exports.rowResizeHandler = rowResizeHandler;
exports.colResizeHandler = colResizeHandler;

var _i18n = require('../../i18n');

// FIXME hot  rowHeights/colWidths  manualRowResize/manualColumnResize 
// https://github.com/handsontable/handsontable/issues/3301
// https://github.com/handsontable/handsontable/issues/4371
var rowResize = exports.rowResize = {
    name: _i18n.MENU.S1,
    hidden: function hidden() {
        return !this.getSelectedRange() || !this.selection.selectedHeader.rows;
    }
};

function rowResizeHandler(sheet, start, end) {
    var height = []._;

    start.row > end.row && (start.row = [end.row, end.row = start.row][0]);

    for (var i = start.row; i <= end.row; ++i) {
        if (!height) {
            height = sheet.handsontable.getRowHeight(i);
        } else if (height !== sheet.handsontable.getRowHeight(i)) {
            height = false;
            break;
        }
    }

    var val = height === false ? '' : height || 24;

    if (_UIProvider.prompt) {
        _UIProvider.prompt(_i18n.MENU.S13, val, function (result) {
            if (result) {
                setRowHeights(sheet, start.row, end.row, result);
            }
        });
    } else {
        var contextMenu = sheet.handsontable.getPlugin('contextMenu');
        contextMenu.close();
        var result = prompt(_i18n.MENU.S13, val);
        if (result !== null) {
            setRowHeights(sheet, start.row, end.row, result);
        }
    }
}

var colResize = exports.colResize = {
    name: _i18n.MENU.S2,
    hidden: function hidden() {
        return !this.getSelectedRange() || !this.selection.selectedHeader.cols;
    }
};

function colResizeHandler(sheet, start, end) {
    var width = []._;

    start.col > end.col && (start.col = [end.col, end.col = start.col][0]);

    for (var i = start.col; i <= end.col; ++i) {
        if (!width) {
            width = sheet.handsontable.getColWidth(i);
        } else if (width !== sheet.handsontable.getColWidth(i)) {
            width = false;
            break;
        }
    }

    var val = width === false ? '' : width || 50;

    if (_UIProvider.prompt) {
        _UIProvider.prompt(_i18n.MENU.S14, val, function (result) {
            if (result) {
                setColWidths(sheet, start.col, end.col, result);
            }
        });
    } else {
        var contextMenu = sheet.handsontable.getPlugin('contextMenu');
        contextMenu.close();
        var result = prompt(_i18n.MENU.S14, val);
        if (result !== null) {
            setColWidths(sheet, start.col, end.col, result);
        }
    }
}

function setRowHeights(sheet, start, end, value) {
    value = numbro().unformat(value) || 24;
    var rowHeights = sheet.handsontable.getSettings().rowHeights || [];
    for (var i = start; i <= end; ++i) {
        rowHeights[i] = value;
    }
    sheet.handsontable.updateSettings({ rowHeights: rowHeights });
}

function setColWidths(sheet, start, end, value) {
    value = numbro().unformat(value) || 50;
    var colWidths = sheet.handsontable.getSettings().colWidths || [];
    for (var i = start; i <= end; ++i) {
        colWidths[i] = value;
    }
    sheet.handsontable.updateSettings({ colWidths: colWidths });
}

},{"../../i18n":21}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _domHelper = require('../../utils/domHelper.js');

var _common = require('../../utils/common.js');

var _dataStructure = require('../../utils/dataStructure.js');

var _eventHelper = require('../../utils/eventHelper.js');

var _settings = require('../../settings.js');

var _i18n = require('../../i18n');

var _SheetError = require('.././SheetError');

var CLASS_CURRENT = 'current';
var CLASS_TABS = 'ssd-tabs';
var CLASS_CONTENT = 'ssd-tabs-content';
var CLASS_SECTION = 'ssd-tabs-section';
var CLASS_NAV = 'ssd-tabs-nav';
var CLASS_UL = 'ssd-tabs-ul';
var CLASS_LI = 'ssd-tabs-li';
var CLASS_FX = 'ssd-tabs-fx';

var animated = _settings.globalSettings.sheet.animated;
var regExp = _settings.globalSettings.sheet.sheetName;

/**
 * workbook  DOM 
 * @private
 * @param {Workbook} workbook
 * @constructor
 */
function Tabs(workbook) {
    this.workbook = workbook;
    /**
     * @type {CaseInsensitiveMap}
     */
    this.liItems = new _dataStructure.CaseInsensitiveMap();
    this.sectionItems = new _dataStructure.CaseInsensitiveMap();
    this._hotTables = new Map();
    this.rootElement = workbook.spreadSheet.getRootElement();
    this.displayMode = workbook.spreadSheet.getDisplayMode();

    this.initDOM();
    this.initBox();
    this.render();
}

Tabs.prototype.render = function () {
    this.rootElement.appendChild(this.TABS);
};

/**
 * @private
 */
Tabs.prototype.initDOM = function () {
    this.TABS = document.createElement('div');
    this.CONTENT = document.createElement('div');
    this.NAV = document.createElement('nav');
    this.UL = document.createElement('ul');

    this.TABS.classList.add(CLASS_TABS);
    this.TABS.id = this.workbook.getId();
    this.CONTENT.classList.add(CLASS_CONTENT);
    this.NAV.classList.add(CLASS_NAV);
    this.UL.classList.add(CLASS_UL);

    this.TABS.appendChild(this.CONTENT);
    this.TABS.appendChild(this.NAV);
    this.NAV.appendChild(this.UL);

    //  sheet  button
    this.appendAddButton();
};

/**
 * @private
 */
Tabs.prototype.initBox = function () {
    var rootEl = this.workbook.spreadSheet.getRootElement();
    this.width = this.workbook.width || (0, _domHelper.outerWidth)(rootEl, false);
    this.height = this.workbook.height || (0, _domHelper.outerHeight)(rootEl, false);

    this.TABS.style.width = this.width + 'px';
    this.TABS.style.height = this.height + 'px';
};

/**
 *  tab 
 * @param {string} sheetName - sheet   tab 
 */
Tabs.prototype.appendTab = function (sheetName) {
    var that = this;
    var li = document.createElement('li');
    var clazz = this.displayMode ? '' : 'close hairline';

    li.innerHTML = '\n        <a href="javascript:;">\n            <span>' + sheetName + '</span>\n            <span class="' + clazz + '"></span>\n        </a>\n    ';
    li.classList.add(CLASS_LI);
    li.setAttribute('data-sheet', sheetName);

    var activeTab = this.TABS.querySelector('.' + CLASS_CURRENT + '.' + CLASS_LI);
    if (activeTab) {
        (0, _domHelper.insertAfter)(activeTab, li);
    } else {
        this.UL.appendChild(li);
    }
    this.liItems.set(sheetName, li);

    li.addEventListener('click', function (e) {
        var sheetName = this.dataset.sheet;
        var sheet = that.workbook.getSheet(sheetName);
        sheet.active();
        (0, _eventHelper.stopImmediatePropagation)(e);
    });

    if (!this.displayMode) {
        li.addEventListener('dblclick', function (e) {
            that._onTabDblclick.call(that, this);
            (0, _eventHelper.stopImmediatePropagation)(e);
        });

        li.querySelector('.close').addEventListener('click', function (e) {
            var sheetName = li.dataset.sheet;
            try {
                that.workbook.closeSheet(sheetName);
            } catch (e) {
                if (e instanceof _SheetError.SheetError) {
                    alert(e.message);
                } else {
                    throw e;
                }
            }
            (0, _eventHelper.stopImmediatePropagation)(e);
        });
    }

    this.appendContent(sheetName);
};

/**
 *  tab 
 * @param {string} sheetName - sheet   tab 
 */
Tabs.prototype.removeTab = function (sheetName) {
    var li = this.liItems.get(sheetName);
    this.UL.removeChild(li);
    this.liItems.delete(sheetName);

    this.removeContent(sheetName);
};

Tabs.prototype.appendAddButton = function () {
    var that = this;
    var li = document.createElement('li');
    var innerHtml = this.displayMode ? '&nbsp;' : '+';

    li.innerHTML = '<a href="javascript:;"><span>' + innerHtml + '</span></a>';
    li.classList.add(CLASS_LI);
    if (!this.displayMode) {
        li.classList.add('add-tab');
    }
    this.UL.appendChild(li);

    if (!this.displayMode) {
        li.addEventListener('click', function () {
            try {
                var newSheet = that.workbook.createSheet();
                newSheet.active();
            } catch (e) {
                if (e instanceof _SheetError.SheetError) {
                    alert(e.message);
                } else {
                    throw e;
                }
            }
        });
    }
};

/**
 * @param {HTMLElement} li
 * @private
 */
Tabs.prototype._onTabDblclick = function (li) {
    var that = this;
    var sheetName = li.dataset.sheet;
    var span = li.getElementsByTagName('span')[0];
    var input = document.createElement('input');

    input.setAttribute('type', 'text');
    input.value = sheetName;
    input.classList.add('editorial');
    input.style.width = (0, _domHelper.outerWidth)(span) + 20 + 'px'; // 20px

    input.addEventListener('blur', function () {
        var check = that._checkTabName(sheetName, this.value);
        if (check === true) {
            that.workbook.renameSheet(sheetName, this.value);
        } else {
            alert(check); // TODO alert 
            that.tabRenameCancel(sheetName, this.value);
        }
    });
    input.addEventListener('keypress', function (event) {
        if (event.keyCode === 13) {
            this.blur();
        }
    });

    (0, _domHelper.empty)(span);
    span.appendChild(input);
    input.select();
};

Tabs.prototype._checkTabName = function (name1, name2) {
    if ((0, _common.isEmptyValue)(name2)) {
        return _i18n.WARNS.S1;
    }
    if (regExp.test(name2)) {
        return _i18n.WARNS.S2;
    }
    // sheet
    if ((0, _common.upperCase)(name1) !== (0, _common.upperCase)(name2) && this.workbook.isSheetExist(name2)) {
        return _i18n.WARNS.S3;
    }
    return true;
};

// DOM
Tabs.prototype.tabRename = function (name1, name2) {
    var li = this.liItems.get(name1);
    var span = li.getElementsByTagName('span')[0];
    (0, _domHelper.innerHTML)(span, name2);
    li.dataset.sheet = name2;
    this.liItems.set(name2, li);
    var section = this.sectionItems.get(name1);
    section.dataset.sheet = name2;
    this.sectionItems.delete(name1);
    this.sectionItems.set(name2, section);

    var sheetNow = this.workbook.getSheet(name2);
    sheetNow.emit('afterRename', sheetNow, name1, name2);
};

//  name1, name2
Tabs.prototype.tabRenameCancel = function (name1, name2) {
    var li = this.liItems.get(name1);
    var span = li.getElementsByTagName('span')[0];
    (0, _domHelper.innerHTML)(span, name1);

    var sheetNow = this.workbook.getSheet(name1);
    sheetNow.emit('afterRenameCancel', sheetNow, name1, name2);
};

/**
 * 
 * @param {string} sheetName
 */
Tabs.prototype.appendContent = function (sheetName) {
    var section = document.createElement('section');
    var fx = document.createElement('div');
    var hot = document.createElement('div');

    section.setAttribute('data-sheet', sheetName);
    section.appendChild(fx);
    section.appendChild(hot);
    section.classList.add(CLASS_SECTION);
    animated && section.classList.add('ssd-animated-fast');

    this.CONTENT.appendChild(section);
    this.sectionItems.set(sheetName, section);

    this.appendFx(fx, sheetName);
    this.appendTable(hot, sheetName);
};

Tabs.prototype.removeContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    this.CONTENT.removeChild(section);
    this.sectionItems.delete(sheetName);
};

/**
 *
 * @param {string} sheetName
 */
Tabs.prototype.hideContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    section.style.display = 'none';
};

/**
 * TODO 
 * @private
 * @param {HTMLElement} fx
 * @param {string} sheetName
 */
Tabs.prototype.appendFx = function (fx, sheetName) {
    fx.classList.add(CLASS_FX);
    fx.classList.add(CLASS_FX + '-' + sheetName);
};

/**
 *  Hansontable 
 * handsontable DOMrootElement
 * 
 * 
 * @private
 * @param hot
 * @param sheetName
 */
Tabs.prototype.appendTable = function (hot, sheetName) {
    var _this = this;

    this._hotTables.set(sheetName, {
        container: hot,
        width: this.width,
        height: function height() {
            return _this.height - (0, _domHelper.outerHeight)(_this.NAV);
        }
    });
};

/**
 * 
 * @param {string} sheetName - sheet 
 */
Tabs.prototype.activeTab = function (sheetName) {
    var former = this.TABS.querySelector('.' + CLASS_CURRENT + '.' + CLASS_LI);
    former && former.classList.remove(CLASS_CURRENT);
    var li = this.liItems.get(sheetName);
    li.classList.add(CLASS_CURRENT);
    this.activeContent(sheetName);
};

/**
 * @private
 * @param {string} sheetName - sheet 
 */
Tabs.prototype.activeContent = function (sheetName) {
    var section = this.sectionItems.get(sheetName);
    var former = this._formerActiveContent;
    if (former) {
        animated && former.classList.remove('fadeIn');
        former.style.display = 'none';
    }
    section.style.display = 'block';
    animated && section.classList.add('fadeIn');

    this._formerActiveContent = section;
};

exports.default = Tabs;

},{"../../i18n":21,"../../settings.js":57,"../../utils/common.js":59,"../../utils/dataStructure.js":60,"../../utils/domHelper.js":61,"../../utils/eventHelper.js":62,".././SheetError":12}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var WARNS = exports.WARNS = {
    S1: '',
    S2: '\u5DE5\u4F5C\u8868\u540D\u79F0\u5305\u542B\u65E0\u6548\u5B57\u7B26: :  / ? * [ ]\u3002',
    S3: ''
};

var MENU = exports.MENU = {
    S1: '...',
    S2: '...',
    S3: '',
    S4: '',
    S5: '',
    S6: '',
    S7: '',
    S8: '',
    S9: '',
    S10: '',
    S11: '',
    S12: '',
    S13: '',
    S14: ''
};

},{}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Plugin = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.validatePlugin = validatePlugin;
exports.registerPlugin = registerPlugin;
exports.getPlugin = getPlugin;
exports.getAllPlugins = getAllPlugins;

var _PluginError = require('./PluginError');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _plugins = new Map();

/**
 * 
 */

var Plugin = function () {

    /**
     *
     * @param {SpreadSheet} spreadSheet
     */
    function Plugin(spreadSheet) {
        _classCallCheck(this, Plugin);

        /**
         * @type {SpreadSheet}
         */
        this.spreadsheet = spreadSheet;
        this.enabled = false;
    }

    //  SpreadSheet  API


    _createClass(Plugin, [{
        key: '_registerMethod',
        value: function _registerMethod(name) {
            var _this = this;

            var proto = this.spreadsheet.constructor.prototype;
            proto[name] = function () {
                return _this[name]();
            };
        }
    }, {
        key: 'isEnable',
        value: function isEnable() {
            return false;
        }
    }, {
        key: 'enable',
        value: function enable() {}
    }, {
        key: 'destroy',
        value: function destroy() {}
    }]);

    return Plugin;
}();

exports.Plugin = Plugin;
function validatePlugin(p) {
    if (!p.enable) {
        throw new _PluginError.PluginError('enable');
    }
    if (!p.destroy) {
        throw new _PluginError.PluginError('destroy');
    }
}

function registerPlugin(name, plugin) {
    _plugins.set(name, plugin);
    plugin.prototype.__name__ = name;
}

function getPlugin(name) {
    var p = _plugins.get(name);
    if (!p) {
        throw new _PluginError.PluginError('' + name);
    }
    return p;
}

/**
 * 
 * @returns {Map}
 */
function getAllPlugins() {
    return _plugins;
}

},{"./PluginError":23}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PluginError = PluginError;

var _SpreadSheetError = require('../SpreadSheetError');

function PluginError(value) {
    this.name = 'PluginError';
    this.message = value;
}
PluginError.prototype = new _SpreadSheetError.SpreadSheetError();
PluginError.prototype.constructor = PluginError;

},{"../SpreadSheetError":5}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Plugin2 = require('../Plugin');

var _Storage = require('./Storage');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Persistent = function (_Plugin) {
    _inherits(Persistent, _Plugin);

    function Persistent(ssd) {
        _classCallCheck(this, Persistent);

        var _this = _possibleConstructorReturn(this, (Persistent.__proto__ || Object.getPrototypeOf(Persistent)).call(this, ssd));

        var settings = _this.spreadsheet.settings;

        if (settings.persistent === true) {
            // persistent  `true` 
            /**
             *  key
             */
            _this.persistentKey = ssd.getId();
        } else {
            // TODO persistent  localStoragesession 
            _this.persistentKey = settings.persistent.key;
        }

        _this.spreadsheet.settings = _Storage.Storage.load(_this.persistentKey) || settings;

        _this._registerMethod('saveState');
        return _this;
    }

    _createClass(Persistent, [{
        key: 'isEnable',
        value: function isEnable() {
            return !!this.spreadsheet.getSettings().persistent;
        }
    }, {
        key: 'enable',
        value: function enable() {
            _get(Persistent.prototype.__proto__ || Object.getPrototypeOf(Persistent.prototype), 'enable', this).call(this);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            _get(Persistent.prototype.__proto__ || Object.getPrototypeOf(Persistent.prototype), 'destroy', this).call(this);
        }
    }, {
        key: 'saveState',
        value: function saveState() {
            var data = this.spreadsheet.getExchangeData();
            _Storage.Storage.save(this.persistentKey, data);
        }
    }]);

    return Persistent;
}(_Plugin2.Plugin);

exports.default = Persistent;

},{"../Plugin":22,"./Storage":25}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 
 */
var Storage = function () {
    function Storage() {
        _classCallCheck(this, Storage);
    }

    _createClass(Storage, null, [{
        key: 'save',
        value: function save(key, value) {
            if (typeof value !== 'string') {
                value = JSON.stringify(value);
            }
            window.localStorage.setItem(Storage.PREFIX + key, value);
        }
    }, {
        key: 'load',
        value: function load(key) {
            var val = window.localStorage.getItem(Storage.PREFIX + key);
            try {
                return JSON.parse(val);
            } catch (e) {
                return val;
            }
        }
    }, {
        key: 'remove',
        value: function remove(key) {
            if (window.localStorage[Storage.PREFIX + key]) {
                window.localStorage.removeItem(Storage.PREFIX + key);
            }
        }
    }, {
        key: 'clear',
        value: function clear() {
            window.localStorage.clear();
        }
    }]);

    return Storage;
}();

Storage.PREFIX = '$$brick!storage-';

exports.Storage = Storage;

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlterManager = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _utils = require('./utils');

var _expressionModifier = require('./expressionModifier');

var _localHooks = require('../../utils/localHooks');

var _localHooks2 = _interopRequireDefault(_localHooks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var mixin = Handsontable.helper.mixin;

var AlterManager = function () {
    function AlterManager(sheet) {
        _classCallCheck(this, AlterManager);

        this.sheet = sheet;

        this.dataProvider = sheet.dataProvider;

        this.matrix = sheet.matrix;
    }

    _createClass(AlterManager, [{
        key: 'insertRow',
        value: function insertRow(row, amount, modifyFormula) {
            this._alter('insert', 'row', row, amount, modifyFormula);
        }
    }, {
        key: 'removeRow',
        value: function removeRow(row, amount, modifyFormula) {
            this._alter('remove', 'row', row, -amount, modifyFormula);
        }
    }, {
        key: 'insertColumn',
        value: function insertColumn(column, amount, modifyFormula) {
            this._alter('insert', 'column', column, amount, modifyFormula);
        }
    }, {
        key: 'removeColumn',
        value: function removeColumn(column, amount, modifyFormula) {
            this._alter('remove', 'column', column, -amount, modifyFormula);
        }
    }, {
        key: '_alter',
        value: function _alter(action, axis, start, amount) {
            var _this = this;

            var modifyFormula = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

            var startCoord = function startCoord(cell) {
                return {
                    row: axis === 'row' ? start : cell.row,
                    column: axis === 'column' ? start : cell.column
                };
            };
            var translateCellRefs = function translateCellRefs(row, column) {
                arrayEach(_this.matrix.cellReferences, function (cell) {
                    if (cell[axis] >= start) {
                        cell.translateTo(row, column);
                    }
                });
            };

            var translate = [];
            var indexOffset = Math.abs(amount) - 1;

            if (axis === 'row') {
                translate.push(amount, 0);
            } else if (axis === 'column') {
                translate.push(0, amount);
            }

            if (action === 'remove') {
                (function () {
                    var removedCellRef = _this.matrix.removeCellRefsAtRange(_defineProperty({}, axis, start), _defineProperty({}, axis, start + indexOffset));
                    var toRemove = [];

                    arrayEach(_this.matrix.data, function (cell) {
                        arrayEach(removedCellRef, function (cellRef) {
                            if (!cell.hasPrecedent(cellRef)) {
                                return;
                            }

                            cell.removePrecedent(cellRef);
                            cell.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);

                            arrayEach(_this.sheet.getCellDependencies(cell.row, cell.column), function (cellValue) {
                                cellValue.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                            });
                        });

                        if (cell[axis] >= start && cell[axis] <= start + indexOffset) {
                            toRemove.push(cell);
                        }
                    });

                    _this.matrix.remove(toRemove);
                })();
            }

            translateCellRefs.apply(undefined, translate);

            arrayEach(this.matrix.data, function (cell) {
                var origRow = cell.row;
                var origColumn = cell.column;

                if (cell[axis] >= start) {
                    cell.translateTo.apply(cell, translate);
                    cell.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                }

                if (modifyFormula) {
                    var row = cell.row;
                    var column = cell.column;
                    var value = _this.dataProvider.getSourceDataAtCell(row, column);

                    if ((0, _utils.isFormulaExpression)(value)) {
                        var expModifier = new _expressionModifier.ExpressionModifier(value);

                        expModifier.translate(startCoord({ row: origRow, column: origColumn }), _defineProperty({}, axis, amount));

                        _this.dataProvider.updateSourceData(row, column, expModifier.toString());
                    }
                }
            });
            this.runLocalHooks('afterAlter', action, axis, start, amount);
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.sheet = null;
            this.dataProvider = null;
            this.matrix = null;
        }
    }]);

    return AlterManager;
}();

mixin(AlterManager, _localHooks2.default);

exports.AlterManager = AlterManager;

},{"../../utils/localHooks":63,"./CellValue":29,"./expressionModifier":35,"./utils":55}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./parser/utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var isObject = Handsontable.helper.isObject;

var BaseCell = function () {
    function BaseCell(row, column) {
        _classCallCheck(this, BaseCell);

        var rowObject = isObject(row);
        var columnObject = isObject(column);

        this._row = rowObject ? row.index : row;
        this.rowAbsolute = rowObject ? row.isAbsolute : false;
        this._column = columnObject ? column.index : column;
        this.columnAbsolute = columnObject ? column.isAbsolute : false;
        this.rowOffset = 0;
        this.columnOffset = 0;

        Object.defineProperty(this, 'row', {
            get: function get() {
                return this.rowOffset + this._row;
            },
            set: function set(row) {
                this._row = row;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(this, 'column', {
            get: function get() {
                return this.columnOffset + this._column;
            },
            set: function set(column) {
                this._column = column;
            },
            enumerable: true,
            configurable: true
        });
    }

    _createClass(BaseCell, [{
        key: 'translateTo',
        value: function translateTo(rowOffset, columnOffset) {
            this.row = this.row + rowOffset;
            this.column = this.column + columnOffset;
        }
    }, {
        key: 'isEqual',
        value: function isEqual(cell) {
            return cell.row === this.row && cell.column === this.column;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return (0, _utils.toLabel)({ index: this.row, isAbsolute: this.rowAbsolute }, { index: this.column, isAbsolute: this.columnAbsolute });
        }
    }]);

    return BaseCell;
}();

exports.default = BaseCell;

},{"./parser/utils":54}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CellReference = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseCell2 = require('./BaseCell');

var _BaseCell3 = _interopRequireDefault(_BaseCell2);

var _utils = require('./parser/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CellReference = function (_BaseCell) {
    _inherits(CellReference, _BaseCell);

    function CellReference(row, column) {
        _classCallCheck(this, CellReference);

        return _possibleConstructorReturn(this, (CellReference.__proto__ || Object.getPrototypeOf(CellReference)).call(this, row, column));
    }

    _createClass(CellReference, [{
        key: 'toString',
        value: function toString() {
            return (0, _utils.toLabel)({ index: this.row, isAbsolute: false }, { index: this.column, isAbsolute: false });
        }
    }]);

    return CellReference;
}(_BaseCell3.default);

exports.CellReference = CellReference;

},{"./BaseCell":27,"./parser/utils":54}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CellValue = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BaseCell2 = require('./BaseCell');

var _BaseCell3 = _interopRequireDefault(_BaseCell2);

var _error = require('./parser/error');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var STATE_OUT_OFF_DATE = 1;
var STATE_COMPUTING = 2;
var STATE_UP_TO_DATE = 3;
var states = [STATE_OUT_OFF_DATE, STATE_COMPUTING, STATE_UP_TO_DATE];

var arrayFilter = Handsontable.helper.arrayFilter;

var CellValue = function (_BaseCell) {
    _inherits(CellValue, _BaseCell);

    _createClass(CellValue, null, [{
        key: 'STATE_OUT_OFF_DATE',
        get: function get() {
            return 1;
        }
    }, {
        key: 'STATE_COMPUTING',
        get: function get() {
            return 2;
        }
    }, {
        key: 'STATE_UP_TO_DATE',
        get: function get() {
            return 3;
        }
    }]);

    function CellValue(row, column) {
        _classCallCheck(this, CellValue);

        var _this = _possibleConstructorReturn(this, (CellValue.__proto__ || Object.getPrototypeOf(CellValue)).call(this, row, column));

        _this.precedents = [];
        _this.value = null;
        _this.error = null;
        _this.state = CellValue.STATE_UP_TO_DATE;
        return _this;
    }

    _createClass(CellValue, [{
        key: 'setValue',
        value: function setValue(value) {
            this.value = value;
        }
    }, {
        key: 'getValue',
        value: function getValue() {
            return this.value;
        }
    }, {
        key: 'setError',
        value: function setError(error) {
            this.error = error;
        }
    }, {
        key: 'getError',
        value: function getError() {
            return this.error;
        }
    }, {
        key: 'hasError',
        value: function hasError() {
            return this.error !== null;
        }
    }, {
        key: 'setState',
        value: function setState(state) {
            if (states.indexOf(state) === -1) {
                throw '\u672A\u77E5\u72B6\u6001: ' + state;
            }
            this.state = state;
        }
    }, {
        key: 'isState',
        value: function isState(state) {
            return this.state === state;
        }
    }, {
        key: 'addPrecedent',
        value: function addPrecedent(cellReference) {
            if (this.isEqual(cellReference)) {
                throw Error(_error.ERROR_REF);
            }
            if (!this.hasPrecedent(cellReference)) {
                this.precedents.push(cellReference);
            }
        }
    }, {
        key: 'removePrecedent',
        value: function removePrecedent(cellReference) {
            if (this.isEqual(cellReference)) {
                throw Error(_error.ERROR_REF);
            }
            this.precedents = arrayFilter(this.precedents, function (cell) {
                return !cell.isEqual(cellReference);
            });
        }
    }, {
        key: 'getPrecedents',
        value: function getPrecedents() {
            return this.precedents;
        }
    }, {
        key: 'hasPrecedents',
        value: function hasPrecedents() {
            return this.precedents.length > 0;
        }
    }, {
        key: 'hasPrecedent',
        value: function hasPrecedent(cellReference) {
            return arrayFilter(this.precedents, function (cell) {
                return cell.isEqual(cellReference);
            }).length ? true : false;
        }
    }]);

    return CellValue;
}(_BaseCell3.default);

exports.CellValue = CellValue;

},{"./BaseCell":27,"./parser/error":36}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataProvider = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var rangeEach = Handsontable.helper.rangeEach;

var DataProvider = function () {
    function DataProvider(hot) {
        _classCallCheck(this, DataProvider);

        this.hot = hot;
        this.changes = {};
    }

    _createClass(DataProvider, [{
        key: 'collectChanges',
        value: function collectChanges(row, column, value) {
            if (!(0, _utils.isFormulaExpression)(value)) {
                this.changes[DataProvider._coordId(row, column)] = value;
            }
        }
    }, {
        key: 'clearChanges',
        value: function clearChanges() {
            this.changes = {};
        }
    }, {
        key: 'isInDataRange',
        value: function isInDataRange(row, column) {
            return row >= 0 && row < this.hot.countRows() && column >= 0 && column < this.hot.countCols();
        }
    }, {
        key: 'getDataAtCell',
        value: function getDataAtCell(row, column) {
            var id = DataProvider._coordId(row, column);
            var result = void 0;

            if (this.changes.hasOwnProperty(id)) {
                result = this.changes[id];
            } else {
                result = this.hot.getDataAtCell(row, column);
            }
            return result;
        }
    }, {
        key: 'getDataAtCellInSheet',
        value: function getDataAtCellInSheet(sheetName, row, column) {
            var sheet = this.workbook.getSheet(sheetName);
            var formulas = sheet.handsontable.getPlugin('XFormulas');
            return formulas.sheet.dataProvider.getDataAtCell(row, column);
        }
    }, {
        key: 'getDataByRange',
        value: function getDataByRange(row1, column1, row2, column2) {
            var _this = this;

            var result = this.hot.getData(row1, column1, row2, column2);

            arrayEach(result, function (rowData, rowIndex) {
                arrayEach(rowData, function (value, columnIndex) {
                    var id = DataProvider._coordId(rowIndex + row1, columnIndex + column1);

                    if (_this.changes.hasOwnProperty(id)) {
                        result[rowIndex][columnIndex] = _this.changes[id];
                    }
                });
            });

            return result;
        }
    }, {
        key: 'getSourceDataAtCell',
        value: function getSourceDataAtCell(row, column) {
            return this.hot.getSourceDataAtCell(row, column);
        }
    }, {
        key: 'getSourceDataByRange',
        value: function getSourceDataByRange(row1, column1, row2, column2) {
            return this.hot.getSourceDataArray(row1, column1, row2, column2);
        }
    }, {
        key: 'updateSourceData',
        value: function updateSourceData(row, column, value) {
            this.hot.getSourceData()[row][this.hot.colToProp(column)] = value;
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.hot = null;
            this.changes = null;
        }
    }], [{
        key: '_coordId',
        value: function _coordId(row, column) {
            return row + ':' + column;
        }
    }]);

    return DataProvider;
}();

exports.DataProvider = DataProvider;

},{"./utils":55}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Matrix = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require("./CellValue");

var _error = require("./parser/error");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var arrayFilter = Handsontable.helper.arrayFilter;
var arrayReduce = Handsontable.helper.arrayReduce;

var Matrix = function () {
    function Matrix() {
        _classCallCheck(this, Matrix);

        this.data = [];
        this.cellReferences = [];
    }

    _createClass(Matrix, [{
        key: "getCellAt",
        value: function getCellAt(row, column) {
            var result = null;

            arrayEach(this.data, function (cell) {
                if (cell.row === row && cell.column === column) {
                    result = cell;

                    return false;
                }
            });

            return result;
        }
    }, {
        key: "getOutOfDateCells",
        value: function getOutOfDateCells() {
            return arrayFilter(this.data, function (cell) {
                return cell.isState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
            });
        }
    }, {
        key: "add",
        value: function add(cellValue) {
            if (!arrayFilter(this.data, function (cell) {
                return cell.isEqual(cellValue);
            }).length) {
                this.data.push(cellValue);
            }
        }
    }, {
        key: "remove",
        value: function remove(cellValue) {
            var isArray = Array.isArray(cellValue);
            var isEqual = function isEqual(cell, cellValue) {
                var result = false;

                if (isArray) {
                    arrayEach(cellValue, function (value) {
                        if (cell.isEqual(value)) {
                            result = true;

                            return false;
                        }
                    });
                } else {
                    result = cell.isEqual(cellValue);
                }

                return result;
            };
            this.data = arrayFilter(this.data, function (cell) {
                return !isEqual(cell, cellValue);
            });
        }
    }, {
        key: "getDependencies",
        value: function getDependencies(cellValue) {
            var _this = this;

            var getDependencies = function getDependencies(cell) {
                return arrayReduce(_this.data, function (acc, cellValue) {
                    if (cellValue.hasPrecedent(cell) && acc.indexOf(cellValue) === -1) {
                        acc.push(cellValue);
                    }
                    return acc;
                }, []);
            };

            var getTotalDependencies = function getTotalDependencies(cell) {
                var deps = getDependencies(cell);

                if (deps.length) {
                    arrayEach(deps, function (cellValue) {
                        if (cellValue.hasPrecedents()) {
                            deps = deps.concat(getTotalDependencies(cellValue));
                        }
                    });
                }
                return deps;
            };

            try {
                return getTotalDependencies(cellValue);
            } catch (e) {
                // TODO 
                // https://github.com/handsontable/handsontable/issues/4357
                var errorValue = new _CellValue.CellValue(cellValue.row, cellValue.column);
                errorValue.setError(_error.ERROR_REF);
                errorValue.setState(_CellValue.CellValue.STATE_UP_TO_DATE);
                return [errorValue];
            }
        }
    }, {
        key: "registerCellRef",
        value: function registerCellRef(cellReference) {
            if (!arrayFilter(this.cellReferences, function (cell) {
                return cell.isEqual(cellReference);
            }).length) {
                this.cellReferences.push(cellReference);
            }
        }
    }, {
        key: "removeCellRefsAtRange",
        value: function removeCellRefsAtRange(_ref, _ref2) {
            var startRow = _ref.row,
                startColumn = _ref.column;
            var endRow = _ref2.row,
                endColumn = _ref2.column;

            var removed = [];

            var rowMatch = function rowMatch(cell) {
                return startRow === void 0 ? true : cell.row >= startRow && cell.row <= endRow;
            };
            var colMatch = function colMatch(cell) {
                return startColumn === void 0 ? true : cell.column >= startColumn && cell.column <= endColumn;
            };

            this.cellReferences = arrayFilter(this.cellReferences, function (cell) {
                if (rowMatch(cell) && colMatch(cell)) {
                    removed.push(cell);

                    return false;
                }

                return true;
            });

            return removed;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.data.length = 0;
            this.cellReferences.length = 0;
        }
    }]);

    return Matrix;
}();

exports.Matrix = Matrix;

},{"./CellValue":29,"./parser/error":36}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Sheet = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _CellReference = require('./CellReference');

var _utils = require('./utils');

var _Matrix = require('./Matrix');

var _AlterManager = require('./AlterManager');

var _parser = require('./parser/parser');

var _error = require('./parser/error');

var _localHooks = require('../../utils/localHooks');

var _localHooks2 = _interopRequireDefault(_localHooks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var STATE_UP_TO_DATE = 1;
var STATE_NEED_REBUILD = 2;
var STATE_NEED_FULL_REBUILD = 3;

var arrayEach = Handsontable.helper.arrayEach;
var arrayMap = Handsontable.helper.arrayMap;
var rangeEach = Handsontable.helper.rangeEach;
var objectEach = Handsontable.helper.objectEach;
var mixin = Handsontable.helper.mixin;

var Sheet = function () {
    function Sheet(dataProvider) {
        var _this = this;

        _classCallCheck(this, Sheet);

        this.dataProvider = dataProvider;
        this.parser = new _parser.Parser();
        this.matrix = new _Matrix.Matrix();
        this.alterManager = new _AlterManager.AlterManager(this);

        this._processingCell = null;
        this._state = STATE_NEED_FULL_REBUILD;

        this.parser.on('callCellValue', function () {
            return _this._onCallCellValue.apply(_this, arguments);
        });
        this.parser.on('callRangeValue', function () {
            return _this._onCallRangeValue.apply(_this, arguments);
        });
        this.parser.on('callCellValueInSheet', function () {
            return _this._onCallCellValueInSheet.apply(_this, arguments);
        });
        this.parser.on('callRangeValueInSheet', function () {
            return _this._onCallRangeValueInSheet.apply(_this, arguments);
        });
        this.alterManager.addLocalHook('afterAlter', function () {
            return _this._onAfterAlter.apply(_this, arguments);
        });
    }

    _createClass(Sheet, [{
        key: 'recalculate',
        value: function recalculate() {
            switch (this._state) {
                case STATE_NEED_FULL_REBUILD:
                    this.recalculateFull();
                    break;
                case STATE_NEED_REBUILD:
                    this.recalculateOptimized();
                    break;
            }
        }
    }, {
        key: 'recalculateOptimized',
        value: function recalculateOptimized() {
            var _this2 = this;

            var cells = this.matrix.getOutOfDateCells();

            arrayEach(cells, function (cellValue) {
                var value = _this2.dataProvider.getSourceDataAtCell(cellValue.row, cellValue.column);

                if ((0, _utils.isFormulaExpression)(value)) {
                    _this2.parseExpression(cellValue, value.substr(1));
                }
            });

            this._state = STATE_UP_TO_DATE;
            this.runLocalHooks('afterRecalculate', cells, 'optimized');
        }
    }, {
        key: 'recalculateFull',
        value: function recalculateFull() {
            var _this3 = this;

            var cells = this.dataProvider.getSourceDataByRange();
            this.matrix.reset();

            arrayEach(cells, function (rowData, row) {
                arrayEach(rowData, function (value, column) {
                    if ((0, _utils.isFormulaExpression)(value)) {
                        _this3.parseExpression(new _CellValue.CellValue(row, column), value.substr(1));
                    }
                });
            });

            this._state = STATE_UP_TO_DATE;
            this.runLocalHooks('afterRecalculate', cells, 'full');
        }
    }, {
        key: 'setVariable',
        value: function setVariable(name, value) {
            this.parser.setVariable(name, value);
        }
    }, {
        key: 'getVariable',
        value: function getVariable(name) {
            return this.parser.getVariable(name);
        }
    }, {
        key: 'applyChanges',
        value: function applyChanges(row, column, newValue) {
            // TODO: Move this to recalculate()
            this.matrix.remove({ row: row, column: column });

            // TODO: Move this to recalculate()
            if ((0, _utils.isFormulaExpression)(newValue)) {
                this.parseExpression(new _CellValue.CellValue(row, column), newValue.substr(1));
            }

            var deps = this.getCellDependencies(row, column);

            arrayEach(deps, function (cellValue) {
                cellValue.setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
            });

            this._state = STATE_NEED_REBUILD;
        }
    }, {
        key: 'parseExpression',
        value: function parseExpression(cellValue, formula) {
            cellValue.setState(_CellValue.CellValue.STATE_COMPUTING);
            this._processingCell = cellValue;

            // TODO  wrapper formula
            // var sheetNames = this.dataProvider.workbook.getSheetNames();

            var _parser$parse = this.parser.parse((0, _utils.toUpperCaseFormula)(formula)),
                error = _parser$parse.error,
                result = _parser$parse.result;

            cellValue.setValue(result);
            cellValue.setError(error);
            cellValue.setState(_CellValue.CellValue.STATE_UP_TO_DATE);

            this.matrix.add(cellValue);
            this._processingCell = null;
        }
    }, {
        key: 'getCellAt',
        value: function getCellAt(row, column) {
            return this.matrix.getCellAt(row, column);
        }
    }, {
        key: 'getCellDependencies',
        value: function getCellDependencies(row, column) {
            return this.matrix.getDependencies({ row: row, column: column });
        }
    }, {
        key: '_onCallCellValue',
        value: function _onCallCellValue(_ref, done) {
            var row = _ref.row,
                column = _ref.column;

            var cell = new _CellReference.CellReference(row, column);

            if (!this.dataProvider.isInDataRange(cell.row, cell.column)) {
                throw Error(_error.ERROR_REF);
            }

            this.matrix.registerCellRef(cell);
            this._processingCell.addPrecedent(cell);

            done(this.dataProvider.getDataAtCell(cell.row, cell.column));
        }
    }, {
        key: '_onCallCellValueInSheet',
        value: function _onCallCellValueInSheet(_ref2, done) {
            var sheetName = _ref2.sheetName,
                row = _ref2.row,
                column = _ref2.column;

            var cell = new _CellReference.CellReference(row, column);

            // TODO 

            done(this.dataProvider.getDataAtCellInSheet(sheetName, cell.row, cell.column));
        }
    }, {
        key: '_onCallRangeValue',
        value: function _onCallRangeValue(_ref3, _ref4, done) {
            var startRow = _ref3.row,
                startColumn = _ref3.column;

            var _this4 = this;

            var endRow = _ref4.row,
                endColumn = _ref4.column;

            rangeEach(startRow.index, endRow.index, function (row) {
                rangeEach(startColumn.index, endColumn.index, function (column) {
                    var cell = new _CellReference.CellReference(row, column);

                    _this4.matrix.registerCellRef(cell);
                    _this4._processingCell.addPrecedent(cell);
                });
            });
            done(this.dataProvider.getDataByRange(startRow.index, startColumn.index, endRow.index, endColumn.index));
        }

        // TODO 

    }, {
        key: '_onCallRangeValueInSheet',
        value: function _onCallRangeValueInSheet(sheetName, _ref5, _ref6, done) {
            var startRow = _ref5.row,
                startColumn = _ref5.column;
            var endRow = _ref6.row,
                endColumn = _ref6.column;


            done('_onCallRangeValueInSheet');
        }
    }, {
        key: '_onAfterAlter',
        value: function _onAfterAlter() {
            this.recalculateOptimized();
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.dataProvider.destroy();
            this.dataProvider = null;
            this.alterManager.destroy();
            this.alterManager = null;
            this.parser = null;
            this.matrix.reset();
            this.matrix = null;
        }
    }]);

    return Sheet;
}();

mixin(Sheet, _localHooks2.default);

exports.Sheet = Sheet;

},{"../../utils/localHooks":63,"./AlterManager":26,"./CellReference":28,"./CellValue":29,"./Matrix":31,"./parser/error":36,"./parser/parser":52,"./utils":55}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UndoRedoSnapshot = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CellValue = require('./CellValue');

var _dataStructure = require('../../utils/dataStructure');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var rangeEach = Handsontable.helper.rangeEach;

var UndoRedoSnapshot = function () {
    function UndoRedoSnapshot(sheet) {
        _classCallCheck(this, UndoRedoSnapshot);

        this.sheet = sheet;
        this.stack = new _dataStructure.Stack();
    }

    _createClass(UndoRedoSnapshot, [{
        key: 'save',
        value: function save(axis, index, amount) {
            var _sheet = this.sheet,
                matrix = _sheet.matrix,
                dataProvider = _sheet.dataProvider;

            var changes = [];

            arrayEach(matrix.data, function (cellValue) {
                var row = cellValue.row,
                    column = cellValue.column;


                if (cellValue[axis] < index || cellValue[axis] > index + (amount - 1)) {
                    var value = dataProvider.getSourceDataAtCell(row, column);

                    changes.push({ row: row, column: column, value: value });
                }
            });

            this.stack.push({ axis: axis, index: index, amount: amount, changes: changes });
        }
    }, {
        key: 'restore',
        value: function restore() {
            var _sheet2 = this.sheet,
                matrix = _sheet2.matrix,
                dataProvider = _sheet2.dataProvider;

            var _stack$pop = this.stack.pop(),
                axis = _stack$pop.axis,
                index = _stack$pop.index,
                amount = _stack$pop.amount,
                changes = _stack$pop.changes;

            if (changes) {
                arrayEach(changes, function (change) {
                    if (change[axis] > index + (amount - 1)) {
                        change[axis] -= amount;
                    }
                    var row = change.row,
                        column = change.column,
                        value = change.value;

                    var rawValue = dataProvider.getSourceDataAtCell(row, column);

                    if (rawValue !== value) {
                        dataProvider.updateSourceData(row, column, value);
                        matrix.getCellAt(row, column).setState(_CellValue.CellValue.STATE_OUT_OFF_DATE);
                    }
                });
            }
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            this.sheet = null;
            this.stack = null;
        }
    }]);

    return UndoRedoSnapshot;
}();

exports.UndoRedoSnapshot = UndoRedoSnapshot;

},{"../../utils/dataStructure":60,"./CellValue":29}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XFormulas = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + worksheet2 `=worksheet1!A2+B2`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + 3 `=1!A1+2B1`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * + sheet5`=SUM(sheet3!B1:B5, sheet4!B6)`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * TODO 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *  hansontable 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *  Workbook  hansontable 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @plugin External plugin XFormulas.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @param hotInstance
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @constructor
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */

// TODO  A1=B1, B1=A1

var _utils = require('./utils');

var _Sheet = require('./Sheet');

var _DataProvider = require('./DataProvider');

var _UndoRedoSnapshot = require('./UndoRedoSnapshot');

var arrayEach = Handsontable.helper.arrayEach;
var isObject = Handsontable.helper.isObject;
var objectEach = Handsontable.helper.objectEach;

function XFormulas(hotInstance) {
    Handsontable.plugins.BasePlugin.call(this, hotInstance);
    this._superClass = Handsontable.plugins.BasePlugin;

    this.eventManager = new Handsontable.EventManager();
    this.dataProvider = new _DataProvider.DataProvider(this.hot);
    this.sheet = new _Sheet.Sheet(this.dataProvider);
    this.undoRedoSnapshot = new _UndoRedoSnapshot.UndoRedoSnapshot(this.sheet);

    this._skipRendering = false;
}

XFormulas.prototype = Object.create(Handsontable.plugins.BasePlugin.prototype, {
    constructor: {
        writable: true,
        configurable: true,
        value: XFormulas
    }
});

XFormulas.prototype.isEnabled = function () {
    return !!this.hot.getSettings().xFormulas;
};

/**
 * 
 * PS: enablePlugin  beforeInit hook 
 *      isEnabled  true 
 */
XFormulas.prototype.enablePlugin = function () {
    var _this = this;

    if (this.enabled) {
        return;
    }

    var settings = this.hot.getSettings();
    if (!settings._isHotTableAdaptor) {
        throw 'XFormulas ';
    }

    var formulasSettings = settings.formulas;
    if (isObject(formulasSettings)) {
        if (isObject(formulasSettings.variables)) {
            objectEach(formulasSettings.variables, function (value, name) {
                return _this.setVariable(name, value);
            });
        }
    }

    // TODO move to DataProvider
    var worksheet = this.dataProvider.worksheet = this.hot.getSettings()._sheet;
    this.dataProvider.workbook = worksheet.workbook;

    this.addHook('afterCreateCol', function () {
        return _this.onAfterCreateCol.apply(_this, arguments);
    });
    this.addHook('afterCreateRow', function () {
        return _this.onAfterCreateRow.apply(_this, arguments);
    });
    this.addHook('afterLoadData', function () {
        return _this.onAfterLoadData();
    });
    this.addHook('afterRemoveCol', function () {
        return _this.onAfterRemoveCol.apply(_this, arguments);
    });
    this.addHook('afterRemoveRow', function () {
        return _this.onAfterRemoveRow.apply(_this, arguments);
    });
    this.addHook('afterSetDataAtCell', function () {
        return _this.onAfterSetDataAtCell.apply(_this, arguments);
    });
    this.addHook('afterSetDataAtRowProp', function () {
        return _this.onAfterSetDataAtCell.apply(_this, arguments);
    });
    //this.addHook('beforeKeyDown', (...args) => this.onBeforeKeyDown(...args));
    this.addHook('beforeCreateCol', function () {
        return _this.onBeforeCreateCol.apply(_this, arguments);
    });
    this.addHook('beforeCreateRow', function () {
        return _this.onBeforeCreateRow.apply(_this, arguments);
    });
    this.addHook('beforeRemoveCol', function () {
        return _this.onBeforeRemoveCol.apply(_this, arguments);
    });
    this.addHook('beforeRemoveRow', function () {
        return _this.onBeforeRemoveRow.apply(_this, arguments);
    });
    this.addHook('beforeValidate', function () {
        return _this.onBeforeValidate.apply(_this, arguments);
    });
    this.addHook('beforeValueRender', function () {
        return _this.onBeforeValueRender.apply(_this, arguments);
    });
    this.addHook('modifyData', function () {
        return _this.onModifyData.apply(_this, arguments);
    });

    this.sheet.addLocalHook('afterRecalculate', function () {
        return _this.onSheetAfterRecalculate.apply(_this, arguments);
    });

    this._superClass.prototype.enablePlugin.call(this);
};

/**
 * 
 * PS: 
 */
XFormulas.prototype.disablePlugin = function () {
    this._superClass.prototype.disablePlugin.call(this);
};

/**
 *  Handsontable  settings  XFormulas 
 * PS:  afterUpdateSettings hook 
 */
XFormulas.prototype.updatePlugin = function () {
    this.disablePlugin();
    this.enablePlugin();
    this._superClass.prototype.updatePlugin.call(this);
};

/**
 * 
 */
XFormulas.prototype.destroy = function () {
    this.dataProvider.destroy();
    this.dataProvider = null;
    this.sheet.destroy();
    this.sheet = null;
    this._superClass.prototype.destroy.call(this);
};

// ---------------------------------------[start] Hooks

// TODO 
XFormulas.prototype.onSheetRename = function (sheet, name1, name2) {};

XFormulas.prototype.onSheetAfterRecalculate = function (cells) {
    if (this._skipRendering) {
        this._skipRendering = false;
        return;
    }
    var hot = this.hot;

    arrayEach(cells, function (_ref) {
        var row = _ref.row,
            column = _ref.column;

        hot.validateCell(hot.getDataAtCell(row, column), hot.getCellMeta(row, column), function () {});
    });
    hot.render();
};

/**
 * TODO
 * Caution -  event.stopImmediatePropagation() 
 * @param event
 */
XFormulas.prototype.onBeforeKeyDown = function (event) {};

XFormulas.prototype.onModifyData = function (row, column, valueHolder, ioMode) {
    if (ioMode === 'get' && this.hasComputedCellValue(row, column)) {
        valueHolder.value = this.getCellValue(row, column);
    } else if (ioMode === 'set' && (0, _utils.isFormulaExpression)(valueHolder.value)) {
        valueHolder.value = (0, _utils.toUpperCaseFormula)(valueHolder.value);
    }
};

XFormulas.prototype.onBeforeValueRender = function (value) {
    if ((0, _utils.isFormulaExpressionEscaped)(value)) {
        value = (0, _utils.unescapeFormulaExpression)(value);
    }
    return value;
};

XFormulas.prototype.onBeforeValidate = function (value, row, prop) {
    var column = this.hot.propToCol(prop);

    if (this.hasComputedCellValue(row, column)) {
        value = this.getCellValue(row, column);
    }

    return value;
};

XFormulas.prototype.onAfterSetDataAtCell = function (changes, source) {
    var _this2 = this;

    if (source === 'loadData') {
        return;
    }

    this.dataProvider.clearChanges();
    arrayEach(changes, function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 4),
            row = _ref3[0],
            column = _ref3[1],
            oldValue = _ref3[2],
            newValue = _ref3[3];

        column = _this2.hot.propToCol(column);
        if ((0, _utils.isFormulaExpression)(newValue)) {
            newValue = (0, _utils.toUpperCaseFormula)(newValue);
        }
        _this2.dataProvider.collectChanges(row, column, newValue);
        if (oldValue !== newValue) {
            _this2.sheet.applyChanges(row, column, newValue);
        }
    });
    this.recalculate();
};

XFormulas.prototype.onBeforeCreateRow = function (row, amount, source) {
    if (source === 'UndoRedo.undo') {
        this.undoRedoSnapshot.restore();
    }
};

XFormulas.prototype.onAfterCreateRow = function (row, amount, source) {
    this.sheet.alterManager.insertRow(row, amount, source !== 'UndoRedo.undo');
};

XFormulas.prototype.onBeforeRemoveRow = function (row, amount) {
    // TODO Storage.save('row', row, amount);
};

XFormulas.prototype.onAfterRemoveRow = function (row, amount) {
    this.sheet.alterManager.removeRow(row, amount);
};

XFormulas.prototype.onBeforeCreateCol = function (column, amount, source) {
    if (source === 'UndoRedo.undo') {
        this.undoRedoSnapshot.restore();
    }
};

XFormulas.prototype.onAfterCreateCol = function (column, amount, source) {
    this.sheet.alterManager.insertColumn(column, amount, source !== 'UndoRedo.undo');
};

XFormulas.prototype.onBeforeRemoveCol = function (column, amount) {
    // TODO Storage.save('column', column, amount);
};

XFormulas.prototype.onAfterRemoveCol = function (column, amount) {
    this.sheet.alterManager.removeColumn(column, amount);
};

XFormulas.prototype.onAfterLoadData = function () {
    this._skipRendering = true;
    this.recalculateFull();
};

// ---------------------------------------[end] Hooks

XFormulas.prototype.getCellValue = function (row, column) {
    var cell = this.sheet.getCellAt(row, column);
    return cell ? cell.getError() || cell.getValue() : void 0;
};

XFormulas.prototype.hasComputedCellValue = function (row, column) {
    return !!this.sheet.getCellAt(row, column);
};

XFormulas.prototype.recalculate = function () {
    this.sheet.recalculate();
};

XFormulas.prototype.recalculateFull = function () {
    this.sheet.recalculateFull();
};

XFormulas.prototype.recalculateOptimized = function () {
    this.sheet.recalculateOptimized();
};

XFormulas.prototype.setVariable = function (name, value) {
    this.sheet.setVariable(name, value);
};

XFormulas.prototype.getVariable = function (name) {
    return this.sheet.getVariable(name);
};

Handsontable.plugins.registerPlugin('xFormulas', XFormulas);

exports.XFormulas = XFormulas;

},{"./DataProvider":30,"./Sheet":32,"./UndoRedoSnapshot":33,"./utils":55}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpressionModifier = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

var _utils2 = require('./parser/utils');

var _error = require('./parser/error');

var _error2 = _interopRequireDefault(_error);

var _localHooks = require('../../utils/localHooks');

var _localHooks2 = _interopRequireDefault(_localHooks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var arrayEach = Handsontable.helper.arrayEach;
var arrayFilter = Handsontable.helper.arrayFilter;
var mixin = Handsontable.helper.mixin;

var BARE_CELL_STRICT_REGEX = /^\$?[A-Z]+\$?\d+$/;
var BARE_CELL_REGEX = /\$?[A-Z]+\$?\d+/;
var CELL_REGEX = /(?:[^0-9A-Z$: ]|^)\s*(\$?[A-Z]+\$?\d+)\s*(?![0-9A-Z_: ])/g;
var RANGE_REGEX = /\$?[A-Z]+\$?\d+\s*:\s*\$?[A-Z]+\$?\d+/g;
var CELL_AND_RANGE_REGEX = /((?:[^0-9A-Z$: ]|^)\s*(\$?[A-Z]+\$?\d+)\s*(?![0-9A-Z_: ]))|(\$?[A-Z]+\$?\d+\s*:\s*\$?[A-Z]+\$?\d+)/g;

var ExpressionModifier = function () {
    function ExpressionModifier(expression) {
        _classCallCheck(this, ExpressionModifier);

        /**
         * 
         * @type {String}
         */
        this.expression = '';

        this.cells = [];

        if (typeof expression === 'string') {
            this.setExpression(expression);
        }
    }

    _createClass(ExpressionModifier, [{
        key: 'setExpression',
        value: function setExpression(expression) {
            this.cells.length = 0;
            this.expression = (0, _utils.toUpperCaseFormula)(expression);

            this._extractCells();
            this._extractCellsRange();

            return this;
        }
    }, {
        key: 'translate',
        value: function translate(_ref, _ref2) {
            var baseRow = _ref.row,
                baseColumn = _ref.column;
            var deltaRow = _ref2.row,
                deltaColumn = _ref2.column;

            arrayEach(this.cells, function (cell) {
                if (deltaRow != null) {
                    ExpressionModifier._translateCell(cell, 'row', baseRow, deltaRow);
                }
                if (deltaColumn != null) {
                    ExpressionModifier._translateCell(cell, 'column', baseColumn, deltaColumn);
                }
            });

            return this;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var _this = this;

            var expression = this.expression.replace(CELL_AND_RANGE_REGEX, function (match, p1, p2) {
                var isSingleCell = match.indexOf(':') === -1;
                var result = match;
                var cellLabel = match;
                var translatedCellLabel = null;

                if (isSingleCell) {
                    cellLabel = BARE_CELL_STRICT_REGEX.test(p1) ? p1 : p2;
                }
                var cell = _this._searchCell(cellLabel);

                if (cell) {
                    translatedCellLabel = cell.refError ? (0, _error2.default)(_error.ERROR_REF) : cell.toLabel();

                    if (isSingleCell) {
                        result = match.replace(cellLabel, translatedCellLabel);
                    } else {
                        result = translatedCellLabel;
                    }
                }

                return result;
            });

            if (!expression.startsWith('=')) {
                expression = '=' + expression;
            }

            return expression;
        }
    }, {
        key: '_extractCells',
        value: function _extractCells() {
            var _this2 = this;

            var matches = this.expression.match(CELL_REGEX);

            if (!matches) {
                return;
            }
            arrayEach(matches, function (coord) {
                coord = coord.match(BARE_CELL_REGEX);

                if (!coord) {
                    return;
                }

                var _extractLabel = (0, _utils2.extractLabel)(coord[0]),
                    _extractLabel2 = _slicedToArray(_extractLabel, 2),
                    row = _extractLabel2[0],
                    column = _extractLabel2[1];

                _this2.cells.push(_this2._createCell({ row: row, column: column }, { row: row, column: column }, coord[0]));
            });
        }
    }, {
        key: '_extractCellsRange',
        value: function _extractCellsRange() {
            var _this3 = this;

            var matches = this.expression.match(RANGE_REGEX);

            if (!matches) {
                return;
            }
            arrayEach(matches, function (match) {
                var _match$split = match.split(':'),
                    _match$split2 = _slicedToArray(_match$split, 2),
                    start = _match$split2[0],
                    end = _match$split2[1];

                var _extractLabel3 = (0, _utils2.extractLabel)(start),
                    _extractLabel4 = _slicedToArray(_extractLabel3, 2),
                    startRow = _extractLabel4[0],
                    startColumn = _extractLabel4[1];

                var _extractLabel5 = (0, _utils2.extractLabel)(end),
                    _extractLabel6 = _slicedToArray(_extractLabel5, 2),
                    endRow = _extractLabel6[0],
                    endColumn = _extractLabel6[1];

                var startCell = {
                    row: startRow,
                    column: startColumn
                };
                var endCell = {
                    row: endRow,
                    column: endColumn
                };

                _this3.cells.push(_this3._createCell(startCell, endCell, match));
            });
        }
    }, {
        key: '_searchCell',
        value: function _searchCell(label) {
            var _arrayFilter = arrayFilter(this.cells, function (cell) {
                return cell.origLabel === label;
            }),
                _arrayFilter2 = _slicedToArray(_arrayFilter, 1),
                cell = _arrayFilter2[0];

            return cell || null;
        }
    }, {
        key: '_createCell',
        value: function _createCell(start, end, label) {
            return {
                start: start,
                end: end,
                origLabel: label,
                type: label.indexOf(':') === -1 ? 'cell' : 'range',
                refError: false,
                toLabel: function toLabel() {
                    var label = (0, _utils2.toLabel)(this.start.row, this.start.column);

                    if (this.type === 'range') {
                        label += ':' + (0, _utils2.toLabel)(this.end.row, this.end.column);
                    }

                    return label;
                }
            };
        }
    }], [{
        key: '_translateCell',
        value: function _translateCell(cell, property) {
            var baseIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var delta = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var type = cell.type,
                start = cell.start,
                end = cell.end;

            var startIndex = start[property].index;
            var endIndex = end[property].index;
            var deltaStart = delta;
            var deltaEnd = delta;
            var refError = false;
            var indexOffset = Math.abs(delta) - 1;

            // 
            if (delta > 0) {
                if (baseIndex > startIndex) {
                    deltaStart = 0;
                }
                if (baseIndex > endIndex) {
                    deltaEnd = 0;
                }
            } else {
                // 
                if (startIndex >= baseIndex && endIndex <= baseIndex + indexOffset) {
                    refError = true;
                }
                if (!refError && type === 'cell') {
                    if (baseIndex >= startIndex) {
                        deltaStart = 0;
                        deltaEnd = 0;
                    }
                }
                if (!refError && type === 'range') {
                    if (baseIndex >= startIndex) {
                        deltaStart = 0;
                    }
                    if (baseIndex > endIndex) {
                        deltaEnd = 0;
                    } else if (endIndex <= baseIndex + indexOffset) {
                        deltaEnd -= Math.min(endIndex - (baseIndex + indexOffset), 0);
                    }
                }
            }

            if (deltaStart && !refError) {
                start[property].index = Math.max(startIndex + deltaStart, 0);
            }
            if (deltaEnd && !refError) {
                end[property].index = Math.max(endIndex + deltaEnd, 0);
            }
            if (refError) {
                cell.refError = true;
            }
        }
    }]);

    return ExpressionModifier;
}();

mixin(ExpressionModifier, _localHooks2.default);

exports.ExpressionModifier = ExpressionModifier;

},{"../../utils/localHooks":63,"./parser/error":36,"./parser/utils":54,"./utils":55}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _errors;

exports.default = error;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ERROR = exports.ERROR = 'ERROR';
var ERROR_DIV_ZERO = exports.ERROR_DIV_ZERO = 'DIV/0';
var ERROR_NAME = exports.ERROR_NAME = 'NAME';
var ERROR_NEED_UPDATE = exports.ERROR_NEED_UPDATE = 'NEED_UPDATE';
var ERROR_NOT_AVAILABLE = exports.ERROR_NOT_AVAILABLE = 'N/A';
var ERROR_NULL = exports.ERROR_NULL = 'NULL';
var ERROR_NUM = exports.ERROR_NUM = 'NUM';
var ERROR_REF = exports.ERROR_REF = 'REF';
var ERROR_VALUE = exports.ERROR_VALUE = 'VALUE';

var errors = (_errors = {}, _defineProperty(_errors, ERROR, '#ERROR!'), _defineProperty(_errors, ERROR_DIV_ZERO, '#DIV/0!'), _defineProperty(_errors, ERROR_NAME, '#NAME?'), _defineProperty(_errors, ERROR_NEED_UPDATE, '#NEED_UPDATE!'), _defineProperty(_errors, ERROR_NOT_AVAILABLE, '#N/A'), _defineProperty(_errors, ERROR_NULL, '#NULL!'), _defineProperty(_errors, ERROR_NUM, '#NUM!'), _defineProperty(_errors, ERROR_REF, '#REF!'), _defineProperty(_errors, ERROR_VALUE, '#VALUE!'), _errors);

function error(type) {
  var error = void 0;
  type = (type + '').replace(/#|!|\?/g, '');

  if (errors[type]) {
    error = errors[type];
  }
  return error ? error : null;
}

},{}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var grammar = function () {
    var o = function o(k, v, _o, l) {
        for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}return _o;
    },
        $V0 = [1, 5],
        $V1 = [1, 8],
        $V2 = [1, 6],
        $V3 = [1, 7],
        $V4 = [1, 9],
        $V5 = [1, 15],
        $V6 = [1, 16],
        $V7 = [1, 17],
        $V8 = [1, 18],
        $V9 = [1, 13],
        $Va = [1, 14],
        $Vb = [1, 19],
        $Vc = [1, 21],
        $Vd = [1, 22],
        $Ve = [1, 23],
        $Vf = [1, 24],
        $Vg = [1, 25],
        $Vh = [1, 26],
        $Vi = [1, 27],
        $Vj = [1, 28],
        $Vk = [1, 29],
        $Vl = [1, 30],
        $Vm = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33],
        $Vn = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 35],
        $Vo = [1, 39],
        $Vp = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 37],
        $Vq = [5, 10, 11, 13, 14, 15, 16, 17, 32, 33],
        $Vr = [5, 10, 13, 14, 15, 16, 32, 33],
        $Vs = [5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 32, 33],
        $Vt = [13, 32, 33],
        $Vu = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33, 34, 38];
    var parser = { trace: function trace() {},
        yy: {},
        symbols_: { "error": 2, "expressions": 3, "expression": 4, "EOF": 5, "variableSequence": 6, "number": 7, "STRING": 8, "&": 9, "=": 10, "+": 11, "(": 12, ")": 13, "<": 14, ">": 15, "NOT": 16, "-": 17, "*": 18, "/": 19, "^": 20, "FUNCTION": 21, "expseq": 22, "sheet": 23, "cell": 24, "SHEET_NAME": 25, "!": 26, "ABSOLUTE_CELL": 27, "RELATIVE_CELL": 28, "MIXED_CELL": 29, ":": 30, "ARRAY": 31, ";": 32, ",": 33, "VARIABLE": 34, "DECIMAL": 35, "NUMBER": 36, "%": 37, "#": 38, "$accept": 0, "$end": 1 },
        terminals_: { 5: "EOF", 8: "STRING", 9: "&", 10: "=", 11: "+", 12: "(", 13: ")", 14: "<", 15: ">", 16: "NOT", 17: "-", 18: "*", 19: "/", 20: "^", 21: "FUNCTION", 25: "SHEET_NAME", 26: "!", 27: "ABSOLUTE_CELL", 28: "RELATIVE_CELL", 29: "MIXED_CELL", 30: ":", 31: "ARRAY", 32: ";", 33: ",", 34: "VARIABLE", 35: "DECIMAL", 36: "NUMBER", 37: "%", 38: "#" },
        productions_: [0, [3, 2], [4, 1], [4, 1], [4, 1], [4, 3], [4, 3], [4, 3], [4, 3], [4, 4], [4, 4], [4, 4], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 2], [4, 2], [4, 3], [4, 4], [4, 1], [4, 1], [4, 1], [4, 2], [23, 3], [23, 3], [23, 3], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [23, 5], [24, 1], [24, 1], [24, 1], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [24, 3], [22, 1], [22, 1], [22, 3], [22, 3], [6, 1], [6, 3], [7, 1], [7, 3], [7, 2], [2, 3], [2, 4]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
            /* this == yyval */

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1:

                    return $$[$0 - 1];

                    break;
                case 2:

                    this.$ = yy.callVariable($$[$0][0]);

                    break;
                case 3:

                    this.$ = yy.toNumber($$[$0]);

                    break;
                case 4:

                    this.$ = yy.trimEdges($$[$0]);

                    break;
                case 5:

                    this.$ = yy.evaluateByOperator('&', [$$[$0 - 2], $$[$0]]);

                    break;
                case 6:

                    this.$ = yy.evaluateByOperator('=', [$$[$0 - 2], $$[$0]]);

                    break;
                case 7:

                    this.$ = yy.evaluateByOperator('+', [$$[$0 - 2], $$[$0]]);

                    break;
                case 8:

                    this.$ = yy.toNumber($$[$0 - 1]);

                    break;
                case 9:

                    this.$ = yy.evaluateByOperator('<=', [$$[$0 - 3], $$[$0]]);

                    break;
                case 10:

                    this.$ = yy.evaluateByOperator('>=', [$$[$0 - 3], $$[$0]]);

                    break;
                case 11:

                    this.$ = yy.evaluateByOperator('<>', [$$[$0 - 3], $$[$0]]);

                    break;
                case 12:

                    this.$ = yy.evaluateByOperator('NOT', [$$[$0 - 2], $$[$0]]);

                    break;
                case 13:

                    this.$ = yy.evaluateByOperator('>', [$$[$0 - 2], $$[$0]]);

                    break;
                case 14:

                    this.$ = yy.evaluateByOperator('<', [$$[$0 - 2], $$[$0]]);

                    break;
                case 15:

                    this.$ = yy.evaluateByOperator('-', [$$[$0 - 2], $$[$0]]);

                    break;
                case 16:

                    this.$ = yy.evaluateByOperator('*', [$$[$0 - 2], $$[$0]]);

                    break;
                case 17:

                    this.$ = yy.evaluateByOperator('/', [$$[$0 - 2], $$[$0]]);

                    break;
                case 18:

                    this.$ = yy.evaluateByOperator('^', [$$[$0 - 2], $$[$0]]);

                    break;
                case 19:

                    var n1 = yy.invertNumber($$[$0]);
                    this.$ = n1;
                    if (isNaN(this.$)) {
                        this.$ = 0;
                    }

                    break;
                case 20:

                    var n1 = yy.toNumber($$[$0]);
                    this.$ = n1;
                    if (isNaN(this.$)) {
                        this.$ = 0;
                    }

                    break;
                case 21:

                    this.$ = yy.callFunction($$[$0 - 2]);

                    break;
                case 22:

                    this.$ = yy.callFunction($$[$0 - 3], $$[$0 - 1]);

                    break;
                case 27:case 28:case 29:

                    this.$ = yy.cellValueInSheet($$[$0 - 2], $$[$0]);

                    break;
                case 30:case 31:case 32:case 33:case 34:case 35:case 36:case 37:case 38:

                    this.$ = yy.rangeValueInSheet($$[$0 - 4], $$[$0 - 2], $$[$0]);

                    break;
                case 39:case 40:case 41:

                    this.$ = yy.cellValue($$[$0]);

                    break;
                case 42:case 43:case 44:case 45:case 46:case 47:case 48:case 49:case 50:

                    this.$ = yy.rangeValue($$[$0 - 2], $$[$0]);

                    break;
                case 51:case 55:

                    this.$ = [$$[$0]];

                    break;
                case 52:

                    var result = [];
                    var arr = eval("[" + yytext + "]");

                    arr.forEach(function (item) {
                        result.push(item);
                    });

                    this.$ = result;

                    break;
                case 53:case 54:

                    $$[$0 - 2].push($$[$0]);
                    this.$ = $$[$0 - 2];

                    break;
                case 56:

                    this.$ = Array.isArray($$[$0 - 2]) ? $$[$0 - 2] : [$$[$0 - 2]];
                    this.$.push($$[$0]);

                    break;
                case 57:

                    this.$ = $$[$0];

                    break;
                case 58:

                    this.$ = ($$[$0 - 2] + '.' + $$[$0]) * 1;

                    break;
                case 59:

                    this.$ = $$[$0 - 1] * 0.01;

                    break;
                case 60:case 61:

                    this.$ = yy.throwError($$[$0 - 2] + $$[$0 - 1] + $$[$0]);

                    break;
            }
        },
        table: [{ 2: 12, 3: 1, 4: 2, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 1: [3] }, { 5: [1, 20], 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }, o($Vm, [2, 2], { 35: [1, 31] }), o($Vm, [2, 3], { 37: [1, 32] }), o($Vm, [2, 4]), { 2: 12, 4: 33, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 34, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 35, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 12: [1, 36] }, o($Vm, [2, 23]), o($Vm, [2, 24]), o($Vm, [2, 25], { 2: 37, 34: [1, 38], 38: $Vb }), o($Vn, [2, 55], { 38: $Vo }), o($Vp, [2, 57], { 35: [1, 40] }), { 26: [1, 41] }, o($Vm, [2, 39], { 30: [1, 42] }), o($Vm, [2, 40], { 30: [1, 43] }), o($Vm, [2, 41], { 30: [1, 44] }), { 34: [1, 45] }, { 1: [2, 1] }, { 2: 12, 4: 46, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 47, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 48, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 51, 6: 3, 7: 4, 8: $V0, 10: [1, 49], 11: $V1, 12: $V2, 15: [1, 50], 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 53, 6: 3, 7: 4, 8: $V0, 10: [1, 52], 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 54, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 55, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 56, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 57, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 58, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 34: [1, 59] }, o($Vp, [2, 59]), { 9: $Vc, 10: $Vd, 11: $Ve, 13: [1, 60], 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }, o($Vq, [2, 19], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 20], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 63, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 13: [1, 61], 17: $V3, 21: $V4, 22: 62, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 31: [1, 64], 34: $V9, 36: $Va, 38: $Vb }, o($Vm, [2, 26]), { 38: $Vo }, { 34: [1, 65] }, { 36: [1, 66] }, { 27: [1, 67], 28: [1, 68], 29: [1, 69] }, { 27: [1, 70], 28: [1, 71], 29: [1, 72] }, { 27: [1, 73], 28: [1, 74], 29: [1, 75] }, { 27: [1, 76], 28: [1, 77], 29: [1, 78] }, { 26: [1, 79] }, o($Vm, [2, 5]), o([5, 10, 13, 32, 33], [2, 6], { 9: $Vc, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 7], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 80, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 81, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vr, [2, 14], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), { 2: 12, 4: 82, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vr, [2, 13], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o([5, 10, 13, 16, 32, 33], [2, 12], { 9: $Vc, 11: $Ve, 14: $Vf, 15: $Vg, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vq, [2, 15], { 9: $Vc, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vs, [2, 16], { 9: $Vc, 20: $Vl }), o($Vs, [2, 17], { 9: $Vc, 20: $Vl }), o([5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 32, 33], [2, 18], { 9: $Vc }), o($Vn, [2, 56]), o($Vm, [2, 8]), o($Vm, [2, 21]), { 13: [1, 83], 32: [1, 84], 33: [1, 85] }, o($Vt, [2, 51], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vt, [2, 52]), { 26: [1, 86] }, o($Vp, [2, 58]), o($Vm, [2, 27], { 30: [1, 87] }), o($Vm, [2, 28], { 30: [1, 88] }), o($Vm, [2, 29], { 30: [1, 89] }), o($Vm, [2, 42]), o($Vm, [2, 43]), o($Vm, [2, 44]), o($Vm, [2, 45]), o($Vm, [2, 46]), o($Vm, [2, 47]), o($Vm, [2, 48]), o($Vm, [2, 49]), o($Vm, [2, 50]), o($Vu, [2, 60]), o($Vr, [2, 9], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vr, [2, 11], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vr, [2, 10], { 9: $Vc, 11: $Ve, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vm, [2, 22]), { 2: 12, 4: 90, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, { 2: 12, 4: 91, 6: 3, 7: 4, 8: $V0, 11: $V1, 12: $V2, 17: $V3, 21: $V4, 23: 10, 24: 11, 25: $V5, 27: $V6, 28: $V7, 29: $V8, 34: $V9, 36: $Va, 38: $Vb }, o($Vu, [2, 61]), { 27: [1, 92], 28: [1, 93], 29: [1, 94] }, { 27: [1, 95], 28: [1, 96], 29: [1, 97] }, { 27: [1, 98], 28: [1, 99], 29: [1, 100] }, o($Vt, [2, 53], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vt, [2, 54], { 9: $Vc, 10: $Vd, 11: $Ve, 14: $Vf, 15: $Vg, 16: $Vh, 17: $Vi, 18: $Vj, 19: $Vk, 20: $Vl }), o($Vm, [2, 30]), o($Vm, [2, 31]), o($Vm, [2, 32]), o($Vm, [2, 33]), o($Vm, [2, 34]), o($Vm, [2, 35]), o($Vm, [2, 36]), o($Vm, [2, 37]), o($Vm, [2, 38])],
        defaultActions: { 20: [2, 1] },
        parseError: function parseError(str, hash) {
            if (hash.recoverable) {
                this.trace(str);
            } else {
                var _parseError = function _parseError(msg, hash) {
                    this.message = msg;
                    this.hash = hash;
                };

                _parseError.prototype = Error;

                throw new _parseError(str, hash);
            }
        },
        parse: function parse(input) {
            var self = this,
                stack = [0],
                tstack = [],
                // token stack
            vstack = [null],
                // semantic value stack
            lstack = [],
                // location stack
            table = this.table,
                yytext = '',
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;

            var args = lstack.slice.call(arguments, 1);

            //this.reductionCount = this.shiftCount = 0;

            var lexer = Object.create(this.lexer);
            var sharedState = { yy: {} };
            // copy state
            for (var k in this.yy) {
                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                    sharedState.yy[k] = this.yy[k];
                }
            }

            lexer.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer;
            sharedState.yy.parser = this;
            if (typeof lexer.yylloc == 'undefined') {
                lexer.yylloc = {};
            }
            var yyloc = lexer.yylloc;
            lstack.push(yyloc);

            var ranges = lexer.options && lexer.options.ranges;

            if (typeof sharedState.yy.parseError === 'function') {
                this.parseError = sharedState.yy.parseError;
            } else {
                this.parseError = Object.getPrototypeOf(this).parseError;
            }

            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }

            _token_stack: var lex = function lex() {
                var token;
                token = lexer.lex() || EOF;
                // if token isn't its numeric value, convert
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            };

            var symbol,
                preErrorSymbol,
                state,
                action,
                a,
                r,
                yyval = {},
                p,
                len,
                newState,
                expected;
            while (true) {
                // retreive state number from top of stack
                state = stack[stack.length - 1];

                // use default actions if available
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == 'undefined') {
                        symbol = lex();
                    }
                    // read action for current state and first input
                    action = table[state] && table[state][symbol];
                }

                _handle_error:
                // handle parse error
                if (typeof action === 'undefined' || !action.length || !action[0]) {

                    // Return the rule stack depth where the nearest error rule can be found.
                    // Return FALSE when no error recovery rule was found.
                    var locateNearestErrorRecoveryRule = function locateNearestErrorRecoveryRule(state) {
                        var stack_probe = stack.length - 1;
                        var depth = 0;

                        // try to recover from error
                        for (;;) {
                            // check for error recovery rule in this state
                            if (TERROR.toString() in table[state]) {
                                return depth;
                            }
                            if (state === 0 || stack_probe < 2) {
                                return false; // No suitable error recovery rule available.
                            }
                            stack_probe -= 2; // popStack(1): [symbol, action]
                            state = stack[stack_probe];
                            ++depth;
                        }
                    };

                    var error_rule_depth;
                    var errStr = '';

                    if (!recovering) {
                        // first see if there's any chance at hitting an error recovery rule:
                        error_rule_depth = locateNearestErrorRecoveryRule(state);

                        // Report error
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ":\n" + lexer.showPosition() + "\nExpecting " + expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected,
                            recoverable: error_rule_depth !== false
                        });
                    } else if (preErrorSymbol !== EOF) {
                        error_rule_depth = locateNearestErrorRecoveryRule(state);
                    }

                    // just recovered from another error
                    if (recovering == 3) {
                        if (symbol === EOF || preErrorSymbol === EOF) {
                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
                        }

                        // discard current lookahead and grab another
                        yyleng = lexer.yyleng;
                        yytext = lexer.yytext;
                        yylineno = lexer.yylineno;
                        yyloc = lexer.yylloc;
                        symbol = lex();
                    }

                    // try to recover from error
                    if (error_rule_depth === false) {
                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
                    }
                    popStack(error_rule_depth);

                    preErrorSymbol = symbol == TERROR ? null : symbol; // save the lookahead token
                    symbol = TERROR; // insert generic error symbol as new lookahead
                    state = stack[stack.length - 1];
                    action = table[state] && table[state][TERROR];
                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
                }

                // this shouldn't happen, unless resolve defaults are off
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                }

                switch (action[0]) {
                    case 1:
                        // shift
                        //this.shiftCount++;

                        stack.push(symbol);
                        vstack.push(lexer.yytext);
                        lstack.push(lexer.yylloc);
                        stack.push(action[1]); // push state
                        symbol = null;
                        if (!preErrorSymbol) {
                            // normal execution/no error
                            yyleng = lexer.yyleng;
                            yytext = lexer.yytext;
                            yylineno = lexer.yylineno;
                            yyloc = lexer.yylloc;
                            if (recovering > 0) {
                                recovering--;
                            }
                        } else {
                            // error just occurred, resume old lookahead f/ before error
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;

                    case 2:
                        // reduce
                        //this.reductionCount++;

                        len = this.productions_[action[1]][1];

                        // perform semantic action
                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
                        // default location, uses first token for firsts, last for lasts
                        yyval._$ = {
                            first_line: lstack[lstack.length - (len || 1)].first_line,
                            last_line: lstack[lstack.length - 1].last_line,
                            first_column: lstack[lstack.length - (len || 1)].first_column,
                            last_column: lstack[lstack.length - 1].last_column
                        };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

                        if (typeof r !== 'undefined') {
                            return r;
                        }

                        // pop off stack
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }

                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        // goto new state = table[STATE][NONTERMINAL]
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;

                    case 3:
                        // accept
                        return true;
                }
            }

            return true;
        } };

    /* generated by jison-lex 0.3.4 */
    var lexer = function () {
        var lexer = {

            EOF: 1,

            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },

            // resets the lexer, sets new input
            setInput: function setInput(input, yy) {
                this.yy = yy || this.yy || {};
                this._input = input;
                this._more = this._backtrack = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                };
                if (this.options.ranges) {
                    this.yylloc.range = [0, 0];
                }
                this.offset = 0;
                return this;
            },

            // consumes and returns one char from the input
            input: function input() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) {
                    this.yylloc.range[1]++;
                }

                this._input = this._input.slice(1);
                return ch;
            },

            // unshifts one char (or a string) into the input
            unput: function unput(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);

                if (lines.length - 1) {
                    this.yylineno -= lines.length - 1;
                }
                var r = this.yylloc.range;

                this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                this.yyleng = this.yytext.length;
                return this;
            },

            // When called from action, caches matched text and appends it on next action
            more: function more() {
                this._more = true;
                return this;
            },

            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function reject() {
                if (this.options.backtrack_lexer) {
                    this._backtrack = true;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
                return this;
            },

            // retain first n characters of the match
            less: function less(n) {
                this.unput(this.match.slice(n));
            },

            // displays already matched input, i.e. for error messages
            pastInput: function pastInput() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },

            // displays upcoming input, i.e. for error messages
            upcomingInput: function upcomingInput() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },

            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function showPosition() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },

            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function test_match(match, indexed_rule) {
                var token, lines, backup;

                if (this.options.backtrack_lexer) {
                    // save context
                    backup = {
                        yylineno: this.yylineno,
                        yylloc: {
                            first_line: this.yylloc.first_line,
                            last_line: this.last_line,
                            first_column: this.yylloc.first_column,
                            last_column: this.yylloc.last_column
                        },
                        yytext: this.yytext,
                        match: this.match,
                        matches: this.matches,
                        matched: this.matched,
                        yyleng: this.yyleng,
                        offset: this.offset,
                        _more: this._more,
                        _input: this._input,
                        yy: this.yy,
                        conditionStack: this.conditionStack.slice(0),
                        done: this.done
                    };
                    if (this.options.ranges) {
                        backup.yylloc.range = this.yylloc.range.slice(0);
                    }
                }

                lines = match[0].match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno += lines.length;
                }
                this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                };
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._backtrack = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) {
                    this.done = false;
                }
                if (token) {
                    return token;
                } else if (this._backtrack) {
                    // recover context
                    for (var k in backup) {
                        this[k] = backup[k];
                    }
                    return false; // rule action called reject() implying the next rule should be tested instead.
                }
                return false;
            },

            // return next match in input
            next: function next() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) {
                    this.done = true;
                }

                var token, match, tempMatch, index;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (this.options.backtrack_lexer) {
                            token = this.test_match(tempMatch, rules[i]);
                            if (token !== false) {
                                return token;
                            } else if (this._backtrack) {
                                match = false;
                                continue; // rule action called reject() implying a rule MISmatch.
                            } else {
                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                return false;
                            }
                        } else if (!this.options.flex) {
                            break;
                        }
                    }
                }
                if (match) {
                    token = this.test_match(match, rules[index]);
                    if (token !== false) {
                        return token;
                    }
                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                    return false;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
            },

            // return next match that has a token
            lex: function lex() {
                var r = this.next();
                if (r) {
                    return r;
                } else {
                    return this.lex();
                }
            },

            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },

            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
                var n = this.conditionStack.length - 1;
                if (n > 0) {
                    return this.conditionStack.pop();
                } else {
                    return this.conditionStack[0];
                }
            },

            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                } else {
                    return this.conditions["INITIAL"].rules;
                }
            },

            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
                n = this.conditionStack.length - 1 - Math.abs(n || 0);
                if (n >= 0) {
                    return this.conditionStack[n];
                } else {
                    return "INITIAL";
                }
            },

            // alias for begin(condition)
            pushState: function pushState(condition) {
                this.begin(condition);
            },

            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
                return this.conditionStack.length;
            },
            options: {},
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                var YYSTATE = YY_START;
                switch ($avoiding_name_collisions) {
                    case 0:
                        /*  */
                        break;
                    case 1:
                        return 25;
                        break;
                    case 2:
                        return 8;
                        break;
                    case 3:
                        return 8;
                        break;
                    case 4:
                        return 21;
                        break;
                    case 5:
                        return 25;
                        break;
                    case 6:
                        return 27;
                        break;
                    case 7:
                        return 29;
                        break;
                    case 8:
                        return 29;
                        break;
                    case 9:
                        return 28;
                        break;
                    case 10:
                        return 21;
                        break;
                    case 11:
                        return 34;
                        break;
                    case 12:
                        return 34;
                        break;
                    case 13:
                        return 36;
                        break;
                    case 14:
                        return 31;
                        break;
                    case 15:
                        break;
                    case 16:
                        return 9;
                        break;
                    case 17:
                        return ' ';
                        break;
                    case 18:
                        return 35;
                        break;
                    case 19:
                        return 30;
                        break;
                    case 20:
                        return 32;
                        break;
                    case 21:
                        return 33;
                        break;
                    case 22:
                        return 18;
                        break;
                    case 23:
                        return 19;
                        break;
                    case 24:
                        return 17;
                        break;
                    case 25:
                        return 11;
                        break;
                    case 26:
                        return 20;
                        break;
                    case 27:
                        return 12;
                        break;
                    case 28:
                        return 13;
                        break;
                    case 29:
                        return 15;
                        break;
                    case 30:
                        return 14;
                        break;
                    case 31:
                        return 16;
                        break;
                    case 32:
                        return '"';
                        break;
                    case 33:
                        return "'";
                        break;
                    case 34:
                        return "!";
                        break;
                    case 35:
                        return 10;
                        break;
                    case 36:
                        return 37;
                        break;
                    case 37:
                        return 38;
                        break;
                    case 38:
                        return 5;
                        break;
                }
            },
            rules: [/^(?:\s+)/, /^(?:'([^\\/\?\*\[\]\!'"]+)'(?=[!]))/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9\.]+(?=[(]))/, /^(?:[^\\/\?\*\[\]'"\!,\)]+(?=[!]))/, /^(?:\$[A-Za-z]+\$[0-9]+)/, /^(?:\$[A-Za-z]+[0-9]+)/, /^(?:[A-Za-z]+\$[0-9]+)/, /^(?:[A-Za-z]+[0-9]+)/, /^(?:[A-Za-z\.]+(?=[(]))/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9]+)/, /^(?:[A-Za-z_]+)/, /^(?:[0-9]+)/, /^(?:\[(.*)?\])/, /^(?:\$)/, /^(?:&)/, /^(?: )/, /^(?:[.])/, /^(?::)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\/)/, /^(?:-)/, /^(?:\+)/, /^(?:\^)/, /^(?:\()/, /^(?:\))/, /^(?:>)/, /^(?:<)/, /^(?:NOT\b)/, /^(?:")/, /^(?:')/, /^(?:!)/, /^(?:=)/, /^(?:%)/, /^(?:[#])/, /^(?:$)/],
            conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38], "inclusive": true } }
        };
        return lexer;
    }();
    parser.lexer = lexer;
    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser;parser.Parser = Parser;
    return new Parser();
}();

var Parser = exports.Parser = grammar.Parser;

},{}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '+';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc + (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '&';

function func() {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return params.reduce(function (acc, value) {
    return acc + value.toString();
  }, '');
};

func.SYMBOL = SYMBOL;

},{}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '/';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc / (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (result === Infinity) {
    throw Error(_error.ERROR_DIV_ZERO);
  }
  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '=';

function func(exp1, exp2) {
  return exp1 === exp2;
};

func.SYMBOL = SYMBOL;

},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _supportedFormulas = require('./../supported-formulas');

var _supportedFormulas2 = _interopRequireDefault(_supportedFormulas);

var _error = require('./../error');

var _formulajs = require('formulajs');

var formulajs = _interopRequireWildcard(_formulajs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SYMBOL = exports.SYMBOL = _supportedFormulas2.default; /**
                                                            * Excel  formulajs 
                                                            *
                                                            */

function func(symbol) {
    return function () {
        symbol = symbol.toUpperCase();

        var symbolParts = symbol.split('.');
        var foundFormula = false;
        var result = void 0;

        if (symbolParts.length === 1) {
            if (formulajs[symbolParts[0]]) {
                foundFormula = true;
                result = formulajs[symbolParts[0]].apply(formulajs, arguments);
            }
        } else {
            var length = symbolParts.length;
            var index = 0;
            var nestedFormula = formulajs;

            while (index < length) {
                nestedFormula = nestedFormula[symbolParts[index]];
                index++;

                if (!nestedFormula) {
                    nestedFormula = null;
                    break;
                }
            }
            if (nestedFormula) {
                foundFormula = true;
                result = nestedFormula.apply(undefined, arguments);
            }
        }

        if (!foundFormula) {
            throw Error(_error.ERROR_NAME);
        }

        return result;
    };
};

func.isFactory = true;
func.SYMBOL = SYMBOL;

},{"./../error":36,"./../supported-formulas":53,"formulajs":1}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '>=';

function func(exp1, exp2) {
  return exp1 >= exp2;
};

func.SYMBOL = SYMBOL;

},{}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '>';

function func(exp1, exp2) {
  return exp1 > exp2;
};

func.SYMBOL = SYMBOL;

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<=';

function func(exp1, exp2) {
  return exp1 <= exp2;
};

func.SYMBOL = SYMBOL;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<';

function func(exp1, exp2) {
  return exp1 < exp2;
};

func.SYMBOL = SYMBOL;

},{}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '-';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc - (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '*';

function func(first) {
  for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var result = rest.reduce(function (acc, value) {
    return acc * (0, _utils.toNumber)(value);
  }, (0, _utils.toNumber)(first));

  if (isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = func;
var SYMBOL = exports.SYMBOL = '<>';

function func(exp1, exp2) {
  return exp1 !== exp2;
};

func.SYMBOL = SYMBOL;

},{}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SYMBOL = undefined;
exports.default = func;

var _utils = require('./../utils');

var _error = require('./../error');

var SYMBOL = exports.SYMBOL = '^';

function func(exp1, exp2) {
  var result = Math.pow((0, _utils.toNumber)(exp1), (0, _utils.toNumber)(exp2));

  if (Number.isNaN(result)) {
    throw Error(_error.ERROR_VALUE);
  }

  return result;
};

func.SYMBOL = SYMBOL;

},{"./../error":36,"./../utils":54}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = evaluateByOperator;
exports.registerOperation = registerOperation;

var _add = require('./operator/add');

var _add2 = _interopRequireDefault(_add);

var _ampersand = require('./operator/ampersand');

var _ampersand2 = _interopRequireDefault(_ampersand);

var _divide = require('./operator/divide');

var _divide2 = _interopRequireDefault(_divide);

var _equal = require('./operator/equal');

var _equal2 = _interopRequireDefault(_equal);

var _formulaFunction = require('./operator/formula-function');

var _formulaFunction2 = _interopRequireDefault(_formulaFunction);

var _greaterThan = require('./operator/greater-than');

var _greaterThan2 = _interopRequireDefault(_greaterThan);

var _greaterThanOrEqual = require('./operator/greater-than-or-equal');

var _greaterThanOrEqual2 = _interopRequireDefault(_greaterThanOrEqual);

var _lessThan = require('./operator/less-than');

var _lessThan2 = _interopRequireDefault(_lessThan);

var _lessThanOrEqual = require('./operator/less-than-or-equal');

var _lessThanOrEqual2 = _interopRequireDefault(_lessThanOrEqual);

var _minus = require('./operator/minus');

var _minus2 = _interopRequireDefault(_minus);

var _multiply = require('./operator/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _notEqual = require('./operator/not-equal');

var _notEqual2 = _interopRequireDefault(_notEqual);

var _power = require('./operator/power');

var _power2 = _interopRequireDefault(_power);

var _error = require('./error');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
// import {default as crossSheet} from './operator/cross-sheet';


var availableOperators = Object.create(null);

registerOperation(_add2.default.SYMBOL, _add2.default);
registerOperation(_ampersand2.default.SYMBOL, _ampersand2.default);
// registerOperation(crossSheet.SYMBOL, crossSheet);
registerOperation(_divide2.default.SYMBOL, _divide2.default);
registerOperation(_equal2.default.SYMBOL, _equal2.default);
registerOperation(_power2.default.SYMBOL, _power2.default);
registerOperation(_formulaFunction2.default.SYMBOL, _formulaFunction2.default);
registerOperation(_greaterThan2.default.SYMBOL, _greaterThan2.default);
registerOperation(_greaterThanOrEqual2.default.SYMBOL, _greaterThanOrEqual2.default);
registerOperation(_lessThan2.default.SYMBOL, _lessThan2.default);
registerOperation(_lessThanOrEqual2.default.SYMBOL, _lessThanOrEqual2.default);
registerOperation(_multiply2.default.SYMBOL, _multiply2.default);
registerOperation(_notEqual2.default.SYMBOL, _notEqual2.default);
registerOperation(_minus2.default.SYMBOL, _minus2.default);

function evaluateByOperator(operator) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    operator = operator.toUpperCase();

    if (!availableOperators[operator]) {
        throw Error(_error.ERROR_NAME);
    }
    return availableOperators[operator].apply(availableOperators, _toConsumableArray(params));
}

/**
 * 
 * @param symbol
 * @param func
 */
function registerOperation(symbol, func) {
    if (!Array.isArray(symbol)) {
        symbol = [symbol.toUpperCase()];
    }
    symbol.forEach(function (s) {
        if (func.isFactory) {
            availableOperators[s] = func(s);
        } else {
            availableOperators[s] = func;
        }
    });
}

},{"./error":36,"./operator/add":38,"./operator/ampersand":39,"./operator/divide":40,"./operator/equal":41,"./operator/formula-function":42,"./operator/greater-than":44,"./operator/greater-than-or-equal":43,"./operator/less-than":46,"./operator/less-than-or-equal":45,"./operator/minus":47,"./operator/multiply":48,"./operator/not-equal":49,"./operator/power":50}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Parser = exports.SUPPORTED_FORMULAS = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _supportedFormulas = require('./supported-formulas');

Object.defineProperty(exports, 'SUPPORTED_FORMULAS', {
    enumerable: true,
    get: function get() {
        return _interopRequireDefault(_supportedFormulas).default;
    }
});

var _Emitter2 = require('../../../utils/Emitter');

var _Emitter3 = _interopRequireDefault(_Emitter2);

var _operators = require('./operators');

var _operators2 = _interopRequireDefault(_operators);

var _grammar = require('./grammar');

var _utils = require('./utils');

var _error = require('./error');

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  jison  http://zaa.ch/jison/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * : jison  AMD  ES6 :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *      `export var Parser = grammar.Parser;`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @class Parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callVariable
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callCellValue
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fires Parser#callRangeValue
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var Parser = function (_Emitter) {
    _inherits(Parser, _Emitter);

    function Parser() {
        _classCallCheck(this, Parser);

        var _this = _possibleConstructorReturn(this, (Parser.__proto__ || Object.getPrototypeOf(Parser)).call(this));

        _this.parser = new _grammar.Parser();
        _this.parser.yy = {
            toNumber: _utils.toNumber,
            trimEdges: _utils.trimEdges,
            invertNumber: _utils.invertNumber,
            throwError: function throwError(errorName) {
                return Parser._throwError(errorName);
            },
            callVariable: function callVariable(variable) {
                return _this._callVariable(variable);
            },
            evaluateByOperator: _operators2.default,
            callFunction: _operators2.default,
            cellValue: function cellValue(value) {
                return _this._callCellValue(value);
            },
            rangeValue: function rangeValue(start, end) {
                return _this._callRangeValue(start, end);
            },
            cellValueInSheet: function cellValueInSheet(sheetName, value) {
                return _this._callCellValueInSheet(sheetName, value);
            },
            rangeValueInSheet: function rangeValueInSheet(sheetName, start, end) {
                return _this._callRangeValueInSheet(sheetName, start, end);
            },
            parseError: function parseError() {
                return Parser._parseError.apply(Parser, arguments);
            }
        };
        _this.variables = Object.create(null);

        _this.setVariable('TRUE', true).setVariable('FALSE', false).setVariable('NULL', null);
        return _this;
    }

    /**
     * 
     * @param expression
     * @returns {{error: *, result: *}}
     */


    _createClass(Parser, [{
        key: 'parse',
        value: function parse(expression) {
            var result = null;
            var error = null;

            try {
                result = this.parser.parse(expression);
            } catch (ex) {
                var message = (0, _error2.default)(ex.message);
                if (message) {
                    error = message;
                } else {
                    error = (0, _error2.default)(_error.ERROR);
                }
            }

            if (result instanceof Error) {
                error = (0, _error2.default)(result.message) || (0, _error2.default)(_error.ERROR);
                result = null;
            }

            return {
                error: error,
                result: result
            };
        }

        /**
         * 
         * @param name
         * @param value
         * @returns {Parser}
         */

    }, {
        key: 'setVariable',
        value: function setVariable(name, value) {
            this.variables[name] = value;
            return this;
        }
    }, {
        key: 'getVariable',
        value: function getVariable(name) {
            return this.variables[name];
        }

        /**
         * 
         * @param name
         * @returns {*}
         * @private
         */

    }, {
        key: '_callVariable',
        value: function _callVariable(name) {
            var value = this.getVariable(name);

            this.emit('callVariable', name, function (newValue) {
                if (newValue !== void 0) {
                    value = newValue;
                }
            });

            if (value === void 0) {
                throw Error(_error.ERROR_NAME);
            }

            return value;
        }

        /**
         * 
         * @param {string} label -  `B3`, `B$3`, `B$3`, `$B$3`
         * @returns {*}
         * @private
         */

    }, {
        key: '_callCellValue',
        value: function _callCellValue(label) {
            var _extractLabel = (0, _utils.extractLabel)(label),
                _extractLabel2 = _slicedToArray(_extractLabel, 2),
                row = _extractLabel2[0],
                column = _extractLabel2[1];

            var value = void 0;

            this.emit('callCellValue', { label: label, row: row, column: column }, function (_value) {
                value = _value;
            });

            return value;
        }

        /**
         *  sheet 
         * @param sheetName
         * @param label
         * @returns {*}
         * @private
         */

    }, {
        key: '_callCellValueInSheet',
        value: function _callCellValueInSheet(sheetName, label) {
            var _extractLabel3 = (0, _utils.extractLabel)(label),
                _extractLabel4 = _slicedToArray(_extractLabel3, 2),
                row = _extractLabel4[0],
                column = _extractLabel4[1];

            var value = void 0;

            this.emit('callCellValueInSheet', { sheetName: sheetName, label: label, row: row, column: column }, function (_value) {
                value = _value;
            });
            return value;
        }
    }, {
        key: '_callRangeValue',


        /**
         *  `B3:A1`
         * @param {string} startLabel -  `B3`
         * @param {string} endLabel -  `A1`
         * @returns {Array}
         * @private
         */
        value: function _callRangeValue(startLabel, endLabel) {
            var _Parser$_explainCell = Parser._explainCell(startLabel, endLabel),
                startCell = _Parser$_explainCell.startCell,
                endCell = _Parser$_explainCell.endCell;

            var value = [];
            this.emit('callRangeValue', startCell, endCell, function () {
                var _value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                value = _value;
            });
            return value;
        }

        /**
         *  sheet  `1!B3:A1`
         * @param sheetName
         * @param startLabel
         * @param endLabel
         * @returns {Array}
         * @private
         */

    }, {
        key: '_callRangeValueInSheet',
        value: function _callRangeValueInSheet(sheetName, startLabel, endLabel) {
            var _Parser$_explainCell2 = Parser._explainCell(startLabel, endLabel),
                startCell = _Parser$_explainCell2.startCell,
                endCell = _Parser$_explainCell2.endCell;

            var value = [];
            this.emit('callRangeValueInSheet', sheetName, startCell, endCell, function () {
                var _value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

                value = _value;
            });
            return value;
        }

        /**
         *
         * @param errorName
         * @returns {*}
         * @private
         */

    }], [{
        key: '_explainCell',
        value: function _explainCell(startLabel, endLabel) {
            var _extractLabel5 = (0, _utils.extractLabel)(startLabel),
                _extractLabel6 = _slicedToArray(_extractLabel5, 2),
                startRow = _extractLabel6[0],
                startColumn = _extractLabel6[1];

            var _extractLabel7 = (0, _utils.extractLabel)(endLabel),
                _extractLabel8 = _slicedToArray(_extractLabel7, 2),
                endRow = _extractLabel8[0],
                endColumn = _extractLabel8[1];

            var startCell = {};
            var endCell = {};

            if (startRow.index <= endRow.index) {
                startCell.row = startRow;
                endCell.row = endRow;
            } else {
                startCell.row = endRow;
                endCell.row = startRow;
            }

            if (startColumn.index <= endColumn.index) {
                startCell.column = startColumn;
                endCell.column = endColumn;
            } else {
                startCell.column = endColumn;
                endCell.column = startColumn;
            }

            startCell.label = (0, _utils.toLabel)(startCell.row, startCell.column);
            endCell.label = (0, _utils.toLabel)(endCell.row, endCell.column);
            return { startCell: startCell, endCell: endCell };
        }
    }, {
        key: '_throwError',
        value: function _throwError(errorName) {
            var parsedError = (0, _error2.default)(errorName);
            if (parsedError) {
                throw Error(parsedError);
            }
            return errorName;
        }

        // TODO 

    }, {
        key: '_parseError',
        value: function _parseError() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            console.log(args);
        }
    }]);

    return Parser;
}(_Emitter3.default);

exports.Parser = Parser;

},{"../../../utils/Emitter":58,"./error":36,"./grammar":37,"./operators":51,"./supported-formulas":53,"./utils":54}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var SUPPORTED_FORMULAS = ['ABS', 'ACCRINT', 'ACOS', 'ACOSH', 'ACOT', 'ACOTH', 'ADD', 'AGGREGATE', 'AND', 'ARABIC', 'ARGS2ARRAY', 'ASIN', 'ASINH', 'ATAN', 'ATAN2', 'ATANH', 'AVEDEV', 'AVERAGE', 'AVERAGEA', 'AVERAGEIF', 'AVERAGEIFS', 'BASE', 'BESSELI', 'BESSELJ', 'BESSELK', 'BESSELY', 'BETA.DIST', 'BETA.INV', 'BETADIST', 'BETAINV', 'BIN2DEC', 'BIN2HEX', 'BIN2OCT', 'BINOM.DIST', 'BINOM.DIST.RANGE', 'BINOM.INV', 'BINOMDIST', 'BITAND', 'BITLSHIFT', 'BITOR', 'BITRSHIFT', 'BITXOR', 'CEILING', 'CEILINGMATH', 'CEILINGPRECISE', 'CHAR', 'CHISQ.DIST', 'CHISQ.DIST.RT', 'CHISQ.INV', 'CHISQ.INV.RT', 'CHOOSE', 'CHOOSE', 'CLEAN', 'CODE', 'COLUMN', 'COLUMNS', 'COMBIN', 'COMBINA', 'COMPLEX', 'CONCATENATE', 'CONFIDENCE', 'CONFIDENCE.NORM', 'CONFIDENCE.T', 'CONVERT', 'CORREL', 'COS', 'COSH', 'COT', 'COTH', 'COUNT', 'COUNTA', 'COUNTBLANK', 'COUNTIF', 'COUNTIFS', 'COUNTIN', 'COUNTUNIQUE', 'COVARIANCE.P', 'COVARIANCE.S', 'CSC', 'CSCH', 'CUMIPMT', 'CUMPRINC', 'DATE', 'DATEVALUE', 'DAY', 'DAYS', 'DAYS360', 'DB', 'DDB', 'DEC2BIN', 'DEC2HEX', 'DEC2OCT', 'DECIMAL', 'DEGREES', 'DELTA', 'DEVSQ', 'DIVIDE', 'DOLLAR', 'DOLLARDE', 'DOLLARFR', 'E', 'EDATE', 'EFFECT', 'EOMONTH', 'EQ', 'ERF', 'ERFC', 'EVEN', 'EXACT', 'EXPON.DIST', 'EXPONDIST', 'F.DIST', 'F.DIST.RT', 'F.INV', 'F.INV.RT', 'FACT', 'FACTDOUBLE', 'FALSE', 'FDIST', 'FDISTRT', 'FIND', 'FINV', 'FINVRT', 'FISHER', 'FISHERINV', 'FIXED', 'FLATTEN', 'FLOOR', 'FORECAST', 'FREQUENCY', 'FV', 'FVSCHEDULE', 'GAMMA', 'GAMMA.DIST', 'GAMMA.INV', 'GAMMADIST', 'GAMMAINV', 'GAMMALN', 'GAMMALN.PRECISE', 'GAUSS', 'GCD', 'GEOMEAN', 'GESTEP', 'GROWTH', 'GTE', 'HARMEAN', 'HEX2BIN', 'HEX2DEC', 'HEX2OCT', 'HOUR', 'HTML2TEXT', 'HYPGEOM.DIST', 'HYPGEOMDIST', 'IF', 'IMABS', 'IMAGINARY', 'IMARGUMENT', 'IMCONJUGATE', 'IMCOS', 'IMCOSH', 'IMCOT', 'IMCSC', 'IMCSCH', 'IMDIV', 'IMEXP', 'IMLN', 'IMLOG10', 'IMLOG2', 'IMPOWER', 'IMPRODUCT', 'IMREAL', 'IMSEC', 'IMSECH', 'IMSIN', 'IMSINH', 'IMSQRT', 'IMSUB', 'IMSUM', 'IMTAN', 'INT', 'INTERCEPT', 'INTERVAL', 'IPMT', 'IRR', 'ISBINARY', 'ISBLANK', 'ISEVEN', 'ISLOGICAL', 'ISNONTEXT', 'ISNUMBER', 'ISODD', 'ISODD', 'ISOWEEKNUM', 'ISPMT', 'ISTEXT', 'JOIN', 'KURT', 'LARGE', 'LCM', 'LEFT', 'LEN', 'LINEST', 'LN', 'LOG', 'LOG10', 'LOGEST', 'LOGNORM.DIST', 'LOGNORM.INV', 'LOGNORMDIST', 'LOGNORMINV', 'LOWER', 'LT', 'LTE', 'MATCH', 'MAX', 'MAXA', 'MEDIAN', 'MID', 'MIN', 'MINA', 'MINUS', 'MINUTE', 'MIRR', 'MOD', 'MODE.MULT', 'MODE.SNGL', 'MODEMULT', 'MODESNGL', 'MONTH', 'MROUND', 'MULTINOMIAL', 'MULTIPLY', 'NE', 'NEGBINOM.DIST', 'NEGBINOMDIST', 'NETWORKDAYS', 'NOMINAL', 'NORM.DIST', 'NORM.INV', 'NORM.S.DIST', 'NORM.S.INV', 'NORMDIST', 'NORMINV', 'NORMSDIST', 'NORMSINV', 'NOT', 'NOW', 'NPER', 'NPV', 'NUMBERS', 'NUMERAL', 'OCT2BIN', 'OCT2DEC', 'OCT2HEX', 'ODD', 'OR', 'PDURATION', 'PEARSON', 'PERCENTILEEXC', 'PERCENTILEINC', 'PERCENTRANKEXC', 'PERCENTRANKINC', 'PERMUT', 'PERMUTATIONA', 'PHI', 'PI', 'PMT', 'POISSON.DIST', 'POISSONDIST', 'POW', 'POWER', 'PPMT', 'PROB', 'PRODUCT', 'PROPER', 'PV', 'QUARTILE.EXC', 'QUARTILE.INC', 'QUARTILEEXC', 'QUARTILEINC', 'QUOTIENT', 'RADIANS', 'RAND', 'RANDBETWEEN', 'RANK.AVG', 'RANK.EQ', 'RANKAVG', 'RANKEQ', 'RATE', 'REFERENCE', 'REGEXEXTRACT', 'REGEXMATCH', 'REGEXREPLACE', 'REPLACE', 'REPT', 'RIGHT', 'ROMAN', 'ROUND', 'ROUNDDOWN', 'ROUNDUP', 'ROW', 'ROWS', 'RRI', 'RSQ', 'SEARCH', 'SEC', 'SECH', 'SECOND', 'SERIESSUM', 'SIGN', 'SIN', 'SINH', 'SKEW', 'SKEW.P', 'SKEWP', 'SLN', 'SLOPE', 'SMALL', 'SPLIT', 'SPLIT', 'SQRT', 'SQRTPI', 'STANDARDIZE', 'STDEV.P', 'STDEV.S', 'STDEVA', 'STDEVP', 'STDEVPA', 'STDEVS', 'STEYX', 'SUBSTITUTE', 'SUBTOTAL', 'SUM', 'SUMIF', 'SUMIFS', 'SUMPRODUCT', 'SUMSQ', 'SUMX2MY2', 'SUMX2PY2', 'SUMXMY2', 'SWITCH', 'SYD', 'T', 'T.DIST', 'T.DIST.2T', 'T.DIST.RT', 'T.INV', 'T.INV.2T', 'TAN', 'TANH', 'TBILLEQ', 'TBILLPRICE', 'TBILLYIELD', 'TDIST', 'TDIST2T', 'TDISTRT', 'TEXT', 'TIME', 'TIMEVALUE', 'TINV', 'TINV2T', 'TODAY', 'TRANSPOSE', 'TREND', 'TRIM', 'TRIMMEAN', 'TRUE', 'TRUNC', 'UNICHAR', 'UNICODE', 'UNIQUE', 'UPPER', 'VALUE', 'VAR.P', 'VAR.S', 'VARA', 'VARP', 'VARPA', 'VARS', 'WEEKDAY', 'WEEKNUM', 'WEIBULL.DIST', 'WEIBULLDIST', 'WORKDAY', 'XIRR', 'XNPV', 'XOR', 'YEAR', 'YEARFRAC'];

exports.default = SUPPORTED_FORMULAS;

},{}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.extractLabel = extractLabel;
exports.toLabel = toLabel;
exports.columnLabelToIndex = columnLabelToIndex;
exports.columnIndexToLabel = columnIndexToLabel;
exports.rowLabelToIndex = rowLabelToIndex;
exports.rowIndexToLabel = rowIndexToLabel;
exports.toNumber = toNumber;
exports.invertNumber = invertNumber;
exports.trimEdges = trimEdges;
/* ****************************************** *\
 *                  
 * ****************************************** */

var LABEL_EXTRACT_REGEXP = /^([$])?([A-Za-z]+)([$])?([0-9]+)$/;

function extractLabel(label) {
    if (!LABEL_EXTRACT_REGEXP.test(label)) {
        return [];
    }

    var _label$match = label.match(LABEL_EXTRACT_REGEXP),
        _label$match2 = _slicedToArray(_label$match, 5),
        columnAbs = _label$match2[1],
        column = _label$match2[2],
        rowAbs = _label$match2[3],
        row = _label$match2[4];

    return [{
        index: rowLabelToIndex(row),
        label: row,
        isAbsolute: rowAbs === '$'
    }, {
        index: columnLabelToIndex(column),
        label: column,
        isAbsolute: columnAbs === '$'
    }];
}

function toLabel(row, column) {
    var rowLabel = (row.isAbsolute ? '$' : '') + rowIndexToLabel(row.index);
    var columnLabel = (column.isAbsolute ? '$' : '') + columnIndexToLabel(column.index);
    return columnLabel + rowLabel;
}

var COLUMN_LABEL_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;

function columnLabelToIndex(label) {
    var result = 0;

    if (label) {
        for (var i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {
            result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j) * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);
        }
    }
    --result;

    return result;
}

function columnIndexToLabel(column) {
    var result = '';

    while (column >= 0) {
        result = String.fromCharCode(column % COLUMN_LABEL_BASE_LENGTH + 97) + result;
        column = Math.floor(column / COLUMN_LABEL_BASE_LENGTH) - 1;
    }

    return result.toUpperCase();
}

function rowLabelToIndex(label) {
    var result = parseInt(label, 10);

    if (Number.isNaN(result)) {
        result = -1;
    } else {
        result = Math.max(result - 1, -1);
    }
    return result;
}

function rowIndexToLabel(row) {
    return row >= 0 ? '' + (row + 1) : '';
}

/* ****************************************** *\
 *                  number
 * ****************************************** */

function toNumber(number) {
    var result = void 0;
    if (typeof number === 'number') {
        result = number;
    } else if (typeof number === 'string') {
        result = number.indexOf('.') > -1 ? parseFloat(number) : parseInt(number, 10);
    }
    return result;
}

/**
 * 
 * @param {Number} number
 * @returns {Number}
 */
function invertNumber(number) {
    return -1 * toNumber(number);
}

/* ****************************************** *\
 *                  string
 * ****************************************** */

function trimEdges(string) {
    var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    string = string.substring(margin, string.length - margin);
    return string;
}

},{}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isFormulaExpression = isFormulaExpression;
exports.isFormulaExpressionEscaped = isFormulaExpressionEscaped;
exports.unescapeFormulaExpression = unescapeFormulaExpression;
exports.toUpperCaseFormula = toUpperCaseFormula;

/**
 * Check if provided expression is valid formula expression.
 *
 * @param {*} expression Expression to check.
 * @returns {Boolean}
 */
function isFormulaExpression(expression) {
    return expression && (expression + '').charAt(0) === '=' ? true : false;
}

/**
 * Check if provided formula expression is escaped.
 *
 * @param {*} expression Expression to check.
 * @returns {Boolean}
 */
function isFormulaExpressionEscaped(expression) {
    return expression && (expression + '').charAt(0) === '\'' && (expression + '').charAt(1) === '=' ? true : false;
}

/**
 * Replace escaped formula expression into valid string.
 *
 * @param {String} expression Expression to process.
 * @returns {String}
 */
function unescapeFormulaExpression(expression) {
    return isFormulaExpressionEscaped(expression) ? expression.substr(1) : expression;
}

/**
 * Upper case formula expression.
 *
 * @param {String} expression Formula expression.
 * @returns {String}
 */
function toUpperCaseFormula(expression) {
    var PATTERN = /(\\"|"(?:\\"|[^"])*"|(\+))|(\\'|'(?:\\'|[^'])*'|(\+))/g;
    var strings = expression.match(PATTERN) || [];
    var index = -1;

    return expression.toUpperCase().replace(PATTERN, function () {
        ++index;

        return strings[index];
    });
}

},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = polyfill;
/**
 *
 * @param _g  window 
 */
function polyfill(_g) {

    // --------------------------------------------- es6 polyfill

    // Number.isNaN()
    if (!_g.Number.isNaN) {
        _g.Number.isNaN = function (x) {
            return x !== x;
        };
    }

    // String.contains()
    if (typeof _g.String.prototype.contains === 'undefined') {
        _g.String.prototype.contains = function (str) {
            return !!~this.indexOf(str);
        };
    }

    // String.startsWith()
    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function (searchString, position) {
            position = position || 0;
            return this.substr(position, searchString.length) === searchString;
        };
    }

    // --------------------------------------------- IE polyfill

    // HTMLElement.classList
    if (!('classList' in document.documentElement)) {
        Object.defineProperty(HTMLElement.prototype, 'classList', {
            get: function get() {
                var self = this;

                function update(fn) {
                    return function (value) {
                        var classes = self.className.split(/\s+/g);
                        var index = classes.indexOf(value);

                        fn(classes, index, value);
                        self.className = classes.join(' ');
                    };
                }

                return {
                    add: update(function (classes, index, value) {
                        if (!~index) {
                            classes.push(value);
                        }
                    }),

                    remove: update(function (classes, index) {
                        if (~index) {
                            classes.splice(index, 1);
                        }
                    }),

                    toggle: update(function (classes, index, value) {
                        if (~index) {
                            classes.splice(index, 1);
                        } else {
                            classes.push(value);
                        }
                    }),

                    contains: function contains(value) {
                        return !!~self.className.split(/\s+/g).indexOf(value);
                    },

                    item: function item(i) {
                        return self.className.split(/\s+/g)[i] || null;
                    }
                };
            }
        });
    }
}

},{}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * 
 */
var globalSettings = {
    idPrefix: 'brick-ssd-',
    idSuffix4Workbook: '-workbook',

    sheet: {

        /**
         * (1, 2...)
         */
        autoPrefix: '',

        /**
         * sheet  Apache POI 
         *
         * Note that sheet name in Excel must not exceed 31 characters
         * and must not contain any of the any of the following characters:
         *    - 0x0000
         *    - 0x0003
         *    - colon (:)
         *    - backslash (\)
         *    - asterisk (*)
         *    - question mark (?)
         *    - forward slash (/)
         *    - opening square bracket ([)
         *    - closing square bracket (])
         *
         */
        sheetName: /[\\/\?\*:\[\]'"]/,

        animated: false
    }

};

/**
 * 
 */
var defaultSettings = {

    workbook: {
        activeSheet: '1',
        sheets: [{
            name: '1'
        }]
    },

    persistent: true

};

exports.globalSettings = globalSettings;
exports.defaultSettings = defaultSettings;

},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * 
 *
 * PS: nodejs  Emitter 
 * @constructor
 */
function Emitter() {
    // 
}

Emitter.prototype = {

    /**
     * 
     * @param {string} name - 
     * @param {function} callback - 
     * @param [ctx] -  callback 
     * @returns {Emitter}
     */
    on: function on(name, callback, ctx) {
        var e = this.e || (this.e = {});

        (e[name] || (e[name] = [])).push({
            fn: callback,
            ctx: ctx
        });

        return this;
    },

    /**
     * 
     * @param {string} name - 
     * @param {function} callback - 
     * @param ctx -  callback 
     * @returns {*|Emitter}
     */
    once: function once(name, callback, ctx) {
        var self = this;

        function listener() {
            self.off(name, listener);
            callback.apply(ctx, arguments);
        }

        listener._ = callback;
        return this.on(name, listener, ctx);
    },

    /**
     * 
     * @param {string} name - 
     * @returns {Emitter}
     */
    emit: function emit(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;

        for (i; i < len; i++) {
            evtArr[i].fn.apply(evtArr[i].ctx, data);
        }

        return this;
    },

    /**
     * 
     * @param {string} name - 
     * @param {function} [callback] -  `name` 
     * @returns {Emitter}
     */
    off: function off(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];

        if (evts && callback) {
            for (var i = 0, len = evts.length; i < len; i++) {
                if (evts[i].fn !== callback && evts[i].fn._ !== callback) {
                    liveEvents.push(evts[i]);
                }
            }
        }

        // 
        liveEvents.length ? e[name] = liveEvents : delete e[name];

        return this;
    },

    /**
     * 
     */
    getGlobalEmitter: function () {
        var instance = new Emitter();
        return function () {
            return instance;
        };
    }()
};

exports.default = Emitter;

/**
 * 
 */

var GlobalEmitter = exports.GlobalEmitter = Emitter.prototype.getGlobalEmitter();

},{}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extend = extend;
exports.objectEach = objectEach;
exports.emptyFunction = emptyFunction;
exports.upperCase = upperCase;
exports.upperCaseFirst = upperCaseFirst;
exports.randomString = randomString;
exports.isEmptyValue = isEmptyValue;


// ------------------------------------- object

function extend(target, extension) {
    objectEach(extension, function (value, key) {
        target[key] = value;
    });
    return target;
}

function objectEach(object, iteratee) {
    for (var key in object) {
        if (!object.hasOwnProperty || object.hasOwnProperty && object.hasOwnProperty(key)) {
            if (iteratee(object[key], key, object) === false) {
                break;
            }
        }
    }
    return object;
}

// ------------------------------------- function

var _emptyFn = function _emptyFn() {};

/**
 * 
 * @param newOne  `false` `true` 
 * @returns {Function}
 */
function emptyFunction() {
    var newOne = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (newOne) {
        return function () {};
    }
    return _emptyFn;
}

// ------------------------------------- string


function upperCase(str) {
    return str.toUpperCase();
}

function upperCaseFirst(str) {
    return str.replace(/^\S/g, function (f) {
        return upperCase(f);
    });
}

/**
 *  16 
 * @returns {*}
 */
function randomString() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    return s4() + s4() + s4() + s4();
}

// ------------------------------------- mixed

/**
 * ``
 * PS
 * @param value
 * @returns {boolean}
 */
function isEmptyValue(value) {
    return value === '' || value === null || typeof value === 'undefined';
}

// ------------------------------------- coordinate


var c_isEqual = function c_isEqual(r1, r2) {
    return r1[0] === r2[0] && r1[1] === r2[1] && r1[2] === r2[2] && r1[3] === r2[3];
};

var c_intersection = function c_intersection(r1, r2) {
    var x1 = Math.max(r1[0], r2[0]);
    var y1 = Math.max(r1[1], r2[1]);
    var x2 = Math.min(r1[2], r2[2]);
    var y2 = Math.min(r1[3], r2[3]);

    if (x1 <= x2 && y1 <= y2) {
        return [x1, y1, x2, y2];
    }
    return false;
};

var c_set = function c_set(t) {
    return function (r1, r2) {
        var ins = c_intersection(r1, r2);
        if (ins) {
            return c_isEqual(ins, t === 'sub' ? r1 : r2);
        }
        return false;
    };
};

var Coordinate = exports.Coordinate = {

    /**
     *  r1  r2 
     * @param {Array} r1
     * @param {int} r1[0] -  r1 
     * @param {int} r1[1] -  r1 
     * @param {int} r1[2] -  r1 
     * @param {int} r1[3] -  r1 
     * @param {Array} r2
     * @param {int} r2[0] -  r2 
     * @param {int} r2[1] -  r2 
     * @param {int} r2[2] -  r2 
     * @param {int} r2[3] -  r2 
     * @returns {boolean}
     */
    isEqual: c_isEqual,

    /**
     *  r1  r2 
     * @returns {boolean}
     */
    intersection: c_intersection,

    /**
     *  r1  r2 
     * @returns {boolean}
     */
    isSubset: c_set('sub'),

    /**
     *  r1  r2 
     * @returns {boolean}
     */
    isSuperset: c_set('sup')
};

// -------------------------------------

},{}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stack = exports.CaseInsensitiveMap = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _common = require('./common.js');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  Map
 */
var CaseInsensitiveMap = function () {
    function CaseInsensitiveMap(iterable) {
        _classCallCheck(this, CaseInsensitiveMap);

        this._map = new Map(iterable);
        this._keys = {};
    }

    _createClass(CaseInsensitiveMap, [{
        key: 'get',
        value: function get(key) {
            var acKey = this._keys[(0, _common.upperCase)(key)];
            return this._map.get(acKey);
        }
    }, {
        key: 'set',
        value: function set(key, value) {
            this._keys[(0, _common.upperCase)(key)] = key;
            return this._map.set(key, value);
        }
    }, {
        key: 'has',
        value: function has(key) {
            return this._keys[(0, _common.upperCase)(key)];
        }
    }, {
        key: 'hasExact',
        value: function hasExact(key) {
            return this._map.has(key);
        }
    }, {
        key: 'clear',
        value: function clear() {
            this._keys = {};
            return this._map.clear();
        }
    }, {
        key: 'delete',
        value: function _delete(key) {
            var acKey = this._keys[(0, _common.upperCase)(key)];
            delete this._keys[(0, _common.upperCase)(key)];
            return this._map.delete(acKey);
        }
    }, {
        key: 'entries',
        value: function entries() {
            return this._map.entries();
        }
    }, {
        key: 'forEach',
        value: function forEach(callbackfn, thisArg) {
            return this._map.forEach(callbackfn, thisArg);
        }

        /**
         *
         * @returns {Iterator.<string>}
         */

    }, {
        key: 'keys',
        value: function keys() {
            return this._map.keys();
        }
    }, {
        key: 'values',
        value: function values() {
            return this._map.values();
        }
    }, {
        key: 'toMap',
        value: function toMap() {
            return this._map;
        }
    }, {
        key: 'size',
        value: function size() {
            return this._map.size;
        }
    }]);

    return CaseInsensitiveMap;
}();

/**
 * Stack
 */


var Stack = function () {
    function Stack() {
        var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        _classCallCheck(this, Stack);

        this.items = initial;
    }

    _createClass(Stack, [{
        key: 'push',
        value: function push() {
            var _items;

            (_items = this.items).push.apply(_items, arguments);
        }
    }, {
        key: 'pop',
        value: function pop() {
            return this.items.pop();
        }
    }, {
        key: 'peek',
        value: function peek() {
            return this.isEmpty() ? void 0 : this.items[this.items.length - 1];
        }
    }, {
        key: 'isEmpty',
        value: function isEmpty() {
            return !this.size();
        }
    }, {
        key: 'size',
        value: function size() {
            return this.items.length;
        }
    }]);

    return Stack;
}();

exports.CaseInsensitiveMap = CaseInsensitiveMap;
exports.Stack = Stack;

},{"./common.js":59}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.innerHTML = innerHTML;
exports.insertAfter = insertAfter;
exports.closest = closest;
exports.empty = empty;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
var textContextSupport = document.createTextNode('test').textContent ? true : false;

var REG_HTML_CHARACTERS = /(<(.*)>|&(.*);)/;

/**
 *  innerHTML 
 *
 * @returns {void}
 */
function innerHTML(element, content) {
    if (REG_HTML_CHARACTERS.test(content)) {
        element.innerHTML = content;
    } else {
        var child = element.firstChild;
        if (child && child.nodeType === 3 && child.nextSibling === null) {
            if (textContextSupport) {
                child.textContent = content;
            } else {
                child.data = content;
            }
        } else {
            empty(element);
            element.appendChild(document.createTextNode(content));
        }
    }
}

/**
 * 
 * @param element
 * @param content
 */
function insertAfter(element, content) {
    if (REG_HTML_CHARACTERS.test(content)) {
        element.insertAdjacentHTML('afterend', content);
    } else {
        if (content.nodeType === 1) {
            if (element.nextSibling) {
                element.parentNode.insertBefore(content, element.nextSibling);
            } else {
                element.parentNode.appendChild(content);
            }
        } else {
            // TODO
        }
    }
}

function closest(element, selector) {
    var ret;
    do {
        element = element.parentNode;
        if (!element || !element.ownerDocument || (ret = element.querySelector(selector))) {
            break;
        }
    } while (element);

    return ret;
}

/**
 * 
 *
 * @param element
 * @returns {void}
 */
function empty(element) {
    var child;
    while (child = element.lastChild) {
        // jshint ignore:line
        try {
            element.removeChild(child);
        } catch (e) {
            // TODO  https://bugzilla.mozilla.org/show_bug.cgi?id=559561
        }
    }
}

/**
 *  paddingborder  margin 
 *
 * @param el
 * @param {Boolean} withMargin -  margin 
 * @returns {number}
 */
function outerHeight(el) {
    var withMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var height = el.offsetHeight;
    var style;

    if (withMargin === false) {
        return height;
    }
    style = getComputedStyle(el);
    height += parseInt(style.marginTop) + parseInt(style.marginBottom);
    return height;
}

/**
 *  paddingborder  margin 
 *
 * @param el
 * @param {Boolean} withMargin -  margin 
 * @returns {number}
 */
function outerWidth(el) {
    var withMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    var width = el.offsetWidth;
    var style;

    if (withMargin === false) {
        return width;
    }
    style = getComputedStyle(el);
    width += parseInt(style.marginLeft) + parseInt(style.marginRight);
    return width;
}

},{}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stopImmediatePropagation = stopImmediatePropagation;
exports.stopPropagation = stopPropagation;
/**
 * 
 * @param {Event} event
 */
function stopImmediatePropagation(event) {
    event.isImmediatePropagationEnabled = false;
    event.cancelBubble = true;
}

/**
 * 
 * @param {Event} event
 */
function stopPropagation(event) {
    if (typeof event.stopPropagation === 'function') {
        event.stopPropagation();
    } else {
        event.cancelBubble = true;
    }
}

},{}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var arrayEach = Handsontable.helper.arrayEach;
var defineGetter = Handsontable.helper.defineGetter;

var MIXIN_NAME = 'localHooks';

/**
 *  hooks.
 *
 * @type {Object}
 */
var localHooks = {

    _localHooks: Object.create(null),

    /**
     *  hook
     *
     * @param {string} key - hook 
     * @param {Function} callback - 
     */
    addLocalHook: function addLocalHook(key, callback) {
        if (!this._localHooks[key]) {
            this._localHooks[key] = [];
        }
        this._localHooks[key].push(callback);
    },

    /**
     *  hooks
     *
     * @param {String} key - hook 
     * @param {*} params
     */
    runLocalHooks: function runLocalHooks(key) {
        var _this = this;

        for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
        }

        if (this._localHooks[key]) {
            arrayEach(this._localHooks[key], function (callback) {
                return callback.apply(_this, params);
            });
        }
    },

    /**
     *  hooks
     */
    clearLocalHooks: function clearLocalHooks() {
        this._localHooks = {};
    }
};

defineGetter(localHooks, 'MIXIN_NAME', MIXIN_NAME, {
    writable: false,
    enumerable: false
});

exports.default = localHooks;

},{}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL2Rpc3QvZm9ybXVsYS5qcyIsIm5vZGVfbW9kdWxlcy9mb3JtdWxhanMvbm9kZV9tb2R1bGVzL2pTdGF0L2Rpc3QvanN0YXQuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL25vZGVfbW9kdWxlcy9udW1lcmFsL251bWVyYWwuanMiLCJub2RlX21vZHVsZXMvZm9ybXVsYWpzL25vZGVfbW9kdWxlcy9udW1lcmljL251bWVyaWMtMS4yLjYuanMiLCJzcmMvU3ByZWFkU2hlZXRFcnJvci5qcyIsInNyYy9icm93c2VyLmpzIiwic3JjL2NvcmUuanMiLCJzcmMvZGVzaWduZXIvQ29uZmlnVHJhbnNsYXRvci5qcyIsInNyYy9kZXNpZ25lci9GcmFtZS5qcyIsInNyYy9kZXNpZ25lci9Ib3RUYWJsZUFkYXB0b3IuanMiLCJzcmMvZGVzaWduZXIvU2hlZXQuanMiLCJzcmMvZGVzaWduZXIvU2hlZXRFcnJvci5qcyIsInNyYy9kZXNpZ25lci9Xb3JrYm9vay5qcyIsInNyYy9kZXNpZ25lci9leHQvU2hlZXRfZXhjaGFuZ2UuanMiLCJzcmMvZGVzaWduZXIvZXh0L1NoZWV0X2hlbHBlci5qcyIsInNyYy9kZXNpZ25lci9mcmFtZS9Db250ZXh0TWVudS5qcyIsInNyYy9kZXNpZ25lci9mcmFtZS9Db250ZXh0TWVudV9hbGlnbm1lbnQuanMiLCJzcmMvZGVzaWduZXIvZnJhbWUvQ29udGV4dE1lbnVfbWVyZ2VDZWxscy5qcyIsInNyYy9kZXNpZ25lci9mcmFtZS9Db250ZXh0TWVudV9yb3dPckNvbHVtblJlc2l6ZS5qcyIsInNyYy9kZXNpZ25lci92aWV3cy9UYWJzLmpzIiwic3JjL2kxOG4uanMiLCJzcmMvcGx1Z2lucy9QbHVnaW4uanMiLCJzcmMvcGx1Z2lucy9QbHVnaW5FcnJvci5qcyIsInNyYy9wbHVnaW5zL3BlcnNpc3RlbnQvUGVyc2lzdGVudC5qcyIsInNyYy9wbHVnaW5zL3BlcnNpc3RlbnQvU3RvcmFnZS5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9BbHRlck1hbmFnZXIuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvQmFzZUNlbGwuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvQ2VsbFJlZmVyZW5jZS5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9DZWxsVmFsdWUuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvRGF0YVByb3ZpZGVyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL01hdHJpeC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9TaGVldC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9VbmRvUmVkb1NuYXBzaG90LmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL1hGb3JtdWxhcy5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9leHByZXNzaW9uTW9kaWZpZXIuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL2Vycm9yLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9ncmFtbWFyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9hZGQuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL2FtcGVyc2FuZC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvZGl2aWRlLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9lcXVhbC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvZm9ybXVsYS1mdW5jdGlvbi5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvZ3JlYXRlci10aGFuLW9yLWVxdWFsLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9ncmVhdGVyLXRoYW4uanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL2xlc3MtdGhhbi1vci1lcXVhbC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvbGVzcy10aGFuLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9vcGVyYXRvci9taW51cy5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvbXVsdGlwbHkuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9yL25vdC1lcXVhbC5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvb3BlcmF0b3IvcG93ZXIuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL29wZXJhdG9ycy5qcyIsInNyYy9wbHVnaW5zL3hmb3JtdWxhcy9wYXJzZXIvcGFyc2VyLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3BhcnNlci9zdXBwb3J0ZWQtZm9ybXVsYXMuanMiLCJzcmMvcGx1Z2lucy94Zm9ybXVsYXMvcGFyc2VyL3V0aWxzLmpzIiwic3JjL3BsdWdpbnMveGZvcm11bGFzL3V0aWxzLmpzIiwic3JjL3BvbHlmaWxsLmpzIiwic3JjL3NldHRpbmdzLmpzIiwic3JjL3V0aWxzL0VtaXR0ZXIuanMiLCJzcmMvdXRpbHMvY29tbW9uLmpzIiwic3JjL3V0aWxzL2RhdGFTdHJ1Y3R1cmUuanMiLCJzcmMvdXRpbHMvZG9tSGVscGVyLmpzIiwic3JjL3V0aWxzL2V2ZW50SGVscGVyLmpzIiwic3JjL3V0aWxzL2xvY2FsSG9va3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUEzQixDQUFUOztBQUVSO0FBQ0EscUJBQUssQ0FBTDs7QUFFUSx5QkFBSyxDQUFMLEdBQVMsR0FBRyxrQkFBSCxDQUFzQixHQUF0QixFQUEyQixDQUFDLEdBQUcsS0FBRyxDQUFOLENBQUQsRUFBVyxHQUFHLEVBQUgsQ0FBWCxDQUEzQixDQUFUOztBQUVSO0FBQ0EscUJBQUssQ0FBTDs7QUFFUSx5QkFBSyxDQUFMLEdBQVMsR0FBRyxrQkFBSCxDQUFzQixHQUF0QixFQUEyQixDQUFDLEdBQUcsS0FBRyxDQUFOLENBQUQsRUFBVyxHQUFHLEVBQUgsQ0FBWCxDQUEzQixDQUFUOztBQUVSO0FBQ0EscUJBQUssQ0FBTDs7QUFFUSx5QkFBSyxDQUFMLEdBQVMsR0FBRyxRQUFILENBQVksR0FBRyxLQUFHLENBQU4sQ0FBWixDQUFUOztBQUVSO0FBQ0EscUJBQUssQ0FBTDs7QUFFUSx5QkFBSyxDQUFMLEdBQVMsR0FBRyxrQkFBSCxDQUFzQixJQUF0QixFQUE0QixDQUFDLEdBQUcsS0FBRyxDQUFOLENBQUQsRUFBVyxHQUFHLEVBQUgsQ0FBWCxDQUE1QixDQUFUOztBQUVSO0FBQ0EscUJBQUssRUFBTDs7QUFFUSx5QkFBSyxDQUFMLEdBQVMsR0FBRyxrQkFBSCxDQUFzQixJQUF0QixFQUE0QixDQUFDLEdBQUcsS0FBRyxDQUFOLENBQUQsRUFBVyxHQUFHLEVBQUgsQ0FBWCxDQUE1QixDQUFUOztBQUVSO0FBQ0EscUJBQUssRUFBTDs7QUFFUSx5QkFBSyxDQUFMLEdBQVMsR0FBRyxrQkFBSCxDQUFzQixJQUF0QixFQUE0QixDQUFDLEdBQUcsS0FBRyxDQUFOLENBQUQsRUFBVyxHQUFHLEVBQUgsQ0FBWCxDQUE1QixDQUFUOztBQUVSO0FBQ0EscUJBQUssRUFBTDs7QUFFUSx5QkFBSyxDQUFMLEdBQVMsR0FBRyxrQkFBSCxDQUFzQixLQUF0QixFQUE2QixDQUFDLEdBQUcsS0FBRyxDQUFOLENBQUQsRUFBVyxHQUFHLEVBQUgsQ0FBWCxDQUE3QixDQUFUOztBQUVSO0FBQ0EscUJBQUssRUFBTDs7QUFFUSx5QkFB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K0JBQU8sRUFBUDtBQUNQO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQ0E7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sQ0FBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEdBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEVBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxFQUFQO0FBQ1I7QUFDQSx5QkFBSyxFQUFMO0FBQVEsK0JBQU8sRUFBUDtBQUNSO0FBQ0EseUJBQUssRUFBTDtBQUFRLCtCQUFPLEdBQVA7QUFDUjtBQUNBLHlCQUFLLEVBQUw7QUFBUSwrQkFBTyxHQUFQO0FBQ1I7QUFDQSx5QkFBSyxF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ekx5QixFQTBMekIsU0ExTHlCLEVBMkx6QixRQTNMeUIsRUE0THpCLFdBNUx5QixFQTZMekIsV0E3THlCLEVBOEx6QixVQTlMeUIsRUErTHpCLE9BL0x5QixFQWdNekIsT0FoTXlCLEVBaU16QixZQWpNeUIsRUFrTXpCLE9BbE15QixFQW1NekIsUUFuTXlCLEVBb016QixNQXBNeUIsRUFxTXpCLE1Bck15QixFQXNNekIsT0F0TXlCLEVBdU16QixLQXZNeUIsRUF3TXpCLE1BeE15QixFQXlNekIsS0F6TXlCLEVBME16QixRQTFNeUIsRUEyTXpCLElBM015QixFQTRNekIsS0E1TXlCLEVBNk16QixPQTdNeUIsRUE4TXpCLFFBOU15QixFQStNekIsY0EvTXlCLEVBZ056QixhQWhOeUIsRUFpTnpCLGFBak55QixFQWtOekIsWUFsTnlCLEVBbU56QixPQW5OeUIsRUFvTnpCLElBcE55QixFQXFOekIsS0FyTnlCLEVBc056QixPQXROeUIsRUF1TnpCLEtBdk55QixFQXdOekIsTUF4TnlCLEVBeU56QixRQXpOeUIsRUEwTnpCLEtBMU55QixFQTJOekIsS0EzTnlCLEVBNE56QixNQTVOeUIsRUE2TnpCLE9BN055QixFQThOekIsUUE5TnlCLEVBK056QixNQS9OeUIsRUFnT3pCLEtBaE95QixFQWlPekIsV0FqT3lCLEVBa096QixXQWxPeUIsRUFtT3pCLFVBbk95QixFQW9PekIsVUFwT3lCLEVBcU96QixPQXJPeUIsRUFzT3pCLFFBdE95QixFQXVPekIsYUF2T3lCLEVBd096QixVQXhPeUIsRUF5T3pCLElBek95QixFQTBPekIsZUExT3lCLEVBMk96QixjQTNPeUIsRUE0T3pCLGFBNU95QixFQTZPekIsU0E3T3lCLEVBOE96QixXQTlPeUIsRUErT3pCLFVBL095QixFQWdQekIsYUFoUHlCLEVBaVB6QixZQWpQeUIsRUFrUHpCLFVBbFB5QixFQW1QekIsU0FuUHlCLEVBb1B6QixXQXBQeUIsRUFxUHpCLFVBclB5QixFQXNQekIsS0F0UHlCLEVBdVB6QixLQXZQeUIsRUF3UHpCLE1BeFB5QixFQXlQekIsS0F6UHlC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QWpCLElBQXdCLEVBQXhCO0FBQ0g7QUFDRCxhQUFLLFdBQUwsQ0FBaUIsR0FBakIsRUFBc0IsSUFBdEIsQ0FBMkIsUUFBM0I7QUFDSCxLQWZjOztBQWlCZjs7Ozs7O0FBTUEsbUJBQWUsdUJBQVUsR0FBVixFQUEwQjtBQUFBOztBQUFBLDBDQUFSLE1BQVE7QUFBUixrQkFBUTtBQUFBOztBQUNyQyxZQUFJLEtBQUssV0FBTCxDQUFpQixHQUFqQixDQUFKLEVBQTJCO0FBQ3ZCLHNCQUFVLEtBQUssV0FBTCxDQUFpQixHQUFqQixDQUFWLEVBQWlDLFVBQUMsUUFBRDtBQUFBLHVCQUFjLFNBQVMsS0FBVCxRQUFxQixNQUFyQixDQUFkO0FBQUEsYUFBakM7QUFDSDtBQUNKLEtBM0JjOztBQTZCZjs7O0FBR0EscUJBQWlCLDJCQUFZO0FBQ3pCLGFBQUssV0FBTCxHQUFtQixFQUFuQjtBQUNIO0FBbENjLENBQW5COztBQXFDQSxhQUFhLFVBQWIsRUFBeUIsWUFBekIsRUFBdUMsVUFBdkMsRUFBbUQ7QUFDL0MsY0FBVSxLQURxQztBQUUvQyxnQkFBWTtBQUZtQyxDQUFuRDs7a0JBS2UsVSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJudW1lcmljXCIpLCByZXF1aXJlKFwibnVtZXJhbFwiKSwgcmVxdWlyZShcImpTdGF0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcIm51bWVyaWNcIiwgXCJudW1lcmFsXCIsIFwialN0YXRcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZm9ybXVsYWpzXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibnVtZXJpY1wiKSwgcmVxdWlyZShcIm51bWVyYWxcIiksIHJlcXVpcmUoXCJqU3RhdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiZm9ybXVsYWpzXCJdID0gZmFjdG9yeShyb290W1wibnVtZXJpY1wiXSwgcm9vdFtcIm51bWVyYWxcIl0sIHJvb3RbXCJqU3RhdFwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBjYXRlZ29yaWVzID0gW1xuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMSksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxMiksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTQpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTcpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTEpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oMTgpLFxuXHQgIF9fd2VicGFja19yZXF1aXJlX18oNiksXG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXygxMClcblx0XTtcblxuXHRmb3IgKHZhciBjIGluIGNhdGVnb3JpZXMpIHtcblx0ICB2YXIgY2F0ZWdvcnkgPSBjYXRlZ29yaWVzW2NdO1xuXHQgIGZvciAodmFyIGYgaW4gY2F0ZWdvcnkpIHtcblx0ICAgIGV4cG9ydHNbZl0gPSBleHBvcnRzW2ZdIHx8IGNhdGVnb3J5W2ZdO1xuXHQgIH1cblx0fVxuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgbWF0aFRyaWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgc3RhdGlzdGljYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgZW5naW5lZXJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0dmFyIGRhdGVUaW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cblx0ZnVuY3Rpb24gc2V0KGZuLCByb290KSB7XG5cdCAgaWYgKHJvb3QpIHtcblx0ICAgIGZvciAodmFyIGkgaW4gcm9vdCkge1xuXHQgICAgICBmbltpXSA9IHJvb3RbaV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBmbjtcblx0fVxuXG5cdGV4cG9ydHMuQkVUQURJU1QgPSBzdGF0aXN0aWNhbC5CRVRBLkRJU1Q7XG5cdGV4cG9ydHMuQkVUQUlOViA9IHN0YXRpc3RpY2FsLkJFVEEuSU5WO1xuXHRleHBvcnRzLkJJTk9NRElTVCA9IHN0YXRpc3RpY2FsLkJJTk9NLkRJU1Q7XG5cdGV4cG9ydHMuQ0VJTElORyA9IGV4cG9ydHMuSVNPQ0VJTElORyA9IHNldChtYXRoVHJpZy5DRUlMSU5HLk1BVEgsIG1hdGhUcmlnLkNFSUxJTkcpO1xuXHRleHBvcnRzLkNFSUxJTkdNQVRIID0gbWF0aFRyaWcuQ0VJTElORy5NQVRIO1xuXHRleHBvcnRzLkNFSUxJTkdQUkVDSVNFID0gbWF0aFRyaWcuQ0VJTElORy5QUkVDSVNFO1xuXHRleHBvcnRzLkNISURJU1QgPSBzdGF0aXN0aWNhbC5DSElTUS5ESVNUO1xuXHRleHBvcnRzLkNISURJU1RSVCA9IHN0YXRpc3RpY2FsLkNISVNRLkRJU1QuUlQ7XG5cdGV4cG9ydHMuQ0hJSU5WID0gc3RhdGlzdGljYWwuQ0hJU1EuSU5WO1xuXHRleHBvcnRzLkNISUlOVlJUID0gc3RhdGlzdGljYWwuQ0hJU1EuSU5WLlJUO1xuXHRleHBvcnRzLkNISVRFU1QgPSBzdGF0aXN0aWNhbC5DSElTUS5URVNUO1xuXHRleHBvcnRzLkNPTkZJREVOQ0UgPSBzZXQoc3RhdGlzdGljYWwuQ09ORklERU5DRS5OT1JNLCBzdGF0aXN0aWNhbC5DT05GSURFTkNFKTtcblx0ZXhwb3J0cy5DT1ZBUiA9IHN0YXRpc3RpY2FsLkNPVkFSSUFOQ0UuUDtcblx0ZXhwb3J0cy5DT1ZBUklBTkNFUCA9IHN0YXRpc3RpY2FsLkNPVkFSSUFOQ0UuUDtcblx0ZXhwb3J0cy5DT1ZBUklBTkNFUyA9IHN0YXRpc3RpY2FsLkNPVkFSSUFOQ0UuUztcblx0ZXhwb3J0cy5DUklUQklOT00gPSBzdGF0aXN0aWNhbC5CSU5PTS5JTlY7XG5cdGV4cG9ydHMuRVhQT05ESVNUID0gc3RhdGlzdGljYWwuRVhQT04uRElTVDtcblx0ZXhwb3J0cy5FUkZDUFJFQ0lTRSA9IGVuZ2luZWVyaW5nLkVSRkMuUFJFQ0lTRTtcblx0ZXhwb3J0cy5FUkZQUkVDSVNFID0gZW5naW5lZXJpbmcuRVJGLlBSRUNJU0U7XG5cdGV4cG9ydHMuRkRJU1QgPSBzdGF0aXN0aWNhbC5GLkRJU1Q7XG5cdGV4cG9ydHMuRkRJU1RSVCA9IHN0YXRpc3RpY2FsLkYuRElTVC5SVDtcblx0ZXhwb3J0cy5GSU5WUlQgPSBzdGF0aXN0aWNhbC5GLklOVi5SVDtcblx0ZXhwb3J0cy5GSU5WID0gc3RhdGlzdGljYWwuRi5JTlY7XG5cdGV4cG9ydHMuRkxPT1IgPSBzZXQobWF0aFRyaWcuRkxPT1IuTUFUSCwgbWF0aFRyaWcuRkxPT1IpO1xuXHRleHBvcnRzLkZMT09STUFUSCA9IG1hdGhUcmlnLkZMT09SLk1BVEg7XG5cdGV4cG9ydHMuRkxPT1JQUkVDSVNFID0gbWF0aFRyaWcuRkxPT1IuUFJFQ0lTRTtcblx0ZXhwb3J0cy5GVEVTVCA9IHN0YXRpc3RpY2FsLkYuVEVTVDtcblx0ZXhwb3J0cy5HQU1NQURJU1QgPSBzdGF0aXN0aWNhbC5HQU1NQS5ESVNUO1xuXHRleHBvcnRzLkdBTU1BSU5WID0gc3RhdGlzdGljYWwuR0FNTUEuSU5WO1xuXHRleHBvcnRzLkdBTU1BTE5QUkVDSVNFID0gc3RhdGlzdGljYWwuR0FNTUFMTi5QUkVDSVNFO1xuXHRleHBvcnRzLkhZUEdFT01ESVNUID0gc3RhdGlzdGljYWwuSFlQR0VPTS5ESVNUO1xuXHRleHBvcnRzLkxPR0lOViA9IHN0YXRpc3RpY2FsLkxPR05PUk0uSU5WO1xuXHRleHBvcnRzLkxPR05PUk1JTlYgPSBzdGF0aXN0aWNhbC5MT0dOT1JNLklOVjtcblx0ZXhwb3J0cy5MT0dOT1JNRElTVCA9IHN0YXRpc3RpY2FsLkxPR05PUk0uRElTVDtcblx0ZXhwb3J0cy5NT0RFID0gc2V0KHN0YXRpc3RpY2FsLk1PREUuU05HTCwgc3RhdGlzdGljYWwuTU9ERSk7XG5cdGV4cG9ydHMuTU9ERU1VTFQgPSBzdGF0aXN0aWNhbC5NT0RFLk1VTFQ7XG5cdGV4cG9ydHMuTU9ERVNOR0wgPSBzdGF0aXN0aWNhbC5NT0RFLlNOR0w7XG5cdGV4cG9ydHMuTkVHQklOT01ESVNUID0gc3RhdGlzdGljYWwuTkVHQklOT00uRElTVDtcblx0ZXhwb3J0cy5ORVRXT1JLREFZU0lOVEwgPSBkYXRlVGltZS5ORVRXT1JLREFZUy5JTlRMO1xuXHRleHBvcnRzLk5PUk1ESVNUID0gc3RhdGlzdGljYWwuTk9STS5ESVNUO1xuXHRleHBvcnRzLk5PUk1JTlYgPSBzdGF0aXN0aWNhbC5OT1JNLklOVjtcblx0ZXhwb3J0cy5OT1JNU0RJU1QgPSBzdGF0aXN0aWNhbC5OT1JNLlMuRElTVDtcblx0ZXhwb3J0cy5OT1JNU0lOViA9IHN0YXRpc3RpY2FsLk5PUk0uUy5JTlY7XG5cdGV4cG9ydHMuUEVSQ0VOVElMRSA9IHNldChzdGF0aXN0aWNhbC5QRVJDRU5USUxFLkVYQywgc3RhdGlzdGljYWwuUEVSQ0VOVElMRSk7XG5cdGV4cG9ydHMuUEVSQ0VOVElMRUVYQyA9IHN0YXRpc3RpY2FsLlBFUkNFTlRJTEUuRVhDO1xuXHRleHBvcnRzLlBFUkNFTlRJTEVJTkMgPSBzdGF0aXN0aWNhbC5QRVJDRU5USUxFLklOQztcblx0ZXhwb3J0cy5QRVJDRU5UUkFOSyA9IHNldChzdGF0aXN0aWNhbC5QRVJDRU5UUkFOSy5JTkMsIHN0YXRpc3RpY2FsLlBFUkNFTlRSQU5LKTtcblx0ZXhwb3J0cy5QRVJDRU5UUkFOS0VYQyA9IHN0YXRpc3RpY2FsLlBFUkNFTlRSQU5LLkVYQztcblx0ZXhwb3J0cy5QRVJDRU5UUkFOS0lOQyA9IHN0YXRpc3RpY2FsLlBFUkNFTlRSQU5LLklOQztcblx0ZXhwb3J0cy5QT0lTU09OID0gc2V0KHN0YXRpc3RpY2FsLlBPSVNTT04uRElTVCwgc3RhdGlzdGljYWwuUE9JU1NPTik7XG5cdGV4cG9ydHMuUE9JU1NPTkRJU1QgPSBzdGF0aXN0aWNhbC5QT0lTU09OLkRJU1Q7XG5cdGV4cG9ydHMuUVVBUlRJTEUgPSBzZXQoc3RhdGlzdGljYWwuUVVBUlRJTEUuSU5DLCBzdGF0aXN0aWNhbC5RVUFSVElMRSk7XG5cdGV4cG9ydHMuUVVBUlRJTEVFWEMgPSBzdGF0aXN0aWNhbC5RVUFSVElMRS5FWEM7XG5cdGV4cG9ydHMuUVVBUlRJTEVJTkMgPSBzdGF0aXN0aWNhbC5RVUFSVElMRS5JTkM7XG5cdGV4cG9ydHMuUkFOSyA9IHNldChzdGF0aXN0aWNhbC5SQU5LLkVRLCBzdGF0aXN0aWNhbC5SQU5LKTtcblx0ZXhwb3J0cy5SQU5LQVZHID0gc3RhdGlzdGljYWwuUkFOSy5BVkc7XG5cdGV4cG9ydHMuUkFOS0VRID0gc3RhdGlzdGljYWwuUkFOSy5FUTtcblx0ZXhwb3J0cy5TS0VXUCA9IHN0YXRpc3RpY2FsLlNLRVcuUDtcblx0ZXhwb3J0cy5TVERFViA9IHNldChzdGF0aXN0aWNhbC5TVERFVi5TLCBzdGF0aXN0aWNhbC5TVERFVik7XG5cdGV4cG9ydHMuU1RERVZQID0gc3RhdGlzdGljYWwuU1RERVYuUDtcblx0ZXhwb3J0cy5TVERFVlMgPSBzdGF0aXN0aWNhbC5TVERFVi5TO1xuXHRleHBvcnRzLlRESVNUID0gc3RhdGlzdGljYWwuVC5ESVNUO1xuXHRleHBvcnRzLlRESVNUUlQgPSBzdGF0aXN0aWNhbC5ULkRJU1QuUlQ7XG5cdGV4cG9ydHMuVElOViA9IHN0YXRpc3RpY2FsLlQuSU5WO1xuXHRleHBvcnRzLlRURVNUID0gc3RhdGlzdGljYWwuVC5URVNUO1xuXHRleHBvcnRzLlZBUiA9IHNldChzdGF0aXN0aWNhbC5WQVIuUywgc3RhdGlzdGljYWwuVkFSKTtcblx0ZXhwb3J0cy5WQVJQID0gc3RhdGlzdGljYWwuVkFSLlA7XG5cdGV4cG9ydHMuVkFSUyA9IHN0YXRpc3RpY2FsLlZBUi5TO1xuXHRleHBvcnRzLldFSUJVTEwgPSBzZXQoc3RhdGlzdGljYWwuV0VJQlVMTC5ESVNULCBzdGF0aXN0aWNhbC5XRUlCVUxMKTtcblx0ZXhwb3J0cy5XRUlCVUxMRElTVCA9IHN0YXRpc3RpY2FsLldFSUJVTEwuRElTVDtcblx0ZXhwb3J0cy5XT1JLREFZSU5UTCA9IGRhdGVUaW1lLldPUktEQVkuSU5UTDtcblx0ZXhwb3J0cy5aVEVTVCA9IHN0YXRpc3RpY2FsLlouVEVTVDtcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIG51bWVyaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgc3RhdGlzdGljYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHR2YXIgaW5mb3JtYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHRleHBvcnRzLkFCUyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hYnModXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5BQ09TID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmFjb3MobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkFDT1NIID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZyhudW1iZXIgKyBNYXRoLnNxcnQobnVtYmVyICogbnVtYmVyIC0gMSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQUNPVCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hdGFuKDEgLyBudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQUNPVEggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDAuNSAqIE1hdGgubG9nKChudW1iZXIgKyAxKSAvIChudW1iZXIgLSAxKSk7XG5cdH07XG5cblx0Ly9UT0RPOiB1c2Ugb3B0aW9uc1xuXHRleHBvcnRzLkFHR1JFR0FURSA9IGZ1bmN0aW9uKGZ1bmN0aW9uX251bSwgb3B0aW9ucywgcmVmMSwgcmVmMikge1xuXHQgIGZ1bmN0aW9uX251bSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1bmN0aW9uX251bSk7XG5cdCAgb3B0aW9ucyA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1bmN0aW9uX251bSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZnVuY3Rpb25fbnVtLCBvcHRpb25zKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBzd2l0Y2ggKGZ1bmN0aW9uX251bSkge1xuXHQgICAgY2FzZSAxOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQVZFUkFHRShyZWYxKTtcblx0ICAgIGNhc2UgMjpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkNPVU5UKHJlZjEpO1xuXHQgICAgY2FzZSAzOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlRBKHJlZjEpO1xuXHQgICAgY2FzZSA0OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUFYKHJlZjEpO1xuXHQgICAgY2FzZSA1OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTUlOKHJlZjEpO1xuXHQgICAgY2FzZSA2OlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QUk9EVUNUKHJlZjEpO1xuXHQgICAgY2FzZSA3OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU1RERVYuUyhyZWYxKTtcblx0ICAgIGNhc2UgODpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNUREVWLlAocmVmMSk7XG5cdCAgICBjYXNlIDk6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlNVTShyZWYxKTtcblx0ICAgIGNhc2UgMTA6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5WQVIuUyhyZWYxKTtcblx0ICAgIGNhc2UgMTE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5WQVIuUChyZWYxKTtcblx0ICAgIGNhc2UgMTI6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NRURJQU4ocmVmMSk7XG5cdCAgICBjYXNlIDEzOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuTU9ERS5TTkdMKHJlZjEpO1xuXHQgICAgY2FzZSAxNDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLkxBUkdFKHJlZjEsIHJlZjIpO1xuXHQgICAgY2FzZSAxNTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlNNQUxMKHJlZjEsIHJlZjIpO1xuXHQgICAgY2FzZSAxNjpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlBFUkNFTlRJTEUuSU5DKHJlZjEsIHJlZjIpO1xuXHQgICAgY2FzZSAxNzpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlFVQVJUSUxFLklOQyhyZWYxLCByZWYyKTtcblx0ICAgIGNhc2UgMTg6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5QRVJDRU5USUxFLkVYQyhyZWYxLCByZWYyKTtcblx0ICAgIGNhc2UgMTk6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5RVUFSVElMRS5FWEMocmVmMSwgcmVmMik7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQVJBQklDID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIC8vIENyZWRpdHM6IFJhZmE/IEt1a2F3c2tpXG5cdCAgaWYgKCEvXk0qKD86RD9DezAsM318Q1tNRF0pKD86TD9YezAsM318WFtDTF0pKD86Vj9JezAsM318SVtYVl0pJC8udGVzdCh0ZXh0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgciA9IDA7XG5cdCAgdGV4dC5yZXBsYWNlKC9bTURMVl18Q1tNRF0/fFhbQ0xdP3xJW1hWXT8vZywgZnVuY3Rpb24oaSkge1xuXHQgICAgciArPSB7XG5cdCAgICAgIE06IDEwMDAsXG5cdCAgICAgIENNOiA5MDAsXG5cdCAgICAgIEQ6IDUwMCxcblx0ICAgICAgQ0Q6IDQwMCxcblx0ICAgICAgQzogMTAwLFxuXHQgICAgICBYQzogOTAsXG5cdCAgICAgIEw6IDUwLFxuXHQgICAgICBYTDogNDAsXG5cdCAgICAgIFg6IDEwLFxuXHQgICAgICBJWDogOSxcblx0ICAgICAgVjogNSxcblx0ICAgICAgSVY6IDQsXG5cdCAgICAgIEk6IDFcblx0ICAgIH1baV07XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblx0ZXhwb3J0cy5BU0lOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmFzaW4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkFTSU5IID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZyhudW1iZXIgKyBNYXRoLnNxcnQobnVtYmVyICogbnVtYmVyICsgMSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQVRBTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5hdGFuKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5BVEFOMiA9IGZ1bmN0aW9uKG51bWJlcl94LCBudW1iZXJfeSkge1xuXHQgIG51bWJlcl94ID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX3gpO1xuXHQgIG51bWJlcl95ID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX3kpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlcl94LCBudW1iZXJfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguYXRhbjIobnVtYmVyX3gsIG51bWJlcl95KTtcblx0fTtcblxuXHRleHBvcnRzLkFUQU5IID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmxvZygoMSArIG51bWJlcikgLyAoMSAtIG51bWJlcikpIC8gMjtcblx0fTtcblxuXHRleHBvcnRzLkJBU0UgPSBmdW5jdGlvbihudW1iZXIsIHJhZGl4LCBtaW5fbGVuZ3RoKSB7XG5cdCAgbWluX2xlbmd0aCA9IG1pbl9sZW5ndGggfHwgMDtcblxuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgcmFkaXggPSB1dGlscy5wYXJzZU51bWJlcihyYWRpeCk7XG5cdCAgbWluX2xlbmd0aCA9IHV0aWxzLnBhcnNlTnVtYmVyKG1pbl9sZW5ndGgpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgcmFkaXgsIG1pbl9sZW5ndGgpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIG1pbl9sZW5ndGggPSAobWluX2xlbmd0aCA9PT0gdW5kZWZpbmVkKSA/IDAgOiBtaW5fbGVuZ3RoO1xuXHQgIHZhciByZXN1bHQgPSBudW1iZXIudG9TdHJpbmcocmFkaXgpO1xuXHQgIHJldHVybiBuZXcgQXJyYXkoTWF0aC5tYXgobWluX2xlbmd0aCArIDEgLSByZXN1bHQubGVuZ3RoLCAwKSkuam9pbignMCcpICsgcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0VJTElORyA9IGZ1bmN0aW9uKG51bWJlciwgc2lnbmlmaWNhbmNlLCBtb2RlKSB7XG5cdCAgc2lnbmlmaWNhbmNlID0gKHNpZ25pZmljYW5jZSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBNYXRoLmFicyhzaWduaWZpY2FuY2UpO1xuXHQgIG1vZGUgPSBtb2RlIHx8IDA7XG5cblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNpZ25pZmljYW5jZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNpZ25pZmljYW5jZSk7XG5cdCAgbW9kZSA9IHV0aWxzLnBhcnNlTnVtYmVyKG1vZGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2lnbmlmaWNhbmNlLCBtb2RlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoc2lnbmlmaWNhbmNlID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cdCAgdmFyIHByZWNpc2lvbiA9IC1NYXRoLmZsb29yKE1hdGgubG9nKHNpZ25pZmljYW5jZSkgLyBNYXRoLmxvZygxMCkpO1xuXHQgIGlmIChudW1iZXIgPj0gMCkge1xuXHQgICAgcmV0dXJuIGV4cG9ydHMuUk9VTkQoTWF0aC5jZWlsKG51bWJlciAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmIChtb2RlID09PSAwKSB7XG5cdCAgICAgIHJldHVybiAtZXhwb3J0cy5ST1VORChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikgLyBzaWduaWZpY2FuY2UpICogc2lnbmlmaWNhbmNlLCBwcmVjaXNpb24pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIC1leHBvcnRzLlJPVU5EKE1hdGguY2VpbChNYXRoLmFicyhudW1iZXIpIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5DRUlMSU5HLk1BVEggPSBleHBvcnRzLkNFSUxJTkc7XG5cblx0ZXhwb3J0cy5DRUlMSU5HLlBSRUNJU0UgPSBleHBvcnRzLkNFSUxJTkc7XG5cblx0ZXhwb3J0cy5DT01CSU4gPSBmdW5jdGlvbihudW1iZXIsIG51bWJlcl9jaG9zZW4pIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIG51bWJlcl9jaG9zZW4gPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXJfY2hvc2VuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIG51bWJlcl9jaG9zZW4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBleHBvcnRzLkZBQ1QobnVtYmVyKSAvIChleHBvcnRzLkZBQ1QobnVtYmVyX2Nob3NlbikgKiBleHBvcnRzLkZBQ1QobnVtYmVyIC0gbnVtYmVyX2Nob3NlbikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09NQklOQSA9IGZ1bmN0aW9uKG51bWJlciwgbnVtYmVyX2Nob3Nlbikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgbnVtYmVyX2Nob3NlbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcl9jaG9zZW4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgbnVtYmVyX2Nob3NlbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChudW1iZXIgPT09IDAgJiYgbnVtYmVyX2Nob3NlbiA9PT0gMCkgPyAxIDogZXhwb3J0cy5DT01CSU4obnVtYmVyICsgbnVtYmVyX2Nob3NlbiAtIDEsIG51bWJlciAtIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09TID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmNvcyhudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09TSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gKE1hdGguZXhwKG51bWJlcikgKyBNYXRoLmV4cCgtbnVtYmVyKSkgLyAyO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09UID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAxIC8gTWF0aC50YW4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkNPVEggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgdmFyIGUyID0gTWF0aC5leHAoMiAqIG51bWJlcik7XG5cdCAgcmV0dXJuIChlMiArIDEpIC8gKGUyIC0gMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5DU0MgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDEgLyBNYXRoLnNpbihudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ1NDSCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gMiAvIChNYXRoLmV4cChudW1iZXIpIC0gTWF0aC5leHAoLW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuREVDSU1BTCA9IGZ1bmN0aW9uKG51bWJlciwgcmFkaXgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblxuXHQgIHJldHVybiBwYXJzZUludChudW1iZXIsIHJhZGl4KTtcblx0fTtcblxuXHRleHBvcnRzLkRFR1JFRVMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWJlciAqIDE4MCAvIE1hdGguUEk7XG5cdH07XG5cblx0ZXhwb3J0cy5FVkVOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBleHBvcnRzLkNFSUxJTkcobnVtYmVyLCAtMiwgLTEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVhQID0gTWF0aC5leHA7XG5cblx0dmFyIE1FTU9JWkVEX0ZBQ1QgPSBbXTtcblx0ZXhwb3J0cy5GQUNUID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHZhciBuID0gTWF0aC5mbG9vcihudW1iZXIpO1xuXHQgIGlmIChuID09PSAwIHx8IG4gPT09IDEpIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH0gZWxzZSBpZiAoTUVNT0laRURfRkFDVFtuXSA+IDApIHtcblx0ICAgIHJldHVybiBNRU1PSVpFRF9GQUNUW25dO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBNRU1PSVpFRF9GQUNUW25dID0gZXhwb3J0cy5GQUNUKG4gLSAxKSAqIG47XG5cdCAgICByZXR1cm4gTUVNT0laRURfRkFDVFtuXTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5GQUNURE9VQkxFID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHZhciBuID0gTWF0aC5mbG9vcihudW1iZXIpO1xuXHQgIGlmIChuIDw9IDApIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gbiAqIGV4cG9ydHMuRkFDVERPVUJMRShuIC0gMik7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuRkxPT1IgPSBmdW5jdGlvbihudW1iZXIsIHNpZ25pZmljYW5jZSkge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgc2lnbmlmaWNhbmNlID0gdXRpbHMucGFyc2VOdW1iZXIoc2lnbmlmaWNhbmNlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHNpZ25pZmljYW5jZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHNpZ25pZmljYW5jZSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgaWYgKCEobnVtYmVyID4gMCAmJiBzaWduaWZpY2FuY2UgPiAwKSAmJiAhKG51bWJlciA8IDAgJiYgc2lnbmlmaWNhbmNlIDwgMCkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgc2lnbmlmaWNhbmNlID0gTWF0aC5hYnMoc2lnbmlmaWNhbmNlKTtcblx0ICB2YXIgcHJlY2lzaW9uID0gLU1hdGguZmxvb3IoTWF0aC5sb2coc2lnbmlmaWNhbmNlKSAvIE1hdGgubG9nKDEwKSk7XG5cdCAgaWYgKG51bWJlciA+PSAwKSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5ST1VORChNYXRoLmZsb29yKG51bWJlciAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiAtZXhwb3J0cy5ST1VORChNYXRoLmNlaWwoTWF0aC5hYnMobnVtYmVyKSAvIHNpZ25pZmljYW5jZSksIHByZWNpc2lvbik7XG5cdCAgfVxuXHR9O1xuXG5cdC8vVE9ETzogVmVyaWZ5XG5cdGV4cG9ydHMuRkxPT1IuTUFUSCA9IGZ1bmN0aW9uKG51bWJlciwgc2lnbmlmaWNhbmNlLCBtb2RlKSB7XG5cdCAgc2lnbmlmaWNhbmNlID0gKHNpZ25pZmljYW5jZSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBzaWduaWZpY2FuY2U7XG5cdCAgbW9kZSA9IChtb2RlID09PSB1bmRlZmluZWQpID8gMCA6IG1vZGU7XG5cblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNpZ25pZmljYW5jZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNpZ25pZmljYW5jZSk7XG5cdCAgbW9kZSA9IHV0aWxzLnBhcnNlTnVtYmVyKG1vZGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2lnbmlmaWNhbmNlLCBtb2RlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoc2lnbmlmaWNhbmNlID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICBzaWduaWZpY2FuY2UgPSBzaWduaWZpY2FuY2UgPyBNYXRoLmFicyhzaWduaWZpY2FuY2UpIDogMTtcblx0ICB2YXIgcHJlY2lzaW9uID0gLU1hdGguZmxvb3IoTWF0aC5sb2coc2lnbmlmaWNhbmNlKSAvIE1hdGgubG9nKDEwKSk7XG5cdCAgaWYgKG51bWJlciA+PSAwKSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5ST1VORChNYXRoLmZsb29yKG51bWJlciAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdCAgfSBlbHNlIGlmIChtb2RlID09PSAwIHx8IG1vZGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIC1leHBvcnRzLlJPVU5EKE1hdGguY2VpbChNYXRoLmFicyhudW1iZXIpIC8gc2lnbmlmaWNhbmNlKSAqIHNpZ25pZmljYW5jZSwgcHJlY2lzaW9uKTtcblx0ICB9XG5cdCAgcmV0dXJuIC1leHBvcnRzLlJPVU5EKE1hdGguZmxvb3IoTWF0aC5hYnMobnVtYmVyKSAvIHNpZ25pZmljYW5jZSkgKiBzaWduaWZpY2FuY2UsIHByZWNpc2lvbik7XG5cdH07XG5cblx0Ly8gRGVwcmVjYXRlZFxuXHRleHBvcnRzLkZMT09SLlBSRUNJU0UgPSBleHBvcnRzLkZMT09SLk1BVEg7XG5cblx0Ly8gYWRhcHRlZCBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvR3JlYXRlc3RfY29tbW9uX2Rpdmlzb3IjSmF2YVNjcmlwdFxuXHRleHBvcnRzLkdDRCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgcjAgPSByYW5nZVswXTtcblx0ICB2YXIgeCA9IHIwIDwgMCA/IC1yMCA6IHIwO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB2YXIgcmkgPSByYW5nZVtpXTtcblx0ICAgIHZhciB5ID0gcmkgPCAwID8gLXJpIDogcmk7XG5cdCAgICB3aGlsZSAoeCAmJiB5KSB7XG5cdCAgICAgIGlmICh4ID4geSkge1xuXHQgICAgICAgIHggJT0geTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB5ICU9IHg7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHggKz0geTtcblx0ICB9XG5cdCAgcmV0dXJuIHg7XG5cdH07XG5cblxuXHRleHBvcnRzLklOVCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuXHR9O1xuXG5cdC8vVE9ETzogdmVyaWZ5XG5cdGV4cG9ydHMuSVNPID0ge1xuXHQgIENFSUxJTkc6IGV4cG9ydHMuQ0VJTElOR1xuXHR9O1xuXG5cdGV4cG9ydHMuTENNID0gZnVuY3Rpb24oKSB7XG5cdCAgLy8gQ3JlZGl0czogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhXG5cdCAgdmFyIG8gPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKG8gaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG87XG5cdCAgfVxuXHQgIGZvciAodmFyIGksIGosIG4sIGQsIHIgPSAxO1xuXHQgICAgKG4gPSBvLnBvcCgpKSAhPT0gdW5kZWZpbmVkOykge1xuXHQgICAgd2hpbGUgKG4gPiAxKSB7XG5cdCAgICAgIGlmIChuICUgMikge1xuXHQgICAgICAgIGZvciAoaSA9IDMsIGogPSBNYXRoLmZsb29yKE1hdGguc3FydChuKSk7IGkgPD0gaiAmJiBuICUgaTsgaSArPSAyKSB7XG5cdCAgICAgICAgICAvL2VtcHR5XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGQgPSAoaSA8PSBqKSA/IGkgOiBuO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGQgPSAyO1xuXHQgICAgICB9XG5cdCAgICAgIGZvciAobiAvPSBkLCByICo9IGQsIGkgPSBvLmxlbmd0aDsgaTtcblx0ICAgICAgICAob1stLWldICUgZCkgPT09IDAgJiYgKG9baV0gLz0gZCkgPT09IDEgJiYgby5zcGxpY2UoaSwgMSkpIHtcblx0ICAgICAgICAvL2VtcHR5XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblx0ZXhwb3J0cy5MTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2cobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkxPRyA9IGZ1bmN0aW9uKG51bWJlciwgYmFzZSkge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgYmFzZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGJhc2UpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgYmFzZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgYmFzZSA9IChiYXNlID09PSB1bmRlZmluZWQpID8gMTAgOiBiYXNlO1xuXHQgIHJldHVybiBNYXRoLmxvZyhudW1iZXIpIC8gTWF0aC5sb2coYmFzZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5MT0cxMCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2cobnVtYmVyKSAvIE1hdGgubG9nKDEwKTtcblx0fTtcblxuXHRleHBvcnRzLk1ERVRFUk0gPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICBtYXRyaXggPSB1dGlscy5wYXJzZU1hdHJpeChtYXRyaXgpO1xuXHQgIGlmIChtYXRyaXggaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG1hdHJpeDtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyaWMuZGV0KG1hdHJpeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5NSU5WRVJTRSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHQgIG1hdHJpeCA9IHV0aWxzLnBhcnNlTWF0cml4KG1hdHJpeCk7XG5cdCAgaWYgKG1hdHJpeCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbWF0cml4O1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJpYy5pbnYobWF0cml4KTtcblx0fTtcblxuXHRleHBvcnRzLk1NVUxUID0gZnVuY3Rpb24obWF0cml4MSwgbWF0cml4Mikge1xuXHQgIG1hdHJpeDEgPSB1dGlscy5wYXJzZU1hdHJpeChtYXRyaXgxKTtcblx0ICBtYXRyaXgyID0gdXRpbHMucGFyc2VNYXRyaXgobWF0cml4Mik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobWF0cml4MSwgbWF0cml4MikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyaWMuZG90KG1hdHJpeDEsIG1hdHJpeDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTU9EID0gZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcblx0ICBkaXZpZGVuZCA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpdmlkZW5kKTtcblx0ICBkaXZpc29yID0gdXRpbHMucGFyc2VOdW1iZXIoZGl2aXNvcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGl2aWRlbmQsIGRpdmlzb3IpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChkaXZpc29yID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZGl2MDtcblx0ICB9XG5cdCAgdmFyIG1vZHVsdXMgPSBNYXRoLmFicyhkaXZpZGVuZCAlIGRpdmlzb3IpO1xuXHQgIHJldHVybiAoZGl2aXNvciA+IDApID8gbW9kdWx1cyA6IC1tb2R1bHVzO1xuXHR9O1xuXG5cdCAgZXhwb3J0cy5NUk9VTkQgPSBmdW5jdGlvbihudW1iZXIsIG11bHRpcGxlKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBtdWx0aXBsZSA9IHV0aWxzLnBhcnNlTnVtYmVyKG11bHRpcGxlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIG11bHRpcGxlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAobnVtYmVyICogbXVsdGlwbGUgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAvIG11bHRpcGxlKSAqIG11bHRpcGxlO1xuXHR9O1xuXG5cdGV4cG9ydHMuTVVMVElOT01JQUwgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAoYXJncyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gYXJncztcblx0ICB9XG5cdCAgdmFyIHN1bSA9IDA7XG5cdCAgdmFyIGRpdmlzb3IgPSAxO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgc3VtICs9IGFyZ3NbaV07XG5cdCAgICBkaXZpc29yICo9IGV4cG9ydHMuRkFDVChhcmdzW2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIGV4cG9ydHMuRkFDVChzdW0pIC8gZGl2aXNvcjtcblx0fTtcblxuXHRleHBvcnRzLk1VTklUID0gZnVuY3Rpb24oZGltZW5zaW9uKSB7XG5cdCAgZGltZW5zaW9uID0gdXRpbHMucGFyc2VOdW1iZXIoZGltZW5zaW9uKTtcblx0ICBpZiAoZGltZW5zaW9uIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBkaW1lbnNpb247XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmljLmlkZW50aXR5KGRpbWVuc2lvbik7XG5cdH07XG5cblx0ZXhwb3J0cy5PREQgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgdmFyIHRlbXAgPSBNYXRoLmNlaWwoTWF0aC5hYnMobnVtYmVyKSk7XG5cdCAgdGVtcCA9ICh0ZW1wICYgMSkgPyB0ZW1wIDogdGVtcCArIDE7XG5cdCAgcmV0dXJuIChudW1iZXIgPiAwKSA/IHRlbXAgOiAtdGVtcDtcblx0fTtcblxuXHRleHBvcnRzLlBJID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIE1hdGguUEk7XG5cdH07XG5cblx0ZXhwb3J0cy5QT1dFUiA9IGZ1bmN0aW9uKG51bWJlciwgcG93ZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHBvd2VyID0gdXRpbHMucGFyc2VOdW1iZXIocG93ZXIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgcG93ZXIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSBNYXRoLnBvdyhudW1iZXIsIHBvd2VyKTtcblx0ICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuUFJPRFVDVCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChhcmdzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBhcmdzO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gMTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCAqPSBhcmdzW2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuUVVPVElFTlQgPSBmdW5jdGlvbihudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG5cdCAgbnVtZXJhdG9yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtZXJhdG9yKTtcblx0ICBkZW5vbWluYXRvciA9IHV0aWxzLnBhcnNlTnVtYmVyKGRlbm9taW5hdG9yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1lcmF0b3IsIGRlbm9taW5hdG9yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gcGFyc2VJbnQobnVtZXJhdG9yIC8gZGVub21pbmF0b3IsIDEwKTtcblx0fTtcblxuXHRleHBvcnRzLlJBRElBTlMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWJlciAqIE1hdGguUEkgLyAxODA7XG5cdH07XG5cblx0ZXhwb3J0cy5SQU5EID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5SQU5EQkVUV0VFTiA9IGZ1bmN0aW9uKGJvdHRvbSwgdG9wKSB7XG5cdCAgYm90dG9tID0gdXRpbHMucGFyc2VOdW1iZXIoYm90dG9tKTtcblx0ICB0b3AgPSB1dGlscy5wYXJzZU51bWJlcih0b3ApO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGJvdHRvbSwgdG9wKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICAvLyBDcmVhdGl2ZSBDb21tb25zIEF0dHJpYnV0aW9uIDMuMCBMaWNlbnNlXG5cdCAgLy8gQ29weXJpZ2h0IChjKSAyMDEyIGVxY29kZVxuXHQgIHJldHVybiBib3R0b20gKyBNYXRoLmNlaWwoKHRvcCAtIGJvdHRvbSArIDEpICogTWF0aC5yYW5kb20oKSkgLSAxO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5ST01BTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICAvLyBUaGUgTUlUIExpY2Vuc2Vcblx0ICAvLyBDb3B5cmlnaHQgKGMpIDIwMDggU3RldmVuIExldml0aGFuXG5cdCAgdmFyIGRpZ2l0cyA9IFN0cmluZyhudW1iZXIpLnNwbGl0KCcnKTtcblx0ICB2YXIga2V5ID0gWycnLCAnQycsICdDQycsICdDQ0MnLCAnQ0QnLCAnRCcsICdEQycsICdEQ0MnLCAnRENDQycsICdDTScsICcnLCAnWCcsICdYWCcsICdYWFgnLCAnWEwnLCAnTCcsICdMWCcsICdMWFgnLCAnTFhYWCcsICdYQycsICcnLCAnSScsICdJSScsICdJSUknLCAnSVYnLCAnVicsICdWSScsICdWSUknLCAnVklJSScsICdJWCddO1xuXHQgIHZhciByb21hbiA9ICcnO1xuXHQgIHZhciBpID0gMztcblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICByb21hbiA9IChrZXlbK2RpZ2l0cy5wb3AoKSArIChpICogMTApXSB8fCAnJykgKyByb21hbjtcblx0ICB9XG5cdCAgcmV0dXJuIG5ldyBBcnJheSgrZGlnaXRzLmpvaW4oJycpICsgMSkuam9pbignTScpICsgcm9tYW47XG5cdH07XG5cblx0ZXhwb3J0cy5ST1VORCA9IGZ1bmN0aW9uKG51bWJlciwgZGlnaXRzKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkaWdpdHMgPSB1dGlscy5wYXJzZU51bWJlcihkaWdpdHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGlnaXRzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGlnaXRzKSkgLyBNYXRoLnBvdygxMCwgZGlnaXRzKTtcblx0fTtcblxuXHRleHBvcnRzLlJPVU5ERE9XTiA9IGZ1bmN0aW9uKG51bWJlciwgZGlnaXRzKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkaWdpdHMgPSB1dGlscy5wYXJzZU51bWJlcihkaWdpdHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGlnaXRzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgc2lnbiA9IChudW1iZXIgPiAwKSA/IDEgOiAtMTtcblx0ICByZXR1cm4gc2lnbiAqIChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikgKiBNYXRoLnBvdygxMCwgZGlnaXRzKSkpIC8gTWF0aC5wb3coMTAsIGRpZ2l0cyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ST1VORFVQID0gZnVuY3Rpb24obnVtYmVyLCBkaWdpdHMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGRpZ2l0cyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpZ2l0cyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBkaWdpdHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBzaWduID0gKG51bWJlciA+IDApID8gMSA6IC0xO1xuXHQgIHJldHVybiBzaWduICogKE1hdGguY2VpbChNYXRoLmFicyhudW1iZXIpICogTWF0aC5wb3coMTAsIGRpZ2l0cykpKSAvIE1hdGgucG93KDEwLCBkaWdpdHMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0VDID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiAxIC8gTWF0aC5jb3MobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLlNFQ0ggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIDIgLyAoTWF0aC5leHAobnVtYmVyKSArIE1hdGguZXhwKC1udW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLlNFUklFU1NVTSA9IGZ1bmN0aW9uKHgsIG4sIG0sIGNvZWZmaWNpZW50cykge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgbSA9IHV0aWxzLnBhcnNlTnVtYmVyKG0pO1xuXHQgIGNvZWZmaWNpZW50cyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoY29lZmZpY2llbnRzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuLCBtLCBjb2VmZmljaWVudHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSBjb2VmZmljaWVudHNbMF0gKiBNYXRoLnBvdyh4LCBuKTtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGNvZWZmaWNpZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IGNvZWZmaWNpZW50c1tpXSAqIE1hdGgucG93KHgsIG4gKyBpICogbSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TSUdOID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfSBlbHNlIGlmIChudW1iZXIgPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5TSU4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguc2luKG51bWJlcik7XG5cdH07XG5cblx0ICBleHBvcnRzLlNJTkggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIG51bWJlcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoTWF0aC5leHAobnVtYmVyKSAtIE1hdGguZXhwKC1udW1iZXIpKSAvIDI7XG5cdCAgfTtcblxuXHQgIGV4cG9ydHMuU1FSVCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgICAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICAgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gbnVtYmVyO1xuXHQgICAgfVxuXHQgICAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBNYXRoLnNxcnQobnVtYmVyKTtcblx0ICB9O1xuXG5cdCAgZXhwb3J0cy5TUVJUUEkgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIG51bWJlcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBNYXRoLnNxcnQobnVtYmVyICogTWF0aC5QSSk7XG5cdCAgfTtcblxuXHRleHBvcnRzLlNVQlRPVEFMID0gZnVuY3Rpb24oZnVuY3Rpb25fY29kZSwgcmVmMSkge1xuXHQgIGZ1bmN0aW9uX2NvZGUgPSB1dGlscy5wYXJzZU51bWJlcihmdW5jdGlvbl9jb2RlKTtcblx0ICBpZiAoZnVuY3Rpb25fY29kZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb25fY29kZTtcblx0ICB9XG5cdCAgc3dpdGNoIChmdW5jdGlvbl9jb2RlKSB7XG5cdCAgICBjYXNlIDE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5BVkVSQUdFKHJlZjEpO1xuXHQgICAgY2FzZSAyOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlQocmVmMSk7XG5cdCAgICBjYXNlIDM6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5DT1VOVEEocmVmMSk7XG5cdCAgICBjYXNlIDQ6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NQVgocmVmMSk7XG5cdCAgICBjYXNlIDU6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NSU4ocmVmMSk7XG5cdCAgICBjYXNlIDY6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBST0RVQ1QocmVmMSk7XG5cdCAgICBjYXNlIDc6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5TKHJlZjEpO1xuXHQgICAgY2FzZSA4OlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuU1RERVYuUChyZWYxKTtcblx0ICAgIGNhc2UgOTpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuU1VNKHJlZjEpO1xuXHQgICAgY2FzZSAxMDpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5TKHJlZjEpO1xuXHQgICAgY2FzZSAxMTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5QKHJlZjEpO1xuXHQgICAgICAvLyBubyBoaWRkZW4gdmFsdWVzIGZvciB1c1xuXHQgICAgY2FzZSAxMDE6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5BVkVSQUdFKHJlZjEpO1xuXHQgICAgY2FzZSAxMDI6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5DT1VOVChyZWYxKTtcblx0ICAgIGNhc2UgMTAzOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuQ09VTlRBKHJlZjEpO1xuXHQgICAgY2FzZSAxMDQ6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5NQVgocmVmMSk7XG5cdCAgICBjYXNlIDEwNTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLk1JTihyZWYxKTtcblx0ICAgIGNhc2UgMTA2OlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QUk9EVUNUKHJlZjEpO1xuXHQgICAgY2FzZSAxMDc6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5TKHJlZjEpO1xuXHQgICAgY2FzZSAxMDg6XG5cdCAgICAgIHJldHVybiBzdGF0aXN0aWNhbC5TVERFVi5QKHJlZjEpO1xuXHQgICAgY2FzZSAxMDk6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlNVTShyZWYxKTtcblx0ICAgIGNhc2UgMTEwOlxuXHQgICAgICByZXR1cm4gc3RhdGlzdGljYWwuVkFSLlMocmVmMSk7XG5cdCAgICBjYXNlIDExMTpcblx0ICAgICAgcmV0dXJuIHN0YXRpc3RpY2FsLlZBUi5QKHJlZjEpO1xuXG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQUREID0gZnVuY3Rpb24gKG51bTEsIG51bTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIG51bTEgPSB1dGlscy5wYXJzZU51bWJlcihudW0xKTtcblx0ICBudW0yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtMSwgbnVtMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtMSArIG51bTI7XG5cdH07XG5cblx0ZXhwb3J0cy5NSU5VUyA9IGZ1bmN0aW9uIChudW0xLCBudW0yKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBudW0xID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMSk7XG5cdCAgbnVtMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bTEsIG51bTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG51bTEgLSBudW0yO1xuXHR9O1xuXG5cdGV4cG9ydHMuRElWSURFID0gZnVuY3Rpb24gKGRpdmlkZW5kLCBkaXZpc29yKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBkaXZpZGVuZCA9IHV0aWxzLnBhcnNlTnVtYmVyKGRpdmlkZW5kKTtcblx0ICBkaXZpc29yID0gdXRpbHMucGFyc2VOdW1iZXIoZGl2aXNvcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGl2aWRlbmQsIGRpdmlzb3IpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKGRpdmlzb3IgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5kaXYwO1xuXHQgIH1cblxuXHQgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG5cdH07XG5cblx0ZXhwb3J0cy5NVUxUSVBMWSA9IGZ1bmN0aW9uIChmYWN0b3IxLCBmYWN0b3IyKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBmYWN0b3IxID0gdXRpbHMucGFyc2VOdW1iZXIoZmFjdG9yMSk7XG5cdCAgZmFjdG9yMiA9IHV0aWxzLnBhcnNlTnVtYmVyKGZhY3RvcjIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGZhY3RvcjEsIGZhY3RvcjIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZhY3RvcjEgKiBmYWN0b3IyO1xuXHR9O1xuXG5cdGV4cG9ydHMuR1RFID0gZnVuY3Rpb24gKG51bTEsIG51bTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIG51bTEgPSB1dGlscy5wYXJzZU51bWJlcihudW0xKTtcblx0ICBudW0yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtMSwgbnVtMikpIHtcblx0ICAgIHJldHVybiBlcnJvci5lcnJvcjtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtMSA+PSBudW0yO1xuXHR9O1xuXG5cdGV4cG9ydHMuTFQgPSBmdW5jdGlvbiAobnVtMSwgbnVtMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgbnVtMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bTEpO1xuXHQgIG51bTIgPSB1dGlscy5wYXJzZU51bWJlcihudW0yKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW0xLCBudW0yKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLmVycm9yO1xuXHQgIH1cblxuXHQgIHJldHVybiBudW0xIDwgbnVtMjtcblx0fTtcblxuXG5cdGV4cG9ydHMuTFRFID0gZnVuY3Rpb24gKG51bTEsIG51bTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIG51bTEgPSB1dGlscy5wYXJzZU51bWJlcihudW0xKTtcblx0ICBudW0yID0gdXRpbHMucGFyc2VOdW1iZXIobnVtMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtMSwgbnVtMikpIHtcblx0ICAgIHJldHVybiBlcnJvci5lcnJvcjtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtMSA8PSBudW0yO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVEgPSBmdW5jdGlvbiAodmFsdWUxLCB2YWx1ZTIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIHJldHVybiB2YWx1ZTEgPT09IHZhbHVlMjtcblx0fTtcblxuXHRleHBvcnRzLk5FID0gZnVuY3Rpb24gKHZhbHVlMSwgdmFsdWUyKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsdWUxICE9PSB2YWx1ZTI7XG5cdH07XG5cblx0ZXhwb3J0cy5QT1cgPSBmdW5jdGlvbiAoYmFzZSwgZXhwb25lbnQpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGJhc2UgPSB1dGlscy5wYXJzZU51bWJlcihiYXNlKTtcblx0ICBleHBvbmVudCA9IHV0aWxzLnBhcnNlTnVtYmVyKGV4cG9uZW50KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihiYXNlLCBleHBvbmVudCkpIHtcblx0ICAgIHJldHVybiBlcnJvci5lcnJvcjtcblx0ICB9XG5cblx0ICByZXR1cm4gZXhwb3J0cy5QT1dFUihiYXNlLCBleHBvbmVudCk7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU0gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgYXJnc0tleXMgPSBPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc0tleXMubGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhciBlbHQgPSBhcmd1bWVudHNbYXJnc0tleXNbaV1dO1xuXHQgICAgaWYgKHR5cGVvZiBlbHQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHJlc3VsdCArPSBlbHQ7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbHQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUZsb2F0KGVsdCk7XG5cdCAgICAgICFpc05hTihwYXJzZWQpICYmIChyZXN1bHQgKz0gcGFyc2VkKTtcblx0ICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbHQpKSB7XG5cdCAgICAgIHJlc3VsdCArPSBleHBvcnRzLlNVTS5hcHBseShudWxsLCBlbHQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNSUYgPSBmdW5jdGlvbihyYW5nZSwgY3JpdGVyaWEpIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2UubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSAoZXZhbChyYW5nZVtpXSArIGNyaXRlcmlhKSkgPyByYW5nZVtpXSA6IDA7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNSUZTID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5hcmdzVG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmdzLnNoaWZ0KCkpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICB2YXIgY3JpdGVyaWEgPSBhcmdzO1xuXG5cdCAgdmFyIG5fcmFuZ2VfZWxlbWVudHMgPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIG5fY3JpdGVyaWFzID0gY3JpdGVyaWEubGVuZ3RoO1xuXG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX3JhbmdlX2VsZW1lbnRzOyBpKyspIHtcblx0ICAgIHZhciBlbCA9IHJhbmdlW2ldO1xuXHQgICAgdmFyIGNvbmRpdGlvbiA9ICcnO1xuXHQgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuX2NyaXRlcmlhczsgYysrKSB7XG5cdCAgICAgIGNvbmRpdGlvbiArPSBlbCArIGNyaXRlcmlhW2NdO1xuXHQgICAgICBpZiAoYyAhPT0gbl9jcml0ZXJpYXMgLSAxKSB7XG5cdCAgICAgICAgY29uZGl0aW9uICs9ICcmJic7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChldmFsKGNvbmRpdGlvbikpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgIHJlc3VsdCArPSBlbDtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTVBST0RVQ1QgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAoIWFyZ3VtZW50cyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBhcnJheXMgPSBhcmd1bWVudHMubGVuZ3RoICsgMTtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgcHJvZHVjdDtcblx0ICB2YXIgaztcblx0ICB2YXIgX2k7XG5cdCAgdmFyIF9pajtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50c1swXS5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKCEoYXJndW1lbnRzWzBdW2ldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICAgIHByb2R1Y3QgPSAxO1xuXHQgICAgICBmb3IgKGsgPSAxOyBrIDwgYXJyYXlzOyBrKyspIHtcblx0ICAgICAgICBfaSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFyZ3VtZW50c1trIC0gMV1baV0pO1xuXHQgICAgICAgIGlmIChfaSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICByZXR1cm4gX2k7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHByb2R1Y3QgKj0gX2k7XG5cdCAgICAgIH1cblx0ICAgICAgcmVzdWx0ICs9IHByb2R1Y3Q7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFyZ3VtZW50c1swXVtpXS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgIHByb2R1Y3QgPSAxO1xuXHQgICAgICAgIGZvciAoayA9IDE7IGsgPCBhcnJheXM7IGsrKykge1xuXHQgICAgICAgICAgX2lqID0gdXRpbHMucGFyc2VOdW1iZXIoYXJndW1lbnRzW2sgLSAxXVtpXVtqXSk7XG5cdCAgICAgICAgICBpZiAoX2lqIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9pajtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHByb2R1Y3QgKj0gX2lqO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gcHJvZHVjdDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNU1EgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgbnVtYmVycyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAobnVtYmVycyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVycztcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgdmFyIGxlbmd0aCA9IG51bWJlcnMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSAoaW5mb3JtYXRpb24uSVNOVU1CRVIobnVtYmVyc1tpXSkpID8gbnVtYmVyc1tpXSAqIG51bWJlcnNbaV0gOiAwO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1VNWDJNWTIgPSBmdW5jdGlvbihhcnJheV94LCBhcnJheV95KSB7XG5cdCAgYXJyYXlfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV94KSk7XG5cdCAgYXJyYXlfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheV95KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXlfeCwgYXJyYXlfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheV94Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZXN1bHQgKz0gYXJyYXlfeFtpXSAqIGFycmF5X3hbaV0gLSBhcnJheV95W2ldICogYXJyYXlfeVtpXTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlNVTVgyUFkyID0gZnVuY3Rpb24oYXJyYXlfeCwgYXJyYXlfeSkge1xuXHQgIGFycmF5X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeCkpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5X3gsIGFycmF5X3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGFycmF5X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeCkpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeSkpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlfeC5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IGFycmF5X3hbaV0gKiBhcnJheV94W2ldICsgYXJyYXlfeVtpXSAqIGFycmF5X3lbaV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5TVU1YTVkyID0gZnVuY3Rpb24oYXJyYXlfeCwgYXJyYXlfeSkge1xuXHQgIGFycmF5X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeCkpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXlfeSkpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5X3gsIGFycmF5X3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGFycmF5X3ggPSB1dGlscy5mbGF0dGVuKGFycmF5X3gpO1xuXHQgIGFycmF5X3kgPSB1dGlscy5mbGF0dGVuKGFycmF5X3kpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlfeC5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IE1hdGgucG93KGFycmF5X3hbaV0gLSBhcnJheV95W2ldLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlRBTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC50YW4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLlRBTkggPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgdmFyIGUyID0gTWF0aC5leHAoMiAqIG51bWJlcik7XG5cdCAgcmV0dXJuIChlMiAtIDEpIC8gKGUyICsgMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5UUlVOQyA9IGZ1bmN0aW9uKG51bWJlciwgZGlnaXRzKSB7XG5cdCAgZGlnaXRzID0gKGRpZ2l0cyA9PT0gdW5kZWZpbmVkKSA/IDAgOiBkaWdpdHM7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkaWdpdHMgPSB1dGlscy5wYXJzZU51bWJlcihkaWdpdHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgZGlnaXRzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgc2lnbiA9IChudW1iZXIgPiAwKSA/IDEgOiAtMTtcblx0ICByZXR1cm4gc2lnbiAqIChNYXRoLmZsb29yKE1hdGguYWJzKG51bWJlcikgKiBNYXRoLnBvdygxMCwgZGlnaXRzKSkpIC8gTWF0aC5wb3coMTAsIGRpZ2l0cyk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXHRmdW5jdGlvbiBmbGF0dGVuU2hhbGxvdyhhcnJheSkge1xuXHQgIGlmICghYXJyYXkgfHwgIWFycmF5LnJlZHVjZSkgeyByZXR1cm4gYXJyYXk7IH1cblx0ICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHZhciBhSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG5cdCAgICB2YXIgYklzQXJyYXkgPSBBcnJheS5pc0FycmF5KGIpO1xuXHQgICAgaWYgKGFJc0FycmF5ICYmIGJJc0FycmF5ICkge1xuXHQgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG5cdCAgICB9XG5cdCAgICBpZiAoYUlzQXJyYXkpIHtcblx0ICAgICAgYS5wdXNoKGIpO1xuXHQgICAgICByZXR1cm4gYTtcblx0ICAgIH1cblx0ICAgIGlmIChiSXNBcnJheSkge1xuXHQgICAgICByZXR1cm4gW2FdLmNvbmNhdChiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBbYSwgYl07XG5cdCAgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0ZsYXQoYXJyYXkpIHtcblx0ICBpZiAoIWFycmF5KSB7IHJldHVybiBmYWxzZTsgfVxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJlc3VsdCA9IGV4cG9ydHMuYXJnc1RvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0ICB3aGlsZSAoIWlzRmxhdChyZXN1bHQpKSB7XG5cdCAgICByZXN1bHQgPSBmbGF0dGVuU2hhbGxvdyhyZXN1bHQpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuYXJnc1RvQXJyYXkgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDApO1xuXHR9O1xuXG5cdGV4cG9ydHMubnVtYmVycyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBwb3NzaWJsZU51bWJlcnMgPSB0aGlzLmZsYXR0ZW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0ICByZXR1cm4gcG9zc2libGVOdW1iZXJzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuXHQgICAgcmV0dXJuIHR5cGVvZiBlbCA9PT0gJ251bWJlcic7XG5cdCAgfSk7XG5cdH07XG5cblx0ZXhwb3J0cy5jbGVhbkZsb2F0ID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgdmFyIHBvd2VyID0gMWUxNDtcblx0ICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiBwb3dlcikgLyBwb3dlcjtcblx0fTtcblxuXHRleHBvcnRzLnBhcnNlQm9vbCA9IGZ1bmN0aW9uKGJvb2wpIHtcblx0ICBpZiAodHlwZW9mIGJvb2wgPT09ICdib29sZWFuJykge1xuXHQgICAgcmV0dXJuIGJvb2w7XG5cdCAgfVxuXG5cdCAgaWYgKGJvb2wgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGJvb2w7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBib29sID09PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIGJvb2wgIT09IDA7XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiBib29sID09PSAnc3RyaW5nJykge1xuXHQgICAgdmFyIHVwID0gYm9vbC50b1VwcGVyQ2FzZSgpO1xuXHQgICAgaWYgKHVwID09PSAnVFJVRScpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh1cCA9PT0gJ0ZBTFNFJykge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKGJvb2wgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihib29sKSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMucGFyc2VOdW1iZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0ICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQgfHwgc3RyaW5nID09PSAnJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoIWlzTmFOKHN0cmluZykpIHtcblx0ICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cmluZyk7XG5cdCAgfVxuXHQgIHJldHVybiBlcnJvci52YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLnBhcnNlTnVtYmVyQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcblx0ICB2YXIgbGVuO1xuXHQgIGlmICghYXJyIHx8IChsZW4gPSBhcnIubGVuZ3RoKSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcGFyc2VkO1xuXHQgIHdoaWxlIChsZW4tLSkge1xuXHQgICAgcGFyc2VkID0gZXhwb3J0cy5wYXJzZU51bWJlcihhcnJbbGVuXSk7XG5cdCAgICBpZiAocGFyc2VkID09PSBlcnJvci52YWx1ZSkge1xuXHQgICAgICByZXR1cm4gcGFyc2VkO1xuXHQgICAgfVxuXHQgICAgYXJyW2xlbl0gPSBwYXJzZWQ7XG5cdCAgfVxuXHQgIHJldHVybiBhcnI7XG5cdH07XG5cblx0ZXhwb3J0cy5wYXJzZU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHQgIHZhciBuO1xuXHQgIGlmICghbWF0cml4IHx8IChuID0gbWF0cml4Lmxlbmd0aCkgPT09IDApIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHBuYXJyO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0cml4Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBwbmFyciA9IGV4cG9ydHMucGFyc2VOdW1iZXJBcnJheShtYXRyaXhbaV0pO1xuXHQgICAgbWF0cml4W2ldID0gcG5hcnI7XG5cdCAgICBpZiAocG5hcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gcG5hcnI7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBtYXRyaXg7XG5cdH07XG5cblx0dmFyIGQxOTAwID0gbmV3IERhdGUoMTkwMCwgMCwgMSk7XG5cdGV4cG9ydHMucGFyc2VEYXRlID0gZnVuY3Rpb24oZGF0ZSkge1xuXHQgIGlmICghaXNOYU4oZGF0ZSkpIHtcblx0ICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHQgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgZCA9IHBhcnNlSW50KGRhdGUsIDEwKTtcblx0ICAgIGlmIChkIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXHQgICAgaWYgKGQgPD0gNjApIHtcblx0ICAgICAgcmV0dXJuIG5ldyBEYXRlKGQxOTAwLmdldFRpbWUoKSArIChkIC0gMSkgKiA4NjQwMDAwMCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IERhdGUoZDE5MDAuZ2V0VGltZSgpICsgKGQgLSAyKSAqIDg2NDAwMDAwKTtcblx0ICB9XG5cdCAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuXHQgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuXHQgICAgaWYgKCFpc05hTihkYXRlKSkge1xuXHQgICAgICByZXR1cm4gZGF0ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMucGFyc2VEYXRlQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcblx0ICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblx0ICB2YXIgcGFyc2VkO1xuXHQgIHdoaWxlIChsZW4tLSkge1xuXHQgICAgcGFyc2VkID0gdGhpcy5wYXJzZURhdGUoYXJyW2xlbl0pO1xuXHQgICAgaWYgKHBhcnNlZCA9PT0gZXJyb3IudmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHBhcnNlZDtcblx0ICAgIH1cblx0ICAgIGFycltsZW5dID0gcGFyc2VkO1xuXHQgIH1cblx0ICByZXR1cm4gYXJyO1xuXHR9O1xuXG5cdGV4cG9ydHMuYW55SXNFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcblx0ICB3aGlsZSAobi0tKSB7XG5cdCAgICBpZiAoYXJndW1lbnRzW25dIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRleHBvcnRzLmFycmF5VmFsdWVzVG9OdW1iZXJzID0gZnVuY3Rpb24oYXJyKSB7XG5cdCAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuXHQgIHZhciBlbDtcblx0ICB3aGlsZSAobi0tKSB7XG5cdCAgICBlbCA9IGFycltuXTtcblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsID09PSB0cnVlKSB7XG5cdCAgICAgIGFycltuXSA9IDE7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsID09PSBmYWxzZSkge1xuXHQgICAgICBhcnJbbl0gPSAwO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHZhciBudW1iZXIgPSB0aGlzLnBhcnNlTnVtYmVyKGVsKTtcblx0ICAgICAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgYXJyW25dID0gMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBhcnJbbl0gPSBudW1iZXI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGFycjtcblx0fTtcblxuXHRleHBvcnRzLnJlc3QgPSBmdW5jdGlvbihhcnJheSwgaWR4KSB7XG5cdCAgaWR4ID0gaWR4IHx8IDE7XG5cdCAgaWYgKCFhcnJheSB8fCB0eXBlb2YgYXJyYXkuc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgIHJldHVybiBhcnJheTtcblx0ICB9XG5cdCAgcmV0dXJuIGFycmF5LnNsaWNlKGlkeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIGlkeCkge1xuXHQgIGlkeCA9IGlkeCB8fCAxO1xuXHQgIGlmICghYXJyYXkgfHwgdHlwZW9mIGFycmF5LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gYXJyYXk7XG5cdCAgfVxuXHQgIHJldHVybiBhcnJheS5zbGljZSgwLCBhcnJheS5sZW5ndGggLSBpZHgpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5uaWwgPSBuZXcgRXJyb3IoJyNOVUxMIScpO1xuXHRleHBvcnRzLmRpdjAgPSBuZXcgRXJyb3IoJyNESVYvMCEnKTtcblx0ZXhwb3J0cy52YWx1ZSA9IG5ldyBFcnJvcignI1ZBTFVFPycpO1xuXHRleHBvcnRzLnJlZiA9IG5ldyBFcnJvcignI1JFRiEnKTtcblx0ZXhwb3J0cy5uYW1lID0gbmV3IEVycm9yKCcjTkFNRT8nKTtcblx0ZXhwb3J0cy5udW0gPSBuZXcgRXJyb3IoJyNOVU0hJyk7XG5cdGV4cG9ydHMubmEgPSBuZXcgRXJyb3IoJyNOL0EnKTtcblx0ZXhwb3J0cy5lcnJvciA9IG5ldyBFcnJvcignI0VSUk9SIScpO1xuXHRleHBvcnRzLmRhdGEgPSBuZXcgRXJyb3IoJyNHRVRUSU5HX0RBVEEnKTtcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIG1hdGhUcmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIHRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgalN0YXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLmpTdGF0O1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgbWlzYyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG5cdHZhciBTUVJUMlBJID0gMi41MDY2MjgyNzQ2MzEwMDAyO1xuXG5cdGV4cG9ydHMuQVZFREVWID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5zdW0oalN0YXQocmFuZ2UpLnN1YnRyYWN0KGpTdGF0Lm1lYW4ocmFuZ2UpKS5hYnMoKVswXSkgLyByYW5nZS5sZW5ndGg7XG5cdH07XG5cblx0ZXhwb3J0cy5BVkVSQUdFID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzdW0gPSAwO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHN1bSArPSByYW5nZVtpXTtcblx0ICAgIGNvdW50ICs9IDE7XG5cdCAgfVxuXHQgIHJldHVybiBzdW0gLyBjb3VudDtcblx0fTtcblxuXHRleHBvcnRzLkFWRVJBR0VBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzdW0gPSAwO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHZhciBlbCA9IHJhbmdlW2ldO1xuXHQgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgc3VtICs9IGVsO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsID09PSB0cnVlKSB7XG5cdCAgICAgIHN1bSsrO1xuXHQgICAgfVxuXHQgICAgaWYgKGVsICE9PSBudWxsKSB7XG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBzdW0gLyBjb3VudDtcblx0fTtcblxuXHRleHBvcnRzLkFWRVJBR0VJRiA9IGZ1bmN0aW9uKHJhbmdlLCBjcml0ZXJpYSwgYXZlcmFnZV9yYW5nZSkge1xuXHQgIGF2ZXJhZ2VfcmFuZ2UgPSBhdmVyYWdlX3JhbmdlIHx8IHJhbmdlO1xuXHQgIHJhbmdlID0gdXRpbHMuZmxhdHRlbihyYW5nZSk7XG5cdCAgYXZlcmFnZV9yYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhdmVyYWdlX3JhbmdlKSk7XG5cdCAgaWYgKGF2ZXJhZ2VfcmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGF2ZXJhZ2VfcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBhdmVyYWdlX2NvdW50ID0gMDtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoZXZhbChyYW5nZVtpXSArIGNyaXRlcmlhKSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgcmVzdWx0ICs9IGF2ZXJhZ2VfcmFuZ2VbaV07XG5cdCAgICAgIGF2ZXJhZ2VfY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdCAvIGF2ZXJhZ2VfY291bnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5BVkVSQUdFSUZTID0gZnVuY3Rpb24oKSB7XG5cdCAgLy8gRG9lcyBub3Qgd29yayB3aXRoIG11bHRpIGRpbWVuc2lvbmFsIHJhbmdlcyB5ZXQhXG5cdCAgLy9odHRwOi8vb2ZmaWNlLm1pY3Jvc29mdC5jb20vZW4tMDAxL2V4Y2VsLWhlbHAvYXZlcmFnZWlmcy1mdW5jdGlvbi1IQTAxMDA0NzQ5My5hc3B4XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5hcmdzVG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciBjcml0ZXJpYSA9IChhcmdzLmxlbmd0aCAtIDEpIC8gMjtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3NbMF0pO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGNvbmRpdGlvbiA9ICcnO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjcml0ZXJpYTsgaisrKSB7XG5cdCAgICAgIGNvbmRpdGlvbiArPSBhcmdzWzIgKiBqICsgMV1baV0gKyBhcmdzWzIgKiBqICsgMl07XG5cdCAgICAgIGlmIChqICE9PSBjcml0ZXJpYSAtIDEpIHtcblx0ICAgICAgICBjb25kaXRpb24gKz0gJyYmJztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGV2YWwoY29uZGl0aW9uKSkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgcmVzdWx0ICs9IHJhbmdlW2ldO1xuXHQgICAgICBjb3VudCsrO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBhdmVyYWdlID0gcmVzdWx0IC8gY291bnQ7XG5cdCAgaWYgKGlzTmFOKGF2ZXJhZ2UpKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGF2ZXJhZ2U7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQkVUQSA9IHt9O1xuXG5cdGV4cG9ydHMuQkVUQS5ESVNUID0gZnVuY3Rpb24oeCwgYWxwaGEsIGJldGEsIGN1bXVsYXRpdmUsIEEsIEIpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBBID0gKEEgPT09IHVuZGVmaW5lZCkgPyAwIDogQTtcblx0ICBCID0gKEIgPT09IHVuZGVmaW5lZCkgPyAxIDogQjtcblxuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBiZXRhID0gdXRpbHMucGFyc2VOdW1iZXIoYmV0YSk7XG5cdCAgQSA9IHV0aWxzLnBhcnNlTnVtYmVyKEEpO1xuXHQgIEIgPSB1dGlscy5wYXJzZU51bWJlcihCKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBhbHBoYSwgYmV0YSwgQSwgQikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB4ID0gKHggLSBBKSAvIChCIC0gQSk7XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LmJldGEuY2RmKHgsIGFscGhhLCBiZXRhKSA6IGpTdGF0LmJldGEucGRmKHgsIGFscGhhLCBiZXRhKTtcblx0fTtcblxuXHRleHBvcnRzLkJFVEEuSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIGFscGhhLCBiZXRhLCBBLCBCKSB7XG5cdCAgQSA9IChBID09PSB1bmRlZmluZWQpID8gMCA6IEE7XG5cdCAgQiA9IChCID09PSB1bmRlZmluZWQpID8gMSA6IEI7XG5cblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBiZXRhID0gdXRpbHMucGFyc2VOdW1iZXIoYmV0YSk7XG5cdCAgQSA9IHV0aWxzLnBhcnNlTnVtYmVyKEEpO1xuXHQgIEIgPSB1dGlscy5wYXJzZU51bWJlcihCKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgYWxwaGEsIGJldGEsIEEsIEIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmJldGEuaW52KHByb2JhYmlsaXR5LCBhbHBoYSwgYmV0YSkgKiAoQiAtIEEpICsgQTtcblx0fTtcblxuXHRleHBvcnRzLkJJTk9NID0ge307XG5cblx0ZXhwb3J0cy5CSU5PTS5ESVNUID0gZnVuY3Rpb24oc3VjY2Vzc2VzLCB0cmlhbHMsIHByb2JhYmlsaXR5LCBjdW11bGF0aXZlKSB7XG5cdCAgc3VjY2Vzc2VzID0gdXRpbHMucGFyc2VOdW1iZXIoc3VjY2Vzc2VzKTtcblx0ICB0cmlhbHMgPSB1dGlscy5wYXJzZU51bWJlcih0cmlhbHMpO1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGN1bXVsYXRpdmUgPSB1dGlscy5wYXJzZU51bWJlcihjdW11bGF0aXZlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihzdWNjZXNzZXMsIHRyaWFscywgcHJvYmFiaWxpdHksIGN1bXVsYXRpdmUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5iaW5vbWlhbC5jZGYoc3VjY2Vzc2VzLCB0cmlhbHMsIHByb2JhYmlsaXR5KSA6IGpTdGF0LmJpbm9taWFsLnBkZihzdWNjZXNzZXMsIHRyaWFscywgcHJvYmFiaWxpdHkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQklOT00uRElTVC5SQU5HRSA9IGZ1bmN0aW9uKHRyaWFscywgcHJvYmFiaWxpdHksIHN1Y2Nlc3Nlcywgc3VjY2Vzc2VzMikge1xuXHQgIHN1Y2Nlc3NlczIgPSAoc3VjY2Vzc2VzMiA9PT0gdW5kZWZpbmVkKSA/IHN1Y2Nlc3NlcyA6IHN1Y2Nlc3NlczI7XG5cblx0ICB0cmlhbHMgPSB1dGlscy5wYXJzZU51bWJlcih0cmlhbHMpO1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIHN1Y2Nlc3NlcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHN1Y2Nlc3Nlcyk7XG5cdCAgc3VjY2Vzc2VzMiA9IHV0aWxzLnBhcnNlTnVtYmVyKHN1Y2Nlc3NlczIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHRyaWFscywgcHJvYmFiaWxpdHksIHN1Y2Nlc3Nlcywgc3VjY2Vzc2VzMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICBmb3IgKHZhciBpID0gc3VjY2Vzc2VzOyBpIDw9IHN1Y2Nlc3NlczI7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IG1hdGhUcmlnLkNPTUJJTih0cmlhbHMsIGkpICogTWF0aC5wb3cocHJvYmFiaWxpdHksIGkpICogTWF0aC5wb3coMSAtIHByb2JhYmlsaXR5LCB0cmlhbHMgLSBpKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkJJTk9NLklOViA9IGZ1bmN0aW9uKHRyaWFscywgcHJvYmFiaWxpdHksIGFscGhhKSB7XG5cdCAgdHJpYWxzID0gdXRpbHMucGFyc2VOdW1iZXIodHJpYWxzKTtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih0cmlhbHMsIHByb2JhYmlsaXR5LCBhbHBoYSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgeCA9IDA7XG5cdCAgd2hpbGUgKHggPD0gdHJpYWxzKSB7XG5cdCAgICBpZiAoalN0YXQuYmlub21pYWwuY2RmKHgsIHRyaWFscywgcHJvYmFiaWxpdHkpID49IGFscGhhKSB7XG5cdCAgICAgIHJldHVybiB4O1xuXHQgICAgfVxuXHQgICAgeCsrO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkNISVNRID0ge307XG5cblx0ZXhwb3J0cy5DSElTUS5ESVNUID0gZnVuY3Rpb24oeCwgaywgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgaykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQuY2hpc3F1YXJlLmNkZih4LCBrKSA6IGpTdGF0LmNoaXNxdWFyZS5wZGYoeCwgayk7XG5cdH07XG5cblx0ZXhwb3J0cy5DSElTUS5ESVNULlJUID0gZnVuY3Rpb24oeCwgaykge1xuXHQgIGlmICgheCB8ICFrKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHggPCAxIHx8IGsgPiBNYXRoLnBvdygxMCwgMTApKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHggIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGsgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiAxIC0gIGpTdGF0LmNoaXNxdWFyZS5jZGYoeCwgayk7XG5cdH07XG5cblx0ZXhwb3J0cy5DSElTUS5JTlYgPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgaykge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGsgPSB1dGlscy5wYXJzZU51bWJlcihrKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgaykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LmNoaXNxdWFyZS5pbnYocHJvYmFiaWxpdHksIGspO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hJU1EuSU5WLlJUID0gZnVuY3Rpb24ocCwgaykge1xuXHQgIGlmICghcCB8ICFrKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHAgPCAwIHx8IHAgPiAxIHx8IGsgPCAxIHx8IGsgPiBNYXRoLnBvdygxMCwgMTApKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHAgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGsgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jaGlzcXVhcmUuaW52KDEuMCAtIHAsIGspO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hJU1EuVEVTVCA9IGZ1bmN0aW9uKG9ic2VydmVkLCBleHBlY3RlZCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKCghKG9ic2VydmVkIGluc3RhbmNlb2YgQXJyYXkpKSB8fCAoIShleHBlY3RlZCBpbnN0YW5jZW9mIEFycmF5KSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAob2JzZXJ2ZWQubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAob2JzZXJ2ZWRbMF0gJiYgZXhwZWN0ZWRbMF0gJiZcblx0ICAgICAgb2JzZXJ2ZWRbMF0ubGVuZ3RoICE9PSBleHBlY3RlZFswXS5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgcm93ID0gb2JzZXJ2ZWQubGVuZ3RoO1xuXHQgIHZhciB0bXAsIGksIGo7XG5cblx0ICAvLyBDb252ZXJ0IHNpbmdsZS1kaW1lbnNpb24gYXJyYXkgaW50byB0d28tZGltZW5zaW9uIGFycmF5XG5cdCAgZm9yIChpID0gMDsgaSA8IHJvdzsgaSArKykge1xuXHQgICAgaWYgKCEob2JzZXJ2ZWRbaV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgICAgdG1wID0gb2JzZXJ2ZWRbaV07XG5cdCAgICAgIG9ic2VydmVkW2ldID0gW107XG5cdCAgICAgIG9ic2VydmVkW2ldLnB1c2godG1wKTtcblx0ICAgIH1cblx0ICAgIGlmICghKGV4cGVjdGVkW2ldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICAgIHRtcCA9IGV4cGVjdGVkW2ldO1xuXHQgICAgICBleHBlY3RlZFtpXSA9IFtdO1xuXHQgICAgICBleHBlY3RlZFtpXS5wdXNoKHRtcCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGNvbCA9IG9ic2VydmVkWzBdLmxlbmd0aDtcblx0ICB2YXIgZG9mID0gKGNvbCA9PT0gMSkgPyByb3ctMSA6IChyb3ctMSkqKGNvbC0xKTtcblx0ICB2YXIgeHNxciA9IDA7XG5cdCAgdmFyIFBpID1NYXRoLlBJO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHJvdzsgaSArKykge1xuXHQgICAgZm9yIChqID0gMDsgaiA8IGNvbDsgaiArKykge1xuXHQgICAgICB4c3FyICs9IE1hdGgucG93KChvYnNlcnZlZFtpXVtqXSAtIGV4cGVjdGVkW2ldW2pdKSwgMikgLyBleHBlY3RlZFtpXVtqXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBHZXQgaW5kZXBlbmRlbmN5IGJ5IFggc3F1YXJlIGFuZCBpdHMgZGVncmVlIG9mIGZyZWVkb21cblx0ICBmdW5jdGlvbiBDaGlTcSh4c3FyLCBkb2YpIHtcblx0ICAgIHZhciBwID0gTWF0aC5leHAoLTAuNSAqIHhzcXIpO1xuXHQgICAgaWYoKGRvZiUyKSA9PT0gMSkge1xuXHQgICAgICBwID0gcCAqIE1hdGguc3FydCgyICogeHNxci9QaSk7XG5cdCAgICB9XG5cdCAgICB2YXIgayA9IGRvZjtcblx0ICAgIHdoaWxlKGsgPj0gMikge1xuXHQgICAgICBwID0gcCAqIHhzcXIvaztcblx0ICAgICAgayA9IGsgLSAyO1xuXHQgICAgfVxuXHQgICAgdmFyIHQgPSBwO1xuXHQgICAgdmFyIGEgPSBkb2Y7XG5cdCAgICB3aGlsZSAodCA+IDAuMDAwMDAwMDAwMSpwKSB7XG5cdCAgICAgIGEgPSBhICsgMjtcblx0ICAgICAgdCA9IHQgKiB4c3FyL2E7XG5cdCAgICAgIHAgPSBwICsgdDtcblx0ICAgIH1cblx0ICAgIHJldHVybiAxLXA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIE1hdGgucm91bmQoQ2hpU3EoeHNxciwgZG9mKSAqIDEwMDAwMDApIC8gMTAwMDAwMDtcblx0fTtcblxuXHRleHBvcnRzLkNPTFVNTiA9IGZ1bmN0aW9uKG1hdHJpeCwgaW5kZXgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChpbmRleCA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgQXJyYXkpIHx8ICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChtYXRyaXgubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jb2wobWF0cml4LCBpbmRleCk7XG5cdH07XG5cblx0ZXhwb3J0cy5DT0xVTU5TID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LmNvbHMobWF0cml4KTtcblx0fTtcblxuXHRleHBvcnRzLkNPTkZJREVOQ0UgPSB7fTtcblxuXHRleHBvcnRzLkNPTkZJREVOQ0UuTk9STSA9IGZ1bmN0aW9uKGFscGhhLCBzZCwgbikge1xuXHQgIGFscGhhID0gdXRpbHMucGFyc2VOdW1iZXIoYWxwaGEpO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhbHBoYSwgc2QsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5ub3JtYWxjaSgxLCBhbHBoYSwgc2QsIG4pWzFdIC0gMTtcblx0fTtcblxuXHRleHBvcnRzLkNPTkZJREVOQ0UuVCA9IGZ1bmN0aW9uKGFscGhhLCBzZCwgbikge1xuXHQgIGFscGhhID0gdXRpbHMucGFyc2VOdW1iZXIoYWxwaGEpO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhbHBoYSwgc2QsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC50Y2koMSwgYWxwaGEsIHNkLCBuKVsxXSAtIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5DT1JSRUwgPSBmdW5jdGlvbihhcnJheTEsIGFycmF5Mikge1xuXHQgIGFycmF5MSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTEpKTtcblx0ICBhcnJheTIgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkyKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXkxLCBhcnJheTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5jb3JyY29lZmYoYXJyYXkxLCBhcnJheTIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09VTlQgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpLmxlbmd0aDtcblx0fTtcblxuXHRleHBvcnRzLkNPVU5UQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICByZXR1cm4gcmFuZ2UubGVuZ3RoIC0gZXhwb3J0cy5DT1VOVEJMQU5LKHJhbmdlKTtcblx0fTtcblxuXHRleHBvcnRzLkNPVU5USU4gPSBmdW5jdGlvbiAocmFuZ2UsIHZhbHVlKSB7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHJhbmdlW2ldID09PSB2YWx1ZSkge1xuXHQgICAgICByZXN1bHQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXG5cdGV4cG9ydHMuQ09VTlRCTEFOSyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgYmxhbmtzID0gMDtcblx0ICB2YXIgZWxlbWVudDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBlbGVtZW50ID0gcmFuZ2VbaV07XG5cdCAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSAnJykge1xuXHQgICAgICBibGFua3MrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGJsYW5rcztcblx0fTtcblxuXHRleHBvcnRzLkNPVU5USUYgPSBmdW5jdGlvbihyYW5nZSwgY3JpdGVyaWEpIHtcblx0ICByYW5nZSA9IHV0aWxzLmZsYXR0ZW4ocmFuZ2UpO1xuXHQgIGlmICghL1s8Pj0hXS8udGVzdChjcml0ZXJpYSkpIHtcblx0ICAgIGNyaXRlcmlhID0gJz09XCInICsgY3JpdGVyaWEgKyAnXCInO1xuXHQgIH1cblx0ICB2YXIgbWF0Y2hlcyA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHR5cGVvZiByYW5nZVtpXSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgaWYgKGV2YWwocmFuZ2VbaV0gKyBjcml0ZXJpYSkpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICAgICAgbWF0Y2hlcysrO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoZXZhbCgnXCInICsgcmFuZ2VbaV0gKyAnXCInICsgY3JpdGVyaWEpKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICAgIG1hdGNoZXMrKztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbWF0Y2hlcztcblx0fTtcblxuXHRleHBvcnRzLkNPVU5USUZTID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5hcmdzVG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KHV0aWxzLmZsYXR0ZW4oYXJnc1swXSkubGVuZ3RoKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdHNbaV0gPSB0cnVlO1xuXHQgIH1cblx0ICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmdzW2ldKTtcblx0ICAgIHZhciBjcml0ZXJpYSA9IGFyZ3NbaSArIDFdO1xuXHQgICAgaWYgKCEvWzw+PSFdLy50ZXN0KGNyaXRlcmlhKSkge1xuXHQgICAgICBjcml0ZXJpYSA9ICc9PVwiJyArIGNyaXRlcmlhICsgJ1wiJztcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmFuZ2UubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgaWYgKHR5cGVvZiByYW5nZVtqXSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICByZXN1bHRzW2pdID0gcmVzdWx0c1tqXSAmJiBldmFsKHJhbmdlW2pdICsgY3JpdGVyaWEpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXN1bHRzW2pdID0gcmVzdWx0c1tqXSAmJiBldmFsKCdcIicgKyByYW5nZVtqXSArICdcIicgKyBjcml0ZXJpYSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAoaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAocmVzdWx0c1tpXSkge1xuXHQgICAgICByZXN1bHQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkNPVU5UVU5JUVVFID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBtaXNjLlVOSVFVRS5hcHBseShudWxsLCB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpLmxlbmd0aDtcblx0fTtcblxuXHRleHBvcnRzLkNPVkFSSUFOQ0UgPSB7fTtcblxuXHRleHBvcnRzLkNPVkFSSUFOQ0UuUCA9IGZ1bmN0aW9uKGFycmF5MSwgYXJyYXkyKSB7XG5cdCAgYXJyYXkxID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5MSkpO1xuXHQgIGFycmF5MiA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTIpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheTEsIGFycmF5MikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4xID0galN0YXQubWVhbihhcnJheTEpO1xuXHQgIHZhciBtZWFuMiA9IGpTdGF0Lm1lYW4oYXJyYXkyKTtcblx0ICB2YXIgcmVzdWx0ID0gMDtcblx0ICB2YXIgbiA9IGFycmF5MS5sZW5ndGg7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSAoYXJyYXkxW2ldIC0gbWVhbjEpICogKGFycmF5MltpXSAtIG1lYW4yKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdCAvIG47XG5cdH07XG5cblx0ZXhwb3J0cy5DT1ZBUklBTkNFLlMgPSBmdW5jdGlvbihhcnJheTEsIGFycmF5Mikge1xuXHQgIGFycmF5MSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcnJheTEpKTtcblx0ICBhcnJheTIgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkyKSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXkxLCBhcnJheTIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5jb3ZhcmlhbmNlKGFycmF5MSwgYXJyYXkyKTtcblx0fTtcblxuXHRleHBvcnRzLkRFVlNRID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBtZWFuID0galN0YXQubWVhbihyYW5nZSk7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0ICs9IE1hdGgucG93KChyYW5nZVtpXSAtIG1lYW4pLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkVYUE9OID0ge307XG5cblx0ZXhwb3J0cy5FWFBPTi5ESVNUID0gZnVuY3Rpb24oeCwgbGFtYmRhLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGxhbWJkYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGxhbWJkYSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbGFtYmRhKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQuZXhwb25lbnRpYWwuY2RmKHgsIGxhbWJkYSkgOiBqU3RhdC5leHBvbmVudGlhbC5wZGYoeCwgbGFtYmRhKTtcblx0fTtcblxuXHRleHBvcnRzLkYgPSB7fTtcblxuXHRleHBvcnRzLkYuRElTVCA9IGZ1bmN0aW9uKHgsIGQxLCBkMiwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBkMSA9IHV0aWxzLnBhcnNlTnVtYmVyKGQxKTtcblx0ICBkMiA9IHV0aWxzLnBhcnNlTnVtYmVyKGQyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBkMSwgZDIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5jZW50cmFsRi5jZGYoeCwgZDEsIGQyKSA6IGpTdGF0LmNlbnRyYWxGLnBkZih4LCBkMSwgZDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRi5ESVNULlJUID0gZnVuY3Rpb24oeCwgZDEsIGQyKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoeCA8IDAgfHwgZDEgPCAxIHx8IGQyIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBkMSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZDIgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiAxIC0galN0YXQuY2VudHJhbEYuY2RmKHgsIGQxLCBkMik7XG5cdH07XG5cblx0ZXhwb3J0cy5GLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBkMSwgZDIpIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBkMSA9IHV0aWxzLnBhcnNlTnVtYmVyKGQxKTtcblx0ICBkMiA9IHV0aWxzLnBhcnNlTnVtYmVyKGQyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgZDEsIGQyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAocHJvYmFiaWxpdHkgPD0gMC4wIHx8IHByb2JhYmlsaXR5ID4gMS4wKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jZW50cmFsRi5pbnYocHJvYmFiaWxpdHksIGQxLCBkMik7XG5cdH07XG5cblx0ZXhwb3J0cy5GLklOVi5SVCA9IGZ1bmN0aW9uKHAsIGQxLCBkMikge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAzKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKHAgPCAwIHx8IHAgPiAxIHx8IGQxIDwgMSB8fCBkMSA+IE1hdGgucG93KDEwLCAxMCkgfHwgZDIgPCAxIHx8IGQyID4gTWF0aC5wb3coMTAsIDEwKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiBwICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBkMSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZDIgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5jZW50cmFsRi5pbnYoMS4wIC0gcCwgZDEsIGQyKTtcblx0fTtcblxuXHRleHBvcnRzLkYuVEVTVCA9IGZ1bmN0aW9uKGFycmF5MSwgYXJyYXkyKSB7XG5cdCAgaWYgKCFhcnJheTEgfHwgIWFycmF5Mikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICghKGFycmF5MSBpbnN0YW5jZW9mIEFycmF5KSB8fCAhKGFycmF5MiBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmIChhcnJheTEubGVuZ3RoIDwgMiB8fCBhcnJheTIubGVuZ3RoIDwgMikge1xuXHQgICAgcmV0dXJuIGVycm9yLmRpdjA7XG5cdCAgfVxuXG5cdCAgdmFyIHN1bU9mU3F1YXJlcyA9IGZ1bmN0aW9uKHZhbHVlcywgeDEpIHtcblx0ICAgIHZhciBzdW0gPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgc3VtICs9TWF0aC5wb3coKHZhbHVlc1tpXSAtIHgxKSwgMik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3VtO1xuXHQgIH07XG5cblx0ICB2YXIgeDEgPSBtYXRoVHJpZy5TVU0oYXJyYXkxKSAvIGFycmF5MS5sZW5ndGg7XG5cdCAgdmFyIHgyID0gbWF0aFRyaWcuU1VNKGFycmF5MikgLyBhcnJheTIubGVuZ3RoO1xuXHQgIHZhciBzdW0xID0gc3VtT2ZTcXVhcmVzKGFycmF5MSwgeDEpIC8gKGFycmF5MS5sZW5ndGggLSAxKTtcblx0ICB2YXIgc3VtMiA9IHN1bU9mU3F1YXJlcyhhcnJheTIsIHgyKSAvIChhcnJheTIubGVuZ3RoIC0gMSk7XG5cblx0ICByZXR1cm4gc3VtMSAvIHN1bTI7XG5cdH07XG5cblx0ZXhwb3J0cy5GSVNIRVIgPSBmdW5jdGlvbih4KSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGlmICh4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiB4O1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcblx0fTtcblxuXHRleHBvcnRzLkZJU0hFUklOViA9IGZ1bmN0aW9uKHkpIHtcblx0ICB5ID0gdXRpbHMucGFyc2VOdW1iZXIoeSk7XG5cdCAgaWYgKHkgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHk7XG5cdCAgfVxuXHQgIHZhciBlMnkgPSBNYXRoLmV4cCgyICogeSk7XG5cdCAgcmV0dXJuIChlMnkgLSAxKSAvIChlMnkgKyAxKTtcblx0fTtcblxuXHRleHBvcnRzLkZPUkVDQVNUID0gZnVuY3Rpb24oeCwgZGF0YV95LCBkYXRhX3gpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHhtZWFuID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgbiA9IGRhdGFfeC5sZW5ndGg7XG5cdCAgdmFyIG51bSA9IDA7XG5cdCAgdmFyIGRlbiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIG51bSArPSAoZGF0YV94W2ldIC0geG1lYW4pICogKGRhdGFfeVtpXSAtIHltZWFuKTtcblx0ICAgIGRlbiArPSBNYXRoLnBvdyhkYXRhX3hbaV0gLSB4bWVhbiwgMik7XG5cdCAgfVxuXHQgIHZhciBiID0gbnVtIC8gZGVuO1xuXHQgIHZhciBhID0geW1lYW4gLSBiICogeG1lYW47XG5cdCAgcmV0dXJuIGEgKyBiICogeDtcblx0fTtcblxuXHRleHBvcnRzLkZSRVFVRU5DWSA9IGZ1bmN0aW9uKGRhdGEsIGJpbnMpIHtcblx0ICBkYXRhID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGEpKTtcblx0ICBiaW5zID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGJpbnMpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhLCBiaW5zKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgbiA9IGRhdGEubGVuZ3RoO1xuXHQgIHZhciBiID0gYmlucy5sZW5ndGg7XG5cdCAgdmFyIHIgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8PSBiOyBpKyspIHtcblx0ICAgIHJbaV0gPSAwO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcblx0ICAgICAgaWYgKGkgPT09IDApIHtcblx0ICAgICAgICBpZiAoZGF0YVtqXSA8PSBiaW5zWzBdKSB7XG5cdCAgICAgICAgICByWzBdICs9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKGkgPCBiKSB7XG5cdCAgICAgICAgaWYgKGRhdGFbal0gPiBiaW5zW2kgLSAxXSAmJiBkYXRhW2pdIDw9IGJpbnNbaV0pIHtcblx0ICAgICAgICAgIHJbaV0gKz0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoaSA9PT0gYikge1xuXHQgICAgICAgIGlmIChkYXRhW2pdID4gYmluc1tiIC0gMV0pIHtcblx0ICAgICAgICAgIHJbYl0gKz0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblxuXHRleHBvcnRzLkdBTU1BID0gZnVuY3Rpb24obnVtYmVyKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgaWYgKG51bWJlciA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAocGFyc2VJbnQobnVtYmVyLCAxMCkgPT09IG51bWJlciAmJiBudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5nYW1tYWZuKG51bWJlcik7XG5cdH07XG5cblx0ZXhwb3J0cy5HQU1NQS5ESVNUID0gZnVuY3Rpb24odmFsdWUsIGFscGhhLCBiZXRhLCBjdW11bGF0aXZlKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDQpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAodmFsdWUgPCAwIHx8IGFscGhhIDw9IDAgfHwgYmV0YSA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGFscGhhICE9PSAnbnVtYmVyJykgfHwgKHR5cGVvZiBiZXRhICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gY3VtdWxhdGl2ZSA/IGpTdGF0LmdhbW1hLmNkZih2YWx1ZSwgYWxwaGEsIGJldGEsIHRydWUpIDogalN0YXQuZ2FtbWEucGRmKHZhbHVlLCBhbHBoYSwgYmV0YSwgZmFsc2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0FNTUEuSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIGFscGhhLCBiZXRhKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAocHJvYmFiaWxpdHkgPCAwIHx8IHByb2JhYmlsaXR5ID4gMSB8fCBhbHBoYSA8PSAwIHx8IGJldGEgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoKHR5cGVvZiBwcm9iYWJpbGl0eSAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgYWxwaGEgIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGJldGEgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5nYW1tYS5pbnYocHJvYmFiaWxpdHksIGFscGhhLCBiZXRhKTtcblx0fTtcblxuXHRleHBvcnRzLkdBTU1BTE4gPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LmdhbW1hbG4obnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLkdBTU1BTE4uUFJFQ0lTRSA9IGZ1bmN0aW9uKHgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICh4IDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5nYW1tYWxuKHgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0FVU1MgPSBmdW5jdGlvbih6KSB7XG5cdCAgeiA9IHV0aWxzLnBhcnNlTnVtYmVyKHopO1xuXHQgIGlmICh6IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiB6O1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQubm9ybWFsLmNkZih6LCAwLCAxKSAtIDAuNTtcblx0fTtcblxuXHRleHBvcnRzLkdFT01FQU4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAoYXJncyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gYXJncztcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0Lmdlb21lYW4oYXJncyk7XG5cdH07XG5cblx0ZXhwb3J0cy5HUk9XVEggPSBmdW5jdGlvbihrbm93bl95LCBrbm93bl94LCBuZXdfeCwgdXNlX2NvbnN0KSB7XG5cdCAgLy8gQ3JlZGl0czogSWxtYXJpIEthcm9uZW4gKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQxNjE5OTAvaG93LXRvLWltcGxlbWVudC1ncm93dGgtZnVuY3Rpb24taW4tamF2YXNjcmlwdClcblxuXHQgIGtub3duX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KGtub3duX3kpO1xuXHQgIGlmIChrbm93bl95IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBrbm93bl95O1xuXHQgIH1cblxuXHQgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25hbCBwYXJhbWV0ZXJzOlxuXHQgIHZhciBpO1xuXHQgIGlmIChrbm93bl94ID09PSB1bmRlZmluZWQpIHtcblx0ICAgIGtub3duX3ggPSBbXTtcblx0ICAgIGZvciAoaSA9IDE7IGkgPD0ga25vd25feS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBrbm93bl94LnB1c2goaSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmIChuZXdfeCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBuZXdfeCA9IFtdO1xuXHQgICAgZm9yIChpID0gMTsgaSA8PSBrbm93bl95Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIG5ld194LnB1c2goaSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAga25vd25feCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoa25vd25feCk7XG5cdCAgbmV3X3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KG5ld194KTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihrbm93bl94LCBuZXdfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblxuXHQgIGlmICh1c2VfY29uc3QgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgdXNlX2NvbnN0ID0gdHJ1ZTtcblx0ICB9XG5cblx0ICAvLyBDYWxjdWxhdGUgc3VtcyBvdmVyIHRoZSBkYXRhOlxuXHQgIHZhciBuID0ga25vd25feS5sZW5ndGg7XG5cdCAgdmFyIGF2Z194ID0gMDtcblx0ICB2YXIgYXZnX3kgPSAwO1xuXHQgIHZhciBhdmdfeHkgPSAwO1xuXHQgIHZhciBhdmdfeHggPSAwO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHZhciB4ID0ga25vd25feFtpXTtcblx0ICAgIHZhciB5ID0gTWF0aC5sb2coa25vd25feVtpXSk7XG5cdCAgICBhdmdfeCArPSB4O1xuXHQgICAgYXZnX3kgKz0geTtcblx0ICAgIGF2Z194eSArPSB4ICogeTtcblx0ICAgIGF2Z194eCArPSB4ICogeDtcblx0ICB9XG5cdCAgYXZnX3ggLz0gbjtcblx0ICBhdmdfeSAvPSBuO1xuXHQgIGF2Z194eSAvPSBuO1xuXHQgIGF2Z194eCAvPSBuO1xuXG5cdCAgLy8gQ29tcHV0ZSBsaW5lYXIgcmVncmVzc2lvbiBjb2VmZmljaWVudHM6XG5cdCAgdmFyIGJldGE7XG5cdCAgdmFyIGFscGhhO1xuXHQgIGlmICh1c2VfY29uc3QpIHtcblx0ICAgIGJldGEgPSAoYXZnX3h5IC0gYXZnX3ggKiBhdmdfeSkgLyAoYXZnX3h4IC0gYXZnX3ggKiBhdmdfeCk7XG5cdCAgICBhbHBoYSA9IGF2Z195IC0gYmV0YSAqIGF2Z194O1xuXHQgIH0gZWxzZSB7XG5cdCAgICBiZXRhID0gYXZnX3h5IC8gYXZnX3h4O1xuXHQgICAgYWxwaGEgPSAwO1xuXHQgIH1cblxuXHQgIC8vIENvbXB1dGUgYW5kIHJldHVybiByZXN1bHQgYXJyYXk6XG5cdCAgdmFyIG5ld195ID0gW107XG5cdCAgZm9yIChpID0gMDsgaSA8IG5ld194Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBuZXdfeS5wdXNoKE1hdGguZXhwKGFscGhhICsgYmV0YSAqIG5ld194W2ldKSk7XG5cdCAgfVxuXHQgIHJldHVybiBuZXdfeTtcblx0fTtcblxuXHRleHBvcnRzLkhBUk1FQU4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIGRlbiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGRlbiArPSAxIC8gcmFuZ2VbaV07XG5cdCAgfVxuXHQgIHJldHVybiBuIC8gZGVuO1xuXHR9O1xuXG5cdGV4cG9ydHMuSFlQR0VPTSA9IHt9O1xuXG5cdGV4cG9ydHMuSFlQR0VPTS5ESVNUID0gZnVuY3Rpb24oeCwgbiwgTSwgTiwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgTSA9IHV0aWxzLnBhcnNlTnVtYmVyKE0pO1xuXHQgIE4gPSB1dGlscy5wYXJzZU51bWJlcihOKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuLCBNLCBOKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHBkZih4LCBuLCBNLCBOKSB7XG5cdCAgICByZXR1cm4gbWF0aFRyaWcuQ09NQklOKE0sIHgpICogbWF0aFRyaWcuQ09NQklOKE4gLSBNLCBuIC0geCkgLyBtYXRoVHJpZy5DT01CSU4oTiwgbik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY2RmKHgsIG4sIE0sIE4pIHtcblx0ICAgIHZhciByZXN1bHQgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0geDsgaSsrKSB7XG5cdCAgICAgIHJlc3VsdCArPSBwZGYoaSwgbiwgTSwgTik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBjZGYoeCwgbiwgTSwgTikgOiBwZGYoeCwgbiwgTSwgTik7XG5cdH07XG5cblx0ZXhwb3J0cy5JTlRFUkNFUFQgPSBmdW5jdGlvbihrbm93bl95LCBrbm93bl94KSB7XG5cdCAga25vd25feSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoa25vd25feSk7XG5cdCAga25vd25feCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkoa25vd25feCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioa25vd25feSwga25vd25feCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGtub3duX3kubGVuZ3RoICE9PSBrbm93bl94Lmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblx0ICByZXR1cm4gZXhwb3J0cy5GT1JFQ0FTVCgwLCBrbm93bl95LCBrbm93bl94KTtcblx0fTtcblxuXHRleHBvcnRzLktVUlQgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKHJhbmdlKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc2lnbWEgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBzaWdtYSArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDQpO1xuXHQgIH1cblx0ICBzaWdtYSA9IHNpZ21hIC8gTWF0aC5wb3coalN0YXQuc3RkZXYocmFuZ2UsIHRydWUpLCA0KTtcblx0ICByZXR1cm4gKChuICogKG4gKyAxKSkgLyAoKG4gLSAxKSAqIChuIC0gMikgKiAobiAtIDMpKSkgKiBzaWdtYSAtIDMgKiAobiAtIDEpICogKG4gLSAxKSAvICgobiAtIDIpICogKG4gLSAzKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5MQVJHRSA9IGZ1bmN0aW9uKHJhbmdlLCBrKSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIGspKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHJldHVybiByYW5nZS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBiIC0gYTtcblx0ICB9KVtrIC0gMV07XG5cdH07XG5cblx0ZXhwb3J0cy5MSU5FU1QgPSBmdW5jdGlvbihkYXRhX3ksIGRhdGFfeCkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgeG1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeCk7XG5cdCAgdmFyIG4gPSBkYXRhX3gubGVuZ3RoO1xuXHQgIHZhciBudW0gPSAwO1xuXHQgIHZhciBkZW4gPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBudW0gKz0gKGRhdGFfeFtpXSAtIHhtZWFuKSAqIChkYXRhX3lbaV0gLSB5bWVhbik7XG5cdCAgICBkZW4gKz0gTWF0aC5wb3coZGF0YV94W2ldIC0geG1lYW4sIDIpO1xuXHQgIH1cblx0ICB2YXIgbSA9IG51bSAvIGRlbjtcblx0ICB2YXIgYiA9IHltZWFuIC0gbSAqIHhtZWFuO1xuXHQgIHJldHVybiBbbSwgYl07XG5cdH07XG5cblx0Ly8gQWNjb3JkaW5nIHRvIE1pY3Jvc29mdDpcblx0Ly8gaHR0cDovL29mZmljZS5taWNyb3NvZnQuY29tL2VuLXVzL3N0YXJ0ZXItaGVscC9sb2dlc3QtZnVuY3Rpb24tSFAwMTAzNDI2NjUuYXNweFxuXHQvLyBMT0dFU1QgcmV0dXJucyBhcmUgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBsaW5lYXIgbW9kZWw6XG5cdC8vIGxuIHkgPSB4MSBsbiBtMSArIC4uLiArIHhuIGxuIG1uICsgbG4gYlxuXHRleHBvcnRzLkxPR0VTVCA9IGZ1bmN0aW9uKGRhdGFfeSwgZGF0YV94KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhX3kubGVuZ3RoOyBpICsrKSB7XG5cdCAgICBkYXRhX3lbaV0gPSBNYXRoLmxvZyhkYXRhX3lbaV0pO1xuXHQgIH1cblxuXHQgIHZhciByZXN1bHQgPSBleHBvcnRzLkxJTkVTVChkYXRhX3ksIGRhdGFfeCk7XG5cdCAgcmVzdWx0WzBdID0gTWF0aC5yb3VuZChNYXRoLmV4cChyZXN1bHRbMF0pKjEwMDAwMDApLzEwMDAwMDA7XG5cdCAgcmVzdWx0WzFdID0gTWF0aC5yb3VuZChNYXRoLmV4cChyZXN1bHRbMV0pKjEwMDAwMDApLzEwMDAwMDA7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkxPR05PUk0gPSB7fTtcblxuXHRleHBvcnRzLkxPR05PUk0uRElTVCA9IGZ1bmN0aW9uKHgsIG1lYW4sIHNkLCBjdW11bGF0aXZlKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG1lYW4gPSB1dGlscy5wYXJzZU51bWJlcihtZWFuKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBtZWFuLCBzZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LmxvZ25vcm1hbC5jZGYoeCwgbWVhbiwgc2QpIDogalN0YXQubG9nbm9ybWFsLnBkZih4LCBtZWFuLCBzZCk7XG5cdH07XG5cblx0ZXhwb3J0cy5MT0dOT1JNLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBtZWFuLCBzZCkge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIG1lYW4gPSB1dGlscy5wYXJzZU51bWJlcihtZWFuKTtcblx0ICBzZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNkKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgbWVhbiwgc2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBqU3RhdC5sb2dub3JtYWwuaW52KHByb2JhYmlsaXR5LCBtZWFuLCBzZCk7XG5cdH07XG5cblx0ZXhwb3J0cy5NQVggPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5udW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgcmV0dXJuIChyYW5nZS5sZW5ndGggPT09IDApID8gMCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHJhbmdlKTtcblx0fTtcblxuXHRleHBvcnRzLk1BWEEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5hcnJheVZhbHVlc1RvTnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHJldHVybiAocmFuZ2UubGVuZ3RoID09PSAwKSA/IDAgOiBNYXRoLm1heC5hcHBseShNYXRoLCByYW5nZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5NRURJQU4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5hcnJheVZhbHVlc1RvTnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHJldHVybiBqU3RhdC5tZWRpYW4ocmFuZ2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlOID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHJldHVybiAocmFuZ2UubGVuZ3RoID09PSAwKSA/IDAgOiBNYXRoLm1pbi5hcHBseShNYXRoLCByYW5nZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5NSU5BID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuYXJyYXlWYWx1ZXNUb051bWJlcnModXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICByZXR1cm4gKHJhbmdlLmxlbmd0aCA9PT0gMCkgPyAwIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgcmFuZ2UpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTU9ERSA9IHt9O1xuXG5cdGV4cG9ydHMuTU9ERS5NVUxUID0gZnVuY3Rpb24oKSB7XG5cdCAgLy8gQ3JlZGl0czogUm/Dtm5hw6RuXG5cdCAgdmFyIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIGlmIChyYW5nZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdCAgfVxuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBjb3VudCA9IHt9O1xuXHQgIHZhciBtYXhJdGVtcyA9IFtdO1xuXHQgIHZhciBtYXggPSAwO1xuXHQgIHZhciBjdXJyZW50SXRlbTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBjdXJyZW50SXRlbSA9IHJhbmdlW2ldO1xuXHQgICAgY291bnRbY3VycmVudEl0ZW1dID0gY291bnRbY3VycmVudEl0ZW1dID8gY291bnRbY3VycmVudEl0ZW1dICsgMSA6IDE7XG5cdCAgICBpZiAoY291bnRbY3VycmVudEl0ZW1dID4gbWF4KSB7XG5cdCAgICAgIG1heCA9IGNvdW50W2N1cnJlbnRJdGVtXTtcblx0ICAgICAgbWF4SXRlbXMgPSBbXTtcblx0ICAgIH1cblx0ICAgIGlmIChjb3VudFtjdXJyZW50SXRlbV0gPT09IG1heCkge1xuXHQgICAgICBtYXhJdGVtc1ttYXhJdGVtcy5sZW5ndGhdID0gY3VycmVudEl0ZW07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBtYXhJdGVtcztcblx0fTtcblxuXHRleHBvcnRzLk1PREUuU05HTCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihhcmd1bWVudHMpKTtcblx0ICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICByZXR1cm4gZXhwb3J0cy5NT0RFLk1VTFQocmFuZ2UpLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pWzBdO1xuXHR9O1xuXG5cdGV4cG9ydHMuTkVHQklOT00gPSB7fTtcblxuXHRleHBvcnRzLk5FR0JJTk9NLkRJU1QgPSBmdW5jdGlvbihrLCByLCBwLCBjdW11bGF0aXZlKSB7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIHIgPSB1dGlscy5wYXJzZU51bWJlcihyKTtcblx0ICBwID0gdXRpbHMucGFyc2VOdW1iZXIocCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoaywgciwgcCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0Lm5lZ2Jpbi5jZGYoaywgciwgcCkgOiBqU3RhdC5uZWdiaW4ucGRmKGssIHIsIHApO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9STSA9IHt9O1xuXG5cdGV4cG9ydHMuTk9STS5ESVNUID0gZnVuY3Rpb24oeCwgbWVhbiwgc2QsIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbWVhbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG1lYW4pO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG1lYW4sIHNkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoc2QgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbm9ybWFsIGRpc3RyaWJ1dGlvbiBjb21wdXRlZCBieSBqU3RhdCBbaHR0cDovL2pzdGF0Lm9yZ11cblx0ICByZXR1cm4gKGN1bXVsYXRpdmUpID8galN0YXQubm9ybWFsLmNkZih4LCBtZWFuLCBzZCkgOiBqU3RhdC5ub3JtYWwucGRmKHgsIG1lYW4sIHNkKTtcblx0fTtcblxuXHRleHBvcnRzLk5PUk0uSU5WID0gZnVuY3Rpb24ocHJvYmFiaWxpdHksIG1lYW4sIHNkKSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgbWVhbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG1lYW4pO1xuXHQgIHNkID0gdXRpbHMucGFyc2VOdW1iZXIoc2QpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBtZWFuLCBzZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0Lm5vcm1hbC5pbnYocHJvYmFiaWxpdHksIG1lYW4sIHNkKTtcblx0fTtcblxuXHRleHBvcnRzLk5PUk0uUyA9IHt9O1xuXG5cdGV4cG9ydHMuTk9STS5TLkRJU1QgPSBmdW5jdGlvbih6LCBjdW11bGF0aXZlKSB7XG5cdCAgeiA9IHV0aWxzLnBhcnNlTnVtYmVyKHopO1xuXHQgIGlmICh6IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0Lm5vcm1hbC5jZGYoeiwgMCwgMSkgOiBqU3RhdC5ub3JtYWwucGRmKHosIDAsIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9STS5TLklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5KSB7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlcihwcm9iYWJpbGl0eSk7XG5cdCAgaWYgKHByb2JhYmlsaXR5IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0Lm5vcm1hbC5pbnYocHJvYmFiaWxpdHksIDAsIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVBUlNPTiA9IGZ1bmN0aW9uKGRhdGFfeCwgZGF0YV95KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHhtZWFuID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgbiA9IGRhdGFfeC5sZW5ndGg7XG5cdCAgdmFyIG51bSA9IDA7XG5cdCAgdmFyIGRlbjEgPSAwO1xuXHQgIHZhciBkZW4yID0gMDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgbnVtICs9IChkYXRhX3hbaV0gLSB4bWVhbikgKiAoZGF0YV95W2ldIC0geW1lYW4pO1xuXHQgICAgZGVuMSArPSBNYXRoLnBvdyhkYXRhX3hbaV0gLSB4bWVhbiwgMik7XG5cdCAgICBkZW4yICs9IE1hdGgucG93KGRhdGFfeVtpXSAtIHltZWFuLCAyKTtcblx0ICB9XG5cdCAgcmV0dXJuIG51bSAvIE1hdGguc3FydChkZW4xICogZGVuMik7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJDRU5USUxFID0ge307XG5cblx0ZXhwb3J0cy5QRVJDRU5USUxFLkVYQyA9IGZ1bmN0aW9uKGFycmF5LCBrKSB7XG5cdCAgYXJyYXkgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkpKTtcblx0ICBrID0gdXRpbHMucGFyc2VOdW1iZXIoayk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXksIGspKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGFycmF5ID0gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICB7XG5cdCAgICAgIHJldHVybiBhIC0gYjtcblx0ICAgIH1cblx0ICB9KTtcblx0ICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcblx0ICBpZiAoayA8IDEgLyAobiArIDEpIHx8IGsgPiAxIC0gMSAvIChuICsgMSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHQgIHZhciBsID0gayAqIChuICsgMSkgLSAxO1xuXHQgIHZhciBmbCA9IE1hdGguZmxvb3IobCk7XG5cdCAgcmV0dXJuIHV0aWxzLmNsZWFuRmxvYXQoKGwgPT09IGZsKSA/IGFycmF5W2xdIDogYXJyYXlbZmxdICsgKGwgLSBmbCkgKiAoYXJyYXlbZmwgKyAxXSAtIGFycmF5W2ZsXSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVSQ0VOVElMRS5JTkMgPSBmdW5jdGlvbihhcnJheSwgaykge1xuXHQgIGFycmF5ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5KSk7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGFycmF5LCBrKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBhcnJheSA9IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pO1xuXHQgIHZhciBuID0gYXJyYXkubGVuZ3RoO1xuXHQgIHZhciBsID0gayAqIChuIC0gMSk7XG5cdCAgdmFyIGZsID0gTWF0aC5mbG9vcihsKTtcblx0ICByZXR1cm4gdXRpbHMuY2xlYW5GbG9hdCgobCA9PT0gZmwpID8gYXJyYXlbbF0gOiBhcnJheVtmbF0gKyAobCAtIGZsKSAqIChhcnJheVtmbCArIDFdIC0gYXJyYXlbZmxdKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJDRU5UUkFOSyA9IHt9O1xuXG5cdGV4cG9ydHMuUEVSQ0VOVFJBTksuRVhDID0gZnVuY3Rpb24oYXJyYXksIHgsIHNpZ25pZmljYW5jZSkge1xuXHQgIHNpZ25pZmljYW5jZSA9IChzaWduaWZpY2FuY2UgPT09IHVuZGVmaW5lZCkgPyAzIDogc2lnbmlmaWNhbmNlO1xuXHQgIGFycmF5ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGFycmF5KSk7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIHNpZ25pZmljYW5jZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNpZ25pZmljYW5jZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYXJyYXksIHgsIHNpZ25pZmljYW5jZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgYXJyYXkgPSBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KTtcblx0ICB2YXIgdW5pcXVlcyA9IG1pc2MuVU5JUVVFLmFwcGx5KG51bGwsIGFycmF5KTtcblx0ICB2YXIgbiA9IGFycmF5Lmxlbmd0aDtcblx0ICB2YXIgbSA9IHVuaXF1ZXMubGVuZ3RoO1xuXHQgIHZhciBwb3dlciA9IE1hdGgucG93KDEwLCBzaWduaWZpY2FuY2UpO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIHZhciBtYXRjaCA9IGZhbHNlO1xuXHQgIHZhciBpID0gMDtcblx0ICB3aGlsZSAoIW1hdGNoICYmIGkgPCBtKSB7XG5cdCAgICBpZiAoeCA9PT0gdW5pcXVlc1tpXSkge1xuXHQgICAgICByZXN1bHQgPSAoYXJyYXkuaW5kZXhPZih1bmlxdWVzW2ldKSArIDEpIC8gKG4gKyAxKTtcblx0ICAgICAgbWF0Y2ggPSB0cnVlO1xuXHQgICAgfSBlbHNlIGlmICh4ID49IHVuaXF1ZXNbaV0gJiYgKHggPCB1bmlxdWVzW2kgKyAxXSB8fCBpID09PSBtIC0gMSkpIHtcblx0ICAgICAgcmVzdWx0ID0gKGFycmF5LmluZGV4T2YodW5pcXVlc1tpXSkgKyAxICsgKHggLSB1bmlxdWVzW2ldKSAvICh1bmlxdWVzW2kgKyAxXSAtIHVuaXF1ZXNbaV0pKSAvIChuICsgMSk7XG5cdCAgICAgIG1hdGNoID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGkrKztcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguZmxvb3IocmVzdWx0ICogcG93ZXIpIC8gcG93ZXI7XG5cdH07XG5cblx0ZXhwb3J0cy5QRVJDRU5UUkFOSy5JTkMgPSBmdW5jdGlvbihhcnJheSwgeCwgc2lnbmlmaWNhbmNlKSB7XG5cdCAgc2lnbmlmaWNhbmNlID0gKHNpZ25pZmljYW5jZSA9PT0gdW5kZWZpbmVkKSA/IDMgOiBzaWduaWZpY2FuY2U7XG5cdCAgYXJyYXkgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJyYXkpKTtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgc2lnbmlmaWNhbmNlID0gdXRpbHMucGFyc2VOdW1iZXIoc2lnbmlmaWNhbmNlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhcnJheSwgeCwgc2lnbmlmaWNhbmNlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBhcnJheSA9IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0pO1xuXHQgIHZhciB1bmlxdWVzID0gbWlzYy5VTklRVUUuYXBwbHkobnVsbCwgYXJyYXkpO1xuXHQgIHZhciBuID0gYXJyYXkubGVuZ3RoO1xuXHQgIHZhciBtID0gdW5pcXVlcy5sZW5ndGg7XG5cdCAgdmFyIHBvd2VyID0gTWF0aC5wb3coMTAsIHNpZ25pZmljYW5jZSk7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgdmFyIG1hdGNoID0gZmFsc2U7XG5cdCAgdmFyIGkgPSAwO1xuXHQgIHdoaWxlICghbWF0Y2ggJiYgaSA8IG0pIHtcblx0ICAgIGlmICh4ID09PSB1bmlxdWVzW2ldKSB7XG5cdCAgICAgIHJlc3VsdCA9IGFycmF5LmluZGV4T2YodW5pcXVlc1tpXSkgLyAobiAtIDEpO1xuXHQgICAgICBtYXRjaCA9IHRydWU7XG5cdCAgICB9IGVsc2UgaWYgKHggPj0gdW5pcXVlc1tpXSAmJiAoeCA8IHVuaXF1ZXNbaSArIDFdIHx8IGkgPT09IG0gLSAxKSkge1xuXHQgICAgICByZXN1bHQgPSAoYXJyYXkuaW5kZXhPZih1bmlxdWVzW2ldKSArICh4IC0gdW5pcXVlc1tpXSkgLyAodW5pcXVlc1tpICsgMV0gLSB1bmlxdWVzW2ldKSkgLyAobiAtIDEpO1xuXHQgICAgICBtYXRjaCA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpKys7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmZsb29yKHJlc3VsdCAqIHBvd2VyKSAvIHBvd2VyO1xuXHR9O1xuXG5cdGV4cG9ydHMuUEVSTVVUID0gZnVuY3Rpb24obnVtYmVyLCBudW1iZXJfY2hvc2VuKSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBudW1iZXJfY2hvc2VuID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyX2Nob3Nlbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyLCBudW1iZXJfY2hvc2VuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gbWF0aFRyaWcuRkFDVChudW1iZXIpIC8gbWF0aFRyaWcuRkFDVChudW1iZXIgLSBudW1iZXJfY2hvc2VuKTtcblx0fTtcblxuXHRleHBvcnRzLlBFUk1VVEFUSU9OQSA9IGZ1bmN0aW9uKG51bWJlciwgbnVtYmVyX2Nob3Nlbikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgbnVtYmVyX2Nob3NlbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcl9jaG9zZW4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgbnVtYmVyX2Nob3NlbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgucG93KG51bWJlciwgbnVtYmVyX2Nob3Nlbik7XG5cdH07XG5cblx0ZXhwb3J0cy5QSEkgPSBmdW5jdGlvbih4KSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIGlmICh4IGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiB4ICogeCkgLyBTUVJUMlBJO1xuXHR9O1xuXG5cdGV4cG9ydHMuUE9JU1NPTiA9IHt9O1xuXG5cdGV4cG9ydHMuUE9JU1NPTi5ESVNUID0gZnVuY3Rpb24oeCwgbWVhbiwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBtZWFuID0gdXRpbHMucGFyc2VOdW1iZXIobWVhbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbWVhbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIChjdW11bGF0aXZlKSA/IGpTdGF0LnBvaXNzb24uY2RmKHgsIG1lYW4pIDogalN0YXQucG9pc3Nvbi5wZGYoeCwgbWVhbik7XG5cdH07XG5cblx0ZXhwb3J0cy5QUk9CID0gZnVuY3Rpb24ocmFuZ2UsIHByb2JhYmlsaXR5LCBsb3dlciwgdXBwZXIpIHtcblx0ICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXHQgIHVwcGVyID0gKHVwcGVyID09PSB1bmRlZmluZWQpID8gbG93ZXIgOiB1cHBlcjtcblxuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgcHJvYmFiaWxpdHkgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocHJvYmFiaWxpdHkpKTtcblx0ICBsb3dlciA9IHV0aWxzLnBhcnNlTnVtYmVyKGxvd2VyKTtcblx0ICB1cHBlciA9IHV0aWxzLnBhcnNlTnVtYmVyKHVwcGVyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYW5nZSwgcHJvYmFiaWxpdHksIGxvd2VyLCB1cHBlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAobG93ZXIgPT09IHVwcGVyKSB7XG5cdCAgICByZXR1cm4gKHJhbmdlLmluZGV4T2YobG93ZXIpID49IDApID8gcHJvYmFiaWxpdHlbcmFuZ2UuaW5kZXhPZihsb3dlcildIDogMDtcblx0ICB9XG5cblx0ICB2YXIgc29ydGVkID0gcmFuZ2Uuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSk7XG5cdCAgdmFyIG4gPSBzb3J0ZWQubGVuZ3RoO1xuXHQgIHZhciByZXN1bHQgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBpZiAoc29ydGVkW2ldID49IGxvd2VyICYmIHNvcnRlZFtpXSA8PSB1cHBlcikge1xuXHQgICAgICByZXN1bHQgKz0gcHJvYmFiaWxpdHlbcmFuZ2UuaW5kZXhPZihzb3J0ZWRbaV0pXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLlFVQVJUSUxFID0ge307XG5cblx0ZXhwb3J0cy5RVUFSVElMRS5FWEMgPSBmdW5jdGlvbihyYW5nZSwgcXVhcnQpIHtcblx0ICByYW5nZSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihyYW5nZSkpO1xuXHQgIHF1YXJ0ID0gdXRpbHMucGFyc2VOdW1iZXIocXVhcnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBxdWFydCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgc3dpdGNoIChxdWFydCkge1xuXHQgICAgY2FzZSAxOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QRVJDRU5USUxFLkVYQyhyYW5nZSwgMC4yNSk7XG5cdCAgICBjYXNlIDI6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuRVhDKHJhbmdlLCAwLjUpO1xuXHQgICAgY2FzZSAzOlxuXHQgICAgICByZXR1cm4gZXhwb3J0cy5QRVJDRU5USUxFLkVYQyhyYW5nZSwgMC43NSk7XG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLlFVQVJUSUxFLklOQyA9IGZ1bmN0aW9uKHJhbmdlLCBxdWFydCkge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgcXVhcnQgPSB1dGlscy5wYXJzZU51bWJlcihxdWFydCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIHF1YXJ0KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBzd2l0Y2ggKHF1YXJ0KSB7XG5cdCAgICBjYXNlIDE6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuSU5DKHJhbmdlLCAwLjI1KTtcblx0ICAgIGNhc2UgMjpcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuUEVSQ0VOVElMRS5JTkMocmFuZ2UsIDAuNSk7XG5cdCAgICBjYXNlIDM6XG5cdCAgICAgIHJldHVybiBleHBvcnRzLlBFUkNFTlRJTEUuSU5DKHJhbmdlLCAwLjc1KTtcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuUkFOSyA9IHt9O1xuXG5cdGV4cG9ydHMuUkFOSy5BVkcgPSBmdW5jdGlvbihudW1iZXIsIHJhbmdlLCBvcmRlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHJhbmdlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByYW5nZSA9IHV0aWxzLmZsYXR0ZW4ocmFuZ2UpO1xuXHQgIG9yZGVyID0gb3JkZXIgfHwgZmFsc2U7XG5cdCAgdmFyIHNvcnQgPSAob3JkZXIpID8gZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgLSBiO1xuXHQgIH0gOiBmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYiAtIGE7XG5cdCAgfTtcblx0ICByYW5nZSA9IHJhbmdlLnNvcnQoc29ydCk7XG5cblx0ICB2YXIgbGVuZ3RoID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBjb3VudCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHJhbmdlW2ldID09PSBudW1iZXIpIHtcblx0ICAgICAgY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gKGNvdW50ID4gMSkgPyAoMiAqIHJhbmdlLmluZGV4T2YobnVtYmVyKSArIGNvdW50ICsgMSkgLyAyIDogcmFuZ2UuaW5kZXhPZihudW1iZXIpICsgMTtcblx0fTtcblxuXHRleHBvcnRzLlJBTksuRVEgPSBmdW5jdGlvbihudW1iZXIsIHJhbmdlLCBvcmRlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHJhbmdlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBvcmRlciA9IG9yZGVyIHx8IGZhbHNlO1xuXHQgIHZhciBzb3J0ID0gKG9yZGVyKSA/IGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9IDogZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGIgLSBhO1xuXHQgIH07XG5cdCAgcmFuZ2UgPSByYW5nZS5zb3J0KHNvcnQpO1xuXHQgIHJldHVybiByYW5nZS5pbmRleE9mKG51bWJlcikgKyAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuUk9XID0gZnVuY3Rpb24obWF0cml4LCBpbmRleCkge1xuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICBpZiAoIShtYXRyaXggaW5zdGFuY2VvZiBBcnJheSkgfHwgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGpTdGF0LnJvdyhtYXRyaXgsIGluZGV4KTtcblx0fTtcblxuXHRleHBvcnRzLlJPV1MgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICghKG1hdHJpeCBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIGlmIChtYXRyaXgubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQucm93cyhtYXRyaXgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUlNRID0gZnVuY3Rpb24oZGF0YV94LCBkYXRhX3kpIHsgLy8gbm8gbmVlZCB0byBmbGF0dGVuIGhlcmUsIFBFQVJTT04gd2lsbCB0YWtlIGNhcmUgb2YgdGhhdFxuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBkYXRhX3kgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV95KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV94LCBkYXRhX3kpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLnBvdyhleHBvcnRzLlBFQVJTT04oZGF0YV94LCBkYXRhX3kpLCAyKTtcblx0fTtcblxuXHRleHBvcnRzLlNLRVcgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKHJhbmdlKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgc2lnbWEgPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBzaWdtYSArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDMpO1xuXHQgIH1cblx0ICByZXR1cm4gbiAqIHNpZ21hIC8gKChuIC0gMSkgKiAobiAtIDIpICogTWF0aC5wb3coalN0YXQuc3RkZXYocmFuZ2UsIHRydWUpLCAzKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5TS0VXLlAgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiByYW5nZTtcblx0ICB9XG5cdCAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKHJhbmdlKTtcblx0ICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcblx0ICB2YXIgbTIgPSAwO1xuXHQgIHZhciBtMyA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIG0zICs9IE1hdGgucG93KHJhbmdlW2ldIC0gbWVhbiwgMyk7XG5cdCAgICBtMiArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDIpO1xuXHQgIH1cblx0ICBtMyA9IG0zIC8gbjtcblx0ICBtMiA9IG0yIC8gbjtcblx0ICByZXR1cm4gbTMgLyBNYXRoLnBvdyhtMiwgMyAvIDIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0xPUEUgPSBmdW5jdGlvbihkYXRhX3ksIGRhdGFfeCkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciB4bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV94KTtcblx0ICB2YXIgeW1lYW4gPSBqU3RhdC5tZWFuKGRhdGFfeSk7XG5cdCAgdmFyIG4gPSBkYXRhX3gubGVuZ3RoO1xuXHQgIHZhciBudW0gPSAwO1xuXHQgIHZhciBkZW4gPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBudW0gKz0gKGRhdGFfeFtpXSAtIHhtZWFuKSAqIChkYXRhX3lbaV0gLSB5bWVhbik7XG5cdCAgICBkZW4gKz0gTWF0aC5wb3coZGF0YV94W2ldIC0geG1lYW4sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtIC8gZGVuO1xuXHR9O1xuXG5cdGV4cG9ydHMuU01BTEwgPSBmdW5jdGlvbihyYW5nZSwgaykge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgayA9IHV0aWxzLnBhcnNlTnVtYmVyKGspO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBrKSkge1xuXHQgICAgcmV0dXJuIHJhbmdlO1xuXHQgIH1cblx0ICByZXR1cm4gcmFuZ2Uuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSlbayAtIDFdO1xuXHR9O1xuXG5cdGV4cG9ydHMuU1RBTkRBUkRJWkUgPSBmdW5jdGlvbih4LCBtZWFuLCBzZCkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBtZWFuID0gdXRpbHMucGFyc2VOdW1iZXIobWVhbik7XG5cdCAgc2QgPSB1dGlscy5wYXJzZU51bWJlcihzZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbWVhbiwgc2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoeCAtIG1lYW4pIC8gc2Q7XG5cdH07XG5cblx0ZXhwb3J0cy5TVERFViA9IHt9O1xuXG5cdGV4cG9ydHMuU1RERVYuUCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciB2ID0gZXhwb3J0cy5WQVIuUC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIHJldHVybiBNYXRoLnNxcnQodik7XG5cdH07XG5cblx0ZXhwb3J0cy5TVERFVi5TID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHYgPSBleHBvcnRzLlZBUi5TLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIE1hdGguc3FydCh2KTtcblx0fTtcblxuXHRleHBvcnRzLlNUREVWQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciB2ID0gZXhwb3J0cy5WQVJBLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIE1hdGguc3FydCh2KTtcblx0fTtcblxuXHRleHBvcnRzLlNUREVWUEEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgdiA9IGV4cG9ydHMuVkFSUEEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICByZXR1cm4gTWF0aC5zcXJ0KHYpO1xuXHR9O1xuXG5cblx0ZXhwb3J0cy5TVEVZWCA9IGZ1bmN0aW9uKGRhdGFfeSwgZGF0YV94KSB7XG5cdCAgZGF0YV95ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeSkpO1xuXHQgIGRhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3gpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3ksIGRhdGFfeCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHhtZWFuID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciB5bWVhbiA9IGpTdGF0Lm1lYW4oZGF0YV95KTtcblx0ICB2YXIgbiA9IGRhdGFfeC5sZW5ndGg7XG5cdCAgdmFyIGxmdCA9IDA7XG5cdCAgdmFyIG51bSA9IDA7XG5cdCAgdmFyIGRlbiA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGxmdCArPSBNYXRoLnBvdyhkYXRhX3lbaV0gLSB5bWVhbiwgMik7XG5cdCAgICBudW0gKz0gKGRhdGFfeFtpXSAtIHhtZWFuKSAqIChkYXRhX3lbaV0gLSB5bWVhbik7XG5cdCAgICBkZW4gKz0gTWF0aC5wb3coZGF0YV94W2ldIC0geG1lYW4sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5zcXJ0KChsZnQgLSBudW0gKiBudW0gLyBkZW4pIC8gKG4gLSAyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5UUkFOU1BPU0UgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0ICBpZiAoIW1hdHJpeCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblx0ICByZXR1cm4galN0YXQudHJhbnNwb3NlKG1hdHJpeCk7XG5cdH07XG5cblx0ZXhwb3J0cy5UID0gdGV4dC5UO1xuXG5cdGV4cG9ydHMuVC5ESVNUID0gZnVuY3Rpb24oeCwgZGYsIGN1bXVsYXRpdmUpIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgZGYgPSB1dGlscy5wYXJzZU51bWJlcihkZik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgZGYpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyBqU3RhdC5zdHVkZW50dC5jZGYoeCwgZGYpIDogalN0YXQuc3R1ZGVudHQucGRmKHgsIGRmKTtcblx0fTtcblxuXHRleHBvcnRzLlQuRElTVFsnMlQnXSA9IGZ1bmN0aW9uKHgsIGRmKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoeCA8IDAgfHwgZGYgPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIGlmICgodHlwZW9mIHggIT09ICdudW1iZXInKSB8fCAodHlwZW9mIGRmICE9PSAnbnVtYmVyJykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gKDEgLSBqU3RhdC5zdHVkZW50dC5jZGYoeCAsIGRmKSkgKiAyO1xuXHR9O1xuXG5cdGV4cG9ydHMuVC5ESVNULlJUID0gZnVuY3Rpb24oeCwgZGYpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIGlmICh4IDwgMCB8fCBkZiA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgaWYgKCh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHx8ICh0eXBlb2YgZGYgIT09ICdudW1iZXInKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiAxIC0galN0YXQuc3R1ZGVudHQuY2RmKHggLCBkZik7XG5cdH07XG5cblx0ZXhwb3J0cy5ULklOViA9IGZ1bmN0aW9uKHByb2JhYmlsaXR5LCBkZikge1xuXHQgIHByb2JhYmlsaXR5ID0gdXRpbHMucGFyc2VOdW1iZXIocHJvYmFiaWxpdHkpO1xuXHQgIGRmID0gdXRpbHMucGFyc2VOdW1iZXIoZGYpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHByb2JhYmlsaXR5LCBkZikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGpTdGF0LnN0dWRlbnR0Lmludihwcm9iYWJpbGl0eSwgZGYpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVC5JTlZbJzJUJ10gPSBmdW5jdGlvbihwcm9iYWJpbGl0eSwgZGYpIHtcblx0ICBwcm9iYWJpbGl0eSA9IHV0aWxzLnBhcnNlTnVtYmVyKHByb2JhYmlsaXR5KTtcblx0ICBkZiA9IHV0aWxzLnBhcnNlTnVtYmVyKGRmKTtcblx0ICBpZiAocHJvYmFiaWxpdHkgPD0gMCB8fCBwcm9iYWJpbGl0eSA+IDEgfHwgZGYgPCAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcm9iYWJpbGl0eSwgZGYpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmFicyhqU3RhdC5zdHVkZW50dC5pbnYocHJvYmFiaWxpdHkvMiwgZGYpKTtcblx0fTtcblxuXHQvLyBUaGUgYWxnb3JpdGhtIGNhbiBiZSBmb3VuZCBoZXJlOlxuXHQvLyBodHRwOi8vd3d3LmNoZW0udW9hLmdyL2FwcGxldHMvQXBwbGV0VHRlc3QvQXBwbF9UdGVzdDIuaHRtbFxuXHRleHBvcnRzLlQuVEVTVCA9IGZ1bmN0aW9uKGRhdGFfeCwgZGF0YV95KSB7XG5cdCAgZGF0YV94ID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKGRhdGFfeCkpO1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkYXRhX3gsIGRhdGFfeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICB2YXIgbWVhbl94ID0galN0YXQubWVhbihkYXRhX3gpO1xuXHQgIHZhciBtZWFuX3kgPSBqU3RhdC5tZWFuKGRhdGFfeSk7XG5cdCAgdmFyIHNfeCA9IDA7XG5cdCAgdmFyIHNfeSA9IDA7XG5cdCAgdmFyIGk7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgZGF0YV94Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICBzX3ggKz0gTWF0aC5wb3coZGF0YV94W2ldIC0gbWVhbl94LCAyKTtcblx0ICB9XG5cdCAgZm9yIChpID0gMDsgaSA8IGRhdGFfeS5sZW5ndGg7IGkrKykge1xuXHQgICAgc195ICs9IE1hdGgucG93KGRhdGFfeVtpXSAtIG1lYW5feSwgMik7XG5cdCAgfVxuXG5cdCAgc194ID0gc194IC8gKGRhdGFfeC5sZW5ndGgtMSk7XG5cdCAgc195ID0gc195IC8gKGRhdGFfeS5sZW5ndGgtMSk7XG5cblx0ICB2YXIgdCA9IE1hdGguYWJzKG1lYW5feCAtIG1lYW5feSkgLyBNYXRoLnNxcnQoc194L2RhdGFfeC5sZW5ndGggKyBzX3kvZGF0YV95Lmxlbmd0aCk7XG5cblx0ICByZXR1cm4gZXhwb3J0cy5ULkRJU1RbJzJUJ10odCwgZGF0YV94Lmxlbmd0aCtkYXRhX3kubGVuZ3RoLTIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJFTkQgPSBmdW5jdGlvbihkYXRhX3ksIGRhdGFfeCwgbmV3X2RhdGFfeCkge1xuXHQgIGRhdGFfeSA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihkYXRhX3kpKTtcblx0ICBkYXRhX3ggPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0YV94KSk7XG5cdCAgbmV3X2RhdGFfeCA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbihuZXdfZGF0YV94KSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZGF0YV95LCBkYXRhX3gsIG5ld19kYXRhX3gpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciBsaW5lc3QgPSBleHBvcnRzLkxJTkVTVChkYXRhX3ksIGRhdGFfeCk7XG5cdCAgdmFyIG0gPSBsaW5lc3RbMF07XG5cdCAgdmFyIGIgPSBsaW5lc3RbMV07XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXG5cdCAgbmV3X2RhdGFfeC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcblx0ICAgIHJlc3VsdC5wdXNoKG0gKiB4ICsgYik7XG5cdCAgfSk7XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJJTU1FQU4gPSBmdW5jdGlvbihyYW5nZSwgcGVyY2VudCkge1xuXHQgIHJhbmdlID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHJhbmdlKSk7XG5cdCAgcGVyY2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmNlbnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhbmdlLCBwZXJjZW50KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgdHJpbSA9IG1hdGhUcmlnLkZMT09SKHJhbmdlLmxlbmd0aCAqIHBlcmNlbnQsIDIpIC8gMjtcblx0ICByZXR1cm4galN0YXQubWVhbih1dGlscy5pbml0aWFsKHV0aWxzLnJlc3QocmFuZ2Uuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSksIHRyaW0pLCB0cmltKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5WQVIgPSB7fTtcblxuXHRleHBvcnRzLlZBUi5QID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMubnVtYmVycyh1dGlscy5mbGF0dGVuKGFyZ3VtZW50cykpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzaWdtYSA9IDA7XG5cdCAgdmFyIG1lYW4gPSBleHBvcnRzLkFWRVJBR0UocmFuZ2UpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBzaWdtYSArPSBNYXRoLnBvdyhyYW5nZVtpXSAtIG1lYW4sIDIpO1xuXHQgIH1cblx0ICByZXR1cm4gc2lnbWEgLyBuO1xuXHR9O1xuXG5cdGV4cG9ydHMuVkFSLlMgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5udW1iZXJzKHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHNpZ21hID0gMDtcblx0ICB2YXIgbWVhbiA9IGV4cG9ydHMuQVZFUkFHRShyYW5nZSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHNpZ21hICs9IE1hdGgucG93KHJhbmdlW2ldIC0gbWVhbiwgMik7XG5cdCAgfVxuXHQgIHJldHVybiBzaWdtYSAvIChuIC0gMSk7XG5cdH07XG5cblx0ZXhwb3J0cy5WQVJBID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIHJhbmdlID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHZhciBzaWdtYSA9IDA7XG5cdCAgdmFyIGNvdW50ID0gMDtcblx0ICB2YXIgbWVhbiA9IGV4cG9ydHMuQVZFUkFHRUEocmFuZ2UpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICB2YXIgZWwgPSByYW5nZVtpXTtcblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KGVsIC0gbWVhbiwgMik7XG5cdCAgICB9IGVsc2UgaWYgKGVsID09PSB0cnVlKSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KDEgLSBtZWFuLCAyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNpZ21hICs9IE1hdGgucG93KDAgLSBtZWFuLCAyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGVsICE9PSBudWxsKSB7XG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBzaWdtYSAvIChjb3VudCAtIDEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVkFSUEEgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmFuZ2UgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG5cdCAgdmFyIHNpZ21hID0gMDtcblx0ICB2YXIgY291bnQgPSAwO1xuXHQgIHZhciBtZWFuID0gZXhwb3J0cy5BVkVSQUdFQShyYW5nZSk7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHZhciBlbCA9IHJhbmdlW2ldO1xuXHQgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coZWwgLSBtZWFuLCAyKTtcblx0ICAgIH0gZWxzZSBpZiAoZWwgPT09IHRydWUpIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coMSAtIG1lYW4sIDIpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2lnbWEgKz0gTWF0aC5wb3coMCAtIG1lYW4sIDIpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZWwgIT09IG51bGwpIHtcblx0ICAgICAgY291bnQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHNpZ21hIC8gY291bnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5XRUlCVUxMID0ge307XG5cblx0ZXhwb3J0cy5XRUlCVUxMLkRJU1QgPSBmdW5jdGlvbih4LCBhbHBoYSwgYmV0YSwgY3VtdWxhdGl2ZSkge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBhbHBoYSA9IHV0aWxzLnBhcnNlTnVtYmVyKGFscGhhKTtcblx0ICBiZXRhID0gdXRpbHMucGFyc2VOdW1iZXIoYmV0YSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgYWxwaGEsIGJldGEpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiAoY3VtdWxhdGl2ZSkgPyAxIC0gTWF0aC5leHAoLU1hdGgucG93KHggLyBiZXRhLCBhbHBoYSkpIDogTWF0aC5wb3coeCwgYWxwaGEgLSAxKSAqIE1hdGguZXhwKC1NYXRoLnBvdyh4IC8gYmV0YSwgYWxwaGEpKSAqIGFscGhhIC8gTWF0aC5wb3coYmV0YSwgYWxwaGEpO1xuXHR9O1xuXG5cdGV4cG9ydHMuWiA9IHt9O1xuXG5cdGV4cG9ydHMuWi5URVNUID0gZnVuY3Rpb24ocmFuZ2UsIHgsIHNkKSB7XG5cdCAgcmFuZ2UgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4ocmFuZ2UpKTtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmFuZ2UsIHgpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgc2QgPSBzZCB8fCBleHBvcnRzLlNUREVWLlMocmFuZ2UpO1xuXHQgIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuXHQgIHJldHVybiAxIC0gZXhwb3J0cy5OT1JNLlMuRElTVCgoZXhwb3J0cy5BVkVSQUdFKHJhbmdlKSAtIHgpIC8gKHNkIC8gTWF0aC5zcXJ0KG4pKSwgdHJ1ZSk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBudW1lcmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuXHQvL1RPRE9cblx0ZXhwb3J0cy5BU0MgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQVNDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vVE9ET1xuXHRleHBvcnRzLkJBSFRURVhUID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0JBSFRURVhUIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hBUiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShudW1iZXIpO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0xFQU4gPSBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgdGV4dCA9IHRleHQgfHwgJyc7XG5cdCAgdmFyIHJlID0gL1tcXDAtXFx4MUZdL2c7XG5cdCAgcmV0dXJuIHRleHQucmVwbGFjZShyZSwgXCJcIik7XG5cdH07XG5cblx0ZXhwb3J0cy5DT0RFID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIHRleHQgPSB0ZXh0IHx8ICcnO1xuXHQgIHJldHVybiB0ZXh0LmNoYXJDb2RlQXQoMCk7XG5cdH07XG5cblx0ZXhwb3J0cy5DT05DQVRFTkFURSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXG5cdCAgdmFyIHRydWVGb3VuZCA9IDA7XG5cdCAgd2hpbGUgKCh0cnVlRm91bmQgPSBhcmdzLmluZGV4T2YodHJ1ZSkpID4gLTEpIHtcblx0ICAgIGFyZ3NbdHJ1ZUZvdW5kXSA9ICdUUlVFJztcblx0ICB9XG5cblx0ICB2YXIgZmFsc2VGb3VuZCA9IDA7XG5cdCAgd2hpbGUgKChmYWxzZUZvdW5kID0gYXJncy5pbmRleE9mKGZhbHNlKSkgPiAtMSkge1xuXHQgICAgYXJnc1tmYWxzZUZvdW5kXSA9ICdGQUxTRSc7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGFyZ3Muam9pbignJyk7XG5cdH07XG5cblx0Ly9UT0RPXG5cdGV4cG9ydHMuREJDUyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdEQkNTIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRE9MTEFSID0gZnVuY3Rpb24obnVtYmVyLCBkZWNpbWFscykge1xuXHQgIGRlY2ltYWxzID0gKGRlY2ltYWxzID09PSB1bmRlZmluZWQpID8gMiA6IGRlY2ltYWxzO1xuXG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkZWNpbWFscyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRlY2ltYWxzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGRlY2ltYWxzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgZm9ybWF0ID0gJyc7XG5cdCAgaWYgKGRlY2ltYWxzIDw9IDApIHtcblx0ICAgIG51bWJlciA9IE1hdGgucm91bmQobnVtYmVyICogTWF0aC5wb3coMTAsIGRlY2ltYWxzKSkgLyBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuXHQgICAgZm9ybWF0ID0gJygkMCwwKSc7XG5cdCAgfSBlbHNlIGlmIChkZWNpbWFscyA+IDApIHtcblx0ICAgIGZvcm1hdCA9ICcoJDAsMC4nICsgbmV3IEFycmF5KGRlY2ltYWxzICsgMSkuam9pbignMCcpICsgJyknO1xuXHQgIH1cblx0ICByZXR1cm4gbnVtZXJhbChudW1iZXIpLmZvcm1hdChmb3JtYXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRVhBQ1QgPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcblx0ICByZXR1cm4gdGV4dDEgPT09IHRleHQyO1xuXHR9O1xuXG5cdGV4cG9ydHMuRklORCA9IGZ1bmN0aW9uKGZpbmRfdGV4dCwgd2l0aGluX3RleHQsIHBvc2l0aW9uKSB7XG5cdCAgcG9zaXRpb24gPSAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkgPyAwIDogcG9zaXRpb247XG5cdCAgcmV0dXJuIHdpdGhpbl90ZXh0ID8gd2l0aGluX3RleHQuaW5kZXhPZihmaW5kX3RleHQsIHBvc2l0aW9uIC0gMSkgKyAxIDogbnVsbDtcblx0fTtcblxuXHRleHBvcnRzLkZJWEVEID0gZnVuY3Rpb24obnVtYmVyLCBkZWNpbWFscywgbm9fY29tbWFzKSB7XG5cdCAgZGVjaW1hbHMgPSAoZGVjaW1hbHMgPT09IHVuZGVmaW5lZCkgPyAyIDogZGVjaW1hbHM7XG5cdCAgbm9fY29tbWFzID0gKG5vX2NvbW1hcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogbm9fY29tbWFzO1xuXG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBkZWNpbWFscyA9IHV0aWxzLnBhcnNlTnVtYmVyKGRlY2ltYWxzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIGRlY2ltYWxzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciBmb3JtYXQgPSBub19jb21tYXMgPyAnMCcgOiAnMCwwJztcblx0ICBpZiAoZGVjaW1hbHMgPD0gMCkge1xuXHQgICAgbnVtYmVyID0gTWF0aC5yb3VuZChudW1iZXIgKiBNYXRoLnBvdygxMCwgZGVjaW1hbHMpKSAvIE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG5cdCAgfSBlbHNlIGlmIChkZWNpbWFscyA+IDApIHtcblx0ICAgIGZvcm1hdCArPSAnLicgKyBuZXcgQXJyYXkoZGVjaW1hbHMgKyAxKS5qb2luKCcwJyk7XG5cdCAgfVxuXHQgIHJldHVybiBudW1lcmFsKG51bWJlcikuZm9ybWF0KGZvcm1hdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5IVE1MMlRFWFQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICB2YXIgcmVzdWx0ID0gJyc7XG5cblx0ICBpZiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcblx0ICAgICAgICBpZiAocmVzdWx0ICE9PSAnJykge1xuXHQgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gKGxpbmUucmVwbGFjZSgvPCg/Oi58XFxuKSo/Pi9nbSwgJycpKTtcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKC88KD86LnxcXG4pKj8+L2dtLCAnJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkxFRlQgPSBmdW5jdGlvbih0ZXh0LCBudW1iZXIpIHtcblx0ICBudW1iZXIgPSAobnVtYmVyID09PSB1bmRlZmluZWQpID8gMSA6IG51bWJlcjtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQgPyB0ZXh0LnN1YnN0cmluZygwLCBudW1iZXIpIDogbnVsbDtcblx0fTtcblxuXHRleHBvcnRzLkxFTiA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLmVycm9yO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiB0ZXh0ID8gdGV4dC5sZW5ndGggOiAwO1xuXHQgIH1cblxuXHQgIGlmICh0ZXh0Lmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xuXHQgIH1cblxuXHQgIHJldHVybiBlcnJvci52YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLkxPV0VSID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQgPyB0ZXh0LnRvTG93ZXJDYXNlKCkgOiB0ZXh0O1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlEID0gZnVuY3Rpb24odGV4dCwgc3RhcnQsIG51bWJlcikge1xuXHQgIHN0YXJ0ID0gdXRpbHMucGFyc2VOdW1iZXIoc3RhcnQpO1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3Ioc3RhcnQsIG51bWJlcikgfHwgdHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIHZhciBiZWdpbiA9IHN0YXJ0IC0gMTtcblx0ICB2YXIgZW5kID0gYmVnaW4gKyBudW1iZXI7XG5cblx0ICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoYmVnaW4sIGVuZCk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk5VTUJFUlZBTFVFID0gZnVuY3Rpb24gKHRleHQsIGRlY2ltYWxfc2VwYXJhdG9yLCBncm91cF9zZXBhcmF0b3IpICB7XG5cdCAgZGVjaW1hbF9zZXBhcmF0b3IgPSAodHlwZW9mIGRlY2ltYWxfc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJykgPyAnLicgOiBkZWNpbWFsX3NlcGFyYXRvcjtcblx0ICBncm91cF9zZXBhcmF0b3IgPSAodHlwZW9mIGdyb3VwX3NlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcpID8gJywnIDogZ3JvdXBfc2VwYXJhdG9yO1xuXHQgIHJldHVybiBOdW1iZXIodGV4dC5yZXBsYWNlKGRlY2ltYWxfc2VwYXJhdG9yLCAnLicpLnJlcGxhY2UoZ3JvdXBfc2VwYXJhdG9yLCAnJykpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5QUk9ORVRJQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdQUk9ORVRJQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLlBST1BFUiA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkIHx8IHRleHQubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmICh0ZXh0ID09PSB0cnVlKSB7XG5cdCAgICB0ZXh0ID0gJ1RSVUUnO1xuXHQgIH1cblx0ICBpZiAodGV4dCA9PT0gZmFsc2UpIHtcblx0ICAgIHRleHQgPSAnRkFMU0UnO1xuXHQgIH1cblx0ICBpZiAoaXNOYU4odGV4dCkgJiYgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcblx0ICAgIHRleHQgPSAnJyArIHRleHQ7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFx3XFxTKi9nLCBmdW5jdGlvbih0eHQpIHtcblx0ICAgIHJldHVybiB0eHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eHQuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XG5cdCAgfSk7XG5cdH07XG5cblx0ZXhwb3J0cy5SRUdFWEVYVFJBQ1QgPSBmdW5jdGlvbiAodGV4dCwgcmVndWxhcl9leHByZXNzaW9uKSB7XG5cdCAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaChuZXcgUmVnRXhwKHJlZ3VsYXJfZXhwcmVzc2lvbikpO1xuXHQgIHJldHVybiBtYXRjaCA/IChtYXRjaFttYXRjaC5sZW5ndGggPiAxID8gbWF0Y2gubGVuZ3RoIC0gMSA6IDBdKSA6IG51bGw7XG5cdH07XG5cblx0ZXhwb3J0cy5SRUdFWE1BVENIID0gZnVuY3Rpb24gKHRleHQsIHJlZ3VsYXJfZXhwcmVzc2lvbiwgZnVsbCkge1xuXHQgIHZhciBtYXRjaCA9IHRleHQubWF0Y2gobmV3IFJlZ0V4cChyZWd1bGFyX2V4cHJlc3Npb24pKTtcblx0ICByZXR1cm4gZnVsbCA/IG1hdGNoIDogISFtYXRjaDtcblx0fTtcblxuXHRleHBvcnRzLlJFR0VYUkVQTEFDRSA9IGZ1bmN0aW9uICh0ZXh0LCByZWd1bGFyX2V4cHJlc3Npb24sIHJlcGxhY2VtZW50KSB7XG5cdCAgcmV0dXJuIHRleHQucmVwbGFjZShuZXcgUmVnRXhwKHJlZ3VsYXJfZXhwcmVzc2lvbiksIHJlcGxhY2VtZW50KTtcblx0fTtcblxuXHRleHBvcnRzLlJFUExBQ0UgPSBmdW5jdGlvbih0ZXh0LCBwb3NpdGlvbiwgbGVuZ3RoLCBuZXdfdGV4dCkge1xuXHQgIHBvc2l0aW9uID0gdXRpbHMucGFyc2VOdW1iZXIocG9zaXRpb24pO1xuXHQgIGxlbmd0aCA9IHV0aWxzLnBhcnNlTnVtYmVyKGxlbmd0aCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocG9zaXRpb24sIGxlbmd0aCkgfHxcblx0ICAgIHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJyB8fFxuXHQgICAgdHlwZW9mIG5ld190ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gdGV4dC5zdWJzdHIoMCwgcG9zaXRpb24gLSAxKSArIG5ld190ZXh0ICsgdGV4dC5zdWJzdHIocG9zaXRpb24gLSAxICsgbGVuZ3RoKTtcblx0fTtcblxuXHRleHBvcnRzLlJFUFQgPSBmdW5jdGlvbih0ZXh0LCBudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIG5ldyBBcnJheShudW1iZXIgKyAxKS5qb2luKHRleHQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUklHSFQgPSBmdW5jdGlvbih0ZXh0LCBudW1iZXIpIHtcblx0ICBudW1iZXIgPSAobnVtYmVyID09PSB1bmRlZmluZWQpID8gMSA6IG51bWJlcjtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQgPyB0ZXh0LnN1YnN0cmluZyh0ZXh0Lmxlbmd0aCAtIG51bWJlcikgOiBudWxsO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0VBUkNIID0gZnVuY3Rpb24oZmluZF90ZXh0LCB3aXRoaW5fdGV4dCwgcG9zaXRpb24pIHtcblx0ICB2YXIgZm91bmRBdDtcblx0ICBpZiAodHlwZW9mIGZpbmRfdGV4dCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHdpdGhpbl90ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBwb3NpdGlvbiA9IChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSA/IDAgOiBwb3NpdGlvbjtcblx0ICBmb3VuZEF0ID0gd2l0aGluX3RleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKGZpbmRfdGV4dC50b0xvd2VyQ2FzZSgpLCBwb3NpdGlvbiAtIDEpKzE7XG5cdCAgcmV0dXJuIChmb3VuZEF0ID09PSAwKT9lcnJvci52YWx1ZTpmb3VuZEF0O1xuXHR9O1xuXG5cdGV4cG9ydHMuU1BMSVQgPSBmdW5jdGlvbiAodGV4dCwgc2VwYXJhdG9yKSB7XG5cdCAgcmV0dXJuIHRleHQuc3BsaXQoc2VwYXJhdG9yKTtcblx0fTtcblxuXHRleHBvcnRzLlNVQlNUSVRVVEUgPSBmdW5jdGlvbih0ZXh0LCBvbGRfdGV4dCwgbmV3X3RleHQsIG9jY3VycmVuY2UpIHtcblx0ICBpZiAoIXRleHQgfHwgIW9sZF90ZXh0IHx8ICFuZXdfdGV4dCkge1xuXHQgICAgcmV0dXJuIHRleHQ7XG5cdCAgfSBlbHNlIGlmIChvY2N1cnJlbmNlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChvbGRfdGV4dCwgJ2cnKSwgbmV3X3RleHQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgdmFyIGkgPSAwO1xuXHQgICAgd2hpbGUgKHRleHQuaW5kZXhPZihvbGRfdGV4dCwgaW5kZXgpID4gMCkge1xuXHQgICAgICBpbmRleCA9IHRleHQuaW5kZXhPZihvbGRfdGV4dCwgaW5kZXggKyAxKTtcblx0ICAgICAgaSsrO1xuXHQgICAgICBpZiAoaSA9PT0gb2NjdXJyZW5jZSkge1xuXHQgICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZygwLCBpbmRleCkgKyBuZXdfdGV4dCArIHRleHQuc3Vic3RyaW5nKGluZGV4ICsgb2xkX3RleHQubGVuZ3RoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLlQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSA/IHZhbHVlIDogJyc7XG5cdH07XG5cblx0Ly8gVE9ETyBpbmNvbXBsZXRlIGltcGxlbWVudGF0aW9uXG5cdGV4cG9ydHMuVEVYVCA9IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQpIHtcblx0ICB2YWx1ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHZhbHVlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVtZXJhbCh2YWx1ZSkuZm9ybWF0KGZvcm1hdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5UUklNID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQucmVwbGFjZSgvICsvZywgJyAnKS50cmltKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5VTklDSEFSID0gdGhpcy5DSEFSO1xuXG5cdGV4cG9ydHMuVU5JQ09ERSA9IHRoaXMuQ09ERTtcblxuXHRleHBvcnRzLlVQUEVSID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRleHQudG9VcHBlckNhc2UoKTtcblx0fTtcblxuXHRleHBvcnRzLlZBTFVFID0gZnVuY3Rpb24odGV4dCkge1xuXHQgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIG51bWVyYWwoKS51bmZvcm1hdCh0ZXh0KTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXztcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV85X187XG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIHV0aWxzICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgbnVtZXJhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0ZXhwb3J0cy5VTklRVUUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgaGFzRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgdmFyIGVsZW1lbnQgICAgPSBhcmd1bWVudHNbaV07XG5cblx0ICAgIC8vIENoZWNrIGlmIHdlJ3ZlIGFscmVhZHkgc2VlbiB0aGlzIGVsZW1lbnQuXG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlc3VsdC5sZW5ndGg7ICsraikge1xuXHQgICAgICBoYXNFbGVtZW50ID0gcmVzdWx0W2pdID09PSBlbGVtZW50O1xuXHQgICAgICBpZiAoaGFzRWxlbWVudCkgeyBicmVhazsgfVxuXHQgICAgfVxuXG5cdCAgICAvLyBJZiB3ZSBkaWQgbm90IGZpbmQgaXQsIGFkZCBpdCB0byB0aGUgcmVzdWx0LlxuXHQgICAgaWYgKCFoYXNFbGVtZW50KSB7XG5cdCAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuRkxBVFRFTiA9IHV0aWxzLmZsYXR0ZW47XG5cblx0ZXhwb3J0cy5BUkdTMkFSUkFZID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXHR9O1xuXG5cdGV4cG9ydHMuUkVGRVJFTkNFID0gZnVuY3Rpb24gKGNvbnRleHQsIHJlZmVyZW5jZSkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgcGF0aCA9IHJlZmVyZW5jZS5zcGxpdCgnLicpO1xuXHQgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQ7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgdmFyIHN0ZXAgPSBwYXRoW2ldO1xuXHQgICAgICBpZiAoc3RlcFtzdGVwLmxlbmd0aCAtIDFdID09PSAnXScpIHtcblx0ICAgICAgICB2YXIgb3BlbmluZyA9IHN0ZXAuaW5kZXhPZignWycpO1xuXHQgICAgICAgIHZhciBpbmRleCA9IHN0ZXAuc3Vic3RyaW5nKG9wZW5pbmcgKyAxLCBzdGVwLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtzdGVwLnN1YnN0cmluZygwLCBvcGVuaW5nKV1baW5kZXhdO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtzdGVwXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGNhdGNoIChlcnJvcikge31cblx0fTtcblxuXHRleHBvcnRzLkpPSU4gPSBmdW5jdGlvbiAoYXJyYXksIHNlcGFyYXRvcikge1xuXHQgIHJldHVybiBhcnJheS5qb2luKHNlcGFyYXRvcik7XG5cdH07XG5cblx0ZXhwb3J0cy5OVU1CRVJTID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBwb3NzaWJsZU51bWJlcnMgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgcmV0dXJuIHBvc3NpYmxlTnVtYmVycy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG5cdCAgICByZXR1cm4gdHlwZW9mIGVsID09PSAnbnVtYmVyJztcblx0ICB9KTtcblx0fTtcblxuXHRleHBvcnRzLk5VTUVSQUwgPSBmdW5jdGlvbiAobnVtYmVyLCBmb3JtYXQpIHtcblx0ICByZXR1cm4gbnVtZXJhbChudW1iZXIpLmZvcm1hdChmb3JtYXQpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNFTEwgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ0VMTCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkVSUk9SID0ge307XG5cdGV4cG9ydHMuRVJST1IuVFlQRSA9IGZ1bmN0aW9uKGVycm9yX3ZhbCkge1xuXHQgIHN3aXRjaCAoZXJyb3JfdmFsKSB7XG5cdCAgICBjYXNlIGVycm9yLm5pbDogcmV0dXJuIDE7XG5cdCAgICBjYXNlIGVycm9yLmRpdjA6IHJldHVybiAyO1xuXHQgICAgY2FzZSBlcnJvci52YWx1ZTogcmV0dXJuIDM7XG5cdCAgICBjYXNlIGVycm9yLnJlZjogcmV0dXJuIDQ7XG5cdCAgICBjYXNlIGVycm9yLm5hbWU6IHJldHVybiA1O1xuXHQgICAgY2FzZSBlcnJvci5udW06IHJldHVybiA2O1xuXHQgICAgY2FzZSBlcnJvci5uYTogcmV0dXJuIDc7XG5cdCAgICBjYXNlIGVycm9yLmRhdGE6IHJldHVybiA4O1xuXHQgIH1cblx0ICByZXR1cm4gZXJyb3IubmE7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLklORk8gPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignSU5GTyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLklTQkxBTksgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcblx0fTtcblxuXHRleHBvcnRzLklTQklOQVJZID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHQgIHJldHVybiAoL15bMDFdezEsMTB9JC8pLnRlc3QobnVtYmVyKTtcblx0fTtcblxuXHRleHBvcnRzLklTRVJSID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gKFtlcnJvci52YWx1ZSwgZXJyb3IucmVmLCBlcnJvci5kaXYwLCBlcnJvci5udW0sIGVycm9yLm5hbWUsIGVycm9yLm5pbF0pLmluZGV4T2YodmFsdWUpID49IDAgfHxcblx0ICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVNFUlJPUiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIGV4cG9ydHMuSVNFUlIodmFsdWUpIHx8IHZhbHVlID09PSBlcnJvci5uYTtcblx0fTtcblxuXHRleHBvcnRzLklTRVZFTiA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIHJldHVybiAoTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKSAmIDEpID8gZmFsc2UgOiB0cnVlO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5JU0ZPUk1VTEEgPSBmdW5jdGlvbigpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ0lTRk9STVVMQSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLklTTE9HSUNBTCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcblx0fTtcblxuXHRleHBvcnRzLklTTkEgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PT0gZXJyb3IubmE7XG5cdH07XG5cblx0ZXhwb3J0cy5JU05PTlRFWFQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB0eXBlb2YodmFsdWUpICE9PSAnc3RyaW5nJztcblx0fTtcblxuXHRleHBvcnRzLklTTlVNQkVSID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JU09ERCA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIHJldHVybiAoTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKSAmIDEpID8gdHJ1ZSA6IGZhbHNlO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5JU1JFRiA9IGZ1bmN0aW9uKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignSVNSRUYgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5JU1RFWFQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnc3RyaW5nJztcblx0fTtcblxuXHRleHBvcnRzLk4gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIGlmICh0aGlzLklTTlVNQkVSKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdCAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuXHQgIH1cblx0ICBpZiAodmFsdWUgPT09IHRydWUpIHtcblx0ICAgIHJldHVybiAxO1xuXHQgIH1cblx0ICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cdCAgaWYgKHRoaXMuSVNFUlJPUih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIDA7XG5cdH07XG5cblx0ZXhwb3J0cy5OQSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBlcnJvci5uYTtcblx0fTtcblxuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5TSEVFVCA9IGZ1bmN0aW9uKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignU0hFRVQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlNIRUVUUyA9IGZ1bmN0aW9uKCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignU0hFRVRTIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVFlQRSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgaWYgKHRoaXMuSVNOVU1CRVIodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cdCAgaWYgKHRoaXMuSVNURVhUKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIDI7XG5cdCAgfVxuXHQgIGlmICh0aGlzLklTTE9HSUNBTCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiA0O1xuXHQgIH1cblx0ICBpZiAodGhpcy5JU0VSUk9SKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIDE2O1xuXHQgIH1cblx0ICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiA2NDtcblx0ICB9XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgalN0YXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLmpTdGF0O1xuXHR2YXIgdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBiZXNzZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuXHRmdW5jdGlvbiBpc1ZhbGlkQmluYXJ5TnVtYmVyKG51bWJlcikge1xuXHQgIHJldHVybiAoL15bMDFdezEsMTB9JC8pLnRlc3QobnVtYmVyKTtcblx0fVxuXG5cdGV4cG9ydHMuQkVTU0VMSSA9IGZ1bmN0aW9uKHgsIG4pIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBiZXNzZWwuYmVzc2VsaSh4LCBuKTtcblx0fTtcblxuXHRleHBvcnRzLkJFU1NFTEogPSBmdW5jdGlvbih4LCBuKSB7XG5cdCAgeCA9IHV0aWxzLnBhcnNlTnVtYmVyKHgpO1xuXHQgIG4gPSB1dGlscy5wYXJzZU51bWJlcihuKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCBuKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gYmVzc2VsLmJlc3NlbGooeCwgbik7XG5cdH07XG5cblx0ZXhwb3J0cy5CRVNTRUxLID0gZnVuY3Rpb24oeCwgbikge1xuXHQgIHggPSB1dGlscy5wYXJzZU51bWJlcih4KTtcblx0ICBuID0gdXRpbHMucGFyc2VOdW1iZXIobik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGJlc3NlbC5iZXNzZWxrKHgsIG4pO1xuXHR9O1xuXG5cdGV4cG9ydHMuQkVTU0VMWSA9IGZ1bmN0aW9uKHgsIG4pIHtcblx0ICB4ID0gdXRpbHMucGFyc2VOdW1iZXIoeCk7XG5cdCAgbiA9IHV0aWxzLnBhcnNlTnVtYmVyKG4pO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIG4pKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHJldHVybiBiZXNzZWwuYmVzc2VseSh4LCBuKTtcblx0fTtcblxuXHRleHBvcnRzLkJJTjJERUMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBiaW5hcnkgb3IgY29udGFpbnMgbW9yZSB0aGFuIDEwIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIWlzVmFsaWRCaW5hcnlOdW1iZXIobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGJpbmFyeSBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChudW1iZXIsIDIpO1xuXG5cdCAgLy8gSGFuZGxlIG5lZ2F0aXZlIG51bWJlcnNcblx0ICB2YXIgc3RyaW5naWZpZWQgPSBudW1iZXIudG9TdHJpbmcoKTtcblx0ICBpZiAoc3RyaW5naWZpZWQubGVuZ3RoID09PSAxMCAmJiBzdHJpbmdpZmllZC5zdWJzdHJpbmcoMCwgMSkgPT09ICcxJykge1xuXHQgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZ2lmaWVkLnN1YnN0cmluZygxKSwgMikgLSA1MTI7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXHR9O1xuXG5cblx0ZXhwb3J0cy5CSU4ySEVYID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBiaW5hcnkgb3IgY29udGFpbnMgbW9yZSB0aGFuIDEwIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIWlzVmFsaWRCaW5hcnlOdW1iZXIobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgaGV4YWRlY2ltYWwgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIHZhciBzdHJpbmdpZmllZCA9IG51bWJlci50b1N0cmluZygpO1xuXHQgIGlmIChzdHJpbmdpZmllZC5sZW5ndGggPT09IDEwICYmIHN0cmluZ2lmaWVkLnN1YnN0cmluZygwLCAxKSA9PT0gJzEnKSB7XG5cdCAgICByZXR1cm4gKDEwOTk1MTE2MjcyNjQgKyBwYXJzZUludChzdHJpbmdpZmllZC5zdWJzdHJpbmcoMSksIDIpKS50b1N0cmluZygxNik7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBiaW5hcnkgbnVtYmVyIHRvIGhleGFkZWNpbWFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMikudG9TdHJpbmcoMTYpO1xuXG5cdCAgLy8gUmV0dXJuIGhleGFkZWNpbWFsIG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmIChwbGFjZXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQklOMk9DVCA9IGZ1bmN0aW9uKG51bWJlciwgcGxhY2VzKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBub3QgYmluYXJ5IG9yIGNvbnRhaW5zIG1vcmUgdGhhbiAxMCBjaGFyYWN0ZXJzICgxMCBkaWdpdHMpXG5cdCAgaWYgKCFpc1ZhbGlkQmluYXJ5TnVtYmVyKG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIG9jdGFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICB2YXIgc3RyaW5naWZpZWQgPSBudW1iZXIudG9TdHJpbmcoKTtcblx0ICBpZiAoc3RyaW5naWZpZWQubGVuZ3RoID09PSAxMCAmJiBzdHJpbmdpZmllZC5zdWJzdHJpbmcoMCwgMSkgPT09ICcxJykge1xuXHQgICAgcmV0dXJuICgxMDczNzQxMzEyICsgcGFyc2VJbnQoc3RyaW5naWZpZWQuc3Vic3RyaW5nKDEpLCAyKSkudG9TdHJpbmcoOCk7XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBiaW5hcnkgbnVtYmVyIHRvIG9jdGFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMikudG9TdHJpbmcoOCk7XG5cblx0ICAvLyBSZXR1cm4gb2N0YWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHBsYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5CSVRBTkQgPSBmdW5jdGlvbihudW1iZXIxLCBudW1iZXIyKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgYSBub24tbnVtZXJpYyB2YWx1ZVxuXHQgIG51bWJlcjEgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIxKTtcblx0ICBudW1iZXIyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IobnVtYmVyMSwgbnVtYmVyMikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBsZXNzIHRoYW4gMFxuXHQgIGlmIChudW1iZXIxIDwgMCB8fCBudW1iZXIyIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBhIG5vbi1pbnRlZ2VyXG5cdCAgaWYgKE1hdGguZmxvb3IobnVtYmVyMSkgIT09IG51bWJlcjEgfHwgTWF0aC5mbG9vcihudW1iZXIyKSAhPT0gbnVtYmVyMikge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIG51bWJlciBpcyBncmVhdGVyIHRoYW4gKDJeNDgpLTFcblx0ICBpZiAobnVtYmVyMSA+IDI4MTQ3NDk3NjcxMDY1NSB8fCBudW1iZXIyID4gMjgxNDc0OTc2NzEwNjU1KSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBiaXR3aXNlIEFORCBvZiB0d28gbnVtYmVyc1xuXHQgIHJldHVybiBudW1iZXIxICYgbnVtYmVyMjtcblx0fTtcblxuXHRleHBvcnRzLkJJVExTSElGVCA9IGZ1bmN0aW9uKG51bWJlciwgc2hpZnQpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNoaWZ0ID0gdXRpbHMucGFyc2VOdW1iZXIoc2hpZnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2hpZnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBsZXNzIHRoYW4gMFxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgYSBub24taW50ZWdlclxuXHQgIGlmIChNYXRoLmZsb29yKG51bWJlcikgIT09IG51bWJlcikge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiAoMl40OCktMVxuXHQgIGlmIChudW1iZXIgPiAyODE0NzQ5NzY3MTA2NTUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBzaGlmdCBpcyBncmVhdGVyIHRoYW4gNTNcblx0ICBpZiAoTWF0aC5hYnMoc2hpZnQpID4gNTMpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG51bWJlciBzaGlmdGVkIGJ5IHNoaWZ0IGJpdHMgdG8gdGhlIGxlZnQgb3IgdG8gdGhlIHJpZ2h0IGlmIHNoaWZ0IGlzIG5lZ2F0aXZlXG5cdCAgcmV0dXJuIChzaGlmdCA+PSAwKSA/IG51bWJlciA8PCBzaGlmdCA6IG51bWJlciA+PiAtc2hpZnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5CSVRPUiA9IGZ1bmN0aW9uKG51bWJlcjEsIG51bWJlcjIpIHtcblx0ICBudW1iZXIxID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMSk7XG5cdCAgbnVtYmVyMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlcjEsIG51bWJlcjIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgbGVzcyB0aGFuIDBcblx0ICBpZiAobnVtYmVyMSA8IDAgfHwgbnVtYmVyMiA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgYSBub24taW50ZWdlclxuXHQgIGlmIChNYXRoLmZsb29yKG51bWJlcjEpICE9PSBudW1iZXIxIHx8IE1hdGguZmxvb3IobnVtYmVyMikgIT09IG51bWJlcjIpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBudW1iZXIgaXMgZ3JlYXRlciB0aGFuICgyXjQ4KS0xXG5cdCAgaWYgKG51bWJlcjEgPiAyODE0NzQ5NzY3MTA2NTUgfHwgbnVtYmVyMiA+IDI4MTQ3NDk3NjcxMDY1NSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYml0d2lzZSBPUiBvZiB0d28gbnVtYmVyc1xuXHQgIHJldHVybiBudW1iZXIxIHwgbnVtYmVyMjtcblx0fTtcblxuXHRleHBvcnRzLkJJVFJTSElGVCA9IGZ1bmN0aW9uKG51bWJlciwgc2hpZnQpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHNoaWZ0ID0gdXRpbHMucGFyc2VOdW1iZXIoc2hpZnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlciwgc2hpZnQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBsZXNzIHRoYW4gMFxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgYSBub24taW50ZWdlclxuXHQgIGlmIChNYXRoLmZsb29yKG51bWJlcikgIT09IG51bWJlcikge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiAoMl40OCktMVxuXHQgIGlmIChudW1iZXIgPiAyODE0NzQ5NzY3MTA2NTUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBzaGlmdCBpcyBncmVhdGVyIHRoYW4gNTNcblx0ICBpZiAoTWF0aC5hYnMoc2hpZnQpID4gNTMpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG51bWJlciBzaGlmdGVkIGJ5IHNoaWZ0IGJpdHMgdG8gdGhlIHJpZ2h0IG9yIHRvIHRoZSBsZWZ0IGlmIHNoaWZ0IGlzIG5lZ2F0aXZlXG5cdCAgcmV0dXJuIChzaGlmdCA+PSAwKSA/IG51bWJlciA+PiBzaGlmdCA6IG51bWJlciA8PCAtc2hpZnQ7XG5cdH07XG5cblx0ZXhwb3J0cy5CSVRYT1IgPSBmdW5jdGlvbihudW1iZXIxLCBudW1iZXIyKSB7XG5cdCAgbnVtYmVyMSA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjEpO1xuXHQgIG51bWJlcjIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIxLCBudW1iZXIyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGxlc3MgdGhhbiAwXG5cdCAgaWYgKG51bWJlcjEgPCAwIHx8IG51bWJlcjIgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGEgbm9uLWludGVnZXJcblx0ICBpZiAoTWF0aC5mbG9vcihudW1iZXIxKSAhPT0gbnVtYmVyMSB8fCBNYXRoLmZsb29yKG51bWJlcjIpICE9PSBudW1iZXIyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiAoMl40OCktMVxuXHQgIGlmIChudW1iZXIxID4gMjgxNDc0OTc2NzEwNjU1IHx8IG51bWJlcjIgPiAyODE0NzQ5NzY3MTA2NTUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGJpdHdpc2UgWE9SIG9mIHR3byBudW1iZXJzXG5cdCAgcmV0dXJuIG51bWJlcjEgXiBudW1iZXIyO1xuXHR9O1xuXG5cdGV4cG9ydHMuQ09NUExFWCA9IGZ1bmN0aW9uKHJlYWwsIGltYWdpbmFyeSwgc3VmZml4KSB7XG5cdCAgcmVhbCA9IHV0aWxzLnBhcnNlTnVtYmVyKHJlYWwpO1xuXHQgIGltYWdpbmFyeSA9IHV0aWxzLnBhcnNlTnVtYmVyKGltYWdpbmFyeSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmVhbCwgaW1hZ2luYXJ5KSkge1xuXHQgICAgcmV0dXJuIHJlYWw7XG5cdCAgfVxuXG5cdCAgLy8gU2V0IHN1ZmZpeFxuXHQgIHN1ZmZpeCA9IChzdWZmaXggPT09IHVuZGVmaW5lZCkgPyAnaScgOiBzdWZmaXg7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc3VmZml4IGlzIG5laXRoZXIgXCJpXCIgbm9yIFwialwiXG5cdCAgaWYgKHN1ZmZpeCAhPT0gJ2knICYmIHN1ZmZpeCAhPT0gJ2onKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGNvbXBsZXggbnVtYmVyXG5cdCAgaWYgKHJlYWwgPT09IDAgJiYgaW1hZ2luYXJ5ID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9IGVsc2UgaWYgKHJlYWwgPT09IDApIHtcblx0ICAgIHJldHVybiAoaW1hZ2luYXJ5ID09PSAxKSA/IHN1ZmZpeCA6IGltYWdpbmFyeS50b1N0cmluZygpICsgc3VmZml4O1xuXHQgIH0gZWxzZSBpZiAoaW1hZ2luYXJ5ID09PSAwKSB7XG5cdCAgICByZXR1cm4gcmVhbC50b1N0cmluZygpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgc2lnbiA9IChpbWFnaW5hcnkgPiAwKSA/ICcrJyA6ICcnO1xuXHQgICAgcmV0dXJuIHJlYWwudG9TdHJpbmcoKSArIHNpZ24gKyAoKGltYWdpbmFyeSA9PT0gMSkgPyBzdWZmaXggOiBpbWFnaW5hcnkudG9TdHJpbmcoKSArIHN1ZmZpeCk7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuQ09OVkVSVCA9IGZ1bmN0aW9uKG51bWJlciwgZnJvbV91bml0LCB0b191bml0KSB7XG5cdCAgbnVtYmVyID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyKTtcblx0ICBpZiAobnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgLy8gTGlzdCBvZiB1bml0cyBzdXBwb3J0ZWQgYnkgQ09OVkVSVCBhbmQgdW5pdHMgZGVmaW5lZCBieSB0aGUgSW50ZXJuYXRpb25hbCBTeXN0ZW0gb2YgVW5pdHNcblx0ICAvLyBbTmFtZSwgU3ltYm9sLCBBbHRlcm5hdGUgc3ltYm9scywgUXVhbnRpdHksIElTVSwgQ09OVkVSVCwgQ29udmVyc2lvbiByYXRpb11cblx0ICB2YXIgdW5pdHMgPSBbXG5cdCAgICBbXCJhLnUuIG9mIGFjdGlvblwiLCBcIj9cIiwgbnVsbCwgXCJhY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCAxLjA1NDU3MTY4MTgxODE4ZS0zNF0sXG5cdCAgICBbXCJhLnUuIG9mIGNoYXJnZVwiLCBcImVcIiwgbnVsbCwgXCJlbGVjdHJpY19jaGFyZ2VcIiwgZmFsc2UsIGZhbHNlLCAxLjYwMjE3NjUzMTQxNDE0ZS0xOV0sXG5cdCAgICBbXCJhLnUuIG9mIGVuZXJneVwiLCBcIkVoXCIsIG51bGwsIFwiZW5lcmd5XCIsIGZhbHNlLCBmYWxzZSwgNC4zNTk3NDQxNzc1NzU3NmUtMThdLFxuXHQgICAgW1wiYS51LiBvZiBsZW5ndGhcIiwgXCJhP1wiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgZmFsc2UsIDUuMjkxNzcyMTA4MTgxODJlLTExXSxcblx0ICAgIFtcImEudS4gb2YgbWFzc1wiLCBcIm0/XCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgZmFsc2UsIDkuMTA5MzgyNjE2MTYxNjJlLTMxXSxcblx0ICAgIFtcImEudS4gb2YgdGltZVwiLCBcIj8vRWhcIiwgbnVsbCwgXCJ0aW1lXCIsIGZhbHNlLCBmYWxzZSwgMi40MTg4ODQzMjY1MDUxNmUtMTddLFxuXHQgICAgW1wiYWRtaXJhbHR5IGtub3RcIiwgXCJhZG1rblwiLCBudWxsLCBcInNwZWVkXCIsIGZhbHNlLCB0cnVlLCAwLjUxNDc3MzMzM10sXG5cdCAgICBbXCJhbXBlcmVcIiwgXCJBXCIsIG51bGwsIFwiZWxlY3RyaWNfY3VycmVudFwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJhbXBlcmUgcGVyIG1ldGVyXCIsIFwiQS9tXCIsIG51bGwsIFwibWFnbmV0aWNfZmllbGRfaW50ZW5zaXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcIsOlbmdzdHLDtm1cIiwgXCLDhVwiLCBbXCJhbmdcIl0sIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAxZS0xMF0sXG5cdCAgICBbXCJhcmVcIiwgXCJhclwiLCBudWxsLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDEwMF0sXG5cdCAgICBbXCJhc3Ryb25vbWljYWwgdW5pdFwiLCBcInVhXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCBmYWxzZSwgMS40OTU5Nzg3MDY5MTY2N2UtMTFdLFxuXHQgICAgW1wiYmFyXCIsIFwiYmFyXCIsIG51bGwsIFwicHJlc3N1cmVcIiwgZmFsc2UsIGZhbHNlLCAxMDAwMDBdLFxuXHQgICAgW1wiYmFyblwiLCBcImJcIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCBmYWxzZSwgMWUtMjhdLFxuXHQgICAgW1wiYmVjcXVlcmVsXCIsIFwiQnFcIiwgbnVsbCwgXCJyYWRpb2FjdGl2aXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImJpdFwiLCBcImJpdFwiLCBbXCJiXCJdLCBcImluZm9ybWF0aW9uXCIsIGZhbHNlLCB0cnVlLCAxXSxcblx0ICAgIFtcImJ0dVwiLCBcIkJUVVwiLCBbXCJidHVcIl0sIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCAxMDU1LjA1NTg1MjYyXSxcblx0ICAgIFtcImJ5dGVcIiwgXCJieXRlXCIsIG51bGwsIFwiaW5mb3JtYXRpb25cIiwgZmFsc2UsIHRydWUsIDhdLFxuXHQgICAgW1wiY2FuZGVsYVwiLCBcImNkXCIsIG51bGwsIFwibHVtaW5vdXNfaW50ZW5zaXR5XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImNhbmRlbGEgcGVyIHNxdWFyZSBtZXRyZVwiLCBcImNkL20/XCIsIG51bGwsIFwibHVtaW5hbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImNvdWxvbWJcIiwgXCJDXCIsIG51bGwsIFwiZWxlY3RyaWNfY2hhcmdlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImN1YmljIMOlbmdzdHLDtm1cIiwgXCJhbmczXCIsIFtcImFuZ14zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMWUtMzBdLFxuXHQgICAgW1wiY3ViaWMgZm9vdFwiLCBcImZ0M1wiLCBbXCJmdF4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMjgzMTY4NDY1OTJdLFxuXHQgICAgW1wiY3ViaWMgaW5jaFwiLCBcImluM1wiLCBbXCJpbl4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAwMTYzODcwNjRdLFxuXHQgICAgW1wiY3ViaWMgbGlnaHQteWVhclwiLCBcImx5M1wiLCBbXCJseV4zXCJdLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgOC40Njc4NjY2NDYyMzcxNWUtNDddLFxuXHQgICAgW1wiY3ViaWMgbWV0cmVcIiwgXCJtP1wiLCBudWxsLCBcInZvbHVtZVwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcImN1YmljIG1pbGVcIiwgXCJtaTNcIiwgW1wibWleM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDQxNjgxODE4MjUuNDQwNThdLFxuXHQgICAgW1wiY3ViaWMgbmF1dGljYWwgbWlsZVwiLCBcIk5taTNcIiwgW1wiTm1pXjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCA2MzUyMTgyMjA4XSxcblx0ICAgIFtcImN1YmljIFBpY2FcIiwgXCJQaWNhM1wiLCBbXCJQaWNhcHQzXCIsIFwiUGljYV4zXCIsIFwiUGljYXB0XjNcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCA3LjU4NjYwMzcwMzcwMzY5ZS04XSxcblx0ICAgIFtcImN1YmljIHlhcmRcIiwgXCJ5ZDNcIiwgW1wieWReM1wiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuNzY0NTU0ODU3OTg0XSxcblx0ICAgIFtcImN1cFwiLCBcImN1cFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAyMzY1ODgyMzY1XSxcblx0ICAgIFtcImRhbHRvblwiLCBcIkRhXCIsIFtcInVcIl0sIFwibWFzc1wiLCBmYWxzZSwgZmFsc2UsIDEuNjYwNTM4ODYyODI4MjhlLTI3XSxcblx0ICAgIFtcImRheVwiLCBcImRcIiwgW1wiZGF5XCJdLCBcInRpbWVcIiwgZmFsc2UsIHRydWUsIDg2NDAwXSxcblx0ICAgIFtcImRlZ3JlZVwiLCBcIsKwXCIsIG51bGwsIFwiYW5nbGVcIiwgZmFsc2UsIGZhbHNlLCAwLjAxNzQ1MzI5MjUxOTk0MzNdLFxuXHQgICAgW1wiZGVncmVlcyBSYW5raW5lXCIsIFwiUmFua1wiLCBudWxsLCBcInRlbXBlcmF0dXJlXCIsIGZhbHNlLCB0cnVlLCAwLjU1NTU1NTU1NTU1NTU1Nl0sXG5cdCAgICBbXCJkeW5lXCIsIFwiZHluXCIsIFtcImR5XCJdLCBcImZvcmNlXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAxXSxcblx0ICAgIFtcImVsZWN0cm9udm9sdFwiLCBcImVWXCIsIFtcImV2XCJdLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMS42MDIxNzY1NjUxNDE0MV0sXG5cdCAgICBbXCJlbGxcIiwgXCJlbGxcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDEuMTQzXSxcblx0ICAgIFtcImVyZ1wiLCBcImVyZ1wiLCBbXCJlXCJdLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMWUtN10sXG5cdCAgICBbXCJmYXJhZFwiLCBcIkZcIiwgbnVsbCwgXCJlbGVjdHJpY19jYXBhY2l0YW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJmbHVpZCBvdW5jZVwiLCBcIm96XCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAyOTU3MzUyOTU2MjVdLFxuXHQgICAgW1wiZm9vdFwiLCBcImZ0XCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAwLjMwNDhdLFxuXHQgICAgW1wiZm9vdC1wb3VuZFwiLCBcImZsYlwiLCBudWxsLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMS4zNTU4MTc5NDgzMzE0XSxcblx0ICAgIFtcImdhbFwiLCBcIkdhbFwiLCBudWxsLCBcImFjY2VsZXJhdGlvblwiLCBmYWxzZSwgZmFsc2UsIDAuMDFdLFxuXHQgICAgW1wiZ2FsbG9uXCIsIFwiZ2FsXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMzc4NTQxMTc4NF0sXG5cdCAgICBbXCJnYXVzc1wiLCBcIkdcIiwgW1wiZ2FcIl0sIFwibWFnbmV0aWNfZmx1eF9kZW5zaXR5XCIsIGZhbHNlLCB0cnVlLCAxXSxcblx0ICAgIFtcImdyYWluXCIsIFwiZ3JhaW5cIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDA2NDc5ODldLFxuXHQgICAgW1wiZ3JhbVwiLCBcImdcIiwgbnVsbCwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCAwLjAwMV0sXG5cdCAgICBbXCJncmF5XCIsIFwiR3lcIiwgbnVsbCwgXCJhYnNvcmJlZF9kb3NlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImdyb3NzIHJlZ2lzdGVyZWQgdG9uXCIsIFwiR1JUXCIsIFtcInJlZ3RvblwiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDIuODMxNjg0NjU5Ml0sXG5cdCAgICBbXCJoZWN0YXJlXCIsIFwiaGFcIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAxMDAwMF0sXG5cdCAgICBbXCJoZW5yeVwiLCBcIkhcIiwgbnVsbCwgXCJpbmR1Y3RhbmNlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImhlcnR6XCIsIFwiSHpcIiwgbnVsbCwgXCJmcmVxdWVuY3lcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wiaG9yc2Vwb3dlclwiLCBcIkhQXCIsIFtcImhcIl0sIFwicG93ZXJcIiwgZmFsc2UsIHRydWUsIDc0NS42OTk4NzE1ODIyN10sXG5cdCAgICBbXCJob3JzZXBvd2VyLWhvdXJcIiwgXCJIUGhcIiwgW1wiaGhcIiwgXCJocGhcIl0sIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCAyNjg0NTE5LjUzOF0sXG5cdCAgICBbXCJob3VyXCIsIFwiaFwiLCBbXCJoclwiXSwgXCJ0aW1lXCIsIGZhbHNlLCB0cnVlLCAzNjAwXSxcblx0ICAgIFtcImltcGVyaWFsIGdhbGxvbiAoVS5LLilcIiwgXCJ1a19nYWxcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDA0NTQ2MDldLFxuXHQgICAgW1wiaW1wZXJpYWwgaHVuZHJlZHdlaWdodFwiLCBcImxjd3RcIiwgW1widWtfY3d0XCIsIFwiaHdlaWdodFwiXSwgXCJtYXNzXCIsIGZhbHNlLCB0cnVlLCA1MC44MDIzNDVdLFxuXHQgICAgW1wiaW1wZXJpYWwgcXVhcnQgKFUuSylcIiwgXCJ1a19xdFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDExMzY1MjI1XSxcblx0ICAgIFtcImltcGVyaWFsIHRvblwiLCBcImJydG9uXCIsIFtcInVrX3RvblwiLCBcIkxUT05cIl0sIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgMTAxNi4wNDY5MDldLFxuXHQgICAgW1wiaW5jaFwiLCBcImluXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAwLjAyNTRdLFxuXHQgICAgW1wiaW50ZXJuYXRpb25hbCBhY3JlXCIsIFwidWtfYWNyZVwiLCBudWxsLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDQwNDYuODU2NDIyNF0sXG5cdCAgICBbXCJJVCBjYWxvcmllXCIsIFwiY2FsXCIsIG51bGwsIFwiZW5lcmd5XCIsIGZhbHNlLCB0cnVlLCA0LjE4NjhdLFxuXHQgICAgW1wiam91bGVcIiwgXCJKXCIsIG51bGwsIFwiZW5lcmd5XCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wia2F0YWxcIiwgXCJrYXRcIiwgbnVsbCwgXCJjYXRhbHl0aWNfYWN0aXZpdHlcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wia2VsdmluXCIsIFwiS1wiLCBbXCJrZWxcIl0sIFwidGVtcGVyYXR1cmVcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJraWxvZ3JhbVwiLCBcImtnXCIsIG51bGwsIFwibWFzc1wiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcImtub3RcIiwgXCJrblwiLCBudWxsLCBcInNwZWVkXCIsIGZhbHNlLCB0cnVlLCAwLjUxNDQ0NDQ0NDQ0NDQ0NF0sXG5cdCAgICBbXCJsaWdodC15ZWFyXCIsIFwibHlcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDk0NjA3MzA0NzI1ODA4MDBdLFxuXHQgICAgW1wibGl0cmVcIiwgXCJMXCIsIFtcImxcIiwgXCJsdFwiXSwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAxXSxcblx0ICAgIFtcImx1bWVuXCIsIFwibG1cIiwgbnVsbCwgXCJsdW1pbm91c19mbHV4XCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcImx1eFwiLCBcImx4XCIsIG51bGwsIFwiaWxsdW1pbmFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wibWF4d2VsbFwiLCBcIk14XCIsIG51bGwsIFwibWFnbmV0aWNfZmx1eFwiLCBmYWxzZSwgZmFsc2UsIDFlLTE4XSxcblx0ICAgIFtcIm1lYXN1cmVtZW50IHRvblwiLCBcIk1UT05cIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDEuMTMyNjczODYzNjhdLFxuXHQgICAgW1wibWV0ZXIgcGVyIGhvdXJcIiwgXCJtL2hcIiwgW1wibS9oclwiXSwgXCJzcGVlZFwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDAyNzc3Nzc3Nzc3Nzc3OF0sXG5cdCAgICBbXCJtZXRlciBwZXIgc2Vjb25kXCIsIFwibS9zXCIsIFtcIm0vc2VjXCJdLCBcInNwZWVkXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wibWV0ZXIgcGVyIHNlY29uZCBzcXVhcmVkXCIsIFwibT9zPz9cIiwgbnVsbCwgXCJhY2NlbGVyYXRpb25cIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wicGFyc2VjXCIsIFwicGNcIiwgW1wicGFyc2VjXCJdLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMzA4NTY3NzU4MTQ2NzE5MDBdLFxuXHQgICAgW1wibWV0ZXIgc3F1YXJlZCBwZXIgc2Vjb25kXCIsIFwibT8vc1wiLCBudWxsLCBcImtpbmVtYXRpY192aXNjb3NpdHlcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wibWV0cmVcIiwgXCJtXCIsIG51bGwsIFwibGVuZ3RoXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wibWlsZXMgcGVyIGhvdXJcIiwgXCJtcGhcIiwgbnVsbCwgXCJzcGVlZFwiLCBmYWxzZSwgdHJ1ZSwgMC40NDcwNF0sXG5cdCAgICBbXCJtaWxsaW1ldHJlIG9mIG1lcmN1cnlcIiwgXCJtbUhnXCIsIG51bGwsIFwicHJlc3N1cmVcIiwgZmFsc2UsIGZhbHNlLCAxMzMuMzIyXSxcblx0ICAgIFtcIm1pbnV0ZVwiLCBcIj9cIiwgbnVsbCwgXCJhbmdsZVwiLCBmYWxzZSwgZmFsc2UsIDAuMDAwMjkwODg4MjA4NjY1NzIyXSxcblx0ICAgIFtcIm1pbnV0ZVwiLCBcIm1pblwiLCBbXCJtblwiXSwgXCJ0aW1lXCIsIGZhbHNlLCB0cnVlLCA2MF0sXG5cdCAgICBbXCJtb2Rlcm4gdGVhc3Bvb25cIiwgXCJ0c3BtXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAwNV0sXG5cdCAgICBbXCJtb2xlXCIsIFwibW9sXCIsIG51bGwsIFwiYW1vdW50X29mX3N1YnN0YW5jZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJtb3JnZW5cIiwgXCJNb3JnZW5cIiwgbnVsbCwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAyNTAwXSxcblx0ICAgIFtcIm4udS4gb2YgYWN0aW9uXCIsIFwiP1wiLCBudWxsLCBcImFjdGlvblwiLCBmYWxzZSwgZmFsc2UsIDEuMDU0NTcxNjgxODE4MThlLTM0XSxcblx0ICAgIFtcIm4udS4gb2YgbWFzc1wiLCBcIm0/XCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgZmFsc2UsIDkuMTA5MzgyNjE2MTYxNjJlLTMxXSxcblx0ICAgIFtcIm4udS4gb2Ygc3BlZWRcIiwgXCJjP1wiLCBudWxsLCBcInNwZWVkXCIsIGZhbHNlLCBmYWxzZSwgMjk5NzkyNDU4XSxcblx0ICAgIFtcIm4udS4gb2YgdGltZVwiLCBcIj8vKG1lP2M/PylcIiwgbnVsbCwgXCJ0aW1lXCIsIGZhbHNlLCBmYWxzZSwgMS4yODgwODg2Njc3ODY4N2UtMjFdLFxuXHQgICAgW1wibmF1dGljYWwgbWlsZVwiLCBcIk1cIiwgW1wiTm1pXCJdLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMTg1Ml0sXG5cdCAgICBbXCJuZXd0b25cIiwgXCJOXCIsIG51bGwsIFwiZm9yY2VcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCLFk3JzdGVkXCIsIFwiT2UgXCIsIG51bGwsIFwibWFnbmV0aWNfZmllbGRfaW50ZW5zaXR5XCIsIGZhbHNlLCBmYWxzZSwgNzkuNTc3NDcxNTQ1OTQ3N10sXG5cdCAgICBbXCJvaG1cIiwgXCLOqVwiLCBudWxsLCBcImVsZWN0cmljX3Jlc2lzdGFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wib3VuY2UgbWFzc1wiLCBcIm96bVwiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDAuMDI4MzQ5NTIzMTI1XSxcblx0ICAgIFtcInBhc2NhbFwiLCBcIlBhXCIsIG51bGwsIFwicHJlc3N1cmVcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wicGFzY2FsIHNlY29uZFwiLCBcIlBhP3NcIiwgbnVsbCwgXCJkeW5hbWljX3Zpc2Nvc2l0eVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJwZmVyZGVzdMOkcmtlXCIsIFwiUFNcIiwgbnVsbCwgXCJwb3dlclwiLCBmYWxzZSwgdHJ1ZSwgNzM1LjQ5ODc1XSxcblx0ICAgIFtcInBob3RcIiwgXCJwaFwiLCBudWxsLCBcImlsbHVtaW5hbmNlXCIsIGZhbHNlLCBmYWxzZSwgMC4wMDAxXSxcblx0ICAgIFtcInBpY2EgKDEvNiBpbmNoKVwiLCBcInBpY2FcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDAuMDAwMzUyNzc3Nzc3Nzc3NzhdLFxuXHQgICAgW1wicGljYSAoMS83MiBpbmNoKVwiLCBcIlBpY2FcIiwgW1wiUGljYXB0XCJdLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMC4wMDQyMzMzMzMzMzMzMzMzM10sXG5cdCAgICBbXCJwb2lzZVwiLCBcIlBcIiwgbnVsbCwgXCJkeW5hbWljX3Zpc2Nvc2l0eVwiLCBmYWxzZSwgZmFsc2UsIDAuMV0sXG5cdCAgICBbXCJwb25kXCIsIFwicG9uZFwiLCBudWxsLCBcImZvcmNlXCIsIGZhbHNlLCB0cnVlLCAwLjAwOTgwNjY1XSxcblx0ICAgIFtcInBvdW5kIGZvcmNlXCIsIFwibGJmXCIsIG51bGwsIFwiZm9yY2VcIiwgZmFsc2UsIHRydWUsIDQuNDQ4MjIxNjE1MjYwNV0sXG5cdCAgICBbXCJwb3VuZCBtYXNzXCIsIFwibGJtXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgMC40NTM1OTIzN10sXG5cdCAgICBbXCJxdWFydFwiLCBcInF0XCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDk0NjM1Mjk0Nl0sXG5cdCAgICBbXCJyYWRpYW5cIiwgXCJyYWRcIiwgbnVsbCwgXCJhbmdsZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJzZWNvbmRcIiwgXCI/XCIsIG51bGwsIFwiYW5nbGVcIiwgZmFsc2UsIGZhbHNlLCAwLjAwMDAwNDg0ODEzNjgxMTA5NTM2XSxcblx0ICAgIFtcInNlY29uZFwiLCBcInNcIiwgW1wic2VjXCJdLCBcInRpbWVcIiwgdHJ1ZSwgdHJ1ZSwgMV0sXG5cdCAgICBbXCJzaG9ydCBodW5kcmVkd2VpZ2h0XCIsIFwiY3d0XCIsIFtcInNod2VpZ2h0XCJdLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDQ1LjM1OTIzN10sXG5cdCAgICBbXCJzaWVtZW5zXCIsIFwiU1wiLCBudWxsLCBcImVsZWN0cmljYWxfY29uZHVjdGFuY2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wic2lldmVydFwiLCBcIlN2XCIsIG51bGwsIFwiZXF1aXZhbGVudF9kb3NlXCIsIHRydWUsIGZhbHNlLCAxXSxcblx0ICAgIFtcInNsdWdcIiwgXCJzZ1wiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIHRydWUsIDE0LjU5MzkwMjk0XSxcblx0ICAgIFtcInNxdWFyZSDDpW5nc3Ryw7ZtXCIsIFwiYW5nMlwiLCBbXCJhbmdeMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAxZS0yMF0sXG5cdCAgICBbXCJzcXVhcmUgZm9vdFwiLCBcImZ0MlwiLCBbXCJmdF4yXCJdLCBcImFyZWFcIiwgZmFsc2UsIHRydWUsIDAuMDkyOTAzMDRdLFxuXHQgICAgW1wic3F1YXJlIGluY2hcIiwgXCJpbjJcIiwgW1wiaW5eMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDY0NTE2XSxcblx0ICAgIFtcInNxdWFyZSBsaWdodC15ZWFyXCIsIFwibHkyXCIsIFtcImx5XjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgOC45NTA1NDIxMDc0ODE4OWUrMzFdLFxuXHQgICAgW1wic3F1YXJlIG1ldGVyXCIsIFwibT9cIiwgbnVsbCwgXCJhcmVhXCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1wic3F1YXJlIG1pbGVcIiwgXCJtaTJcIiwgW1wibWleMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAyNTg5OTg4LjExMDMzNl0sXG5cdCAgICBbXCJzcXVhcmUgbmF1dGljYWwgbWlsZVwiLCBcIk5taTJcIiwgW1wiTm1pXjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMzQyOTkwNF0sXG5cdCAgICBbXCJzcXVhcmUgUGljYVwiLCBcIlBpY2EyXCIsIFtcIlBpY2FwdDJcIiwgXCJQaWNhXjJcIiwgXCJQaWNhcHReMlwiXSwgXCJhcmVhXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAxNzkyMTExMTExMTExXSxcblx0ICAgIFtcInNxdWFyZSB5YXJkXCIsIFwieWQyXCIsIFtcInlkXjJcIl0sIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgMC44MzYxMjczNl0sXG5cdCAgICBbXCJzdGF0dXRlIG1pbGVcIiwgXCJtaVwiLCBudWxsLCBcImxlbmd0aFwiLCBmYWxzZSwgdHJ1ZSwgMTYwOS4zNDRdLFxuXHQgICAgW1wic3RlcmFkaWFuXCIsIFwic3JcIiwgbnVsbCwgXCJzb2xpZF9hbmdsZVwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJzdGlsYlwiLCBcInNiXCIsIG51bGwsIFwibHVtaW5hbmNlXCIsIGZhbHNlLCBmYWxzZSwgMC4wMDAxXSxcblx0ICAgIFtcInN0b2tlc1wiLCBcIlN0XCIsIG51bGwsIFwia2luZW1hdGljX3Zpc2Nvc2l0eVwiLCBmYWxzZSwgZmFsc2UsIDAuMDAwMV0sXG5cdCAgICBbXCJzdG9uZVwiLCBcInN0b25lXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgNi4zNTAyOTMxOF0sXG5cdCAgICBbXCJ0YWJsZXNwb29uXCIsIFwidGJzXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDAxNDc4NjhdLFxuXHQgICAgW1widGVhc3Bvb25cIiwgXCJ0c3BcIiwgbnVsbCwgXCJ2b2x1bWVcIiwgZmFsc2UsIHRydWUsIDAuMDAwMDA0OTI4OTJdLFxuXHQgICAgW1widGVzbGFcIiwgXCJUXCIsIG51bGwsIFwibWFnbmV0aWNfZmx1eF9kZW5zaXR5XCIsIHRydWUsIHRydWUsIDFdLFxuXHQgICAgW1widGhlcm1vZHluYW1pYyBjYWxvcmllXCIsIFwiY1wiLCBudWxsLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgNC4xODRdLFxuXHQgICAgW1widG9uXCIsIFwidG9uXCIsIG51bGwsIFwibWFzc1wiLCBmYWxzZSwgdHJ1ZSwgOTA3LjE4NDc0XSxcblx0ICAgIFtcInRvbm5lXCIsIFwidFwiLCBudWxsLCBcIm1hc3NcIiwgZmFsc2UsIGZhbHNlLCAxMDAwXSxcblx0ICAgIFtcIlUuSy4gcGludFwiLCBcInVrX3B0XCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDU2ODI2MTI1XSxcblx0ICAgIFtcIlUuUy4gYnVzaGVsXCIsIFwiYnVzaGVsXCIsIG51bGwsIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAzNTIzOTA3XSxcblx0ICAgIFtcIlUuUy4gb2lsIGJhcnJlbFwiLCBcImJhcnJlbFwiLCBudWxsLCBcInZvbHVtZVwiLCBmYWxzZSwgdHJ1ZSwgMC4xNTg5ODcyOTVdLFxuXHQgICAgW1wiVS5TLiBwaW50XCIsIFwicHRcIiwgW1widXNfcHRcIl0sIFwidm9sdW1lXCIsIGZhbHNlLCB0cnVlLCAwLjAwMDQ3MzE3NjQ3M10sXG5cdCAgICBbXCJVLlMuIHN1cnZleSBtaWxlXCIsIFwic3VydmV5X21pXCIsIG51bGwsIFwibGVuZ3RoXCIsIGZhbHNlLCB0cnVlLCAxNjA5LjM0NzIxOV0sXG5cdCAgICBbXCJVLlMuIHN1cnZleS9zdGF0dXRlIGFjcmVcIiwgXCJ1c19hY3JlXCIsIG51bGwsIFwiYXJlYVwiLCBmYWxzZSwgdHJ1ZSwgNDA0Ni44NzI2MV0sXG5cdCAgICBbXCJ2b2x0XCIsIFwiVlwiLCBudWxsLCBcInZvbHRhZ2VcIiwgdHJ1ZSwgZmFsc2UsIDFdLFxuXHQgICAgW1wid2F0dFwiLCBcIldcIiwgbnVsbCwgXCJwb3dlclwiLCB0cnVlLCB0cnVlLCAxXSxcblx0ICAgIFtcIndhdHQtaG91clwiLCBcIldoXCIsIFtcIndoXCJdLCBcImVuZXJneVwiLCBmYWxzZSwgdHJ1ZSwgMzYwMF0sXG5cdCAgICBbXCJ3ZWJlclwiLCBcIldiXCIsIG51bGwsIFwibWFnbmV0aWNfZmx1eFwiLCB0cnVlLCBmYWxzZSwgMV0sXG5cdCAgICBbXCJ5YXJkXCIsIFwieWRcIiwgbnVsbCwgXCJsZW5ndGhcIiwgZmFsc2UsIHRydWUsIDAuOTE0NF0sXG5cdCAgICBbXCJ5ZWFyXCIsIFwieXJcIiwgbnVsbCwgXCJ0aW1lXCIsIGZhbHNlLCB0cnVlLCAzMTU1NzYwMF1cblx0ICBdO1xuXG5cdCAgLy8gQmluYXJ5IHByZWZpeGVzXG5cdCAgLy8gW05hbWUsIFByZWZpeCBwb3dlciBvZiAyIHZhbHVlLCBQcmV2aXggdmFsdWUsIEFiYnJldmlhdGlvbiwgRGVyaXZlZCBmcm9tXVxuXHQgIHZhciBiaW5hcnlfcHJlZml4ZXMgPSB7XG5cdCAgICBZaTogW1wieW9iaVwiLCA4MCwgMTIwODkyNTgxOTYxNDYyOTE3NDcwNjE3NiwgXCJZaVwiLCBcInlvdHRhXCJdLFxuXHQgICAgWmk6IFtcInplYmlcIiwgNzAsIDExODA1OTE2MjA3MTc0MTEzMDM0MjQsIFwiWmlcIiwgXCJ6ZXR0YVwiXSxcblx0ICAgIEVpOiBbXCJleGJpXCIsIDYwLCAxMTUyOTIxNTA0NjA2ODQ2OTc2LCBcIkVpXCIsIFwiZXhhXCJdLFxuXHQgICAgUGk6IFtcInBlYmlcIiwgNTAsIDExMjU4OTk5MDY4NDI2MjQsIFwiUGlcIiwgXCJwZXRhXCJdLFxuXHQgICAgVGk6IFtcInRlYmlcIiwgNDAsIDEwOTk1MTE2Mjc3NzYsIFwiVGlcIiwgXCJ0ZXJhXCJdLFxuXHQgICAgR2k6IFtcImdpYmlcIiwgMzAsIDEwNzM3NDE4MjQsIFwiR2lcIiwgXCJnaWdhXCJdLFxuXHQgICAgTWk6IFtcIm1lYmlcIiwgMjAsIDEwNDg1NzYsIFwiTWlcIiwgXCJtZWdhXCJdLFxuXHQgICAga2k6IFtcImtpYmlcIiwgMTAsIDEwMjQsIFwia2lcIiwgXCJraWxvXCJdXG5cdCAgfTtcblxuXHQgIC8vIFVuaXQgcHJlZml4ZXNcblx0ICAvLyBbTmFtZSwgTXVsdGlwbGllciwgQWJicmV2aWF0aW9uXVxuXHQgIHZhciB1bml0X3ByZWZpeGVzID0ge1xuXHQgICAgWTogW1wieW90dGFcIiwgMWUrMjQsIFwiWVwiXSxcblx0ICAgIFo6IFtcInpldHRhXCIsIDFlKzIxLCBcIlpcIl0sXG5cdCAgICBFOiBbXCJleGFcIiwgMWUrMTgsIFwiRVwiXSxcblx0ICAgIFA6IFtcInBldGFcIiwgMWUrMTUsIFwiUFwiXSxcblx0ICAgIFQ6IFtcInRlcmFcIiwgMWUrMTIsIFwiVFwiXSxcblx0ICAgIEc6IFtcImdpZ2FcIiwgMWUrMDksIFwiR1wiXSxcblx0ICAgIE06IFtcIm1lZ2FcIiwgMWUrMDYsIFwiTVwiXSxcblx0ICAgIGs6IFtcImtpbG9cIiwgMWUrMDMsIFwia1wiXSxcblx0ICAgIGg6IFtcImhlY3RvXCIsIDFlKzAyLCBcImhcIl0sXG5cdCAgICBlOiBbXCJkZWthb1wiLCAxZSswMSwgXCJlXCJdLFxuXHQgICAgZDogW1wiZGVjaVwiLCAxZS0wMSwgXCJkXCJdLFxuXHQgICAgYzogW1wiY2VudGlcIiwgMWUtMDIsIFwiY1wiXSxcblx0ICAgIG06IFtcIm1pbGxpXCIsIDFlLTAzLCBcIm1cIl0sXG5cdCAgICB1OiBbXCJtaWNyb1wiLCAxZS0wNiwgXCJ1XCJdLFxuXHQgICAgbjogW1wibmFub1wiLCAxZS0wOSwgXCJuXCJdLFxuXHQgICAgcDogW1wicGljb1wiLCAxZS0xMiwgXCJwXCJdLFxuXHQgICAgZjogW1wiZmVtdG9cIiwgMWUtMTUsIFwiZlwiXSxcblx0ICAgIGE6IFtcImF0dG9cIiwgMWUtMTgsIFwiYVwiXSxcblx0ICAgIHo6IFtcInplcHRvXCIsIDFlLTIxLCBcInpcIl0sXG5cdCAgICB5OiBbXCJ5b2N0b1wiLCAxZS0yNCwgXCJ5XCJdXG5cdCAgfTtcblxuXHQgIC8vIEluaXRpYWxpemUgdW5pdHMgYW5kIG11bHRpcGxpZXJzXG5cdCAgdmFyIGZyb20gPSBudWxsO1xuXHQgIHZhciB0byA9IG51bGw7XG5cdCAgdmFyIGJhc2VfZnJvbV91bml0ID0gZnJvbV91bml0O1xuXHQgIHZhciBiYXNlX3RvX3VuaXQgPSB0b191bml0O1xuXHQgIHZhciBmcm9tX211bHRpcGxpZXIgPSAxO1xuXHQgIHZhciB0b19tdWx0aXBsaWVyID0gMTtcblx0ICB2YXIgYWx0O1xuXG5cdCAgLy8gTG9va3VwIGZyb20gYW5kIHRvIHVuaXRzXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgYWx0ID0gKHVuaXRzW2ldWzJdID09PSBudWxsKSA/IFtdIDogdW5pdHNbaV1bMl07XG5cdCAgICBpZiAodW5pdHNbaV1bMV0gPT09IGJhc2VfZnJvbV91bml0IHx8IGFsdC5pbmRleE9mKGJhc2VfZnJvbV91bml0KSA+PSAwKSB7XG5cdCAgICAgIGZyb20gPSB1bml0c1tpXTtcblx0ICAgIH1cblx0ICAgIGlmICh1bml0c1tpXVsxXSA9PT0gYmFzZV90b191bml0IHx8IGFsdC5pbmRleE9mKGJhc2VfdG9fdW5pdCkgPj0gMCkge1xuXHQgICAgICB0byA9IHVuaXRzW2ldO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBmcm9tIHByZWZpeFxuXHQgIGlmIChmcm9tID09PSBudWxsKSB7XG5cdCAgICB2YXIgZnJvbV9iaW5hcnlfcHJlZml4ID0gYmluYXJ5X3ByZWZpeGVzW2Zyb21fdW5pdC5zdWJzdHJpbmcoMCwgMildO1xuXHQgICAgdmFyIGZyb21fdW5pdF9wcmVmaXggPSB1bml0X3ByZWZpeGVzW2Zyb21fdW5pdC5zdWJzdHJpbmcoMCwgMSldO1xuXG5cdCAgICAvLyBIYW5kbGUgZGVrYW8gdW5pdCBwcmVmaXggKG9ubHkgdW5pdCBwcmVmaXggd2l0aCB0d28gY2hhcmFjdGVycylcblx0ICAgIGlmIChmcm9tX3VuaXQuc3Vic3RyaW5nKDAsIDIpID09PSAnZGEnKSB7XG5cdCAgICAgIGZyb21fdW5pdF9wcmVmaXggPSBbXCJkZWthb1wiLCAxZSswMSwgXCJkYVwiXTtcblx0ICAgIH1cblxuXHQgICAgLy8gSGFuZGxlIGJpbmFyeSBwcmVmaXhlcyBmaXJzdCAoc28gdGhhdCAnWWknIGlzIHByb2Nlc3NlZCBiZWZvcmUgJ1knKVxuXHQgICAgaWYgKGZyb21fYmluYXJ5X3ByZWZpeCkge1xuXHQgICAgICBmcm9tX211bHRpcGxpZXIgPSBmcm9tX2JpbmFyeV9wcmVmaXhbMl07XG5cdCAgICAgIGJhc2VfZnJvbV91bml0ID0gZnJvbV91bml0LnN1YnN0cmluZygyKTtcblx0ICAgIH0gZWxzZSBpZiAoZnJvbV91bml0X3ByZWZpeCkge1xuXHQgICAgICBmcm9tX211bHRpcGxpZXIgPSBmcm9tX3VuaXRfcHJlZml4WzFdO1xuXHQgICAgICBiYXNlX2Zyb21fdW5pdCA9IGZyb21fdW5pdC5zdWJzdHJpbmcoZnJvbV91bml0X3ByZWZpeFsyXS5sZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBMb29rdXAgZnJvbSB1bml0XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVuaXRzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgIGFsdCA9ICh1bml0c1tqXVsyXSA9PT0gbnVsbCkgPyBbXSA6IHVuaXRzW2pdWzJdO1xuXHQgICAgICBpZiAodW5pdHNbal1bMV0gPT09IGJhc2VfZnJvbV91bml0IHx8IGFsdC5pbmRleE9mKGJhc2VfZnJvbV91bml0KSA+PSAwKSB7XG5cdCAgICAgICAgZnJvbSA9IHVuaXRzW2pdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHRvIHByZWZpeFxuXHQgIGlmICh0byA9PT0gbnVsbCkge1xuXHQgICAgdmFyIHRvX2JpbmFyeV9wcmVmaXggPSBiaW5hcnlfcHJlZml4ZXNbdG9fdW5pdC5zdWJzdHJpbmcoMCwgMildO1xuXHQgICAgdmFyIHRvX3VuaXRfcHJlZml4ID0gdW5pdF9wcmVmaXhlc1t0b191bml0LnN1YnN0cmluZygwLCAxKV07XG5cblx0ICAgIC8vIEhhbmRsZSBkZWthbyB1bml0IHByZWZpeCAob25seSB1bml0IHByZWZpeCB3aXRoIHR3byBjaGFyYWN0ZXJzKVxuXHQgICAgaWYgKHRvX3VuaXQuc3Vic3RyaW5nKDAsIDIpID09PSAnZGEnKSB7XG5cdCAgICAgIHRvX3VuaXRfcHJlZml4ID0gW1wiZGVrYW9cIiwgMWUrMDEsIFwiZGFcIl07XG5cdCAgICB9XG5cblx0ICAgIC8vIEhhbmRsZSBiaW5hcnkgcHJlZml4ZXMgZmlyc3QgKHNvIHRoYXQgJ1lpJyBpcyBwcm9jZXNzZWQgYmVmb3JlICdZJylcblx0ICAgIGlmICh0b19iaW5hcnlfcHJlZml4KSB7XG5cdCAgICAgIHRvX211bHRpcGxpZXIgPSB0b19iaW5hcnlfcHJlZml4WzJdO1xuXHQgICAgICBiYXNlX3RvX3VuaXQgPSB0b191bml0LnN1YnN0cmluZygyKTtcblx0ICAgIH0gZWxzZSBpZiAodG9fdW5pdF9wcmVmaXgpIHtcblx0ICAgICAgdG9fbXVsdGlwbGllciA9IHRvX3VuaXRfcHJlZml4WzFdO1xuXHQgICAgICBiYXNlX3RvX3VuaXQgPSB0b191bml0LnN1YnN0cmluZyh0b191bml0X3ByZWZpeFsyXS5sZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBMb29rdXAgdG8gdW5pdFxuXHQgICAgZm9yICh2YXIgayA9IDA7IGsgPCB1bml0cy5sZW5ndGg7IGsrKykge1xuXHQgICAgICBhbHQgPSAodW5pdHNba11bMl0gPT09IG51bGwpID8gW10gOiB1bml0c1trXVsyXTtcblx0ICAgICAgaWYgKHVuaXRzW2tdWzFdID09PSBiYXNlX3RvX3VuaXQgfHwgYWx0LmluZGV4T2YoYmFzZV90b191bml0KSA+PSAwKSB7XG5cdCAgICAgICAgdG8gPSB1bml0c1trXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBhIHVuaXQgZG9lcyBub3QgZXhpc3Rcblx0ICBpZiAoZnJvbSA9PT0gbnVsbCB8fCB0byA9PT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm5hO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB1bml0cyByZXByZXNlbnQgZGlmZmVyZW50IHF1YW50aXRpZXNcblx0ICBpZiAoZnJvbVszXSAhPT0gdG9bM10pIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gY29udmVydGVkIG51bWJlclxuXHQgIHJldHVybiBudW1iZXIgKiBmcm9tWzZdICogZnJvbV9tdWx0aXBsaWVyIC8gKHRvWzZdICogdG9fbXVsdGlwbGllcik7XG5cdH07XG5cblx0ZXhwb3J0cy5ERUMyQklOID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBkZWNpbWFsLCBpcyBsb3dlciB0aGFuIC01MTIsIG9yIGlzIGdyZWF0ZXIgdGhhbiA1MTFcblx0ICBpZiAoIS9eLT9bMC05XXsxLDN9JC8udGVzdChudW1iZXIpIHx8IG51bWJlciA8IC01MTIgfHwgbnVtYmVyID4gNTExKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBiaW5hcnkgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gJzEnICsgdGV4dC5SRVBUKCcwJywgOSAtICg1MTIgKyBudW1iZXIpLnRvU3RyaW5nKDIpLmxlbmd0aCkgKyAoNTEyICsgbnVtYmVyKS50b1N0cmluZygyKTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIGJpbmFyeVxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChudW1iZXIsIDEwKS50b1N0cmluZygyKTtcblxuXHQgIC8vIFJldHVybiBiaW5hcnkgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHR5cGVvZiBwbGFjZXMgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5ERUMySEVYID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmIChudW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIG51bWJlcjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBkZWNpbWFsLCBpcyBsb3dlciB0aGFuIC01NDk3NTU4MTM4ODgsIG9yIGlzIGdyZWF0ZXIgdGhhbiA1NDk3NTU4MTM4ODdcblx0ICBpZiAoIS9eLT9bMC05XXsxLDEyfSQvLnRlc3QobnVtYmVyKSB8fCBudW1iZXIgPCAtNTQ5NzU1ODEzODg4IHx8IG51bWJlciA+IDU0OTc1NTgxMzg4Nykge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBJZ25vcmUgcGxhY2VzIGFuZCByZXR1cm4gYSAxMC1jaGFyYWN0ZXIgaGV4YWRlY2ltYWwgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChudW1iZXIgPCAwKSB7XG5cdCAgICByZXR1cm4gKDEwOTk1MTE2Mjc3NzYgKyBudW1iZXIpLnRvU3RyaW5nKDE2KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIGhleGFkZWNpbWFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMTApLnRvU3RyaW5nKDE2KTtcblxuXHQgIC8vIFJldHVybiBoZXhhZGVjaW1hbCBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAodHlwZW9mIHBsYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkRFQzJPQ1QgPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIG51bWJlciA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcik7XG5cdCAgaWYgKG51bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGRlY2ltYWwsIGlzIGxvd2VyIHRoYW4gLTU0OTc1NTgxMzg4OCwgb3IgaXMgZ3JlYXRlciB0aGFuIDU0OTc1NTgxMzg4N1xuXHQgIGlmICghL14tP1swLTldezEsOX0kLy50ZXN0KG51bWJlcikgfHwgbnVtYmVyIDwgLTUzNjg3MDkxMiB8fCBudW1iZXIgPiA1MzY4NzA5MTEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIG9jdGFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAobnVtYmVyIDwgMCkge1xuXHQgICAgcmV0dXJuICgxMDczNzQxODI0ICsgbnVtYmVyKS50b1N0cmluZyg4KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIG9jdGFsXG5cdCAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG51bWJlciwgMTApLnRvU3RyaW5nKDgpO1xuXG5cdCAgLy8gUmV0dXJuIG9jdGFsIG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmICh0eXBlb2YgcGxhY2VzID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuREVMVEEgPSBmdW5jdGlvbihudW1iZXIxLCBudW1iZXIyKSB7XG5cdCAgLy8gU2V0IG51bWJlcjIgdG8gemVybyBpZiB1bmRlZmluZWRcblx0ICBudW1iZXIyID0gKG51bWJlcjIgPT09IHVuZGVmaW5lZCkgPyAwIDogbnVtYmVyMjtcblx0ICBudW1iZXIxID0gdXRpbHMucGFyc2VOdW1iZXIobnVtYmVyMSk7XG5cdCAgbnVtYmVyMiA9IHV0aWxzLnBhcnNlTnVtYmVyKG51bWJlcjIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKG51bWJlcjEsIG51bWJlcjIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGRlbHRhXG5cdCAgcmV0dXJuIChudW1iZXIxID09PSBudW1iZXIyKSA/IDEgOiAwO1xuXHR9O1xuXG5cdC8vIFRPRE86IHdoeSBpcyB1cHBlcl9ib3VuZCBub3QgdXNlZCA/IFRoZSBleGNlbCBkb2N1bWVudGF0aW9uIGhhcyBubyBleGFtcGxlcyB3aXRoIHVwcGVyX2JvdW5kXG5cdGV4cG9ydHMuRVJGID0gZnVuY3Rpb24obG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSB7XG5cdCAgLy8gU2V0IG51bWJlcjIgdG8gemVybyBpZiB1bmRlZmluZWRcblx0ICB1cHBlcl9ib3VuZCA9ICh1cHBlcl9ib3VuZCA9PT0gdW5kZWZpbmVkKSA/IDAgOiB1cHBlcl9ib3VuZDtcblxuXHQgIGxvd2VyX2JvdW5kID0gdXRpbHMucGFyc2VOdW1iZXIobG93ZXJfYm91bmQpO1xuXHQgIHVwcGVyX2JvdW5kID0gdXRpbHMucGFyc2VOdW1iZXIodXBwZXJfYm91bmQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4galN0YXQuZXJmKGxvd2VyX2JvdW5kKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuRVJGLlBSRUNJU0UgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignRVJGLlBSRUNJU0UgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5FUkZDID0gZnVuY3Rpb24oeCkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiB4IGlzIG5vdCBhIG51bWJlclxuXHQgIGlmIChpc05hTih4KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBqU3RhdC5lcmZjKHgpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5FUkZDLlBSRUNJU0UgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignRVJGQy5QUkVDSVNFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuR0VTVEVQID0gZnVuY3Rpb24obnVtYmVyLCBzdGVwKSB7XG5cdCAgc3RlcCA9IHN0ZXAgfHwgMDtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHN0ZXAsIG51bWJlcikpIHtcblx0ICAgIHJldHVybiBudW1iZXI7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGRlbHRhXG5cdCAgcmV0dXJuIChudW1iZXIgPj0gc3RlcCkgPyAxIDogMDtcblx0fTtcblxuXHRleHBvcnRzLkhFWDJCSU4gPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGhleGFkZWNpbWFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC05QS1GYS1mXXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDaGVjayBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICB2YXIgbmVnYXRpdmUgPSAobnVtYmVyLmxlbmd0aCA9PT0gMTAgJiYgbnVtYmVyLnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpID09PSAnZicpID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdCAgLy8gQ29udmVydCBoZXhhZGVjaW1hbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gKG5lZ2F0aXZlKSA/IHBhcnNlSW50KG51bWJlciwgMTYpIC0gMTA5OTUxMTYyNzc3NiA6IHBhcnNlSW50KG51bWJlciwgMTYpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIG51bWJlciBpcyBsb3dlciB0aGFuIC01MTIgb3IgZ3JlYXRlciB0aGFuIDUxMVxuXHQgIGlmIChkZWNpbWFsIDwgLTUxMiB8fCBkZWNpbWFsID4gNTExKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBiaW5hcnkgbnVtYmVyIGlmIG51bWJlciBpcyBuZWdhdGl2ZVxuXHQgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgcmV0dXJuICcxJyArIHRleHQuUkVQVCgnMCcsIDkgLSAoNTEyICsgZGVjaW1hbCkudG9TdHJpbmcoMikubGVuZ3RoKSArICg1MTIgKyBkZWNpbWFsKS50b1N0cmluZygyKTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIGJpbmFyeVxuXHQgIHZhciByZXN1bHQgPSBkZWNpbWFsLnRvU3RyaW5nKDIpO1xuXG5cdCAgLy8gUmV0dXJuIGJpbmFyeSBudW1iZXIgdXNpbmcgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgbmVjZXNzYXJ5IGlmIHBsYWNlcyBpcyB1bmRlZmluZWRcblx0ICBpZiAocGxhY2VzID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbm9ubnVtZXJpY1xuXHQgICAgaWYgKGlzTmFOKHBsYWNlcykpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5lZ2F0aXZlXG5cdCAgICBpZiAocGxhY2VzIDwgMCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUcnVuY2F0ZSBwbGFjZXMgaW4gY2FzZSBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgICAgcGxhY2VzID0gTWF0aC5mbG9vcihwbGFjZXMpO1xuXG5cdCAgICAvLyBQYWQgcmV0dXJuIHZhbHVlIHdpdGggbGVhZGluZyAwcyAoemVyb3MpIGlmIG5lY2Vzc2FyeSAodXNpbmcgVW5kZXJzY29yZS5zdHJpbmcpXG5cdCAgICByZXR1cm4gKHBsYWNlcyA+PSByZXN1bHQubGVuZ3RoKSA/IHRleHQuUkVQVCgnMCcsIHBsYWNlcyAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0IDogZXJyb3IubnVtO1xuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLkhFWDJERUMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBoZXhhZGVjaW1hbCBvciBjb250YWlucyBtb3JlIHRoYW4gdGVuIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIS9eWzAtOUEtRmEtZl17MSwxMH0kLy50ZXN0KG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBoZXhhZGVjaW1hbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gcGFyc2VJbnQobnVtYmVyLCAxNik7XG5cblx0ICAvLyBSZXR1cm4gZGVjaW1hbCBudW1iZXJcblx0ICByZXR1cm4gKGRlY2ltYWwgPj0gNTQ5NzU1ODEzODg4KSA/IGRlY2ltYWwgLSAxMDk5NTExNjI3Nzc2IDogZGVjaW1hbDtcblx0fTtcblxuXHRleHBvcnRzLkhFWDJPQ1QgPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGhleGFkZWNpbWFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC05QS1GYS1mXXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGhleGFkZWNpbWFsIG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIGRlY2ltYWwgPSBwYXJzZUludChudW1iZXIsIDE2KTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgcG9zaXRpdmUgYW5kIGdyZWF0ZXIgdGhhbiAweDFmZmZmZmZmICg1MzY4NzA5MTEpXG5cdCAgaWYgKGRlY2ltYWwgPiA1MzY4NzA5MTEgJiYgZGVjaW1hbCA8IDEwOTg5NzQ3NTY4NjQpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIG9jdGFsIG51bWJlciBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICBpZiAoZGVjaW1hbCA+PSAxMDk4OTc0NzU2ODY0KSB7XG5cdCAgICByZXR1cm4gKGRlY2ltYWwgLSAxMDk4NDM3ODg1OTUyKS50b1N0cmluZyg4KTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IGRlY2ltYWwgbnVtYmVyIHRvIG9jdGFsXG5cdCAgdmFyIHJlc3VsdCA9IGRlY2ltYWwudG9TdHJpbmcoOCk7XG5cblx0ICAvLyBSZXR1cm4gb2N0YWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHBsYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5JTUFCUyA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIGNvZWZmaWNpZW50IGlzIG5vdCBhIG51bWJlclxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGFic29sdXRlIHZhbHVlIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNQUdJTkFSWSA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICBpZiAoaW51bWJlciA9PT0gdW5kZWZpbmVkIHx8IGludW1iZXIgPT09IHRydWUgfHwgaW51bWJlciA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gMCBpZiBpbnVtYmVyIGlzIGVxdWFsIHRvIDBcblx0ICBpZiAoaW51bWJlciA9PT0gMCB8fCBpbnVtYmVyID09PSAnMCcpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2VzXG5cdCAgaWYgKFsnaScsICdqJ10uaW5kZXhPZihpbnVtYmVyKSA+PSAwKSB7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cblx0ICAvLyBOb3JtYWxpemUgaW1hZ2luYXJ5IGNvZWZmaWNpZW50XG5cdCAgaW51bWJlciA9IGludW1iZXIucmVwbGFjZSgnK2knLCAnKzFpJykucmVwbGFjZSgnLWknLCAnLTFpJykucmVwbGFjZSgnK2onLCAnKzFqJykucmVwbGFjZSgnLWonLCAnLTFqJyk7XG5cblx0ICAvLyBMb29rdXAgc2lnblxuXHQgIHZhciBwbHVzID0gaW51bWJlci5pbmRleE9mKCcrJyk7XG5cdCAgdmFyIG1pbnVzID0gaW51bWJlci5pbmRleE9mKCctJyk7XG5cdCAgaWYgKHBsdXMgPT09IDApIHtcblx0ICAgIHBsdXMgPSBpbnVtYmVyLmluZGV4T2YoJysnLCAxKTtcblx0ICB9XG5cblx0ICBpZiAobWludXMgPT09IDApIHtcblx0ICAgIG1pbnVzID0gaW51bWJlci5pbmRleE9mKCctJywgMSk7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIGxhc3QgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEsIGludW1iZXIubGVuZ3RoKTtcblx0ICB2YXIgdW5pdCA9IChsYXN0ID09PSAnaScgfHwgbGFzdCA9PT0gJ2onKTtcblxuXHQgIGlmIChwbHVzID49IDAgfHwgbWludXMgPj0gMCkge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIGltYWdpbmFyeSB1bml0IGlzIG5laXRoZXIgaSBub3IgalxuXHQgICAgaWYgKCF1bml0KSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBpbWFnaW5hcnkgY29lZmZpY2llbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICAgIGlmIChwbHVzID49IDApIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBwbHVzKSkgfHwgaXNOYU4oaW51bWJlci5zdWJzdHJpbmcocGx1cyArIDEsIGludW1iZXIubGVuZ3RoIC0gMSkpKSA/XG5cdCAgICAgICAgZXJyb3IubnVtIDpcblx0ICAgICAgICBOdW1iZXIoaW51bWJlci5zdWJzdHJpbmcocGx1cyArIDEsIGludW1iZXIubGVuZ3RoIC0gMSkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBtaW51cykpIHx8IGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKG1pbnVzICsgMSwgaW51bWJlci5sZW5ndGggLSAxKSkpID9cblx0ICAgICAgICBlcnJvci5udW0gOlxuXHQgICAgICAgIC1OdW1iZXIoaW51bWJlci5zdWJzdHJpbmcobWludXMgKyAxLCBpbnVtYmVyLmxlbmd0aCAtIDEpKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHVuaXQpIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyLnN1YnN0cmluZygwLCBpbnVtYmVyLmxlbmd0aCAtIDEpKSkgPyBlcnJvci5udW0gOiBpbnVtYmVyLnN1YnN0cmluZygwLCBpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIChpc05hTihpbnVtYmVyKSkgPyBlcnJvci5udW0gOiAwO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHRleHBvcnRzLklNQVJHVU1FTlQgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgZXhwb3J0cy5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBjb2VmZmljaWVudCBpcyBub3QgYSBudW1iZXJcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyIGlzIGVxdWFsIHRvIHplcm9cblx0ICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IuZGl2MDtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gUEkvMiBpZiB4IGlzIGVxdWFsIHRvIHplcm8gYW5kIHkgaXMgcG9zaXRpdmVcblx0ICBpZiAoeCA9PT0gMCAmJiB5ID4gMCkge1xuXHQgICAgcmV0dXJuIE1hdGguUEkgLyAyO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAtUEkvMiBpZiB4IGlzIGVxdWFsIHRvIHplcm8gYW5kIHkgaXMgbmVnYXRpdmVcblx0ICBpZiAoeCA9PT0gMCAmJiB5IDwgMCkge1xuXHQgICAgcmV0dXJuIC1NYXRoLlBJIC8gMjtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gemVybyBpZiB4IGlzIG5lZ2F0aXZlIGFuZCB5IGlzIGVxdWFsIHRvIHplcm9cblx0ICBpZiAoeSA9PT0gMCAmJiB4ID4gMCkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHplcm8gaWYgeCBpcyBuZWdhdGl2ZSBhbmQgeSBpcyBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHkgPT09IDAgJiYgeCA8IDApIHtcblx0ICAgIHJldHVybiAtTWF0aC5QSTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYXJndW1lbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICBpZiAoeCA+IDApIHtcblx0ICAgIHJldHVybiBNYXRoLmF0YW4oeSAvIHgpO1xuXHQgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+PSAwKSB7XG5cdCAgICByZXR1cm4gTWF0aC5hdGFuKHkgLyB4KSArIE1hdGguUEk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBNYXRoLmF0YW4oeSAvIHgpIC0gTWF0aC5QSTtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNPTkpVR0FURSA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBjb25qdWdhdGUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gKHkgIT09IDApID8gZXhwb3J0cy5DT01QTEVYKHgsIC15LCB1bml0KSA6IGludW1iZXI7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNPUyA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBjb3NpbmUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGguY29zKHgpICogKE1hdGguZXhwKHkpICsgTWF0aC5leHAoLXkpKSAvIDIsIC1NYXRoLnNpbih4KSAqIChNYXRoLmV4cCh5KSAtIE1hdGguZXhwKC15KSkgLyAyLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNQ09TSCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBleHBvcnRzLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBoeXBlcmJvbGljIGNvc2luZSBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5jb3MoeSkgKiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMiwgTWF0aC5zaW4oeSkgKiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMiwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUNPVCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBjb3RhbmdlbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVihleHBvcnRzLklNQ09TKGludW1iZXIpLCBleHBvcnRzLklNU0lOKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNRElWID0gZnVuY3Rpb24oaW51bWJlcjEsIGludW1iZXIyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIGEgPSBleHBvcnRzLklNUkVBTChpbnVtYmVyMSk7XG5cdCAgdmFyIGIgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyMSk7XG5cdCAgdmFyIGMgPSBleHBvcnRzLklNUkVBTChpbnVtYmVyMik7XG5cdCAgdmFyIGQgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyMik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhLCBiLCBjLCBkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0MSA9IGludW1iZXIxLnN1YnN0cmluZyhpbnVtYmVyMS5sZW5ndGggLSAxKTtcblx0ICB2YXIgdW5pdDIgPSBpbnVtYmVyMi5zdWJzdHJpbmcoaW51bWJlcjIubGVuZ3RoIC0gMSk7XG5cdCAgdmFyIHVuaXQgPSAnaSc7XG5cdCAgaWYgKHVuaXQxID09PSAnaicpIHtcblx0ICAgIHVuaXQgPSAnaic7XG5cdCAgfSBlbHNlIGlmICh1bml0MiA9PT0gJ2onKSB7XG5cdCAgICB1bml0ID0gJ2onO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyMiBpcyBudWxsXG5cdCAgaWYgKGMgPT09IDAgJiYgZCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICB2YXIgZGVuID0gYyAqIGMgKyBkICogZDtcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKChhICogYyArIGIgKiBkKSAvIGRlbiwgKGIgKiBjIC0gYSAqIGQpIC8gZGVuLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNRVhQID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGV4cG9uZW50aWFsIG9mIGNvbXBsZXggbnVtYmVyXG5cdCAgdmFyIGUgPSBNYXRoLmV4cCh4KTtcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKGUgKiBNYXRoLmNvcyh5KSwgZSAqIE1hdGguc2luKHkpLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNTE4gPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGgubG9nKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSksIE1hdGguYXRhbih5IC8geCksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1MT0cxMCA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBMb29rdXAgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvZWZmaWNpZW50cyB1c2luZyBGb3JtdWxhLmpzIFtodHRwOi8vZm9ybXVsYWpzLm9yZ11cblx0ICB2YXIgeCA9IGV4cG9ydHMuSU1SRUFMKGludW1iZXIpO1xuXHQgIHZhciB5ID0gZXhwb3J0cy5JTUFHSU5BUlkoaW51bWJlcik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxKTtcblx0ICB1bml0ID0gKHVuaXQgPT09ICdpJyB8fCB1bml0ID09PSAnaicpID8gdW5pdCA6ICdpJztcblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5sb2coTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKSAvIE1hdGgubG9nKDEwKSwgTWF0aC5hdGFuKHkgLyB4KSAvIE1hdGgubG9nKDEwKSwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTUxPRzIgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGgubG9nKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSkgLyBNYXRoLmxvZygyKSwgTWF0aC5hdGFuKHkgLyB4KSAvIE1hdGgubG9nKDIpLCB1bml0KTtcblx0fTtcblxuXHRleHBvcnRzLklNUE9XRVIgPSBmdW5jdGlvbihpbnVtYmVyLCBudW1iZXIpIHtcblx0ICBudW1iZXIgPSB1dGlscy5wYXJzZU51bWJlcihudW1iZXIpO1xuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihudW1iZXIsIHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIHBvd2VyIG9mIG1vZHVsdXNcblx0ICB2YXIgcCA9IE1hdGgucG93KGV4cG9ydHMuSU1BQlMoaW51bWJlciksIG51bWJlcik7XG5cblx0ICAvLyBDYWxjdWxhdGUgYXJndW1lbnRcblx0ICB2YXIgdCA9IGV4cG9ydHMuSU1BUkdVTUVOVChpbnVtYmVyKTtcblxuXHQgIC8vIFJldHVybiBleHBvbmVudGlhbCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgocCAqIE1hdGguY29zKG51bWJlciAqIHQpLCBwICogTWF0aC5zaW4obnVtYmVyICogdCksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1QUk9EVUNUID0gZnVuY3Rpb24oKSB7XG5cdCAgLy8gSW5pdGlhbGl6ZSByZXN1bHRcblx0ICB2YXIgcmVzdWx0ID0gYXJndW1lbnRzWzBdO1xuXG5cdCAgLy8gTG9vcCBvbiBhbGwgbnVtYmVyc1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAvLyBMb29rdXAgY29lZmZpY2llbnRzIG9mIHR3byBjb21wbGV4IG51bWJlcnNcblx0ICAgIHZhciBhID0gZXhwb3J0cy5JTVJFQUwocmVzdWx0KTtcblx0ICAgIHZhciBiID0gZXhwb3J0cy5JTUFHSU5BUlkocmVzdWx0KTtcblx0ICAgIHZhciBjID0gZXhwb3J0cy5JTVJFQUwoYXJndW1lbnRzW2ldKTtcblx0ICAgIHZhciBkID0gZXhwb3J0cy5JTUFHSU5BUlkoYXJndW1lbnRzW2ldKTtcblxuXHQgICAgaWYgKHV0aWxzLmFueUlzRXJyb3IoYSwgYiwgYywgZCkpIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb21wbHV0ZSBwcm9kdWN0IG9mIHR3byBjb21wbGV4IG51bWJlcnNcblx0ICAgIHJlc3VsdCA9IGV4cG9ydHMuQ09NUExFWChhICogYyAtIGIgKiBkLCBhICogZCArIGIgKiBjKTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gcHJvZHVjdCBvZiBjb21wbGV4IG51bWJlcnNcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1SRUFMID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIGlmIChpbnVtYmVyID09PSB1bmRlZmluZWQgfHwgaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiAwIGlmIGludW1iZXIgaXMgZXF1YWwgdG8gMFxuXHQgIGlmIChpbnVtYmVyID09PSAwIHx8IGludW1iZXIgPT09ICcwJykge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcblx0ICBpZiAoWydpJywgJytpJywgJzFpJywgJysxaScsICctaScsICctMWknLCAnaicsICcraicsICcxaicsICcrMWonLCAnLWonLCAnLTFqJ10uaW5kZXhPZihpbnVtYmVyKSA+PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgc2lnblxuXHQgIHZhciBwbHVzID0gaW51bWJlci5pbmRleE9mKCcrJyk7XG5cdCAgdmFyIG1pbnVzID0gaW51bWJlci5pbmRleE9mKCctJyk7XG5cdCAgaWYgKHBsdXMgPT09IDApIHtcblx0ICAgIHBsdXMgPSBpbnVtYmVyLmluZGV4T2YoJysnLCAxKTtcblx0ICB9XG5cdCAgaWYgKG1pbnVzID09PSAwKSB7XG5cdCAgICBtaW51cyA9IGludW1iZXIuaW5kZXhPZignLScsIDEpO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciBsYXN0ID0gaW51bWJlci5zdWJzdHJpbmcoaW51bWJlci5sZW5ndGggLSAxLCBpbnVtYmVyLmxlbmd0aCk7XG5cdCAgdmFyIHVuaXQgPSAobGFzdCA9PT0gJ2knIHx8IGxhc3QgPT09ICdqJyk7XG5cblx0ICBpZiAocGx1cyA+PSAwIHx8IG1pbnVzID49IDApIHtcblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBpbWFnaW5hcnkgdW5pdCBpcyBuZWl0aGVyIGkgbm9yIGpcblx0ICAgIGlmICghdW5pdCkge1xuXHQgICAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZXR1cm4gcmVhbCBjb2VmZmljaWVudCBvZiBjb21wbGV4IG51bWJlclxuXHQgICAgaWYgKHBsdXMgPj0gMCkge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKDAsIHBsdXMpKSB8fCBpc05hTihpbnVtYmVyLnN1YnN0cmluZyhwbHVzICsgMSwgaW51bWJlci5sZW5ndGggLSAxKSkpID9cblx0ICAgICAgICBlcnJvci5udW0gOlxuXHQgICAgICAgIE51bWJlcihpbnVtYmVyLnN1YnN0cmluZygwLCBwbHVzKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gKGlzTmFOKGludW1iZXIuc3Vic3RyaW5nKDAsIG1pbnVzKSkgfHwgaXNOYU4oaW51bWJlci5zdWJzdHJpbmcobWludXMgKyAxLCBpbnVtYmVyLmxlbmd0aCAtIDEpKSkgP1xuXHQgICAgICAgIGVycm9yLm51bSA6XG5cdCAgICAgICAgTnVtYmVyKGludW1iZXIuc3Vic3RyaW5nKDAsIG1pbnVzKSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICh1bml0KSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlci5zdWJzdHJpbmcoMCwgaW51bWJlci5sZW5ndGggLSAxKSkpID8gZXJyb3IubnVtIDogMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiAoaXNOYU4oaW51bWJlcikpID8gZXJyb3IubnVtIDogaW51bWJlcjtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNFQyA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlciBpcyBhIGxvZ2ljYWwgdmFsdWVcblx0ICBpZiAoaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHNlY2FudCBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLklNRElWKCcxJywgZXhwb3J0cy5JTUNPUyhpbnVtYmVyKSk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNFQ0ggPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gaHlwZXJib2xpYyBzZWNhbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVignMScsIGV4cG9ydHMuSU1DT1NIKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNU0lOID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIHNpbmUgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKE1hdGguc2luKHgpICogKE1hdGguZXhwKHkpICsgTWF0aC5leHAoLXkpKSAvIDIsIE1hdGguY29zKHgpICogKE1hdGguZXhwKHkpIC0gTWF0aC5leHAoLXkpKSAvIDIsIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1TSU5IID0gZnVuY3Rpb24oaW51bWJlcikge1xuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIGltYWdpbmFyeSB1bml0XG5cdCAgdmFyIHVuaXQgPSBpbnVtYmVyLnN1YnN0cmluZyhpbnVtYmVyLmxlbmd0aCAtIDEpO1xuXHQgIHVuaXQgPSAodW5pdCA9PT0gJ2knIHx8IHVuaXQgPT09ICdqJykgPyB1bml0IDogJ2knO1xuXG5cdCAgLy8gUmV0dXJuIGh5cGVyYm9saWMgc2luZSBvZiBjb21wbGV4IG51bWJlclxuXHQgIHJldHVybiBleHBvcnRzLkNPTVBMRVgoTWF0aC5jb3MoeSkgKiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMiwgTWF0aC5zaW4oeSkgKiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMiwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNRUlQgPSBmdW5jdGlvbihpbnVtYmVyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBMb29rdXAgaW1hZ2luYXJ5IHVuaXRcblx0ICB2YXIgdW5pdCA9IGludW1iZXIuc3Vic3RyaW5nKGludW1iZXIubGVuZ3RoIC0gMSk7XG5cdCAgdW5pdCA9ICh1bml0ID09PSAnaScgfHwgdW5pdCA9PT0gJ2onKSA/IHVuaXQgOiAnaSc7XG5cblx0ICAvLyBDYWxjdWxhdGUgcG93ZXIgb2YgbW9kdWx1c1xuXHQgIHZhciBzID0gTWF0aC5zcXJ0KGV4cG9ydHMuSU1BQlMoaW51bWJlcikpO1xuXG5cdCAgLy8gQ2FsY3VsYXRlIGFyZ3VtZW50XG5cdCAgdmFyIHQgPSBleHBvcnRzLklNQVJHVU1FTlQoaW51bWJlcik7XG5cblx0ICAvLyBSZXR1cm4gZXhwb25lbnRpYWwgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5DT01QTEVYKHMgKiBNYXRoLmNvcyh0IC8gMiksIHMgKiBNYXRoLnNpbih0IC8gMiksIHVuaXQpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1DU0MgPSBmdW5jdGlvbiAoaW51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBpbnVtYmVyIGlzIGEgbG9naWNhbCB2YWx1ZVxuXHQgIGlmIChpbnVtYmVyID09PSB0cnVlIHx8IGludW1iZXIgPT09IGZhbHNlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIHggPSBleHBvcnRzLklNUkVBTChpbnVtYmVyKTtcblx0ICB2YXIgeSA9IGV4cG9ydHMuSU1BR0lOQVJZKGludW1iZXIpO1xuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciBjb2VmZmljaWVudCBpcyBub3QgYSBudW1iZXJcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih4LCB5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gY29zZWNhbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVignMScsIGV4cG9ydHMuSU1TSU4oaW51bWJlcikpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU1DU0NIID0gZnVuY3Rpb24gKGludW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlciBpcyBhIGxvZ2ljYWwgdmFsdWVcblx0ICBpZiAoaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgY29lZmZpY2llbnQgaXMgbm90IGEgbnVtYmVyXG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeCwgeSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGh5cGVyYm9saWMgY29zZWNhbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gZXhwb3J0cy5JTURJVignMScsIGV4cG9ydHMuSU1TSU5IKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLklNU1VCID0gZnVuY3Rpb24oaW51bWJlcjEsIGludW1iZXIyKSB7XG5cdCAgLy8gTG9va3VwIHJlYWwgYW5kIGltYWdpbmFyeSBjb2VmZmljaWVudHMgdXNpbmcgRm9ybXVsYS5qcyBbaHR0cDovL2Zvcm11bGFqcy5vcmddXG5cdCAgdmFyIGEgPSB0aGlzLklNUkVBTChpbnVtYmVyMSk7XG5cdCAgdmFyIGIgPSB0aGlzLklNQUdJTkFSWShpbnVtYmVyMSk7XG5cdCAgdmFyIGMgPSB0aGlzLklNUkVBTChpbnVtYmVyMik7XG5cdCAgdmFyIGQgPSB0aGlzLklNQUdJTkFSWShpbnVtYmVyMik7XG5cblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihhLCBiLCBjLCBkKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCBpbWFnaW5hcnkgdW5pdFxuXHQgIHZhciB1bml0MSA9IGludW1iZXIxLnN1YnN0cmluZyhpbnVtYmVyMS5sZW5ndGggLSAxKTtcblx0ICB2YXIgdW5pdDIgPSBpbnVtYmVyMi5zdWJzdHJpbmcoaW51bWJlcjIubGVuZ3RoIC0gMSk7XG5cdCAgdmFyIHVuaXQgPSAnaSc7XG5cdCAgaWYgKHVuaXQxID09PSAnaicpIHtcblx0ICAgIHVuaXQgPSAnaic7XG5cdCAgfSBlbHNlIGlmICh1bml0MiA9PT0gJ2onKSB7XG5cdCAgICB1bml0ID0gJ2onO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBfIG9mIHR3byBjb21wbGV4IG51bWJlcnNcblx0ICByZXR1cm4gdGhpcy5DT01QTEVYKGEgLSBjLCBiIC0gZCwgdW5pdCk7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVNVTSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXG5cdCAgLy8gSW5pdGlhbGl6ZSByZXN1bHRcblx0ICB2YXIgcmVzdWx0ID0gYXJnc1swXTtcblxuXHQgIC8vIExvb3Agb24gYWxsIG51bWJlcnNcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgIC8vIExvb2t1cCBjb2VmZmljaWVudHMgb2YgdHdvIGNvbXBsZXggbnVtYmVyc1xuXHQgICAgdmFyIGEgPSB0aGlzLklNUkVBTChyZXN1bHQpO1xuXHQgICAgdmFyIGIgPSB0aGlzLklNQUdJTkFSWShyZXN1bHQpO1xuXHQgICAgdmFyIGMgPSB0aGlzLklNUkVBTChhcmdzW2ldKTtcblx0ICAgIHZhciBkID0gdGhpcy5JTUFHSU5BUlkoYXJnc1tpXSk7XG5cblx0ICAgIGlmICh1dGlscy5hbnlJc0Vycm9yKGEsIGIsIGMsIGQpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29tcGx1dGUgcHJvZHVjdCBvZiB0d28gY29tcGxleCBudW1iZXJzXG5cdCAgICByZXN1bHQgPSB0aGlzLkNPTVBMRVgoYSArIGMsIGIgKyBkKTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gc3VtIG9mIGNvbXBsZXggbnVtYmVyc1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5JTVRBTiA9IGZ1bmN0aW9uKGludW1iZXIpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgaW51bWJlciBpcyBhIGxvZ2ljYWwgdmFsdWVcblx0ICBpZiAoaW51bWJlciA9PT0gdHJ1ZSB8fCBpbnVtYmVyID09PSBmYWxzZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIExvb2t1cCByZWFsIGFuZCBpbWFnaW5hcnkgY29lZmZpY2llbnRzIHVzaW5nIEZvcm11bGEuanMgW2h0dHA6Ly9mb3JtdWxhanMub3JnXVxuXHQgIHZhciB4ID0gZXhwb3J0cy5JTVJFQUwoaW51bWJlcik7XG5cdCAgdmFyIHkgPSBleHBvcnRzLklNQUdJTkFSWShpbnVtYmVyKTtcblxuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHgsIHkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIHRhbmdlbnQgb2YgY29tcGxleCBudW1iZXJcblx0ICByZXR1cm4gdGhpcy5JTURJVih0aGlzLklNU0lOKGludW1iZXIpLCB0aGlzLklNQ09TKGludW1iZXIpKTtcblx0fTtcblxuXHRleHBvcnRzLk9DVDJCSU4gPSBmdW5jdGlvbihudW1iZXIsIHBsYWNlcykge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IGhleGFkZWNpbWFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC03XXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDaGVjayBpZiBudW1iZXIgaXMgbmVnYXRpdmVcblx0ICB2YXIgbmVnYXRpdmUgPSAobnVtYmVyLmxlbmd0aCA9PT0gMTAgJiYgbnVtYmVyLnN1YnN0cmluZygwLCAxKSA9PT0gJzcnKSA/IHRydWUgOiBmYWxzZTtcblxuXHQgIC8vIENvbnZlcnQgb2N0YWwgbnVtYmVyIHRvIGRlY2ltYWxcblx0ICB2YXIgZGVjaW1hbCA9IChuZWdhdGl2ZSkgPyBwYXJzZUludChudW1iZXIsIDgpIC0gMTA3Mzc0MTgyNCA6IHBhcnNlSW50KG51bWJlciwgOCk7XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIGxvd2VyIHRoYW4gLTUxMiBvciBncmVhdGVyIHRoYW4gNTExXG5cdCAgaWYgKGRlY2ltYWwgPCAtNTEyIHx8IGRlY2ltYWwgPiA1MTEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSWdub3JlIHBsYWNlcyBhbmQgcmV0dXJuIGEgMTAtY2hhcmFjdGVyIGJpbmFyeSBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICByZXR1cm4gJzEnICsgdGV4dC5SRVBUKCcwJywgOSAtICg1MTIgKyBkZWNpbWFsKS50b1N0cmluZygyKS5sZW5ndGgpICsgKDUxMiArIGRlY2ltYWwpLnRvU3RyaW5nKDIpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gYmluYXJ5XG5cdCAgdmFyIHJlc3VsdCA9IGRlY2ltYWwudG9TdHJpbmcoMik7XG5cblx0ICAvLyBSZXR1cm4gYmluYXJ5IG51bWJlciB1c2luZyB0aGUgbWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBuZWNlc3NhcnkgaWYgcGxhY2VzIGlzIHVuZGVmaW5lZFxuXHQgIGlmICh0eXBlb2YgcGxhY2VzID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBub25udW1lcmljXG5cdCAgICBpZiAoaXNOYU4ocGxhY2VzKSkge1xuXHQgICAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIFJldHVybiBlcnJvciBpZiBwbGFjZXMgaXMgbmVnYXRpdmVcblx0ICAgIGlmIChwbGFjZXMgPCAwKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgICB9XG5cblx0ICAgIC8vIFRydW5jYXRlIHBsYWNlcyBpbiBjYXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgICBwbGFjZXMgPSBNYXRoLmZsb29yKHBsYWNlcyk7XG5cblx0ICAgIC8vIFBhZCByZXR1cm4gdmFsdWUgd2l0aCBsZWFkaW5nIDBzICh6ZXJvcykgaWYgbmVjZXNzYXJ5ICh1c2luZyBVbmRlcnNjb3JlLnN0cmluZylcblx0ICAgIHJldHVybiAocGxhY2VzID49IHJlc3VsdC5sZW5ndGgpID8gdGV4dC5SRVBUKCcwJywgcGxhY2VzIC0gcmVzdWx0Lmxlbmd0aCkgKyByZXN1bHQgOiBlcnJvci5udW07XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuT0NUMkRFQyA9IGZ1bmN0aW9uKG51bWJlcikge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBudW1iZXIgaXMgbm90IG9jdGFsIG9yIGNvbnRhaW5zIG1vcmUgdGhhbiB0ZW4gY2hhcmFjdGVycyAoMTAgZGlnaXRzKVxuXHQgIGlmICghL15bMC03XXsxLDEwfSQvLnRlc3QobnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IG9jdGFsIG51bWJlciB0byBkZWNpbWFsXG5cdCAgdmFyIGRlY2ltYWwgPSBwYXJzZUludChudW1iZXIsIDgpO1xuXG5cdCAgLy8gUmV0dXJuIGRlY2ltYWwgbnVtYmVyXG5cdCAgcmV0dXJuIChkZWNpbWFsID49IDUzNjg3MDkxMikgPyBkZWNpbWFsIC0gMTA3Mzc0MTgyNCA6IGRlY2ltYWw7XG5cdH07XG5cblx0ZXhwb3J0cy5PQ1QySEVYID0gZnVuY3Rpb24obnVtYmVyLCBwbGFjZXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbnVtYmVyIGlzIG5vdCBvY3RhbCBvciBjb250YWlucyBtb3JlIHRoYW4gdGVuIGNoYXJhY3RlcnMgKDEwIGRpZ2l0cylcblx0ICBpZiAoIS9eWzAtN117MSwxMH0kLy50ZXN0KG51bWJlcikpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gQ29udmVydCBvY3RhbCBudW1iZXIgdG8gZGVjaW1hbFxuXHQgIHZhciBkZWNpbWFsID0gcGFyc2VJbnQobnVtYmVyLCA4KTtcblxuXHQgIC8vIElnbm9yZSBwbGFjZXMgYW5kIHJldHVybiBhIDEwLWNoYXJhY3RlciBvY3RhbCBudW1iZXIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlXG5cdCAgaWYgKGRlY2ltYWwgPj0gNTM2ODcwOTEyKSB7XG5cdCAgICByZXR1cm4gJ2ZmJyArIChkZWNpbWFsICsgMzIyMTIyNTQ3MikudG9TdHJpbmcoMTYpO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGVjaW1hbCBudW1iZXIgdG8gaGV4YWRlY2ltYWxcblx0ICB2YXIgcmVzdWx0ID0gZGVjaW1hbC50b1N0cmluZygxNik7XG5cblx0ICAvLyBSZXR1cm4gaGV4YWRlY2ltYWwgbnVtYmVyIHVzaW5nIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIG5lY2Vzc2FyeSBpZiBwbGFjZXMgaXMgdW5kZWZpbmVkXG5cdCAgaWYgKHBsYWNlcyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZXR1cm4gZXJyb3IgaWYgcGxhY2VzIGlzIG5vbm51bWVyaWNcblx0ICAgIGlmIChpc05hTihwbGFjZXMpKSB7XG5cdCAgICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gUmV0dXJuIGVycm9yIGlmIHBsYWNlcyBpcyBuZWdhdGl2ZVxuXHQgICAgaWYgKHBsYWNlcyA8IDApIHtcblx0ICAgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICAgIH1cblxuXHQgICAgLy8gVHJ1bmNhdGUgcGxhY2VzIGluIGNhc2UgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICAgIHBsYWNlcyA9IE1hdGguZmxvb3IocGxhY2VzKTtcblxuXHQgICAgLy8gUGFkIHJldHVybiB2YWx1ZSB3aXRoIGxlYWRpbmcgMHMgKHplcm9zKSBpZiBuZWNlc3NhcnkgKHVzaW5nIFVuZGVyc2NvcmUuc3RyaW5nKVxuXHQgICAgcmV0dXJuIChwbGFjZXMgPj0gcmVzdWx0Lmxlbmd0aCkgPyB0ZXh0LlJFUFQoJzAnLCBwbGFjZXMgLSByZXN1bHQubGVuZ3RoKSArIHJlc3VsdCA6IGVycm9yLm51bTtcblx0ICB9XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIE0gPSBNYXRoO1xuXHRmdW5jdGlvbiBfaG9ybmVyKGFyciwgdikgeyByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbih6LHcpe3JldHVybiB2ICogeiArIHc7fSwwKTsgfTtcblx0ZnVuY3Rpb24gX2Jlc3NlbF9pdGVyKHgsIG4sIGYwLCBmMSwgc2lnbikge1xuXHQgIGlmKCFzaWduKSBzaWduID0gLTE7XG5cdCAgdmFyIHRkeCA9IDIgLyB4LCBmMjtcblx0ICBpZihuID09PSAwKSByZXR1cm4gZjA7XG5cdCAgaWYobiA9PT0gMSkgcmV0dXJuIGYxO1xuXHQgIGZvcih2YXIgbyA9IDE7IG8gIT0gbjsgKytvKSB7XG5cdCAgICBmMiA9IGYxICogbyAqIHRkeCArIHNpZ24gKiBmMDtcblx0ICAgIGYwID0gZjE7IGYxID0gZjI7XG5cdCAgfVxuXHQgIHJldHVybiBmMTtcblx0fVxuXHRmdW5jdGlvbiBfYmVzc2VsX3dyYXAoYmVzc2VsMCwgYmVzc2VsMSwgbmFtZSwgbm9uemVybywgc2lnbikge1xuXHQgIHJldHVybiBmdW5jdGlvbiBiZXNzZWwoeCxuKSB7XG5cdCAgICBpZihuID09PSAwKSByZXR1cm4gYmVzc2VsMCh4KTtcblx0ICAgIGlmKG4gPT09IDEpIHJldHVybiBiZXNzZWwxKHgpO1xuXHQgICAgaWYobiA8IDApIHRocm93IG5hbWUgKyAnOiBPcmRlciAoJyArIG4gKyAnKSBtdXN0IGJlIG5vbm5lZ2F0aXZlJztcblx0ICAgIGlmKG5vbnplcm8gPT0gMSAmJiB4ID09PSAwKSB0aHJvdyBuYW1lICsgJzogVW5kZWZpbmVkIHdoZW4geCA9PSAwJztcblx0ICAgIGlmKG5vbnplcm8gPT0gMiAmJiB4IDw9IDApIHRocm93IG5hbWUgKyAnOiBVbmRlZmluZWQgd2hlbiB4IDw9IDAnO1xuXHQgICAgdmFyIGIwID0gYmVzc2VsMCh4KSwgYjEgPSBiZXNzZWwxKHgpO1xuXHQgICAgcmV0dXJuIF9iZXNzZWxfaXRlcih4LCBuLCBiMCwgYjEsIHNpZ24pO1xuXHQgIH07XG5cdH1cblx0dmFyIGJlc3NlbGogPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGIwX2ExYSA9IFs1NzU2ODQ5MDU3NC4wLC0xMzM2MjU5MDM1NC4wLDY1MTYxOTY0MC43LC0xMTIxNDQyNC4xOCw3NzM5Mi4zMzAxNywtMTg0LjkwNTI0NTZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYTJhID0gWzU3NTY4NDkwNDExLjAsMTAyOTUzMjk4NS4wLDk0OTQ2ODAuNzE4LDU5MjcyLjY0ODUzLDI2Ny44NTMyNzEyLDEuMF0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMWIgPSBbMS4wLCAtMC4xMDk4NjI4NjI3ZS0yLCAwLjI3MzQ1MTA0MDdlLTQsIC0wLjIwNzMzNzA2MzllLTUsIDAuMjA5Mzg4NzIxMWUtNl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMmIgPSBbLTAuMTU2MjQ5OTk5NWUtMSwgMC4xNDMwNDg4NzY1ZS0zLCAtMC42OTExMTQ3NjUxZS01LCAwLjc2MjEwOTUxNjFlLTYsIC0wLjkzNDkzNTE1MmUtN10ucmV2ZXJzZSgpO1xuXHQgIHZhciBXID0gMC42MzY2MTk3NzI7IC8vIDIgLyBNYXRoLlBJXG5cblx0ICBmdW5jdGlvbiBiZXNzZWwwKHgpIHtcblx0ICAgIHZhciBhLCBhMSwgYTIsIHkgPSB4ICogeCwgeHggPSBNLmFicyh4KSAtIDAuNzg1Mzk4MTY0O1xuXHQgICAgaWYoTS5hYnMoeCkgPCA4KSB7XG5cdCAgICAgIGExID0gX2hvcm5lcihiMF9hMWEsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjBfYTJhLCB5KTtcblx0ICAgICAgYSA9IGExL2EyO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHkgPSA2NCAvIHk7XG5cdCAgICAgIGExID0gX2hvcm5lcihiMF9hMWIsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjBfYTJiLCB5KTtcblx0ICAgICAgYSA9IE0uc3FydChXL00uYWJzKHgpKSooTS5jb3MoeHgpKmExLU0uc2luKHh4KSphMio4L00uYWJzKHgpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhO1xuXHQgIH1cblx0ICB2YXIgYjFfYTFhID0gWzcyMzYyNjE0MjMyLjAsLTc4OTUwNTkyMzUuMCwyNDIzOTY4NTMuMSwtMjk3MjYxMS40MzksIDE1NzA0LjQ4MjYwLCAtMzAuMTYwMzY2MDZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTJhID0gWzE0NDcyNTIyODQ0Mi4wLCAyMzAwNTM1MTc4LjAsIDE4NTgzMzA0Ljc0LCA5OTQ0Ny40MzM5NCwgMzc2Ljk5OTEzOTcsIDEuMF0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMV9hMWIgPSBbMS4wLCAwLjE4MzEwNWUtMiwgLTAuMzUxNjM5NjQ5NmUtNCwgMC4yNDU3NTIwMTc0ZS01LCAtMC4yNDAzMzcwMTllLTZdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTJiID0gWzAuMDQ2ODc0OTk5OTUsIC0wLjIwMDI2OTA4NzNlLTMsIDAuODQ0OTE5OTA5NmUtNSwgLTAuODgyMjg5ODdlLTYsIDAuMTA1Nzg3NDEyZS02XS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG5cdCAgICB2YXIgYSwgYTEsIGEyLCB5ID0geCp4LCB4eCA9IE0uYWJzKHgpIC0gMi4zNTYxOTQ0OTE7XG5cdCAgICBpZihNYXRoLmFicyh4KTwgOCkge1xuXHQgICAgICBhMSA9IHgqX2hvcm5lcihiMV9hMWEsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjFfYTJhLCB5KTtcblx0ICAgICAgYSA9IGExIC8gYTI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB5ID0gNjQgLyB5O1xuXHQgICAgICBhMT1faG9ybmVyKGIxX2ExYiwgeSk7XG5cdCAgICAgIGEyPV9ob3JuZXIoYjFfYTJiLCB5KTtcblx0ICAgICAgYT1NLnNxcnQoVy9NLmFicyh4KSkqKE0uY29zKHh4KSphMS1NLnNpbih4eCkqYTIqOC9NLmFicyh4KSk7XG5cdCAgICAgIGlmKHggPCAwKSBhID0gLWE7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYTtcblx0ICB9XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIGJlc3NlbGooeCwgbikge1xuXHQgICAgbiA9IE1hdGgucm91bmQobik7XG5cdCAgICBpZihuID09PSAwKSByZXR1cm4gYmVzc2VsMChNLmFicyh4KSk7XG5cdCAgICBpZihuID09PSAxKSByZXR1cm4gYmVzc2VsMShNLmFicyh4KSk7XG5cdCAgICBpZihuIDwgMCkgdGhyb3cgJ0JFU1NFTEo6IE9yZGVyICgnICsgbiArICcpIG11c3QgYmUgbm9ubmVnYXRpdmUnO1xuXHQgICAgaWYoTS5hYnMoeCkgPT09IDApIHJldHVybiAwO1xuXG5cdCAgICB2YXIgcmV0LCBqLCB0b3ggPSAyIC8gTS5hYnMoeCksIG0sIGpzdW0sIHN1bSwgYmpwLCBiaiwgYmptO1xuXHQgICAgaWYoTS5hYnMoeCkgPiBuKSB7XG5cdCAgICAgIHJldCA9IF9iZXNzZWxfaXRlcih4LCBuLCBiZXNzZWwwKE0uYWJzKHgpKSwgYmVzc2VsMShNLmFicyh4KSksLTEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbT0yKk0uZmxvb3IoKG4rTS5mbG9vcihNLnNxcnQoNDAqbikpKS8yKTtcblx0ICAgICAganN1bT0wO1xuXHQgICAgICBianA9cmV0PXN1bT0wLjA7XG5cdCAgICAgIGJqPTEuMDtcblx0ICAgICAgZm9yIChqPW07aj4wO2otLSkge1xuXHQgICAgICAgIGJqbT1qKnRveCpiai1ianA7XG5cdCAgICAgICAgYmpwPWJqO1xuXHQgICAgICAgIGJqPWJqbTtcblx0ICAgICAgICBpZiAoTS5hYnMoYmopID4gMUUxMCkge1xuXHQgICAgICAgICAgYmogKj0gMUUtMTA7XG5cdCAgICAgICAgICBianAgKj0gMUUtMTA7XG5cdCAgICAgICAgICByZXQgKj0gMUUtMTA7XG5cdCAgICAgICAgICBzdW0gKj0gMUUtMTA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChqc3VtKSBzdW0gKz0gYmo7XG5cdCAgICAgICAganN1bT0hanN1bTtcblx0ICAgICAgICBpZiAoaiA9PSBuKSByZXQ9YmpwO1xuXHQgICAgICB9XG5cdCAgICAgIHN1bT0yLjAqc3VtLWJqO1xuXHQgICAgICByZXQgLz0gc3VtO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHggPCAwICYmIChuJTIpID8gLXJldCA6IHJldDtcblx0ICB9O1xuXHR9KSgpO1xuXHR2YXIgYmVzc2VseSA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgYjBfYTFhID0gWy0yOTU3ODIxMzg5LjAsIDcwNjI4MzQwNjUuMCwgLTUxMjM1OTgwMy42LCAxMDg3OTg4MS4yOSwgLTg2MzI3LjkyNzU3LCAyMjguNDYyMjczM10ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMmEgPSBbNDAwNzY1NDQyNjkuMCwgNzQ1MjQ5OTY0LjgsIDcxODk0NjYuNDM4LCA0NzQ0Ny4yNjQ3MCwgMjI2LjEwMzAyNDQsIDEuMF0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMWIgPSBbMS4wLCAtMC4xMDk4NjI4NjI3ZS0yLCAwLjI3MzQ1MTA0MDdlLTQsIC0wLjIwNzMzNzA2MzllLTUsIDAuMjA5Mzg4NzIxMWUtNl0ucmV2ZXJzZSgpO1xuXHQgIHZhciBiMF9hMmIgPSBbLTAuMTU2MjQ5OTk5NWUtMSwgMC4xNDMwNDg4NzY1ZS0zLCAtMC42OTExMTQ3NjUxZS01LCAwLjc2MjEwOTUxNjFlLTYsIC0wLjkzNDk0NTE1MmUtN10ucmV2ZXJzZSgpO1xuXG5cdCAgdmFyIFcgPSAwLjYzNjYxOTc3Mjtcblx0ICBmdW5jdGlvbiBiZXNzZWwwKHgpIHtcblx0ICAgIHZhciBhLCBhMSwgYTIsIHkgPSB4ICogeCwgeHggPSB4IC0gMC43ODUzOTgxNjQ7XG5cdCAgICBpZih4IDwgOCkge1xuXHQgICAgICBhMSA9IF9ob3JuZXIoYjBfYTFhLCB5KTtcblx0ICAgICAgYTIgPSBfaG9ybmVyKGIwX2EyYSwgeSk7XG5cdCAgICAgIGEgPSBhMS9hMiArIFcgKiBiZXNzZWxqKHgsMCkgKiBNLmxvZyh4KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHkgPSA2NCAvIHk7XG5cdCAgICAgIGExID0gX2hvcm5lcihiMF9hMWIsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjBfYTJiLCB5KTtcblx0ICAgICAgYSA9IE0uc3FydChXL3gpKihNLnNpbih4eCkqYTErTS5jb3MoeHgpKmEyKjgveCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYTtcblx0ICB9XG5cblx0ICB2YXIgYjFfYTFhID0gWy0wLjQ5MDA2MDQ5NDNlMTMsIDAuMTI3NTI3NDM5MGUxMywgLTAuNTE1MzQzODEzOWUxMSwgMC43MzQ5MjY0NTUxZTksIC0wLjQyMzc5MjI3MjZlNywgMC44NTExOTM3OTM1ZTRdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTJhID0gWzAuMjQ5OTU4MDU3MGUxNCwgMC40MjQ0NDE5NjY0ZTEyLCAwLjM3MzM2NTAzNjdlMTAsIDAuMjI0NTkwNDAwMmU4LCAwLjEwMjA0MjYwNTBlNiwgMC4zNTQ5NjMyODg1ZTMsIDFdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYTFiID0gWzEuMCwgMC4xODMxMDVlLTIsIC0wLjM1MTYzOTY0OTZlLTQsIDAuMjQ1NzUyMDE3NGUtNSwgLTAuMjQwMzM3MDE5ZS02XS5yZXZlcnNlKCk7XG5cdCAgdmFyIGIxX2EyYiA9IFswLjA0Njg3NDk5OTk1LCAtMC4yMDAyNjkwODczZS0zLCAwLjg0NDkxOTkwOTZlLTUsIC0wLjg4MjI4OTg3ZS02LCAwLjEwNTc4NzQxMmUtNl0ucmV2ZXJzZSgpO1xuXHQgIGZ1bmN0aW9uIGJlc3NlbDEoeCkge1xuXHQgICAgdmFyIGEsIGExLCBhMiwgeSA9IHgqeCwgeHggPSB4IC0gMi4zNTYxOTQ0OTE7XG5cdCAgICBpZih4IDwgOCkge1xuXHQgICAgICBhMSA9IHgqX2hvcm5lcihiMV9hMWEsIHkpO1xuXHQgICAgICBhMiA9IF9ob3JuZXIoYjFfYTJhLCB5KTtcblx0ICAgICAgYSA9IGExL2EyICsgVyAqIChiZXNzZWxqKHgsMSkgKiBNLmxvZyh4KSAtIDEgLyB4KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHkgPSA2NCAvIHk7XG5cdCAgICAgIGExPV9ob3JuZXIoYjFfYTFiLCB5KTtcblx0ICAgICAgYTI9X2hvcm5lcihiMV9hMmIsIHkpO1xuXHQgICAgICBhPU0uc3FydChXL3gpKihNLnNpbih4eCkqYTErTS5jb3MoeHgpKmEyKjgveCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYTtcblx0ICB9XG5cblx0ICByZXR1cm4gX2Jlc3NlbF93cmFwKGJlc3NlbDAsIGJlc3NlbDEsICdCRVNTRUxZJywgMSwgLTEpO1xuXHR9KSgpO1xuXHR2YXIgYmVzc2VsaSA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgYjBfYSA9IFsxLjAsIDMuNTE1NjIyOSwgMy4wODk5NDI0LCAxLjIwNjc0OTIsIDAuMjY1OTczMiwgMC4zNjA3NjhlLTEsIDAuNDU4MTNlLTJdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYiA9IFswLjM5ODk0MjI4LCAwLjEzMjg1OTJlLTEsIDAuMjI1MzE5ZS0yLCAtMC4xNTc1NjVlLTIsIDAuOTE2MjgxZS0yLCAtMC4yMDU3NzA2ZS0xLCAwLjI2MzU1MzdlLTEsIC0wLjE2NDc2MzNlLTEsIDAuMzkyMzc3ZS0yXS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMCh4KSB7XG5cdCAgICBpZih4IDw9IDMuNzUpIHJldHVybiBfaG9ybmVyKGIwX2EsIHgqeC8oMy43NSozLjc1KSk7XG5cdCAgICByZXR1cm4gTS5leHAoTS5hYnMoeCkpL00uc3FydChNLmFicyh4KSkqX2hvcm5lcihiMF9iLCAzLjc1L00uYWJzKHgpKTtcblx0ICB9XG5cblx0ICB2YXIgYjFfYSA9IFswLjUsIDAuODc4OTA1OTQsIDAuNTE0OTg4NjksIDAuMTUwODQ5MzQsIDAuMjY1ODczM2UtMSwgMC4zMDE1MzJlLTIsIDAuMzI0MTFlLTNdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYiA9IFswLjM5ODk0MjI4LCAtMC4zOTg4MDI0ZS0xLCAtMC4zNjIwMThlLTIsIDAuMTYzODAxZS0yLCAtMC4xMDMxNTU1ZS0xLCAwLjIyODI5NjdlLTEsIC0wLjI4OTUzMTJlLTEsIDAuMTc4NzY1NGUtMSwgLTAuNDIwMDU5ZS0yXS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG5cdCAgICBpZih4IDwgMy43NSkgcmV0dXJuIHggKiBfaG9ybmVyKGIxX2EsIHgqeC8oMy43NSozLjc1KSk7XG5cdCAgICByZXR1cm4gKHggPCAwID8gLTEgOiAxKSAqIE0uZXhwKE0uYWJzKHgpKS9NLnNxcnQoTS5hYnMoeCkpKl9ob3JuZXIoYjFfYiwgMy43NS9NLmFicyh4KSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIGJlc3NlbGkoeCwgbikge1xuXHQgICAgbiA9IE1hdGgucm91bmQobik7XG5cdCAgICBpZihuID09PSAwKSByZXR1cm4gYmVzc2VsMCh4KTtcblx0ICAgIGlmKG4gPT0gMSkgcmV0dXJuIGJlc3NlbDEoeCk7XG5cdCAgICBpZihuIDwgMCkgdGhyb3cgJ0JFU1NFTEkgT3JkZXIgKCcgKyBuICsgJykgbXVzdCBiZSBub25uZWdhdGl2ZSc7XG5cdCAgICBpZihNLmFicyh4KSA9PT0gMCkgcmV0dXJuIDA7XG5cblx0ICAgIHZhciByZXQsIGosIHRveCA9IDIgLyBNLmFicyh4KSwgbSwgYmlwLCBiaSwgYmltO1xuXHQgICAgbT0yKk0ucm91bmQoKG4rTS5yb3VuZChNLnNxcnQoNDAqbikpKS8yKTtcblx0ICAgIGJpcD1yZXQ9MC4wO1xuXHQgICAgYmk9MS4wO1xuXHQgICAgZm9yIChqPW07aj4wO2otLSkge1xuXHQgICAgICBiaW09aip0b3gqYmkgKyBiaXA7XG5cdCAgICAgIGJpcD1iaTsgYmk9YmltO1xuXHQgICAgICBpZiAoTS5hYnMoYmkpID4gMUUxMCkge1xuXHQgICAgICAgIGJpICo9IDFFLTEwO1xuXHQgICAgICAgIGJpcCAqPSAxRS0xMDtcblx0ICAgICAgICByZXQgKj0gMUUtMTA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYoaiA9PSBuKSByZXQgPSBiaXA7XG5cdCAgICB9XG5cdCAgICByZXQgKj0gYmVzc2VsaSh4LCAwKSAvIGJpO1xuXHQgICAgcmV0dXJuIHggPCAwICYmIChuJTIpID8gLXJldCA6IHJldDtcblx0ICB9O1xuXG5cdH0pKCk7XG5cblx0dmFyIGJlc3NlbGsgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGIwX2EgPSBbLTAuNTc3MjE1NjYsIDAuNDIyNzg0MjAsIDAuMjMwNjk3NTYsIDAuMzQ4ODU5MGUtMSwgMC4yNjI2OThlLTIsIDAuMTA3NTBlLTMsIDAuNzRlLTVdLnJldmVyc2UoKTtcblx0ICB2YXIgYjBfYiA9IFsxLjI1MzMxNDE0LCAtMC43ODMyMzU4ZS0xLCAwLjIxODk1NjhlLTEsIC0wLjEwNjI0NDZlLTEsIDAuNTg3ODcyZS0yLCAtMC4yNTE1NDBlLTIsIDAuNTMyMDhlLTNdLnJldmVyc2UoKTtcblx0ICBmdW5jdGlvbiBiZXNzZWwwKHgpIHtcblx0ICAgIGlmKHggPD0gMikgcmV0dXJuIC1NLmxvZyh4LzIpKmJlc3NlbGkoeCwwKSArIF9ob3JuZXIoYjBfYSwgeCp4LzQpO1xuXHQgICAgcmV0dXJuIE0uZXhwKC14KS9NLnNxcnQoeCkqX2hvcm5lcihiMF9iLCAyL3gpO1xuXHQgIH1cblxuXHQgIHZhciBiMV9hID0gWzEuMCwgMC4xNTQ0MzE0NCwgLTAuNjcyNzg1NzksIC0wLjE4MTU2ODk3LCAtMC4xOTE5NDAyZS0xLCAtMC4xMTA0MDRlLTIsIC0wLjQ2ODZlLTRdLnJldmVyc2UoKTtcblx0ICB2YXIgYjFfYiA9IFsxLjI1MzMxNDE0LCAwLjIzNDk4NjE5LCAtMC4zNjU1NjIwZS0xLCAwLjE1MDQyNjhlLTEsIC0wLjc4MDM1M2UtMiwgMC4zMjU2MTRlLTIsIC0wLjY4MjQ1ZS0zXS5yZXZlcnNlKCk7XG5cdCAgZnVuY3Rpb24gYmVzc2VsMSh4KSB7XG5cdCAgICBpZih4IDw9IDIpIHJldHVybiBNLmxvZyh4LzIpKmJlc3NlbGkoeCwxKSArICgxL3gpKl9ob3JuZXIoYjFfYSwgeCp4LzQpO1xuXHQgICAgcmV0dXJuIE0uZXhwKC14KS9NLnNxcnQoeCkqX2hvcm5lcihiMV9iLCAyL3gpO1xuXHQgIH1cblxuXHQgIHJldHVybiBfYmVzc2VsX3dyYXAoYmVzc2VsMCwgYmVzc2VsMSwgJ0JFU1NFTEsnLCAyLCAxKTtcblx0fSkoKTtcblx0aWYodHJ1ZSkge1xuXHQgIGV4cG9ydHMuYmVzc2VsaiA9IGJlc3NlbGo7XG5cdCAgZXhwb3J0cy5iZXNzZWx5ID0gYmVzc2VseTtcblx0ICBleHBvcnRzLmJlc3NlbGkgPSBiZXNzZWxpO1xuXHQgIGV4cG9ydHMuYmVzc2VsayA9IGJlc3NlbGs7XG5cdH1cblxuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXHR2YXIgZDE5MDAgPSBuZXcgRGF0ZSgxOTAwLCAwLCAxKTtcblx0dmFyIFdFRUtfU1RBUlRTID0gW1xuXHQgIHVuZGVmaW5lZCxcblx0ICAwLFxuXHQgIDEsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgMSxcblx0ICAyLFxuXHQgIDMsXG5cdCAgNCxcblx0ICA1LFxuXHQgIDYsXG5cdCAgMFxuXHRdO1xuXHR2YXIgV0VFS19UWVBFUyA9IFtcblx0ICBbXSxcblx0ICBbMSwgMiwgMywgNCwgNSwgNiwgN10sXG5cdCAgWzcsIDEsIDIsIDMsIDQsIDUsIDZdLFxuXHQgIFs2LCAwLCAxLCAyLCAzLCA0LCA1XSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbXSxcblx0ICBbNywgMSwgMiwgMywgNCwgNSwgNl0sXG5cdCAgWzYsIDcsIDEsIDIsIDMsIDQsIDVdLFxuXHQgIFs1LCA2LCA3LCAxLCAyLCAzLCA0XSxcblx0ICBbNCwgNSwgNiwgNywgMSwgMiwgM10sXG5cdCAgWzMsIDQsIDUsIDYsIDcsIDEsIDJdLFxuXHQgIFsyLCAzLCA0LCA1LCA2LCA3LCAxXSxcblx0ICBbMSwgMiwgMywgNCwgNSwgNiwgN11cblx0XTtcblx0dmFyIFdFRUtFTkRfVFlQRVMgPSBbXG5cdCAgW10sXG5cdCAgWzYsIDBdLFxuXHQgIFswLCAxXSxcblx0ICBbMSwgMl0sXG5cdCAgWzIsIDNdLFxuXHQgIFszLCA0XSxcblx0ICBbNCwgNV0sXG5cdCAgWzUsIDZdLFxuXHQgIHVuZGVmaW5lZCxcblx0ICB1bmRlZmluZWQsXG5cdCAgdW5kZWZpbmVkLCBbMCwgMF0sXG5cdCAgWzEsIDFdLFxuXHQgIFsyLCAyXSxcblx0ICBbMywgM10sXG5cdCAgWzQsIDRdLFxuXHQgIFs1LCA1XSxcblx0ICBbNiwgNl1cblx0XTtcblxuXHRleHBvcnRzLkRBVEUgPSBmdW5jdGlvbih5ZWFyLCBtb250aCwgZGF5KSB7XG5cdCAgeWVhciA9IHV0aWxzLnBhcnNlTnVtYmVyKHllYXIpO1xuXHQgIG1vbnRoID0gdXRpbHMucGFyc2VOdW1iZXIobW9udGgpO1xuXHQgIGRheSA9IHV0aWxzLnBhcnNlTnVtYmVyKGRheSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoeWVhciwgbW9udGgsIGRheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKHllYXIgPCAwIHx8IG1vbnRoIDwgMCB8fCBkYXkgPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblx0ICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcblx0ICByZXR1cm4gZGF0ZTtcblx0fTtcblxuXHRleHBvcnRzLkRBVEVWQUxVRSA9IGZ1bmN0aW9uKGRhdGVfdGV4dCkge1xuXHQgIGlmICh0eXBlb2YgZGF0ZV90ZXh0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgZGF0ZSA9IERhdGUucGFyc2UoZGF0ZV90ZXh0KTtcblx0ICBpZiAoaXNOYU4oZGF0ZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGRhdGUgPD0gLTIyMDM4OTEyMDAwMDApIHtcblx0ICAgIHJldHVybiAoZGF0ZSAtIGQxOTAwKSAvIDg2NDAwMDAwICsgMTtcblx0ICB9XG5cdCAgcmV0dXJuIChkYXRlIC0gZDE5MDApIC8gODY0MDAwMDAgKyAyO1xuXHR9O1xuXG5cdGV4cG9ydHMuREFZID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHZhciBkYXRlID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChkYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBkYXRlO1xuXHQgIH1cblx0ICByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XG5cdH07XG5cblx0ZXhwb3J0cy5EQVlTID0gZnVuY3Rpb24oZW5kX2RhdGUsIHN0YXJ0X2RhdGUpIHtcblx0ICBlbmRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShlbmRfZGF0ZSk7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBpZiAoZW5kX2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVuZF9kYXRlO1xuXHQgIH1cblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHNlcmlhbChlbmRfZGF0ZSkgLSBzZXJpYWwoc3RhcnRfZGF0ZSk7XG5cdH07XG5cblx0ZXhwb3J0cy5EQVlTMzYwID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZW5kX2RhdGUsIG1ldGhvZCkge1xuXHQgIG1ldGhvZCA9IHV0aWxzLnBhcnNlQm9vbChtZXRob2QpO1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgZW5kX2RhdGUgPSB1dGlscy5wYXJzZURhdGUoZW5kX2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBpZiAoZW5kX2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVuZF9kYXRlO1xuXHQgIH1cblx0ICBpZiAobWV0aG9kIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBtZXRob2Q7XG5cdCAgfVxuXHQgIHZhciBzbSA9IHN0YXJ0X2RhdGUuZ2V0TW9udGgoKTtcblx0ICB2YXIgZW0gPSBlbmRfZGF0ZS5nZXRNb250aCgpO1xuXHQgIHZhciBzZCwgZWQ7XG5cdCAgaWYgKG1ldGhvZCkge1xuXHQgICAgc2QgPSBzdGFydF9kYXRlLmdldERhdGUoKSA9PT0gMzEgPyAzMCA6IHN0YXJ0X2RhdGUuZ2V0RGF0ZSgpO1xuXHQgICAgZWQgPSBlbmRfZGF0ZS5nZXREYXRlKCkgPT09IDMxID8gMzAgOiBlbmRfZGF0ZS5nZXREYXRlKCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBzbWQgPSBuZXcgRGF0ZShzdGFydF9kYXRlLmdldEZ1bGxZZWFyKCksIHNtICsgMSwgMCkuZ2V0RGF0ZSgpO1xuXHQgICAgdmFyIGVtZCA9IG5ldyBEYXRlKGVuZF9kYXRlLmdldEZ1bGxZZWFyKCksIGVtICsgMSwgMCkuZ2V0RGF0ZSgpO1xuXHQgICAgc2QgPSBzdGFydF9kYXRlLmdldERhdGUoKSA9PT0gc21kID8gMzAgOiBzdGFydF9kYXRlLmdldERhdGUoKTtcblx0ICAgIGlmIChlbmRfZGF0ZS5nZXREYXRlKCkgPT09IGVtZCkge1xuXHQgICAgICBpZiAoc2QgPCAzMCkge1xuXHQgICAgICAgIGVtKys7XG5cdCAgICAgICAgZWQgPSAxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVkID0gMzA7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVkID0gZW5kX2RhdGUuZ2V0RGF0ZSgpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gMzYwICogKGVuZF9kYXRlLmdldEZ1bGxZZWFyKCkgLSBzdGFydF9kYXRlLmdldEZ1bGxZZWFyKCkpICtcblx0ICAgIDMwICogKGVtIC0gc20pICsgKGVkIC0gc2QpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRURBVEUgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBtb250aHMpIHtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBpZiAoaXNOYU4obW9udGhzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBtb250aHMgPSBwYXJzZUludChtb250aHMsIDEwKTtcblx0ICBzdGFydF9kYXRlLnNldE1vbnRoKHN0YXJ0X2RhdGUuZ2V0TW9udGgoKSArIG1vbnRocyk7XG5cdCAgcmV0dXJuIHNlcmlhbChzdGFydF9kYXRlKTtcblx0fTtcblxuXHRleHBvcnRzLkVPTU9OVEggPSBmdW5jdGlvbihzdGFydF9kYXRlLCBtb250aHMpIHtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBpZiAoaXNOYU4obW9udGhzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBtb250aHMgPSBwYXJzZUludChtb250aHMsIDEwKTtcblx0ICByZXR1cm4gc2VyaWFsKG5ldyBEYXRlKHN0YXJ0X2RhdGUuZ2V0RnVsbFllYXIoKSwgc3RhcnRfZGF0ZS5nZXRNb250aCgpICsgbW9udGhzICsgMSwgMCkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSE9VUiA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gc2VyaWFsX251bWJlci5nZXRIb3VycygpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSU5URVJWQUwgPSBmdW5jdGlvbiAoc2Vjb25kKSB7XG5cdCAgaWYgKHR5cGVvZiBzZWNvbmQgIT09ICdudW1iZXInICYmIHR5cGVvZiBzZWNvbmQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHNlY29uZCA9IHBhcnNlSW50KHNlY29uZCwgMTApO1xuXHQgIH1cblxuXHQgIHZhciB5ZWFyICA9IE1hdGguZmxvb3Ioc2Vjb25kLzk0NjA4MDAwMCk7XG5cdCAgc2Vjb25kICAgID0gc2Vjb25kJTk0NjA4MDAwMDtcblx0ICB2YXIgbW9udGggPSBNYXRoLmZsb29yKHNlY29uZC8yNTkyMDAwKTtcblx0ICBzZWNvbmQgICAgPSBzZWNvbmQlMjU5MjAwMDtcblx0ICB2YXIgZGF5ICAgPSBNYXRoLmZsb29yKHNlY29uZC84NjQwMCk7XG5cdCAgc2Vjb25kICAgID0gc2Vjb25kJTg2NDAwO1xuXG5cdCAgdmFyIGhvdXIgID0gTWF0aC5mbG9vcihzZWNvbmQvMzYwMCk7XG5cdCAgc2Vjb25kICAgID0gc2Vjb25kJTM2MDA7XG5cdCAgdmFyIG1pbiAgID0gTWF0aC5mbG9vcihzZWNvbmQvNjApO1xuXHQgIHNlY29uZCAgICA9IHNlY29uZCU2MDtcblx0ICB2YXIgc2VjICAgPSBzZWNvbmQ7XG5cblx0ICB5ZWFyICA9ICh5ZWFyICA+IDApID8geWVhciAgKyAnWScgOiAnJztcblx0ICBtb250aCA9IChtb250aCA+IDApID8gbW9udGggKyAnTScgOiAnJztcblx0ICBkYXkgICA9IChkYXkgICA+IDApID8gZGF5ICAgKyAnRCcgOiAnJztcblx0ICBob3VyICA9IChob3VyICA+IDApID8gaG91ciAgKyAnSCcgOiAnJztcblx0ICBtaW4gICA9IChtaW4gICA+IDApID8gbWluICAgKyAnTScgOiAnJztcblx0ICBzZWMgICA9IChzZWMgICA+IDApID8gc2VjICAgKyAnUycgOiAnJztcblxuXHQgIHJldHVybiAnUCcgKyB5ZWFyICsgbW9udGggKyBkYXkgK1xuXHQgICdUJyArIGhvdXIgKyBtaW4gKyBzZWM7XG5cdH07XG5cblx0ZXhwb3J0cy5JU09XRUVLTlVNID0gZnVuY3Rpb24oZGF0ZSkge1xuXHQgIGRhdGUgPSB1dGlscy5wYXJzZURhdGUoZGF0ZSk7XG5cdCAgaWYgKGRhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGRhdGU7XG5cdCAgfVxuXG5cdCAgZGF0ZS5zZXRIb3VycygwLCAwLCAwKTtcblx0ICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyA0IC0gKGRhdGUuZ2V0RGF5KCkgfHwgNykpO1xuXHQgIHZhciB5ZWFyU3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuXHQgIHJldHVybiBNYXRoLmNlaWwoKCgoZGF0ZSAtIHllYXJTdGFydCkgLyA4NjQwMDAwMCkgKyAxKSAvIDcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlOVVRFID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWxfbnVtYmVyLmdldE1pbnV0ZXMoKTtcblx0fTtcblxuXHRleHBvcnRzLk1PTlRIID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWxfbnVtYmVyLmdldE1vbnRoKCkgKyAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuTkVUV09SS0RBWVMgPSBmdW5jdGlvbihzdGFydF9kYXRlLCBlbmRfZGF0ZSwgaG9saWRheXMpIHtcblx0ICByZXR1cm4gdGhpcy5ORVRXT1JLREFZUy5JTlRMKHN0YXJ0X2RhdGUsIGVuZF9kYXRlLCAxLCBob2xpZGF5cyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ORVRXT1JLREFZUy5JTlRMID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZW5kX2RhdGUsIHdlZWtlbmQsIGhvbGlkYXlzKSB7XG5cdCAgc3RhcnRfZGF0ZSA9IHV0aWxzLnBhcnNlRGF0ZShzdGFydF9kYXRlKTtcblx0ICBpZiAoc3RhcnRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc3RhcnRfZGF0ZTtcblx0ICB9XG5cdCAgZW5kX2RhdGUgPSB1dGlscy5wYXJzZURhdGUoZW5kX2RhdGUpO1xuXHQgIGlmIChlbmRfZGF0ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gZW5kX2RhdGU7XG5cdCAgfVxuXHQgIGlmICh3ZWVrZW5kID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHdlZWtlbmQgPSBXRUVLRU5EX1RZUEVTWzFdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB3ZWVrZW5kID0gV0VFS0VORF9UWVBFU1t3ZWVrZW5kXTtcblx0ICB9XG5cdCAgaWYgKCEod2Vla2VuZCBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICBpZiAoaG9saWRheXMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgaG9saWRheXMgPSBbXTtcblx0ICB9IGVsc2UgaWYgKCEoaG9saWRheXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIGhvbGlkYXlzID0gW2hvbGlkYXlzXTtcblx0ICB9XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBob2xpZGF5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGggPSB1dGlscy5wYXJzZURhdGUoaG9saWRheXNbaV0pO1xuXHQgICAgaWYgKGggaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICByZXR1cm4gaDtcblx0ICAgIH1cblx0ICAgIGhvbGlkYXlzW2ldID0gaDtcblx0ICB9XG5cdCAgdmFyIGRheXMgPSAoZW5kX2RhdGUgLSBzdGFydF9kYXRlKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSArIDE7XG5cdCAgdmFyIHRvdGFsID0gZGF5cztcblx0ICB2YXIgZGF5ID0gc3RhcnRfZGF0ZTtcblx0ICBmb3IgKGkgPSAwOyBpIDwgZGF5czsgaSsrKSB7XG5cdCAgICB2YXIgZCA9IChuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgPiAwKSA/IGRheS5nZXRVVENEYXkoKSA6IGRheS5nZXREYXkoKTtcblx0ICAgIHZhciBkZWMgPSBmYWxzZTtcblx0ICAgIGlmIChkID09PSB3ZWVrZW5kWzBdIHx8IGQgPT09IHdlZWtlbmRbMV0pIHtcblx0ICAgICAgZGVjID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgaG9saWRheXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgdmFyIGhvbGlkYXkgPSBob2xpZGF5c1tqXTtcblx0ICAgICAgaWYgKGhvbGlkYXkuZ2V0RGF0ZSgpID09PSBkYXkuZ2V0RGF0ZSgpICYmXG5cdCAgICAgICAgaG9saWRheS5nZXRNb250aCgpID09PSBkYXkuZ2V0TW9udGgoKSAmJlxuXHQgICAgICAgIGhvbGlkYXkuZ2V0RnVsbFllYXIoKSA9PT0gZGF5LmdldEZ1bGxZZWFyKCkpIHtcblx0ICAgICAgICBkZWMgPSB0cnVlO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoZGVjKSB7XG5cdCAgICAgIHRvdGFsLS07XG5cdCAgICB9XG5cdCAgICBkYXkuc2V0RGF0ZShkYXkuZ2V0RGF0ZSgpICsgMSk7XG5cdCAgfVxuXHQgIHJldHVybiB0b3RhbDtcblx0fTtcblxuXHRleHBvcnRzLk5PVyA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBuZXcgRGF0ZSgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuU0VDT05EID0gZnVuY3Rpb24oc2VyaWFsX251bWJlcikge1xuXHQgIHNlcmlhbF9udW1iZXIgPSB1dGlscy5wYXJzZURhdGUoc2VyaWFsX251bWJlcik7XG5cdCAgaWYgKHNlcmlhbF9udW1iZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHNlcmlhbF9udW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiBzZXJpYWxfbnVtYmVyLmdldFNlY29uZHMoKTtcblx0fTtcblxuXHRleHBvcnRzLlRJTUUgPSBmdW5jdGlvbihob3VyLCBtaW51dGUsIHNlY29uZCkge1xuXHQgIGhvdXIgPSB1dGlscy5wYXJzZU51bWJlcihob3VyKTtcblx0ICBtaW51dGUgPSB1dGlscy5wYXJzZU51bWJlcihtaW51dGUpO1xuXHQgIHNlY29uZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHNlY29uZCk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoaG91ciwgbWludXRlLCBzZWNvbmQpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChob3VyIDwgMCB8fCBtaW51dGUgPCAwIHx8IHNlY29uZCA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXHQgIHJldHVybiAoMzYwMCAqIGhvdXIgKyA2MCAqIG1pbnV0ZSArIHNlY29uZCkgLyA4NjQwMDtcblx0fTtcblxuXHRleHBvcnRzLlRJTUVWQUxVRSA9IGZ1bmN0aW9uKHRpbWVfdGV4dCkge1xuXHQgIHRpbWVfdGV4dCA9IHV0aWxzLnBhcnNlRGF0ZSh0aW1lX3RleHQpO1xuXHQgIGlmICh0aW1lX3RleHQgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHRpbWVfdGV4dDtcblx0ICB9XG5cdCAgcmV0dXJuICgzNjAwICogdGltZV90ZXh0LmdldEhvdXJzKCkgK1xuXHQgICAgNjAgKiB0aW1lX3RleHQuZ2V0TWludXRlcygpICtcblx0ICAgIHRpbWVfdGV4dC5nZXRTZWNvbmRzKCkpIC8gODY0MDA7XG5cdH07XG5cblx0ZXhwb3J0cy5UT0RBWSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBuZXcgRGF0ZSgpO1xuXHR9O1xuXG5cdGV4cG9ydHMuV0VFS0RBWSA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIsIHJldHVybl90eXBlKSB7XG5cdCAgc2VyaWFsX251bWJlciA9IHV0aWxzLnBhcnNlRGF0ZShzZXJpYWxfbnVtYmVyKTtcblx0ICBpZiAoc2VyaWFsX251bWJlciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICByZXR1cm4gc2VyaWFsX251bWJlcjtcblx0ICB9XG5cdCAgaWYgKHJldHVybl90eXBlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybl90eXBlID0gMTtcblx0ICB9XG5cdCAgdmFyIGRheSA9IHNlcmlhbF9udW1iZXIuZ2V0RGF5KCk7XG5cdCAgcmV0dXJuIFdFRUtfVFlQRVNbcmV0dXJuX3R5cGVdW2RheV07XG5cdH07XG5cblx0ZXhwb3J0cy5XRUVLTlVNID0gZnVuY3Rpb24oc2VyaWFsX251bWJlciwgcmV0dXJuX3R5cGUpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICBpZiAocmV0dXJuX3R5cGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuX3R5cGUgPSAxO1xuXHQgIH1cblx0ICBpZiAocmV0dXJuX3R5cGUgPT09IDIxKSB7XG5cdCAgICByZXR1cm4gdGhpcy5JU09XRUVLTlVNKHNlcmlhbF9udW1iZXIpO1xuXHQgIH1cblx0ICB2YXIgd2Vla19zdGFydCA9IFdFRUtfU1RBUlRTW3JldHVybl90eXBlXTtcblx0ICB2YXIgamFuID0gbmV3IERhdGUoc2VyaWFsX251bWJlci5nZXRGdWxsWWVhcigpLCAwLCAxKTtcblx0ICB2YXIgaW5jID0gamFuLmdldERheSgpIDwgd2Vla19zdGFydCA/IDEgOiAwO1xuXHQgIGphbiAtPSBNYXRoLmFicyhqYW4uZ2V0RGF5KCkgLSB3ZWVrX3N0YXJ0KSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cdCAgcmV0dXJuIE1hdGguZmxvb3IoKChzZXJpYWxfbnVtYmVyIC0gamFuKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSkgLyA3ICsgMSkgKyBpbmM7XG5cdH07XG5cblx0ZXhwb3J0cy5XT1JLREFZID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZGF5cywgaG9saWRheXMpIHtcblx0ICByZXR1cm4gdGhpcy5XT1JLREFZLklOVEwoc3RhcnRfZGF0ZSwgZGF5cywgMSwgaG9saWRheXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuV09SS0RBWS5JTlRMID0gZnVuY3Rpb24oc3RhcnRfZGF0ZSwgZGF5cywgd2Vla2VuZCwgaG9saWRheXMpIHtcblx0ICBzdGFydF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKHN0YXJ0X2RhdGUpO1xuXHQgIGlmIChzdGFydF9kYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzdGFydF9kYXRlO1xuXHQgIH1cblx0ICBkYXlzID0gdXRpbHMucGFyc2VOdW1iZXIoZGF5cyk7XG5cdCAgaWYgKGRheXMgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGRheXM7XG5cdCAgfVxuXHQgIGlmIChkYXlzIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cdCAgaWYgKHdlZWtlbmQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgd2Vla2VuZCA9IFdFRUtFTkRfVFlQRVNbMV07XG5cdCAgfSBlbHNlIHtcblx0ICAgIHdlZWtlbmQgPSBXRUVLRU5EX1RZUEVTW3dlZWtlbmRdO1xuXHQgIH1cblx0ICBpZiAoISh3ZWVrZW5kIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIGlmIChob2xpZGF5cyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBob2xpZGF5cyA9IFtdO1xuXHQgIH0gZWxzZSBpZiAoIShob2xpZGF5cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHQgICAgaG9saWRheXMgPSBbaG9saWRheXNdO1xuXHQgIH1cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGhvbGlkYXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgaCA9IHV0aWxzLnBhcnNlRGF0ZShob2xpZGF5c1tpXSk7XG5cdCAgICBpZiAoaCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgIHJldHVybiBoO1xuXHQgICAgfVxuXHQgICAgaG9saWRheXNbaV0gPSBoO1xuXHQgIH1cblx0ICB2YXIgZCA9IDA7XG5cdCAgd2hpbGUgKGQgPCBkYXlzKSB7XG5cdCAgICBzdGFydF9kYXRlLnNldERhdGUoc3RhcnRfZGF0ZS5nZXREYXRlKCkgKyAxKTtcblx0ICAgIHZhciBkYXkgPSBzdGFydF9kYXRlLmdldERheSgpO1xuXHQgICAgaWYgKGRheSA9PT0gd2Vla2VuZFswXSB8fCBkYXkgPT09IHdlZWtlbmRbMV0pIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhvbGlkYXlzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgIHZhciBob2xpZGF5ID0gaG9saWRheXNbal07XG5cdCAgICAgIGlmIChob2xpZGF5LmdldERhdGUoKSA9PT0gc3RhcnRfZGF0ZS5nZXREYXRlKCkgJiZcblx0ICAgICAgICBob2xpZGF5LmdldE1vbnRoKCkgPT09IHN0YXJ0X2RhdGUuZ2V0TW9udGgoKSAmJlxuXHQgICAgICAgIGhvbGlkYXkuZ2V0RnVsbFllYXIoKSA9PT0gc3RhcnRfZGF0ZS5nZXRGdWxsWWVhcigpKSB7XG5cdCAgICAgICAgZC0tO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBkKys7XG5cdCAgfVxuXHQgIHJldHVybiBzdGFydF9kYXRlO1xuXHR9O1xuXG5cdGV4cG9ydHMuWUVBUiA9IGZ1bmN0aW9uKHNlcmlhbF9udW1iZXIpIHtcblx0ICBzZXJpYWxfbnVtYmVyID0gdXRpbHMucGFyc2VEYXRlKHNlcmlhbF9udW1iZXIpO1xuXHQgIGlmIChzZXJpYWxfbnVtYmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgIHJldHVybiBzZXJpYWxfbnVtYmVyO1xuXHQgIH1cblx0ICByZXR1cm4gc2VyaWFsX251bWJlci5nZXRGdWxsWWVhcigpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuXHQgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCAxLCAyOSkuZ2V0TW9udGgoKSA9PT0gMTtcblx0fVxuXG5cdC8vIFRPRE8gOiBVc2UgREFZUyA/XG5cdGZ1bmN0aW9uIGRheXNCZXR3ZWVuKHN0YXJ0X2RhdGUsIGVuZF9kYXRlKSB7XG5cdCAgcmV0dXJuIE1hdGguY2VpbCgoZW5kX2RhdGUgLSBzdGFydF9kYXRlKSAvIDEwMDAgLyA2MCAvIDYwIC8gMjQpO1xuXHR9XG5cblx0ZXhwb3J0cy5ZRUFSRlJBQyA9IGZ1bmN0aW9uKHN0YXJ0X2RhdGUsIGVuZF9kYXRlLCBiYXNpcykge1xuXHQgIHN0YXJ0X2RhdGUgPSB1dGlscy5wYXJzZURhdGUoc3RhcnRfZGF0ZSk7XG5cdCAgaWYgKHN0YXJ0X2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIHN0YXJ0X2RhdGU7XG5cdCAgfVxuXHQgIGVuZF9kYXRlID0gdXRpbHMucGFyc2VEYXRlKGVuZF9kYXRlKTtcblx0ICBpZiAoZW5kX2RhdGUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGVuZF9kYXRlO1xuXHQgIH1cblxuXHQgIGJhc2lzID0gYmFzaXMgfHwgMDtcblx0ICB2YXIgc2QgPSBzdGFydF9kYXRlLmdldERhdGUoKTtcblx0ICB2YXIgc20gPSBzdGFydF9kYXRlLmdldE1vbnRoKCkgKyAxO1xuXHQgIHZhciBzeSA9IHN0YXJ0X2RhdGUuZ2V0RnVsbFllYXIoKTtcblx0ICB2YXIgZWQgPSBlbmRfZGF0ZS5nZXREYXRlKCk7XG5cdCAgdmFyIGVtID0gZW5kX2RhdGUuZ2V0TW9udGgoKSArIDE7XG5cdCAgdmFyIGV5ID0gZW5kX2RhdGUuZ2V0RnVsbFllYXIoKTtcblxuXHQgIHN3aXRjaCAoYmFzaXMpIHtcblx0ICAgIGNhc2UgMDpcblx0ICAgICAgLy8gVVMgKE5BU0QpIDMwLzM2MFxuXHQgICAgICBpZiAoc2QgPT09IDMxICYmIGVkID09PSAzMSkge1xuXHQgICAgICAgIHNkID0gMzA7XG5cdCAgICAgICAgZWQgPSAzMDtcblx0ICAgICAgfSBlbHNlIGlmIChzZCA9PT0gMzEpIHtcblx0ICAgICAgICBzZCA9IDMwO1xuXHQgICAgICB9IGVsc2UgaWYgKHNkID09PSAzMCAmJiBlZCA9PT0gMzEpIHtcblx0ICAgICAgICBlZCA9IDMwO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAoKGVkICsgZW0gKiAzMCArIGV5ICogMzYwKSAtIChzZCArIHNtICogMzAgKyBzeSAqIDM2MCkpIC8gMzYwO1xuXHQgICAgY2FzZSAxOlxuXHQgICAgICAvLyBBY3R1YWwvYWN0dWFsXG5cdCAgICAgIHZhciBmZWIyOUJldHdlZW4gPSBmdW5jdGlvbihkYXRlMSwgZGF0ZTIpIHtcblx0ICAgICAgICB2YXIgeWVhcjEgPSBkYXRlMS5nZXRGdWxsWWVhcigpO1xuXHQgICAgICAgIHZhciBtYXIxeWVhcjEgPSBuZXcgRGF0ZSh5ZWFyMSwgMiwgMSk7XG5cdCAgICAgICAgaWYgKGlzTGVhcFllYXIoeWVhcjEpICYmIGRhdGUxIDwgbWFyMXllYXIxICYmIGRhdGUyID49IG1hcjF5ZWFyMSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB5ZWFyMiA9IGRhdGUyLmdldEZ1bGxZZWFyKCk7XG5cdCAgICAgICAgdmFyIG1hcjF5ZWFyMiA9IG5ldyBEYXRlKHllYXIyLCAyLCAxKTtcblx0ICAgICAgICByZXR1cm4gKGlzTGVhcFllYXIoeWVhcjIpICYmIGRhdGUyID49IG1hcjF5ZWFyMiAmJiBkYXRlMSA8IG1hcjF5ZWFyMik7XG5cdCAgICAgIH07XG5cdCAgICAgIHZhciB5bGVuZ3RoID0gMzY1O1xuXHQgICAgICBpZiAoc3kgPT09IGV5IHx8ICgoc3kgKyAxKSA9PT0gZXkpICYmICgoc20gPiBlbSkgfHwgKChzbSA9PT0gZW0pICYmIChzZCA+PSBlZCkpKSkge1xuXHQgICAgICAgIGlmICgoc3kgPT09IGV5ICYmIGlzTGVhcFllYXIoc3kpKSB8fFxuXHQgICAgICAgICAgICBmZWIyOUJldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIHx8XG5cdCAgICAgICAgICAgIChlbSA9PT0gMSAmJiBlZCA9PT0gMjkpKSB7XG5cdCAgICAgICAgICB5bGVuZ3RoID0gMzY2O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGF5c0JldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIC8geWxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgeWVhcnMgPSAoZXkgLSBzeSkgKyAxO1xuXHQgICAgICB2YXIgZGF5cyA9IChuZXcgRGF0ZShleSArIDEsIDAsIDEpIC0gbmV3IERhdGUoc3ksIDAsIDEpKSAvIDEwMDAgLyA2MCAvIDYwIC8gMjQ7XG5cdCAgICAgIHZhciBhdmVyYWdlID0gZGF5cyAvIHllYXJzO1xuXHQgICAgICByZXR1cm4gZGF5c0JldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIC8gYXZlcmFnZTtcblx0ICAgIGNhc2UgMjpcblx0ICAgICAgLy8gQWN0dWFsLzM2MFxuXHQgICAgICByZXR1cm4gZGF5c0JldHdlZW4oc3RhcnRfZGF0ZSwgZW5kX2RhdGUpIC8gMzYwO1xuXHQgICAgY2FzZSAzOlxuXHQgICAgICAvLyBBY3R1YWwvMzY1XG5cdCAgICAgIHJldHVybiBkYXlzQmV0d2VlbihzdGFydF9kYXRlLCBlbmRfZGF0ZSkgLyAzNjU7XG5cdCAgICBjYXNlIDQ6XG5cdCAgICAgIC8vIEV1cm9wZWFuIDMwLzM2MFxuXHQgICAgICByZXR1cm4gKChlZCArIGVtICogMzAgKyBleSAqIDM2MCkgLSAoc2QgKyBzbSAqIDMwICsgc3kgKiAzNjApKSAvIDM2MDtcblx0ICB9XG5cdH07XG5cblx0ZnVuY3Rpb24gc2VyaWFsKGRhdGUpIHtcblx0ICB2YXIgYWRkT24gPSAoZGF0ZSA+IC0yMjAzODkxMjAwMDAwKT8yOjE7XG5cdCAgcmV0dXJuIChkYXRlIC0gZDE5MDApIC8gODY0MDAwMDAgKyBhZGRPbjtcblx0fVxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBzdGF0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBtYXRocyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblx0ZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuXHQgIGlmICghYXJyYXkpIHsgcmV0dXJuIGFycmF5OyB9XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmICghYXJyYXlbaV0pIHsgY29udGludWU7IH1cblx0ICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGV4cG9ydHMuRklOREZJRUxEID0gZnVuY3Rpb24oZGF0YWJhc2UsIHRpdGxlKSB7XG5cdCAgdmFyIGluZGV4ID0gbnVsbDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFiYXNlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoZGF0YWJhc2VbaV1bMF0gPT09IHRpdGxlKSB7XG5cdCAgICAgIGluZGV4ID0gaTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHRoZSBpbnB1dCBmaWVsZCB0aXRsZSBpcyBpbmNvcnJlY3Rcblx0ICBpZiAoaW5kZXggPT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gaW5kZXg7XG5cdH07XG5cblx0ZnVuY3Rpb24gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYXMpIHtcblx0ICB2YXIgbWF0Y2hlcyA9IHt9O1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgZGF0YWJhc2VbMF0ubGVuZ3RoOyArK2kpIHtcblx0ICAgIG1hdGNoZXNbaV0gPSB0cnVlO1xuXHQgIH1cblx0ICB2YXIgbWF4Q3JpdGVyaWFMZW5ndGggPSBjcml0ZXJpYXNbMF0ubGVuZ3RoO1xuXHQgIGZvciAoaSA9IDE7IGkgPCBjcml0ZXJpYXMubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmIChjcml0ZXJpYXNbaV0ubGVuZ3RoID4gbWF4Q3JpdGVyaWFMZW5ndGgpIHtcblx0ICAgICAgbWF4Q3JpdGVyaWFMZW5ndGggPSBjcml0ZXJpYXNbaV0ubGVuZ3RoO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZvciAodmFyIGsgPSAxOyBrIDwgZGF0YWJhc2UubGVuZ3RoOyArK2spIHtcblx0ICAgIGZvciAodmFyIGwgPSAxOyBsIDwgZGF0YWJhc2Vba10ubGVuZ3RoOyArK2wpIHtcblx0ICAgICAgdmFyIGN1cnJlbnRDcml0ZXJpYVJlc3VsdCA9IGZhbHNlO1xuXHQgICAgICB2YXIgaGFzTWF0Y2hpbmdDcml0ZXJpYSAgID0gZmFsc2U7XG5cdCAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3JpdGVyaWFzLmxlbmd0aDsgKytqKSB7XG5cdCAgICAgICAgdmFyIGNyaXRlcmlhID0gY3JpdGVyaWFzW2pdO1xuXHQgICAgICAgIGlmIChjcml0ZXJpYS5sZW5ndGggPCBtYXhDcml0ZXJpYUxlbmd0aCkge1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNyaXRlcmlhRmllbGQgPSBjcml0ZXJpYVswXTtcblx0ICAgICAgICBpZiAoZGF0YWJhc2Vba11bMF0gIT09IGNyaXRlcmlhRmllbGQpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBoYXNNYXRjaGluZ0NyaXRlcmlhID0gdHJ1ZTtcblx0ICAgICAgICBmb3IgKHZhciBwID0gMTsgcCA8IGNyaXRlcmlhLmxlbmd0aDsgKytwKSB7XG5cdCAgICAgICAgICBjdXJyZW50Q3JpdGVyaWFSZXN1bHQgPSBjdXJyZW50Q3JpdGVyaWFSZXN1bHQgfHwgZXZhbChkYXRhYmFzZVtrXVtsXSArIGNyaXRlcmlhW3BdKTsgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAoaGFzTWF0Y2hpbmdDcml0ZXJpYSkge1xuXHQgICAgICAgIG1hdGNoZXNbbF0gPSBtYXRjaGVzW2xdICYmIGN1cnJlbnRDcml0ZXJpYVJlc3VsdDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICBmb3IgKHZhciBuID0gMDsgbiA8IGRhdGFiYXNlWzBdLmxlbmd0aDsgKytuKSB7XG5cdCAgICBpZiAobWF0Y2hlc1tuXSkge1xuXHQgICAgICByZXN1bHQucHVzaChuIC0gMSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvLyBEYXRhYmFzZSBmdW5jdGlvbnNcblx0ZXhwb3J0cy5EQVZFUkFHRSA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHN1bSA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBzdW0gKz0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0SW5kZXhlcy5sZW5ndGggPT09IDAgPyBlcnJvci5kaXYwIDogc3VtIC8gcmVzdWx0SW5kZXhlcy5sZW5ndGg7XG5cdH07XG5cblx0ZXhwb3J0cy5EQ09VTlQgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0YXRzLkNPVU5UKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5EQ09VTlRBID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiBzdGF0cy5DT1VOVEEodGFyZ2V0VmFsdWVzKTtcblx0fTtcblxuXHRleHBvcnRzLkRHRVQgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBubyByZWNvcmQgbWVldHMgdGhlIGNyaXRlcmlhXG5cdCAgaWYgKHJlc3VsdEluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIC8vIFJldHVybnMgdGhlICNOVU0hIGVycm9yIHZhbHVlIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSByZWNvcmQgbWVldHMgdGhlXG5cdCAgLy8gY3JpdGVyaWFcblx0ICBpZiAocmVzdWx0SW5kZXhlcy5sZW5ndGggPiAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIHJldHVybiB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1swXV07XG5cdH07XG5cblx0ZXhwb3J0cy5ETUFYID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgbWF4VmFsdWUgPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1swXV07XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAobWF4VmFsdWUgPCB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV0pIHtcblx0ICAgICAgbWF4VmFsdWUgPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBtYXhWYWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLkRNSU4gPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciBtaW5WYWx1ZSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzWzBdXTtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChtaW5WYWx1ZSA+IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXSkge1xuXHQgICAgICBtaW5WYWx1ZSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG1pblZhbHVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuRFBST0RVQ1QgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgdGFyZ2V0VmFsdWVzID0gY29tcGFjdCh0YXJnZXRWYWx1ZXMpO1xuXHQgIHZhciByZXN1bHQgPSAxO1xuXHQgIGZvciAoaSA9IDA7IGkgPCB0YXJnZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCAqPSB0YXJnZXRWYWx1ZXNbaV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5EU1RERVYgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgdGFyZ2V0VmFsdWVzID0gY29tcGFjdCh0YXJnZXRWYWx1ZXMpO1xuXHQgIHJldHVybiBzdGF0cy5TVERFVi5TKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5EU1RERVZQID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHRhcmdldFZhbHVlcyA9IGNvbXBhY3QodGFyZ2V0VmFsdWVzKTtcblx0ICByZXR1cm4gc3RhdHMuU1RERVYuUCh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRFNVTSA9IGZ1bmN0aW9uKGRhdGFiYXNlLCBmaWVsZCwgY3JpdGVyaWEpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZmllbGQgaXMgbm90IGEgbnVtYmVyIGFuZCBub3QgYSBzdHJpbmdcblx0ICBpZiAoaXNOYU4oZmllbGQpICYmICh0eXBlb2YgZmllbGQgIT09IFwic3RyaW5nXCIpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXHQgIHZhciByZXN1bHRJbmRleGVzID0gZmluZFJlc3VsdEluZGV4KGRhdGFiYXNlLCBjcml0ZXJpYSk7XG5cdCAgdmFyIHRhcmdldEZpZWxkcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBpbmRleCA9IGV4cG9ydHMuRklOREZJRUxEKGRhdGFiYXNlLCBmaWVsZCk7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2luZGV4XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbZmllbGRdKTtcblx0ICB9XG5cdCAgdmFyIHRhcmdldFZhbHVlcyA9IFtdO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgdGFyZ2V0VmFsdWVzW2ldID0gdGFyZ2V0RmllbGRzW3Jlc3VsdEluZGV4ZXNbaV1dO1xuXHQgIH1cblx0ICByZXR1cm4gbWF0aHMuU1VNKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblx0ZXhwb3J0cy5EVkFSID0gZnVuY3Rpb24oZGF0YWJhc2UsIGZpZWxkLCBjcml0ZXJpYSkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmaWVsZCBpcyBub3QgYSBudW1iZXIgYW5kIG5vdCBhIHN0cmluZ1xuXHQgIGlmIChpc05hTihmaWVsZCkgJiYgKHR5cGVvZiBmaWVsZCAhPT0gXCJzdHJpbmdcIikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cdCAgdmFyIHJlc3VsdEluZGV4ZXMgPSBmaW5kUmVzdWx0SW5kZXgoZGF0YWJhc2UsIGNyaXRlcmlhKTtcblx0ICB2YXIgdGFyZ2V0RmllbGRzID0gW107XG5cdCAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5GSU5ERklFTEQoZGF0YWJhc2UsIGZpZWxkKTtcblx0ICAgIHRhcmdldEZpZWxkcyA9IHV0aWxzLnJlc3QoZGF0YWJhc2VbaW5kZXhdKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtmaWVsZF0pO1xuXHQgIH1cblx0ICB2YXIgdGFyZ2V0VmFsdWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0YXJnZXRWYWx1ZXNbaV0gPSB0YXJnZXRGaWVsZHNbcmVzdWx0SW5kZXhlc1tpXV07XG5cdCAgfVxuXHQgIHJldHVybiBzdGF0cy5WQVIuUyh0YXJnZXRWYWx1ZXMpO1xuXHR9O1xuXG5cdGV4cG9ydHMuRFZBUlAgPSBmdW5jdGlvbihkYXRhYmFzZSwgZmllbGQsIGNyaXRlcmlhKSB7XG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZpZWxkIGlzIG5vdCBhIG51bWJlciBhbmQgbm90IGEgc3RyaW5nXG5cdCAgaWYgKGlzTmFOKGZpZWxkKSAmJiAodHlwZW9mIGZpZWxkICE9PSBcInN0cmluZ1wiKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0SW5kZXhlcyA9IGZpbmRSZXN1bHRJbmRleChkYXRhYmFzZSwgY3JpdGVyaWEpO1xuXHQgIHZhciB0YXJnZXRGaWVsZHMgPSBbXTtcblx0ICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgaW5kZXggPSBleHBvcnRzLkZJTkRGSUVMRChkYXRhYmFzZSwgZmllbGQpO1xuXHQgICAgdGFyZ2V0RmllbGRzID0gdXRpbHMucmVzdChkYXRhYmFzZVtpbmRleF0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0YXJnZXRGaWVsZHMgPSB1dGlscy5yZXN0KGRhdGFiYXNlW2ZpZWxkXSk7XG5cdCAgfVxuXHQgIHZhciB0YXJnZXRWYWx1ZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRhcmdldFZhbHVlc1tpXSA9IHRhcmdldEZpZWxkc1tyZXN1bHRJbmRleGVzW2ldXTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0YXRzLlZBUi5QKHRhcmdldFZhbHVlcyk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgaW5mb3JtYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHRleHBvcnRzLkFORCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzID0gdXRpbHMuZmxhdHRlbihhcmd1bWVudHMpO1xuXHQgIHZhciByZXN1bHQgPSB0cnVlO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKCFhcmdzW2ldKSB7XG5cdCAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuQ0hPT1NFID0gZnVuY3Rpb24oKSB7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXG5cdCAgdmFyIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuXHQgIGlmIChpbmRleCA8IDEgfHwgaW5kZXggPiAyNTQpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IGluZGV4ICsgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBhcmd1bWVudHNbaW5kZXhdO1xuXHR9O1xuXG5cdGV4cG9ydHMuRkFMU0UgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0ZXhwb3J0cy5JRiA9IGZ1bmN0aW9uKHRlc3QsIHRoZW5fdmFsdWUsIG90aGVyd2lzZV92YWx1ZSkge1xuXHQgIHJldHVybiB0ZXN0ID8gdGhlbl92YWx1ZSA6IG90aGVyd2lzZV92YWx1ZTtcblx0fTtcblxuXHRleHBvcnRzLklGRVJST1IgPSBmdW5jdGlvbih2YWx1ZSwgdmFsdWVJZkVycm9yKSB7XG5cdCAgaWYgKGluZm9ybWF0aW9uLklTRVJST1IodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gdmFsdWVJZkVycm9yO1xuXHQgIH1cblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5JRk5BID0gZnVuY3Rpb24odmFsdWUsIHZhbHVlX2lmX25hKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSBlcnJvci5uYSA/IHZhbHVlX2lmX25hIDogdmFsdWU7XG5cdH07XG5cblx0ZXhwb3J0cy5OT1QgPSBmdW5jdGlvbihsb2dpY2FsKSB7XG5cdCAgcmV0dXJuICFsb2dpY2FsO1xuXHR9O1xuXG5cdGV4cG9ydHMuT1IgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncyA9IHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKTtcblx0ICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoYXJnc1tpXSkge1xuXHQgICAgICByZXN1bHQgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuVFJVRSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdGV4cG9ydHMuWE9SID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5mbGF0dGVuKGFyZ3VtZW50cyk7XG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoYXJnc1tpXSkge1xuXHQgICAgICByZXN1bHQrKztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIChNYXRoLmZsb29yKE1hdGguYWJzKHJlc3VsdCkpICYgMSkgPyB0cnVlIDogZmFsc2U7XG5cdH07XG5cblx0ZXhwb3J0cy5TV0lUQ0ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHJlc3VsdDtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApICB7XG5cdCAgICB2YXIgdGFyZ2V0VmFsdWUgPSBhcmd1bWVudHNbMF07XG5cdCAgICB2YXIgYXJnYyA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXHQgICAgdmFyIHN3aXRjaENvdW50ID0gTWF0aC5mbG9vcihhcmdjIC8gMik7XG5cdCAgICB2YXIgc3dpdGNoU2F0aXNmaWVkID0gZmFsc2U7XG5cdCAgICB2YXIgZGVmYXVsdENsYXVzZSA9IGFyZ2MgJSAyID09PSAwID8gbnVsbCA6IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cblx0ICAgIGlmIChzd2l0Y2hDb3VudCkge1xuXHQgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3dpdGNoQ291bnQ7IGluZGV4KyspIHtcblx0ICAgICAgICBpZiAodGFyZ2V0VmFsdWUgPT09IGFyZ3VtZW50c1tpbmRleCAqIDIgKyAxXSkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzW2luZGV4ICogMiArIDJdO1xuXHQgICAgICAgICAgc3dpdGNoU2F0aXNmaWVkID0gdHJ1ZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIXN3aXRjaFNhdGlzZmllZCAmJiBkZWZhdWx0Q2xhdXNlKSB7XG5cdCAgICAgIHJlc3VsdCA9IGRlZmF1bHRDbGF1c2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBkYXRlVGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdGZ1bmN0aW9uIHZhbGlkRGF0ZShkKSB7XG5cdCAgcmV0dXJuIGQgJiYgZC5nZXRUaW1lICYmICFpc05hTihkLmdldFRpbWUoKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbnN1cmVEYXRlKGQpIHtcblx0ICByZXR1cm4gKGQgaW5zdGFuY2VvZiBEYXRlKT9kOm5ldyBEYXRlKGQpO1xuXHR9XG5cblx0ZXhwb3J0cy5BQ0NSSU5UID0gZnVuY3Rpb24oaXNzdWUsIGZpcnN0LCBzZXR0bGVtZW50LCByYXRlLCBwYXIsIGZyZXF1ZW5jeSwgYmFzaXMpIHtcblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZWl0aGVyIGRhdGUgaXMgaW52YWxpZFxuXHQgIGlzc3VlICAgICAgPSBlbnN1cmVEYXRlKGlzc3VlKTtcblx0ICBmaXJzdCAgICAgID0gZW5zdXJlRGF0ZShmaXJzdCk7XG5cdCAgc2V0dGxlbWVudCA9IGVuc3VyZURhdGUoc2V0dGxlbWVudCk7XG5cdCAgaWYgKCF2YWxpZERhdGUoaXNzdWUpIHx8ICF2YWxpZERhdGUoZmlyc3QpIHx8ICF2YWxpZERhdGUoc2V0dGxlbWVudCkpIHtcblx0ICAgIHJldHVybiAnI1ZBTFVFISc7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciByYXRlIG9yIHBhciBhcmUgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHJhdGUgPD0gMCB8fCBwYXIgPD0gMCkge1xuXHQgICAgcmV0dXJuICcjTlVNISc7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZyZXF1ZW5jeSBpcyBuZWl0aGVyIDEsIDIsIG9yIDRcblx0ICBpZiAoWzEsIDIsIDRdLmluZGV4T2YoZnJlcXVlbmN5KSA9PT0gLTEpIHtcblx0ICAgIHJldHVybiAnI05VTSEnO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBiYXNpcyBpcyBuZWl0aGVyIDAsIDEsIDIsIDMsIG9yIDRcblx0ICBpZiAoWzAsIDEsIDIsIDMsIDRdLmluZGV4T2YoYmFzaXMpID09PSAtMSkge1xuXHQgICAgcmV0dXJuICcjTlVNISc7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHNldHRsZW1lbnQgaXMgYmVmb3JlIG9yIGVxdWFsIHRvIGlzc3VlXG5cdCAgaWYgKHNldHRsZW1lbnQgPD0gaXNzdWUpIHtcblx0ICAgIHJldHVybiAnI05VTSEnO1xuXHQgIH1cblxuXHQgIC8vIFNldCBkZWZhdWx0IHZhbHVlc1xuXHQgIHBhciAgID0gcGFyICAgfHwgMDtcblx0ICBiYXNpcyA9IGJhc2lzIHx8IDA7XG5cblx0ICAvLyBDb21wdXRlIGFjY3J1ZWQgaW50ZXJlc3Rcblx0ICByZXR1cm4gcGFyICogcmF0ZSAqIGRhdGVUaW1lLllFQVJGUkFDKGlzc3VlLCBzZXR0bGVtZW50LCBiYXNpcyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkFDQ1JJTlRNID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0FDQ1JJTlRNIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5BTU9SREVHUkMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQU1PUkRFR1JDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5BTU9STElOQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdBTU9STElOQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUERBWUJTID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NPVVBEQVlCUyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUERBWVMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUERBWVMgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNPVVBEQVlTTkMgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUERBWVNOQyBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuQ09VUE5DRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdDT1VQTkNEIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5DT1VQTlVNID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0NPVVBOVU0gaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLkNPVVBQQ0QgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignQ09VUFBDRCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLkNVTUlQTVQgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzLCB2YWx1ZSwgc3RhcnQsIGVuZCwgdHlwZSkge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXHQgIC8vIENyZWRpdHM6IEhhbm5lcyBTdGllYml0emhvZmVyIGZvciB0aGUgdHJhbnNsYXRpb25zIG9mIGZ1bmN0aW9uIGFuZCB2YXJpYWJsZSBuYW1lc1xuXHQgIC8vIFJlcXVpcmVzIGV4cG9ydHMuRlYoKSBhbmQgZXhwb3J0cy5QTVQoKSBmcm9tIGV4cG9ydHMuanMgW2h0dHA6Ly9zdG9pYy5jb20vZXhwb3J0cy9dXG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHZhbHVlID0gdXRpbHMucGFyc2VOdW1iZXIodmFsdWUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBlaXRoZXIgcmF0ZSwgcGVyaW9kcywgb3IgdmFsdWUgYXJlIGxvd2VyIHRoYW4gb3IgZXF1YWwgdG8gemVyb1xuXHQgIGlmIChyYXRlIDw9IDAgfHwgcGVyaW9kcyA8PSAwIHx8IHZhbHVlIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHN0YXJ0IDwgMSwgZW5kIDwgMSwgb3Igc3RhcnQgPiBlbmRcblx0ICBpZiAoc3RhcnQgPCAxIHx8IGVuZCA8IDEgfHwgc3RhcnQgPiBlbmQpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHR5cGUgaXMgbmVpdGhlciAwIG5vciAxXG5cdCAgaWYgKHR5cGUgIT09IDAgJiYgdHlwZSAhPT0gMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBDb21wdXRlIGN1bXVsYXRpdmUgaW50ZXJlc3Rcblx0ICB2YXIgcGF5bWVudCA9IGV4cG9ydHMuUE1UKHJhdGUsIHBlcmlvZHMsIHZhbHVlLCAwLCB0eXBlKTtcblx0ICB2YXIgaW50ZXJlc3QgPSAwO1xuXG5cdCAgaWYgKHN0YXJ0ID09PSAxKSB7XG5cdCAgICBpZiAodHlwZSA9PT0gMCkge1xuXHQgICAgICBpbnRlcmVzdCA9IC12YWx1ZTtcblx0ICAgICAgc3RhcnQrKztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcblx0ICAgIGlmICh0eXBlID09PSAxKSB7XG5cdCAgICAgIGludGVyZXN0ICs9IGV4cG9ydHMuRlYocmF0ZSwgaSAtIDIsIHBheW1lbnQsIHZhbHVlLCAxKSAtIHBheW1lbnQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpbnRlcmVzdCArPSBleHBvcnRzLkZWKHJhdGUsIGkgLSAxLCBwYXltZW50LCB2YWx1ZSwgMCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGludGVyZXN0ICo9IHJhdGU7XG5cblx0ICAvLyBSZXR1cm4gY3VtdWxhdGl2ZSBpbnRlcmVzdFxuXHQgIHJldHVybiBpbnRlcmVzdDtcblx0fTtcblxuXHRleHBvcnRzLkNVTVBSSU5DID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcywgdmFsdWUsIHN0YXJ0LCBlbmQsIHR5cGUpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2Vcblx0ICAvLyBDcmVkaXRzOiBIYW5uZXMgU3RpZWJpdHpob2ZlciBmb3IgdGhlIHRyYW5zbGF0aW9ucyBvZiBmdW5jdGlvbiBhbmQgdmFyaWFibGUgbmFtZXNcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgdmFsdWUgPSB1dGlscy5wYXJzZU51bWJlcih2YWx1ZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgdmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGVpdGhlciByYXRlLCBwZXJpb2RzLCBvciB2YWx1ZSBhcmUgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHJhdGUgPD0gMCB8fCBwZXJpb2RzIDw9IDAgfHwgdmFsdWUgPD0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgc3RhcnQgPCAxLCBlbmQgPCAxLCBvciBzdGFydCA+IGVuZFxuXHQgIGlmIChzdGFydCA8IDEgfHwgZW5kIDwgMSB8fCBzdGFydCA+IGVuZCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgdHlwZSBpcyBuZWl0aGVyIDAgbm9yIDFcblx0ICBpZiAodHlwZSAhPT0gMCAmJiB0eXBlICE9PSAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIENvbXB1dGUgY3VtdWxhdGl2ZSBwcmluY2lwYWxcblx0ICB2YXIgcGF5bWVudCA9IGV4cG9ydHMuUE1UKHJhdGUsIHBlcmlvZHMsIHZhbHVlLCAwLCB0eXBlKTtcblx0ICB2YXIgcHJpbmNpcGFsID0gMDtcblx0ICBpZiAoc3RhcnQgPT09IDEpIHtcblx0ICAgIGlmICh0eXBlID09PSAwKSB7XG5cdCAgICAgIHByaW5jaXBhbCA9IHBheW1lbnQgKyB2YWx1ZSAqIHJhdGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBwcmluY2lwYWwgPSBwYXltZW50O1xuXHQgICAgfVxuXHQgICAgc3RhcnQrKztcblx0ICB9XG5cdCAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG5cdCAgICBpZiAodHlwZSA+IDApIHtcblx0ICAgICAgcHJpbmNpcGFsICs9IHBheW1lbnQgLSAoZXhwb3J0cy5GVihyYXRlLCBpIC0gMiwgcGF5bWVudCwgdmFsdWUsIDEpIC0gcGF5bWVudCkgKiByYXRlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcHJpbmNpcGFsICs9IHBheW1lbnQgLSBleHBvcnRzLkZWKHJhdGUsIGkgLSAxLCBwYXltZW50LCB2YWx1ZSwgMCkgKiByYXRlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBjdW11bGF0aXZlIHByaW5jaXBhbFxuXHQgIHJldHVybiBwcmluY2lwYWw7XG5cdH07XG5cblx0ZXhwb3J0cy5EQiA9IGZ1bmN0aW9uKGNvc3QsIHNhbHZhZ2UsIGxpZmUsIHBlcmlvZCwgbW9udGgpIHtcblx0ICAvLyBJbml0aWFsaXplIG1vbnRoXG5cdCAgbW9udGggPSAobW9udGggPT09IHVuZGVmaW5lZCkgPyAxMiA6IG1vbnRoO1xuXG5cdCAgY29zdCA9IHV0aWxzLnBhcnNlTnVtYmVyKGNvc3QpO1xuXHQgIHNhbHZhZ2UgPSB1dGlscy5wYXJzZU51bWJlcihzYWx2YWdlKTtcblx0ICBsaWZlID0gdXRpbHMucGFyc2VOdW1iZXIobGlmZSk7XG5cdCAgcGVyaW9kID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kKTtcblx0ICBtb250aCA9IHV0aWxzLnBhcnNlTnVtYmVyKG1vbnRoKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QsIG1vbnRoKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgaXMgbmVnYXRpdmVcblx0ICBpZiAoY29zdCA8IDAgfHwgc2FsdmFnZSA8IDAgfHwgbGlmZSA8IDAgfHwgcGVyaW9kIDwgMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbW9udGggaXMgbm90IGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCAxMlxuXHQgIGlmIChbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMl0uaW5kZXhPZihtb250aCkgPT09IC0xKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBwZXJpb2QgaXMgZ3JlYXRlciB0aGFuIGxpZmVcblx0ICBpZiAocGVyaW9kID4gbGlmZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gMCAoemVybykgaWYgc2FsdmFnZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gY29zdFxuXHQgIGlmIChzYWx2YWdlID49IGNvc3QpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIFJhdGUgaXMgcm91bmRlZCB0byB0aHJlZSBkZWNpbWFscyBwbGFjZXNcblx0ICB2YXIgcmF0ZSA9ICgxIC0gTWF0aC5wb3coc2FsdmFnZSAvIGNvc3QsIDEgLyBsaWZlKSkudG9GaXhlZCgzKTtcblxuXHQgIC8vIENvbXB1dGUgaW5pdGlhbCBkZXByZWNpYXRpb25cblx0ICB2YXIgaW5pdGlhbCA9IGNvc3QgKiByYXRlICogbW9udGggLyAxMjtcblxuXHQgIC8vIENvbXB1dGUgdG90YWwgZGVwcmVjaWF0aW9uXG5cdCAgdmFyIHRvdGFsID0gaW5pdGlhbDtcblx0ICB2YXIgY3VycmVudCA9IDA7XG5cdCAgdmFyIGNlaWxpbmcgPSAocGVyaW9kID09PSBsaWZlKSA/IGxpZmUgLSAxIDogcGVyaW9kO1xuXHQgIGZvciAodmFyIGkgPSAyOyBpIDw9IGNlaWxpbmc7IGkrKykge1xuXHQgICAgY3VycmVudCA9IChjb3N0IC0gdG90YWwpICogcmF0ZTtcblx0ICAgIHRvdGFsICs9IGN1cnJlbnQ7XG5cdCAgfVxuXG5cdCAgLy8gRGVwcmVjaWF0aW9uIGZvciB0aGUgZmlyc3QgYW5kIGxhc3QgcGVyaW9kcyBhcmUgc3BlY2lhbCBjYXNlc1xuXHQgIGlmIChwZXJpb2QgPT09IDEpIHtcblx0ICAgIC8vIEZpcnN0IHBlcmlvZFxuXHQgICAgcmV0dXJuIGluaXRpYWw7XG5cdCAgfSBlbHNlIGlmIChwZXJpb2QgPT09IGxpZmUpIHtcblx0ICAgIC8vIExhc3QgcGVyaW9kXG5cdCAgICByZXR1cm4gKGNvc3QgLSB0b3RhbCkgKiByYXRlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gY3VycmVudDtcblx0ICB9XG5cdH07XG5cblx0ZXhwb3J0cy5EREIgPSBmdW5jdGlvbihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QsIGZhY3Rvcikge1xuXHQgIC8vIEluaXRpYWxpemUgZmFjdG9yXG5cdCAgZmFjdG9yID0gKGZhY3RvciA9PT0gdW5kZWZpbmVkKSA/IDIgOiBmYWN0b3I7XG5cblx0ICBjb3N0ID0gdXRpbHMucGFyc2VOdW1iZXIoY29zdCk7XG5cdCAgc2FsdmFnZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHNhbHZhZ2UpO1xuXHQgIGxpZmUgPSB1dGlscy5wYXJzZU51bWJlcihsaWZlKTtcblx0ICBwZXJpb2QgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2QpO1xuXHQgIGZhY3RvciA9IHV0aWxzLnBhcnNlTnVtYmVyKGZhY3Rvcik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoY29zdCwgc2FsdmFnZSwgbGlmZSwgcGVyaW9kLCBmYWN0b3IpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBpcyBuZWdhdGl2ZSBvciBpZiBmYWN0b3IgaXMgbnVsbFxuXHQgIGlmIChjb3N0IDwgMCB8fCBzYWx2YWdlIDwgMCB8fCBsaWZlIDwgMCB8fCBwZXJpb2QgPCAwIHx8IGZhY3RvciA8PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBwZXJpb2QgaXMgZ3JlYXRlciB0aGFuIGxpZmVcblx0ICBpZiAocGVyaW9kID4gbGlmZSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gMCAoemVybykgaWYgc2FsdmFnZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gY29zdFxuXHQgIGlmIChzYWx2YWdlID49IGNvc3QpIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH1cblxuXHQgIC8vIENvbXB1dGUgZGVwcmVjaWF0aW9uXG5cdCAgdmFyIHRvdGFsID0gMDtcblx0ICB2YXIgY3VycmVudCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPD0gcGVyaW9kOyBpKyspIHtcblx0ICAgIGN1cnJlbnQgPSBNYXRoLm1pbigoY29zdCAtIHRvdGFsKSAqIChmYWN0b3IgLyBsaWZlKSwgKGNvc3QgLSBzYWx2YWdlIC0gdG90YWwpKTtcblx0ICAgIHRvdGFsICs9IGN1cnJlbnQ7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGRlcHJlY2lhdGlvblxuXHQgIHJldHVybiBjdXJyZW50O1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5ESVNDID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ0RJU0MgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5ET0xMQVJERSA9IGZ1bmN0aW9uKGRvbGxhciwgZnJhY3Rpb24pIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIGRvbGxhciA9IHV0aWxzLnBhcnNlTnVtYmVyKGRvbGxhcik7XG5cdCAgZnJhY3Rpb24gPSB1dGlscy5wYXJzZU51bWJlcihmcmFjdGlvbik7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoZG9sbGFyLCBmcmFjdGlvbikpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZnJhY3Rpb24gaXMgbmVnYXRpdmVcblx0ICBpZiAoZnJhY3Rpb24gPCAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmcmFjdGlvbiBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBhbmQgbGVzcyB0aGFuIDFcblx0ICBpZiAoZnJhY3Rpb24gPj0gMCAmJiBmcmFjdGlvbiA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5kaXYwO1xuXHQgIH1cblxuXHQgIC8vIFRydW5jYXRlIGZyYWN0aW9uIGlmIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgZnJhY3Rpb24gPSBwYXJzZUludChmcmFjdGlvbiwgMTApO1xuXG5cdCAgLy8gQ29tcHV0ZSBpbnRlZ2VyIHBhcnRcblx0ICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQoZG9sbGFyLCAxMCk7XG5cblx0ICAvLyBBZGQgZGVjaW1hbCBwYXJ0XG5cdCAgcmVzdWx0ICs9IChkb2xsYXIgJSAxKSAqIE1hdGgucG93KDEwLCBNYXRoLmNlaWwoTWF0aC5sb2coZnJhY3Rpb24pIC8gTWF0aC5MTjEwKSkgLyBmcmFjdGlvbjtcblxuXHQgIC8vIFJvdW5kIHJlc3VsdFxuXHQgIHZhciBwb3dlciA9IE1hdGgucG93KDEwLCBNYXRoLmNlaWwoTWF0aC5sb2coZnJhY3Rpb24pIC8gTWF0aC5MTjIpICsgMSk7XG5cdCAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQgKiBwb3dlcikgLyBwb3dlcjtcblxuXHQgIC8vIFJldHVybiBjb252ZXJ0ZWQgZG9sbGFyIHByaWNlXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRleHBvcnRzLkRPTExBUkZSID0gZnVuY3Rpb24oZG9sbGFyLCBmcmFjdGlvbikge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgZG9sbGFyID0gdXRpbHMucGFyc2VOdW1iZXIoZG9sbGFyKTtcblx0ICBmcmFjdGlvbiA9IHV0aWxzLnBhcnNlTnVtYmVyKGZyYWN0aW9uKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihkb2xsYXIsIGZyYWN0aW9uKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiBmcmFjdGlvbiBpcyBuZWdhdGl2ZVxuXHQgIGlmIChmcmFjdGlvbiA8IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGZyYWN0aW9uIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIGFuZCBsZXNzIHRoYW4gMVxuXHQgIGlmIChmcmFjdGlvbiA+PSAwICYmIGZyYWN0aW9uIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLmRpdjA7XG5cdCAgfVxuXG5cdCAgLy8gVHJ1bmNhdGUgZnJhY3Rpb24gaWYgaXQgaXMgbm90IGFuIGludGVnZXJcblx0ICBmcmFjdGlvbiA9IHBhcnNlSW50KGZyYWN0aW9uLCAxMCk7XG5cblx0ICAvLyBDb21wdXRlIGludGVnZXIgcGFydFxuXHQgIHZhciByZXN1bHQgPSBwYXJzZUludChkb2xsYXIsIDEwKTtcblxuXHQgIC8vIEFkZCBkZWNpbWFsIHBhcnRcblx0ICByZXN1bHQgKz0gKGRvbGxhciAlIDEpICogTWF0aC5wb3coMTAsIC1NYXRoLmNlaWwoTWF0aC5sb2coZnJhY3Rpb24pIC8gTWF0aC5MTjEwKSkgKiBmcmFjdGlvbjtcblxuXHQgIC8vIFJldHVybiBjb252ZXJ0ZWQgZG9sbGFyIHByaWNlXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuRFVSQVRJT04gPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignRFVSQVRJT04gaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5FRkZFQ1QgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzKSB7XG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2RzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiByYXRlIDw9MCBvciBwZXJpb2RzIDwgMVxuXHQgIGlmIChyYXRlIDw9IDAgfHwgcGVyaW9kcyA8IDEpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gVHJ1bmNhdGUgcGVyaW9kcyBpZiBpdCBpcyBub3QgYW4gaW50ZWdlclxuXHQgIHBlcmlvZHMgPSBwYXJzZUludChwZXJpb2RzLCAxMCk7XG5cblx0ICAvLyBSZXR1cm4gZWZmZWN0aXZlIGFubnVhbCBpbnRlcmVzdCByYXRlXG5cdCAgcmV0dXJuIE1hdGgucG93KDEgKyByYXRlIC8gcGVyaW9kcywgcGVyaW9kcykgLSAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuRlYgPSBmdW5jdGlvbihyYXRlLCBwZXJpb2RzLCBwYXltZW50LCB2YWx1ZSwgdHlwZSkge1xuXHQgIC8vIENyZWRpdHM6IGFsZ29yaXRobSBpbnNwaXJlZCBieSBBcGFjaGUgT3Blbk9mZmljZVxuXG5cdCAgdmFsdWUgPSB2YWx1ZSB8fCAwO1xuXHQgIHR5cGUgPSB0eXBlIHx8IDA7XG5cblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHBheW1lbnQgPSB1dGlscy5wYXJzZU51bWJlcihwYXltZW50KTtcblx0ICB2YWx1ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHZhbHVlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgcGF5bWVudCwgdmFsdWUsIHR5cGUpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGZ1dHVyZSB2YWx1ZVxuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYgKHJhdGUgPT09IDApIHtcblx0ICAgIHJlc3VsdCA9IHZhbHVlICsgcGF5bWVudCAqIHBlcmlvZHM7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciB0ZXJtID0gTWF0aC5wb3coMSArIHJhdGUsIHBlcmlvZHMpO1xuXHQgICAgaWYgKHR5cGUgPT09IDEpIHtcblx0ICAgICAgcmVzdWx0ID0gdmFsdWUgKiB0ZXJtICsgcGF5bWVudCAqICgxICsgcmF0ZSkgKiAodGVybSAtIDEpIC8gcmF0ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc3VsdCA9IHZhbHVlICogdGVybSArIHBheW1lbnQgKiAodGVybSAtIDEpIC8gcmF0ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIC1yZXN1bHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5GVlNDSEVEVUxFID0gZnVuY3Rpb24ocHJpbmNpcGFsLCBzY2hlZHVsZSkge1xuXHQgIHByaW5jaXBhbCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByaW5jaXBhbCk7XG5cdCAgc2NoZWR1bGUgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oc2NoZWR1bGUpKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihwcmluY2lwYWwsIHNjaGVkdWxlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIHZhciBuID0gc2NoZWR1bGUubGVuZ3RoO1xuXHQgIHZhciBmdXR1cmUgPSBwcmluY2lwYWw7XG5cblx0ICAvLyBBcHBseSBhbGwgaW50ZXJlc3RzIGluIHNjaGVkdWxlXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIC8vIEFwcGx5IHNjaGVkdWxlZCBpbnRlcmVzdFxuXHQgICAgZnV0dXJlICo9IDEgKyBzY2hlZHVsZVtpXTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZnV0dXJlIHZhbHVlXG5cdCAgcmV0dXJuIGZ1dHVyZTtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuSU5UUkFURSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdJTlRSQVRFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuSVBNVCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICBmdXR1cmUgPSBmdXR1cmUgfHwgMDtcblx0ICB0eXBlID0gdHlwZSB8fCAwO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZCk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIHR5cGUgPSB1dGlscy5wYXJzZU51bWJlcih0eXBlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBDb21wdXRlIHBheW1lbnRcblx0ICB2YXIgcGF5bWVudCA9IGV4cG9ydHMuUE1UKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSk7XG5cblx0ICAvLyBDb21wdXRlIGludGVyZXN0XG5cdCAgdmFyIGludGVyZXN0O1xuXHQgIGlmIChwZXJpb2QgPT09IDEpIHtcblx0ICAgIGlmICh0eXBlID09PSAxKSB7XG5cdCAgICAgIGludGVyZXN0ID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGludGVyZXN0ID0gLXByZXNlbnQ7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICh0eXBlID09PSAxKSB7XG5cdCAgICAgIGludGVyZXN0ID0gZXhwb3J0cy5GVihyYXRlLCBwZXJpb2QgLSAyLCBwYXltZW50LCBwcmVzZW50LCAxKSAtIHBheW1lbnQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpbnRlcmVzdCA9IGV4cG9ydHMuRlYocmF0ZSwgcGVyaW9kIC0gMSwgcGF5bWVudCwgcHJlc2VudCwgMCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGludGVyZXN0XG5cdCAgcmV0dXJuIGludGVyZXN0ICogcmF0ZTtcblx0fTtcblxuXHRleHBvcnRzLklSUiA9IGZ1bmN0aW9uKHZhbHVlcywgZ3Vlc3MpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIGd1ZXNzID0gZ3Vlc3MgfHwgMDtcblxuXHQgIHZhbHVlcyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbih2YWx1ZXMpKTtcblx0ICBndWVzcyA9IHV0aWxzLnBhcnNlTnVtYmVyKGd1ZXNzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih2YWx1ZXMsIGd1ZXNzKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIENhbGN1bGF0ZXMgdGhlIHJlc3VsdGluZyBhbW91bnRcblx0ICB2YXIgaXJyUmVzdWx0ID0gZnVuY3Rpb24odmFsdWVzLCBkYXRlcywgcmF0ZSkge1xuXHQgICAgdmFyIHIgPSByYXRlICsgMTtcblx0ICAgIHZhciByZXN1bHQgPSB2YWx1ZXNbMF07XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICByZXN1bHQgKz0gdmFsdWVzW2ldIC8gTWF0aC5wb3cociwgKGRhdGVzW2ldIC0gZGF0ZXNbMF0pIC8gMzY1KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblxuXHQgIC8vIENhbGN1bGF0ZXMgdGhlIGZpcnN0IGRlcml2YXRpb25cblx0ICB2YXIgaXJyUmVzdWx0RGVyaXYgPSBmdW5jdGlvbih2YWx1ZXMsIGRhdGVzLCByYXRlKSB7XG5cdCAgICB2YXIgciA9IHJhdGUgKyAxO1xuXHQgICAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgZnJhYyA9IChkYXRlc1tpXSAtIGRhdGVzWzBdKSAvIDM2NTtcblx0ICAgICAgcmVzdWx0IC09IGZyYWMgKiB2YWx1ZXNbaV0gLyBNYXRoLnBvdyhyLCBmcmFjICsgMSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBJbml0aWFsaXplIGRhdGVzIGFuZCBjaGVjayB0aGF0IHZhbHVlcyBjb250YWlucyBhdCBsZWFzdCBvbmUgcG9zaXRpdmUgdmFsdWUgYW5kIG9uZSBuZWdhdGl2ZSB2YWx1ZVxuXHQgIHZhciBkYXRlcyA9IFtdO1xuXHQgIHZhciBwb3NpdGl2ZSA9IGZhbHNlO1xuXHQgIHZhciBuZWdhdGl2ZSA9IGZhbHNlO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBkYXRlc1tpXSA9IChpID09PSAwKSA/IDAgOiBkYXRlc1tpIC0gMV0gKyAzNjU7XG5cdCAgICBpZiAodmFsdWVzW2ldID4gMCkge1xuXHQgICAgICBwb3NpdGl2ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWVzW2ldIDwgMCkge1xuXHQgICAgICBuZWdhdGl2ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHZhbHVlcyBkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZSBwb3NpdGl2ZSB2YWx1ZSBhbmQgb25lIG5lZ2F0aXZlIHZhbHVlXG5cdCAgaWYgKCFwb3NpdGl2ZSB8fCAhbmVnYXRpdmUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gSW5pdGlhbGl6ZSBndWVzcyBhbmQgcmVzdWx0UmF0ZVxuXHQgIGd1ZXNzID0gKGd1ZXNzID09PSB1bmRlZmluZWQpID8gMC4xIDogZ3Vlc3M7XG5cdCAgdmFyIHJlc3VsdFJhdGUgPSBndWVzcztcblxuXHQgIC8vIFNldCBtYXhpbXVtIGVwc2lsb24gZm9yIGVuZCBvZiBpdGVyYXRpb25cblx0ICB2YXIgZXBzTWF4ID0gMWUtMTA7XG5cblx0ICAvLyBJbXBsZW1lbnQgTmV3dG9uJ3MgbWV0aG9kXG5cdCAgdmFyIG5ld1JhdGUsIGVwc1JhdGUsIHJlc3VsdFZhbHVlO1xuXHQgIHZhciBjb250TG9vcCA9IHRydWU7XG5cdCAgZG8ge1xuXHQgICAgcmVzdWx0VmFsdWUgPSBpcnJSZXN1bHQodmFsdWVzLCBkYXRlcywgcmVzdWx0UmF0ZSk7XG5cdCAgICBuZXdSYXRlID0gcmVzdWx0UmF0ZSAtIHJlc3VsdFZhbHVlIC8gaXJyUmVzdWx0RGVyaXYodmFsdWVzLCBkYXRlcywgcmVzdWx0UmF0ZSk7XG5cdCAgICBlcHNSYXRlID0gTWF0aC5hYnMobmV3UmF0ZSAtIHJlc3VsdFJhdGUpO1xuXHQgICAgcmVzdWx0UmF0ZSA9IG5ld1JhdGU7XG5cdCAgICBjb250TG9vcCA9IChlcHNSYXRlID4gZXBzTWF4KSAmJiAoTWF0aC5hYnMocmVzdWx0VmFsdWUpID4gZXBzTWF4KTtcblx0ICB9IHdoaWxlIChjb250TG9vcCk7XG5cblx0ICAvLyBSZXR1cm4gaW50ZXJuYWwgcmF0ZSBvZiByZXR1cm5cblx0ICByZXR1cm4gcmVzdWx0UmF0ZTtcblx0fTtcblxuXHRleHBvcnRzLklTUE1UID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kLCBwZXJpb2RzLCB2YWx1ZSkge1xuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2QgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2QpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICB2YWx1ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHZhbHVlKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBpbnRlcmVzdFxuXHQgIHJldHVybiB2YWx1ZSAqIHJhdGUgKiAocGVyaW9kIC8gcGVyaW9kcyAtIDEpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5NRFVSQVRJT04gPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignTURVUkFUSU9OIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTUlSUiA9IGZ1bmN0aW9uKHZhbHVlcywgZmluYW5jZV9yYXRlLCByZWludmVzdF9yYXRlKSB7XG5cdCAgdmFsdWVzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHZhbHVlcykpO1xuXHQgIGZpbmFuY2VfcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZpbmFuY2VfcmF0ZSk7XG5cdCAgcmVpbnZlc3RfcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJlaW52ZXN0X3JhdGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHZhbHVlcywgZmluYW5jZV9yYXRlLCByZWludmVzdF9yYXRlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIEluaXRpYWxpemUgbnVtYmVyIG9mIHZhbHVlc1xuXHQgIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcblxuXHQgIC8vIExvb2t1cCBwYXltZW50cyAobmVnYXRpdmUgdmFsdWVzKSBhbmQgaW5jb21lcyAocG9zaXRpdmUgdmFsdWVzKVxuXHQgIHZhciBwYXltZW50cyA9IFtdO1xuXHQgIHZhciBpbmNvbWVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGlmICh2YWx1ZXNbaV0gPCAwKSB7XG5cdCAgICAgIHBheW1lbnRzLnB1c2godmFsdWVzW2ldKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGluY29tZXMucHVzaCh2YWx1ZXNbaV0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBtb2RpZmllZCBpbnRlcm5hbCByYXRlIG9mIHJldHVyblxuXHQgIHZhciBudW0gPSAtZXhwb3J0cy5OUFYocmVpbnZlc3RfcmF0ZSwgaW5jb21lcykgKiBNYXRoLnBvdygxICsgcmVpbnZlc3RfcmF0ZSwgbiAtIDEpO1xuXHQgIHZhciBkZW4gPSBleHBvcnRzLk5QVihmaW5hbmNlX3JhdGUsIHBheW1lbnRzKSAqICgxICsgZmluYW5jZV9yYXRlKTtcblx0ICByZXR1cm4gTWF0aC5wb3cobnVtIC8gZGVuLCAxIC8gKG4gLSAxKSkgLSAxO1xuXHR9O1xuXG5cdGV4cG9ydHMuTk9NSU5BTCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZHMpIHtcblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHJhdGUgPD0wIG9yIHBlcmlvZHMgPCAxXG5cdCAgaWYgKHJhdGUgPD0gMCB8fCBwZXJpb2RzIDwgMSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBUcnVuY2F0ZSBwZXJpb2RzIGlmIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgcGVyaW9kcyA9IHBhcnNlSW50KHBlcmlvZHMsIDEwKTtcblxuXHQgIC8vIFJldHVybiBub21pbmFsIGFubnVhbCBpbnRlcmVzdCByYXRlXG5cdCAgcmV0dXJuIChNYXRoLnBvdyhyYXRlICsgMSwgMSAvIHBlcmlvZHMpIC0gMSkgKiBwZXJpb2RzO1xuXHR9O1xuXG5cdGV4cG9ydHMuTlBFUiA9IGZ1bmN0aW9uKHJhdGUsIHBheW1lbnQsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkge1xuXHQgIHR5cGUgPSAodHlwZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiB0eXBlO1xuXHQgIGZ1dHVyZSA9IChmdXR1cmUgPT09IHVuZGVmaW5lZCkgPyAwIDogZnV0dXJlO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBheW1lbnQgPSB1dGlscy5wYXJzZU51bWJlcihwYXltZW50KTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGF5bWVudCwgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBudW1iZXIgb2YgcGVyaW9kc1xuXHQgIHZhciBudW0gPSBwYXltZW50ICogKDEgKyByYXRlICogdHlwZSkgLSBmdXR1cmUgKiByYXRlO1xuXHQgIHZhciBkZW4gPSAocHJlc2VudCAqIHJhdGUgKyBwYXltZW50ICogKDEgKyByYXRlICogdHlwZSkpO1xuXHQgIHJldHVybiBNYXRoLmxvZyhudW0gLyBkZW4pIC8gTWF0aC5sb2coMSArIHJhdGUpO1xuXHR9O1xuXG5cdGV4cG9ydHMuTlBWID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MgPSB1dGlscy5wYXJzZU51bWJlckFycmF5KHV0aWxzLmZsYXR0ZW4oYXJndW1lbnRzKSk7XG5cdCAgaWYgKGFyZ3MgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgcmV0dXJuIGFyZ3M7XG5cdCAgfVxuXG5cdCAgLy8gTG9va3VwIHJhdGVcblx0ICB2YXIgcmF0ZSA9IGFyZ3NbMF07XG5cblx0ICAvLyBJbml0aWFsaXplIG5ldCBwcmVzZW50IHZhbHVlXG5cdCAgdmFyIHZhbHVlID0gMDtcblxuXHQgIC8vIExvb3Agb24gYWxsIHZhbHVlc1xuXHQgIGZvciAodmFyIGogPSAxOyBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuXHQgICAgdmFsdWUgKz0gYXJnc1tqXSAvIE1hdGgucG93KDEgKyByYXRlLCBqKTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gbmV0IHByZXNlbnQgdmFsdWVcblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk9EREZQUklDRSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdPRERGUFJJQ0UgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk9EREZZSUVMRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdPRERGWUlFTEQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk9ERExQUklDRSA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdPRERMUFJJQ0UgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLk9ERExZSUVMRCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdPRERMWUlFTEQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0ZXhwb3J0cy5QRFVSQVRJT04gPSBmdW5jdGlvbihyYXRlLCBwcmVzZW50LCBmdXR1cmUpIHtcblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcHJlc2VudCwgZnV0dXJlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiByYXRlIDw9MFxuXHQgIGlmIChyYXRlIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIG51bWJlciBvZiBwZXJpb2RzXG5cdCAgcmV0dXJuIChNYXRoLmxvZyhmdXR1cmUpIC0gTWF0aC5sb2cocHJlc2VudCkpIC8gTWF0aC5sb2coMSArIHJhdGUpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUE1UID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgLy8gQ3JlZGl0czogYWxnb3JpdGhtIGluc3BpcmVkIGJ5IEFwYWNoZSBPcGVuT2ZmaWNlXG5cblx0ICBmdXR1cmUgPSBmdXR1cmUgfHwgMDtcblx0ICB0eXBlID0gdHlwZSB8fCAwO1xuXG5cdCAgcmF0ZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHJhdGUpO1xuXHQgIHBlcmlvZHMgPSB1dGlscy5wYXJzZU51bWJlcihwZXJpb2RzKTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSkge1xuXHQgICAgcmV0dXJuIGVycm9yLnZhbHVlO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBwYXltZW50XG5cdCAgdmFyIHJlc3VsdDtcblx0ICBpZiAocmF0ZSA9PT0gMCkge1xuXHQgICAgcmVzdWx0ID0gKHByZXNlbnQgKyBmdXR1cmUpIC8gcGVyaW9kcztcblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHRlcm0gPSBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcyk7XG5cdCAgICBpZiAodHlwZSA9PT0gMSkge1xuXHQgICAgICByZXN1bHQgPSAoZnV0dXJlICogcmF0ZSAvICh0ZXJtIC0gMSkgKyBwcmVzZW50ICogcmF0ZSAvICgxIC0gMSAvIHRlcm0pKSAvICgxICsgcmF0ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXN1bHQgPSBmdXR1cmUgKiByYXRlIC8gKHRlcm0gLSAxKSArIHByZXNlbnQgKiByYXRlIC8gKDEgLSAxIC8gdGVybSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiAtcmVzdWx0O1xuXHR9O1xuXG5cdGV4cG9ydHMuUFBNVCA9IGZ1bmN0aW9uKHJhdGUsIHBlcmlvZCwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgZnV0dXJlID0gZnV0dXJlIHx8IDA7XG5cdCAgdHlwZSA9IHR5cGUgfHwgMDtcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcHJlc2VudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHByZXNlbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gZXhwb3J0cy5QTVQocmF0ZSwgcGVyaW9kcywgcHJlc2VudCwgZnV0dXJlLCB0eXBlKSAtIGV4cG9ydHMuSVBNVChyYXRlLCBwZXJpb2QsIHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlBSSUNFID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1BSSUNFIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5QUklDRURJU0MgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignUFJJQ0VESVNDIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5QUklDRU1BVCA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdQUklDRU1BVCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRleHBvcnRzLlBWID0gZnVuY3Rpb24ocmF0ZSwgcGVyaW9kcywgcGF5bWVudCwgZnV0dXJlLCB0eXBlKSB7XG5cdCAgZnV0dXJlID0gZnV0dXJlIHx8IDA7XG5cdCAgdHlwZSA9IHR5cGUgfHwgMDtcblxuXHQgIHJhdGUgPSB1dGlscy5wYXJzZU51bWJlcihyYXRlKTtcblx0ICBwZXJpb2RzID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kcyk7XG5cdCAgcGF5bWVudCA9IHV0aWxzLnBhcnNlTnVtYmVyKHBheW1lbnQpO1xuXHQgIGZ1dHVyZSA9IHV0aWxzLnBhcnNlTnVtYmVyKGZ1dHVyZSk7XG5cdCAgdHlwZSA9IHV0aWxzLnBhcnNlTnVtYmVyKHR5cGUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHBlcmlvZHMsIHBheW1lbnQsIGZ1dHVyZSwgdHlwZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gcHJlc2VudCB2YWx1ZVxuXHQgIGlmIChyYXRlID09PSAwKSB7XG5cdCAgICByZXR1cm4gLXBheW1lbnQgKiBwZXJpb2RzIC0gZnV0dXJlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gKCgoMSAtIE1hdGgucG93KDEgKyByYXRlLCBwZXJpb2RzKSkgLyByYXRlKSAqIHBheW1lbnQgKiAoMSArIHJhdGUgKiB0eXBlKSAtIGZ1dHVyZSkgLyBNYXRoLnBvdygxICsgcmF0ZSwgcGVyaW9kcyk7XG5cdCAgfVxuXHR9O1xuXG5cdGV4cG9ydHMuUkFURSA9IGZ1bmN0aW9uKHBlcmlvZHMsIHBheW1lbnQsIHByZXNlbnQsIGZ1dHVyZSwgdHlwZSwgZ3Vlc3MpIHtcblx0ICAvLyBDcmVkaXRzOiByYWJ1Z2VudG9cblxuXHQgIGd1ZXNzID0gKGd1ZXNzID09PSB1bmRlZmluZWQpID8gMC4wMSA6IGd1ZXNzO1xuXHQgIGZ1dHVyZSA9IChmdXR1cmUgPT09IHVuZGVmaW5lZCkgPyAwIDogZnV0dXJlO1xuXHQgIHR5cGUgPSAodHlwZSA9PT0gdW5kZWZpbmVkKSA/IDAgOiB0eXBlO1xuXG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHBheW1lbnQgPSB1dGlscy5wYXJzZU51bWJlcihwYXltZW50KTtcblx0ICBwcmVzZW50ID0gdXRpbHMucGFyc2VOdW1iZXIocHJlc2VudCk7XG5cdCAgZnV0dXJlID0gdXRpbHMucGFyc2VOdW1iZXIoZnV0dXJlKTtcblx0ICB0eXBlID0gdXRpbHMucGFyc2VOdW1iZXIodHlwZSk7XG5cdCAgZ3Vlc3MgPSB1dGlscy5wYXJzZU51bWJlcihndWVzcyk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IocGVyaW9kcywgcGF5bWVudCwgcHJlc2VudCwgZnV0dXJlLCB0eXBlLCBndWVzcykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBTZXQgbWF4aW11bSBlcHNpbG9uIGZvciBlbmQgb2YgaXRlcmF0aW9uXG5cdCAgdmFyIGVwc01heCA9IDFlLTY7XG5cblx0ICAvLyBTZXQgbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9uc1xuXHQgIHZhciBpdGVyTWF4ID0gMTAwO1xuXHQgIHZhciBpdGVyID0gMDtcblx0ICB2YXIgY2xvc2UgPSBmYWxzZTtcblx0ICB2YXIgcmF0ZSA9IGd1ZXNzO1xuXG5cdCAgd2hpbGUgKGl0ZXIgPCBpdGVyTWF4ICYmICFjbG9zZSkge1xuXHQgICAgdmFyIHQxID0gTWF0aC5wb3cocmF0ZSArIDEsIHBlcmlvZHMpO1xuXHQgICAgdmFyIHQyID0gTWF0aC5wb3cocmF0ZSArIDEsIHBlcmlvZHMgLSAxKTtcblxuXHQgICAgdmFyIGYxID0gZnV0dXJlICsgdDEgKiBwcmVzZW50ICsgcGF5bWVudCAqICh0MSAtIDEpICogKHJhdGUgKiB0eXBlICsgMSkgLyByYXRlO1xuXHQgICAgdmFyIGYyID0gcGVyaW9kcyAqIHQyICogcHJlc2VudCAtIHBheW1lbnQgKiAodDEgLSAxKSAqKHJhdGUgKiB0eXBlICsgMSkgLyBNYXRoLnBvdyhyYXRlLDIpO1xuXHQgICAgdmFyIGYzID0gcGVyaW9kcyAqIHBheW1lbnQgKiB0MiAqIChyYXRlICogdHlwZSArIDEpIC8gcmF0ZSArIHBheW1lbnQgKiAodDEgLSAxKSAqIHR5cGUgLyByYXRlO1xuXG5cdCAgICB2YXIgbmV3UmF0ZSA9IHJhdGUgLSBmMSAvIChmMiArIGYzKTtcblxuXHQgICAgaWYgKE1hdGguYWJzKG5ld1JhdGUgLSByYXRlKSA8IGVwc01heCkgY2xvc2UgPSB0cnVlO1xuXHQgICAgaXRlcisrXG5cdCAgICByYXRlID0gbmV3UmF0ZTtcblx0ICB9XG5cblx0ICBpZiAoIWNsb3NlKSByZXR1cm4gTnVtYmVyLk5hTiArIHJhdGU7XG5cdCAgcmV0dXJuIHJhdGU7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLlJFQ0VJVkVEID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1JFQ0VJVkVEIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdGV4cG9ydHMuUlJJID0gZnVuY3Rpb24ocGVyaW9kcywgcHJlc2VudCwgZnV0dXJlKSB7XG5cdCAgcGVyaW9kcyA9IHV0aWxzLnBhcnNlTnVtYmVyKHBlcmlvZHMpO1xuXHQgIHByZXNlbnQgPSB1dGlscy5wYXJzZU51bWJlcihwcmVzZW50KTtcblx0ICBmdXR1cmUgPSB1dGlscy5wYXJzZU51bWJlcihmdXR1cmUpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHBlcmlvZHMsIHByZXNlbnQsIGZ1dHVyZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcGVyaW9kcyBvciBwcmVzZW50IGlzIGVxdWFsIHRvIDAgKHplcm8pXG5cdCAgaWYgKHBlcmlvZHMgPT09IDAgfHwgcHJlc2VudCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXF1aXZhbGVudCBpbnRlcmVzdCByYXRlXG5cdCAgcmV0dXJuIE1hdGgucG93KGZ1dHVyZSAvIHByZXNlbnQsIDEgLyBwZXJpb2RzKSAtIDE7XG5cdH07XG5cblx0ZXhwb3J0cy5TTE4gPSBmdW5jdGlvbihjb3N0LCBzYWx2YWdlLCBsaWZlKSB7XG5cdCAgY29zdCA9IHV0aWxzLnBhcnNlTnVtYmVyKGNvc3QpO1xuXHQgIHNhbHZhZ2UgPSB1dGlscy5wYXJzZU51bWJlcihzYWx2YWdlKTtcblx0ICBsaWZlID0gdXRpbHMucGFyc2VOdW1iZXIobGlmZSk7XG5cdCAgaWYgKHV0aWxzLmFueUlzRXJyb3IoY29zdCwgc2FsdmFnZSwgbGlmZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbGlmZSBlcXVhbCB0byAwICh6ZXJvKVxuXHQgIGlmIChsaWZlID09PSAwKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIFJldHVybiBzdHJhaWdodC1saW5lIGRlcHJlY2lhdGlvblxuXHQgIHJldHVybiAoY29zdCAtIHNhbHZhZ2UpIC8gbGlmZTtcblx0fTtcblxuXHRleHBvcnRzLlNZRCA9IGZ1bmN0aW9uKGNvc3QsIHNhbHZhZ2UsIGxpZmUsIHBlcmlvZCkge1xuXHQgIC8vIFJldHVybiBlcnJvciBpZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgaXMgbm90IGEgbnVtYmVyXG5cdCAgY29zdCA9IHV0aWxzLnBhcnNlTnVtYmVyKGNvc3QpO1xuXHQgIHNhbHZhZ2UgPSB1dGlscy5wYXJzZU51bWJlcihzYWx2YWdlKTtcblx0ICBsaWZlID0gdXRpbHMucGFyc2VOdW1iZXIobGlmZSk7XG5cdCAgcGVyaW9kID0gdXRpbHMucGFyc2VOdW1iZXIocGVyaW9kKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcihjb3N0LCBzYWx2YWdlLCBsaWZlLCBwZXJpb2QpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIGxpZmUgZXF1YWwgdG8gMCAoemVybylcblx0ICBpZiAobGlmZSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcGVyaW9kIGlzIGxvd2VyIHRoYW4gMSBvciBncmVhdGVyIHRoYW4gbGlmZVxuXHQgIGlmIChwZXJpb2QgPCAxIHx8IHBlcmlvZCA+IGxpZmUpIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gVHJ1bmNhdGUgcGVyaW9kIGlmIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXG5cdCAgcGVyaW9kID0gcGFyc2VJbnQocGVyaW9kLCAxMCk7XG5cblx0ICAvLyBSZXR1cm4gc3RyYWlnaHQtbGluZSBkZXByZWNpYXRpb25cblx0ICByZXR1cm4gKChjb3N0IC0gc2FsdmFnZSkgKiAobGlmZSAtIHBlcmlvZCArIDEpICogMikgLyAobGlmZSAqIChsaWZlICsgMSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVEJJTExFUSA9IGZ1bmN0aW9uKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkge1xuXHQgIHNldHRsZW1lbnQgPSB1dGlscy5wYXJzZURhdGUoc2V0dGxlbWVudCk7XG5cdCAgbWF0dXJpdHkgPSB1dGlscy5wYXJzZURhdGUobWF0dXJpdHkpO1xuXHQgIGRpc2NvdW50ID0gdXRpbHMucGFyc2VOdW1iZXIoZGlzY291bnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZGlzY291bnQgaXMgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKGRpc2NvdW50IDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHNldHRsZW1lbnQgaXMgZ3JlYXRlciB0aGFuIG1hdHVyaXR5XG5cdCAgaWYgKHNldHRsZW1lbnQgPiBtYXR1cml0eSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbWF0dXJpdHkgaXMgbW9yZSB0aGFuIG9uZSB5ZWFyIGFmdGVyIHNldHRsZW1lbnRcblx0ICBpZiAobWF0dXJpdHkgLSBzZXR0bGVtZW50ID4gMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYm9uZC1lcXVpdmFsZW50IHlpZWxkXG5cdCAgcmV0dXJuICgzNjUgKiBkaXNjb3VudCkgLyAoMzYwIC0gZGlzY291bnQgKiBkYXRlVGltZS5EQVlTMzYwKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBmYWxzZSkpO1xuXHR9O1xuXG5cdGV4cG9ydHMuVEJJTExQUklDRSA9IGZ1bmN0aW9uKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkge1xuXHQgIHNldHRsZW1lbnQgPSB1dGlscy5wYXJzZURhdGUoc2V0dGxlbWVudCk7XG5cdCAgbWF0dXJpdHkgPSB1dGlscy5wYXJzZURhdGUobWF0dXJpdHkpO1xuXHQgIGRpc2NvdW50ID0gdXRpbHMucGFyc2VOdW1iZXIoZGlzY291bnQpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBkaXNjb3VudCkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgZGlzY291bnQgaXMgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKGRpc2NvdW50IDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHNldHRsZW1lbnQgaXMgZ3JlYXRlciB0aGFuIG1hdHVyaXR5XG5cdCAgaWYgKHNldHRsZW1lbnQgPiBtYXR1cml0eSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbWF0dXJpdHkgaXMgbW9yZSB0aGFuIG9uZSB5ZWFyIGFmdGVyIHNldHRsZW1lbnRcblx0ICBpZiAobWF0dXJpdHkgLSBzZXR0bGVtZW50ID4gMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYm9uZC1lcXVpdmFsZW50IHlpZWxkXG5cdCAgcmV0dXJuIDEwMCAqICgxIC0gZGlzY291bnQgKiBkYXRlVGltZS5EQVlTMzYwKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBmYWxzZSkgLyAzNjApO1xuXHR9O1xuXG5cdGV4cG9ydHMuVEJJTExZSUVMRCA9IGZ1bmN0aW9uKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBwcmljZSkge1xuXHQgIHNldHRsZW1lbnQgPSB1dGlscy5wYXJzZURhdGUoc2V0dGxlbWVudCk7XG5cdCAgbWF0dXJpdHkgPSB1dGlscy5wYXJzZURhdGUobWF0dXJpdHkpO1xuXHQgIHByaWNlID0gdXRpbHMucGFyc2VOdW1iZXIocHJpY2UpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBwcmljZSkpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgcHJpY2UgaXMgbG93ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvXG5cdCAgaWYgKHByaWNlIDw9IDApIHtcblx0ICAgIHJldHVybiBlcnJvci5udW07XG5cdCAgfVxuXG5cdCAgLy8gUmV0dXJuIGVycm9yIGlmIHNldHRsZW1lbnQgaXMgZ3JlYXRlciB0aGFuIG1hdHVyaXR5XG5cdCAgaWYgKHNldHRsZW1lbnQgPiBtYXR1cml0eSkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gZXJyb3IgaWYgbWF0dXJpdHkgaXMgbW9yZSB0aGFuIG9uZSB5ZWFyIGFmdGVyIHNldHRsZW1lbnRcblx0ICBpZiAobWF0dXJpdHkgLSBzZXR0bGVtZW50ID4gMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCkge1xuXHQgICAgcmV0dXJuIGVycm9yLm51bTtcblx0ICB9XG5cblx0ICAvLyBSZXR1cm4gYm9uZC1lcXVpdmFsZW50IHlpZWxkXG5cdCAgcmV0dXJuICgxMDAgLSBwcmljZSkgKiAzNjAgLyAocHJpY2UgKiBkYXRlVGltZS5EQVlTMzYwKHNldHRsZW1lbnQsIG1hdHVyaXR5LCBmYWxzZSkpO1xuXHR9O1xuXG5cdC8vIFRPRE9cblx0ZXhwb3J0cy5WREIgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignVkRCIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cblx0ZXhwb3J0cy5YSVJSID0gZnVuY3Rpb24odmFsdWVzLCBkYXRlcywgZ3Vlc3MpIHtcblx0ICAvLyBDcmVkaXRzOiBhbGdvcml0aG0gaW5zcGlyZWQgYnkgQXBhY2hlIE9wZW5PZmZpY2VcblxuXHQgIHZhbHVlcyA9IHV0aWxzLnBhcnNlTnVtYmVyQXJyYXkodXRpbHMuZmxhdHRlbih2YWx1ZXMpKTtcblx0ICBkYXRlcyA9IHV0aWxzLnBhcnNlRGF0ZUFycmF5KHV0aWxzLmZsYXR0ZW4oZGF0ZXMpKTtcblx0ICBndWVzcyA9IHV0aWxzLnBhcnNlTnVtYmVyKGd1ZXNzKTtcblx0ICBpZiAodXRpbHMuYW55SXNFcnJvcih2YWx1ZXMsIGRhdGVzLCBndWVzcykpIHtcblx0ICAgIHJldHVybiBlcnJvci52YWx1ZTtcblx0ICB9XG5cblx0ICAvLyBDYWxjdWxhdGVzIHRoZSByZXN1bHRpbmcgYW1vdW50XG5cdCAgdmFyIGlyclJlc3VsdCA9IGZ1bmN0aW9uKHZhbHVlcywgZGF0ZXMsIHJhdGUpIHtcblx0ICAgIHZhciByID0gcmF0ZSArIDE7XG5cdCAgICB2YXIgcmVzdWx0ID0gdmFsdWVzWzBdO1xuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcmVzdWx0ICs9IHZhbHVlc1tpXSAvIE1hdGgucG93KHIsIGRhdGVUaW1lLkRBWVMoZGF0ZXNbaV0sIGRhdGVzWzBdKSAvIDM2NSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cblx0ICAvLyBDYWxjdWxhdGVzIHRoZSBmaXJzdCBkZXJpdmF0aW9uXG5cdCAgdmFyIGlyclJlc3VsdERlcml2ID0gZnVuY3Rpb24odmFsdWVzLCBkYXRlcywgcmF0ZSkge1xuXHQgICAgdmFyIHIgPSByYXRlICsgMTtcblx0ICAgIHZhciByZXN1bHQgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGZyYWMgPSBkYXRlVGltZS5EQVlTKGRhdGVzW2ldLCBkYXRlc1swXSkgLyAzNjU7XG5cdCAgICAgIHJlc3VsdCAtPSBmcmFjICogdmFsdWVzW2ldIC8gTWF0aC5wb3cociwgZnJhYyArIDEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXG5cdCAgLy8gQ2hlY2sgdGhhdCB2YWx1ZXMgY29udGFpbnMgYXQgbGVhc3Qgb25lIHBvc2l0aXZlIHZhbHVlIGFuZCBvbmUgbmVnYXRpdmUgdmFsdWVcblx0ICB2YXIgcG9zaXRpdmUgPSBmYWxzZTtcblx0ICB2YXIgbmVnYXRpdmUgPSBmYWxzZTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKHZhbHVlc1tpXSA+IDApIHtcblx0ICAgICAgcG9zaXRpdmUgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlc1tpXSA8IDApIHtcblx0ICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIFJldHVybiBlcnJvciBpZiB2YWx1ZXMgZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcG9zaXRpdmUgdmFsdWUgYW5kIG9uZSBuZWdhdGl2ZSB2YWx1ZVxuXHQgIGlmICghcG9zaXRpdmUgfHwgIW5lZ2F0aXZlKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubnVtO1xuXHQgIH1cblxuXHQgIC8vIEluaXRpYWxpemUgZ3Vlc3MgYW5kIHJlc3VsdFJhdGVcblx0ICBndWVzcyA9IGd1ZXNzIHx8IDAuMTtcblx0ICB2YXIgcmVzdWx0UmF0ZSA9IGd1ZXNzO1xuXG5cdCAgLy8gU2V0IG1heGltdW0gZXBzaWxvbiBmb3IgZW5kIG9mIGl0ZXJhdGlvblxuXHQgIHZhciBlcHNNYXggPSAxZS0xMDtcblxuXHQgIC8vIEltcGxlbWVudCBOZXd0b24ncyBtZXRob2Rcblx0ICB2YXIgbmV3UmF0ZSwgZXBzUmF0ZSwgcmVzdWx0VmFsdWU7XG5cdCAgdmFyIGNvbnRMb29wID0gdHJ1ZTtcblx0ICBkbyB7XG5cdCAgICByZXN1bHRWYWx1ZSA9IGlyclJlc3VsdCh2YWx1ZXMsIGRhdGVzLCByZXN1bHRSYXRlKTtcblx0ICAgIG5ld1JhdGUgPSByZXN1bHRSYXRlIC0gcmVzdWx0VmFsdWUgLyBpcnJSZXN1bHREZXJpdih2YWx1ZXMsIGRhdGVzLCByZXN1bHRSYXRlKTtcblx0ICAgIGVwc1JhdGUgPSBNYXRoLmFicyhuZXdSYXRlIC0gcmVzdWx0UmF0ZSk7XG5cdCAgICByZXN1bHRSYXRlID0gbmV3UmF0ZTtcblx0ICAgIGNvbnRMb29wID0gKGVwc1JhdGUgPiBlcHNNYXgpICYmIChNYXRoLmFicyhyZXN1bHRWYWx1ZSkgPiBlcHNNYXgpO1xuXHQgIH0gd2hpbGUgKGNvbnRMb29wKTtcblxuXHQgIC8vIFJldHVybiBpbnRlcm5hbCByYXRlIG9mIHJldHVyblxuXHQgIHJldHVybiByZXN1bHRSYXRlO1xuXHR9O1xuXG5cdGV4cG9ydHMuWE5QViA9IGZ1bmN0aW9uKHJhdGUsIHZhbHVlcywgZGF0ZXMpIHtcblx0ICByYXRlID0gdXRpbHMucGFyc2VOdW1iZXIocmF0ZSk7XG5cdCAgdmFsdWVzID0gdXRpbHMucGFyc2VOdW1iZXJBcnJheSh1dGlscy5mbGF0dGVuKHZhbHVlcykpO1xuXHQgIGRhdGVzID0gdXRpbHMucGFyc2VEYXRlQXJyYXkodXRpbHMuZmxhdHRlbihkYXRlcykpO1xuXHQgIGlmICh1dGlscy5hbnlJc0Vycm9yKHJhdGUsIHZhbHVlcywgZGF0ZXMpKSB7XG5cdCAgICByZXR1cm4gZXJyb3IudmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdCArPSB2YWx1ZXNbaV0gLyBNYXRoLnBvdygxICsgcmF0ZSwgZGF0ZVRpbWUuREFZUyhkYXRlc1tpXSwgZGF0ZXNbMF0pIC8gMzY1KTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBUT0RPXG5cdGV4cG9ydHMuWUlFTEQgPSBmdW5jdGlvbigpIHtcblx0IHRocm93IG5ldyBFcnJvcignWUlFTEQgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLllJRUxERElTQyA9IGZ1bmN0aW9uKCkge1xuXHQgdGhyb3cgbmV3IEVycm9yKCdZSUVMRERJU0MgaXMgbm90IGltcGxlbWVudGVkJyk7XG5cdH07XG5cblx0Ly8gVE9ET1xuXHRleHBvcnRzLllJRUxETUFUID0gZnVuY3Rpb24oKSB7XG5cdCB0aHJvdyBuZXcgRXJyb3IoJ1lJRUxETUFUIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBlcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblx0ZXhwb3J0cy5NQVRDSCA9IGZ1bmN0aW9uKGxvb2t1cFZhbHVlLCBsb29rdXBBcnJheSwgbWF0Y2hUeXBlKSB7XG5cdCAgaWYgKCFsb29rdXBWYWx1ZSAmJiAhbG9va3VwQXJyYXkpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgbWF0Y2hUeXBlID0gMTtcblx0ICB9XG5cdCAgaWYgKCEobG9va3VwQXJyYXkgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0ICAgIHJldHVybiBlcnJvci5uYTtcblx0ICB9XG5cblx0ICBpZiAobWF0Y2hUeXBlICE9PSAtMSAmJiBtYXRjaFR5cGUgIT09IDAgJiYgbWF0Y2hUeXBlICE9PSAxKSB7XG5cdCAgICByZXR1cm4gZXJyb3IubmE7XG5cdCAgfVxuXHQgIHZhciBpbmRleDtcblx0ICB2YXIgaW5kZXhWYWx1ZTtcblx0ICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBBcnJheS5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICBpZiAobWF0Y2hUeXBlID09PSAxKSB7XG5cdCAgICAgIGlmIChsb29rdXBBcnJheVtpZHhdID09PSBsb29rdXBWYWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBpZHggKyAxO1xuXHQgICAgICB9IGVsc2UgaWYgKGxvb2t1cEFycmF5W2lkeF0gPCBsb29rdXBWYWx1ZSkge1xuXHQgICAgICAgIGlmICghaW5kZXhWYWx1ZSkge1xuXHQgICAgICAgICAgaW5kZXggPSBpZHggKyAxO1xuXHQgICAgICAgICAgaW5kZXhWYWx1ZSA9IGxvb2t1cEFycmF5W2lkeF07XG5cdCAgICAgICAgfSBlbHNlIGlmIChsb29rdXBBcnJheVtpZHhdID4gaW5kZXhWYWx1ZSkge1xuXHQgICAgICAgICAgaW5kZXggPSBpZHggKyAxO1xuXHQgICAgICAgICAgaW5kZXhWYWx1ZSA9IGxvb2t1cEFycmF5W2lkeF07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG1hdGNoVHlwZSA9PT0gMCkge1xuXHQgICAgICBpZiAodHlwZW9mIGxvb2t1cFZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIGxvb2t1cFZhbHVlID0gbG9va3VwVmFsdWUucmVwbGFjZSgvXFw/L2csICcuJyk7XG5cdCAgICAgICAgaWYgKGxvb2t1cEFycmF5W2lkeF0udG9Mb3dlckNhc2UoKS5tYXRjaChsb29rdXBWYWx1ZS50b0xvd2VyQ2FzZSgpKSkge1xuXHQgICAgICAgICAgcmV0dXJuIGlkeCArIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChsb29rdXBBcnJheVtpZHhdID09PSBsb29rdXBWYWx1ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGlkeCArIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKG1hdGNoVHlwZSA9PT0gLTEpIHtcblx0ICAgICAgaWYgKGxvb2t1cEFycmF5W2lkeF0gPT09IGxvb2t1cFZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGlkeCArIDE7XG5cdCAgICAgIH0gZWxzZSBpZiAobG9va3VwQXJyYXlbaWR4XSA+IGxvb2t1cFZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFpbmRleFZhbHVlKSB7XG5cdCAgICAgICAgICBpbmRleCA9IGlkeCArIDE7XG5cdCAgICAgICAgICBpbmRleFZhbHVlID0gbG9va3VwQXJyYXlbaWR4XTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGxvb2t1cEFycmF5W2lkeF0gPCBpbmRleFZhbHVlKSB7XG5cdCAgICAgICAgICBpbmRleCA9IGlkeCArIDE7XG5cdCAgICAgICAgICBpbmRleFZhbHVlID0gbG9va3VwQXJyYXlbaWR4XTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gaW5kZXggPyBpbmRleCA6IGVycm9yLm5hO1xuXHR9O1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47IiwidGhpcy5qJCA9IHRoaXMualN0YXQgPSAoZnVuY3Rpb24oTWF0aCwgdW5kZWZpbmVkKSB7XG5cbi8vIEZvciBxdWljayByZWZlcmVuY2UuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIENhbGN1bGF0ZSBjb3JyZWN0aW9uIGZvciBJRUVFIGVycm9yXG4vLyBUT0RPOiBUaGlzIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXByb3ZlZC5cbmZ1bmN0aW9uIGNhbGNSZHgobiwgbSkge1xuICB2YXIgdmFsID0gbiA+IG0gPyBuIDogbTtcbiAgcmV0dXJuIE1hdGgucG93KDEwLFxuICAgICAgICAgICAgICAgICAgMTcgLSB+fihNYXRoLmxvZygoKHZhbCA+IDApID8gdmFsIDogLXZhbCkpICogTWF0aC5MT0cxMEUpKTtcbn1cblxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInICYmIGFyZyA9PT0gYXJnO1xufVxuXG5cbi8vIENvbnZlcnRzIHRoZSBqU3RhdCBtYXRyaXggdG8gdmVjdG9yLlxuZnVuY3Rpb24gdG9WZWN0b3IoYXJyKSB7XG4gIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGFycik7XG59XG5cblxuLy8gVGhlIG9uZSBhbmQgb25seSBqU3RhdCBjb25zdHJ1Y3Rvci5cbmZ1bmN0aW9uIGpTdGF0KCkge1xuICByZXR1cm4gbmV3IGpTdGF0Ll9pbml0KGFyZ3VtZW50cyk7XG59XG5cblxuLy8gVE9ETzogUmVtb3ZlIGFmdGVyIGFsbCByZWZlcmVuY2VzIGluIHNyYyBmaWxlcyBoYXZlIGJlZW4gcmVtb3ZlZC5cbmpTdGF0LmZuID0galN0YXQucHJvdG90eXBlO1xuXG5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGluaXRpYWxpemVyIGZyb20gdGhlIGNvbnN0cnVjdG9yIGl0J3MgZWFzaWVyIHRvIGhhbmRsZVxuLy8gYWx3YXlzIHJldHVybmluZyBhIG5ldyBpbnN0YW5jZSB3aGV0aGVyIFwibmV3XCIgd2FzIHVzZWQgb3Igbm90LlxualN0YXQuX2luaXQgPSBmdW5jdGlvbiBfaW5pdChhcmdzKSB7XG4gIHZhciBpO1xuXG4gIC8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5LCBtdXN0IGJlIHZlY3RvciBvciBtYXRyaXguXG4gIGlmIChpc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgLy8gQ2hlY2sgaWYgbWF0cml4LlxuICAgIGlmIChpc0FycmF5KGFyZ3NbMF1bMF0pKSB7XG4gICAgICAvLyBTZWUgaWYgYSBtYXBwaW5nIGZ1bmN0aW9uIHdhcyBhbHNvIHBhc3NlZC5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZ3NbMV0pKVxuICAgICAgICBhcmdzWzBdID0galN0YXQubWFwKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggaXMgZmFzdGVyIHRoYW4gdGhpcy5wdXNoLmFwcGx5KHRoaXMsIGFyZ3NbMF0uXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnc1swXS5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpc1tpXSA9IGFyZ3NbMF1baV07XG4gICAgICB0aGlzLmxlbmd0aCA9IGFyZ3NbMF0ubGVuZ3RoO1xuXG4gICAgLy8gT3RoZXJ3aXNlIG11c3QgYmUgYSB2ZWN0b3IuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbMF0gPSBpc0Z1bmN0aW9uKGFyZ3NbMV0pID8galN0YXQubWFwKGFyZ3NbMF0sIGFyZ3NbMV0pIDogYXJnc1swXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgLy8gSWYgZmlyc3QgYXJndW1lbnQgaXMgbnVtYmVyLCBhc3N1bWUgY3JlYXRpb24gb2Ygc2VxdWVuY2UuXG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoYXJnc1swXSkpIHtcbiAgICB0aGlzWzBdID0galN0YXQuc2VxLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAvLyBIYW5kbGUgY2FzZSB3aGVuIGpTdGF0IG9iamVjdCBpcyBwYXNzZWQgdG8galN0YXQuXG4gIH0gZWxzZSBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIGpTdGF0KSB7XG4gICAgLy8gRHVwbGljYXRlIHRoZSBvYmplY3QgYW5kIHBhc3MgaXQgYmFjay5cbiAgICByZXR1cm4galN0YXQoYXJnc1swXS50b0FycmF5KCkpO1xuXG4gIC8vIFVuZXhwZWN0ZWQgYXJndW1lbnQgdmFsdWUsIHJldHVybiBlbXB0eSBqU3RhdCBvYmplY3QuXG4gIC8vIFRPRE86IFRoaXMgaXMgc3RyYW5nZSBiZWhhdmlvci4gU2hvdWxkbid0IHRoaXMgdGhyb3cgb3Igc29tZSBzdWNoIHRvIGxldFxuICAvLyB0aGUgdXNlciBrbm93IHRoZXkgaGFkIGJhZCBhcmd1bWVudHM/XG4gIH0gZWxzZSB7XG4gICAgdGhpc1swXSA9IFtdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbmpTdGF0Ll9pbml0LnByb3RvdHlwZSA9IGpTdGF0LnByb3RvdHlwZTtcbmpTdGF0Ll9pbml0LmNvbnN0cnVjdG9yID0galN0YXQ7XG5cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMuXG4vLyBUT0RPOiBmb3IgaW50ZXJuYWwgdXNlIG9ubHk/XG5qU3RhdC51dGlscyA9IHtcbiAgY2FsY1JkeDogY2FsY1JkeCxcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICB0b1ZlY3RvcjogdG9WZWN0b3Jcbn07XG5cblxuLy8gRWFzaWx5IGV4dGVuZCB0aGUgalN0YXQgb2JqZWN0LlxuLy8gVE9ETzogaXMgdGhpcyBzZXJpb3VzbHkgbmVjZXNzYXJ5P1xualN0YXQuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICB2YXIgaSwgajtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGZvciAoaiBpbiBvYmopXG4gICAgICBqU3RhdFtqXSA9IG9ialtqXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGogaW4gYXJndW1lbnRzW2ldKVxuICAgICAgb2JqW2pdID0gYXJndW1lbnRzW2ldW2pdO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeC5cbmpTdGF0LnJvd3MgPSBmdW5jdGlvbiByb3dzKGFycikge1xuICByZXR1cm4gYXJyLmxlbmd0aCB8fCAxO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4LlxualN0YXQuY29scyA9IGZ1bmN0aW9uIGNvbHMoYXJyKSB7XG4gIHJldHVybiBhcnJbMF0ubGVuZ3RoIHx8IDE7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9iamVjdCB7IHJvd3M6IGksIGNvbHM6IGogfVxualN0YXQuZGltZW5zaW9ucyA9IGZ1bmN0aW9uIGRpbWVuc2lvbnMoYXJyKSB7XG4gIHJldHVybiB7XG4gICAgcm93czogalN0YXQucm93cyhhcnIpLFxuICAgIGNvbHM6IGpTdGF0LmNvbHMoYXJyKVxuICB9O1xufTtcblxuXG4vLyBSZXR1cm5zIGEgc3BlY2lmaWVkIHJvdyBhcyBhIHZlY3RvclxualN0YXQucm93ID0gZnVuY3Rpb24gcm93KGFyciwgaW5kZXgpIHtcbiAgcmV0dXJuIGFycltpbmRleF07XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIHNwZWNpZmllZCBjb2x1bW4gYXMgYSB2ZWN0b3JcbmpTdGF0LmNvbCA9IGZ1bmN0aW9uIGNvbHMoYXJyLCBpbmRleCkge1xuICB2YXIgY29sdW1uID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICBjb2x1bW5baV0gPSBbYXJyW2ldW2luZGV4XV07XG4gIHJldHVybiBjb2x1bW47XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGRpYWdvbmFsIG9mIHRoZSBtYXRyaXhcbmpTdGF0LmRpYWcgPSBmdW5jdGlvbiBkaWFnKGFycikge1xuICB2YXIgbnJvdyA9IGpTdGF0LnJvd3MoYXJyKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShucm93KTtcbiAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbnJvdzsgcm93KyspXG4gICAgcmVzW3Jvd10gPSBbYXJyW3Jvd11bcm93XV07XG4gIHJldHVybiByZXM7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGFudGktZGlhZ29uYWwgb2YgdGhlIG1hdHJpeFxualN0YXQuYW50aWRpYWcgPSBmdW5jdGlvbiBhbnRpZGlhZyhhcnIpIHtcbiAgdmFyIG5yb3cgPSBqU3RhdC5yb3dzKGFycikgLSAxO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG5yb3cpO1xuICBmb3IgKHZhciBpID0gMDsgbnJvdyA+PSAwOyBucm93LS0sIGkrKylcbiAgICByZXNbaV0gPSBbYXJyW2ldW25yb3ddXTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIFRyYW5zcG9zZSBhIG1hdHJpeCBvciBhcnJheS5cbmpTdGF0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZShhcnIpIHtcbiAgdmFyIG9iaiA9IFtdO1xuICB2YXIgb2JqQXJyLCByb3dzLCBjb2xzLCBqLCBpO1xuXG4gIC8vIE1ha2Ugc3VyZSBhcnIgaXMgaW4gbWF0cml4IGZvcm1hdC5cbiAgaWYgKCFpc0FycmF5KGFyclswXSkpXG4gICAgYXJyID0gW2Fycl07XG5cbiAgcm93cyA9IGFyci5sZW5ndGg7XG4gIGNvbHMgPSBhcnJbMF0ubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcbiAgICBvYmpBcnIgPSBuZXcgQXJyYXkocm93cyk7XG4gICAgZm9yIChqID0gMDsgaiA8IHJvd3M7IGorKylcbiAgICAgIG9iakFycltqXSA9IGFycltqXVtpXTtcbiAgICBvYmoucHVzaChvYmpBcnIpO1xuICB9XG5cbiAgLy8gSWYgb2JqIGlzIHZlY3RvciwgcmV0dXJuIG9ubHkgc2luZ2xlIGFycmF5LlxuICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMSA/IG9ialswXSA6IG9iajtcbn07XG5cblxuLy8gTWFwIGEgZnVuY3Rpb24gdG8gYW4gYXJyYXkgb3IgYXJyYXkgb2YgYXJyYXlzLlxuLy8gXCJ0b0FsdGVyXCIgaXMgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG5qU3RhdC5tYXAgPSBmdW5jdGlvbiBtYXAoYXJyLCBmdW5jLCB0b0FsdGVyKSB7XG4gIHZhciByb3csIG5yb3csIG5jb2wsIHJlcywgY29sO1xuXG4gIGlmICghaXNBcnJheShhcnJbMF0pKVxuICAgIGFyciA9IFthcnJdO1xuXG4gIG5yb3cgPSBhcnIubGVuZ3RoO1xuICBuY29sID0gYXJyWzBdLmxlbmd0aDtcbiAgcmVzID0gdG9BbHRlciA/IGFyciA6IG5ldyBBcnJheShucm93KTtcblxuICBmb3IgKHJvdyA9IDA7IHJvdyA8IG5yb3c7IHJvdysrKSB7XG4gICAgLy8gaWYgdGhlIHJvdyBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICBpZiAoIXJlc1tyb3ddKVxuICAgICAgcmVzW3Jvd10gPSBuZXcgQXJyYXkobmNvbCk7XG4gICAgZm9yIChjb2wgPSAwOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgIHJlc1tyb3ddW2NvbF0gPSBmdW5jKGFycltyb3ddW2NvbF0sIHJvdywgY29sKTtcbiAgfVxuXG4gIHJldHVybiByZXMubGVuZ3RoID09PSAxID8gcmVzWzBdIDogcmVzO1xufTtcblxuXG4vLyBEZXN0cnVjdGl2ZWx5IGFsdGVyIGFuIGFycmF5LlxualN0YXQuYWx0ZXIgPSBmdW5jdGlvbiBhbHRlcihhcnIsIGZ1bmMpIHtcbiAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmMsIHRydWUpO1xufTtcblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBhY2NvcmRpbmcgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLlxualN0YXQuY3JlYXRlID0gZnVuY3Rpb24gIGNyZWF0ZShyb3dzLCBjb2xzLCBmdW5jKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkocm93cyk7XG4gIHZhciBpLCBqO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGNvbHMpKSB7XG4gICAgZnVuYyA9IGNvbHM7XG4gICAgY29scyA9IHJvd3M7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgcmVzW2ldID0gbmV3IEFycmF5KGNvbHMpO1xuICAgIGZvciAoaiA9IDA7IGogPCBjb2xzOyBqKyspXG4gICAgICByZXNbaV1bal0gPSBmdW5jKGksIGopO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuZnVuY3Rpb24gcmV0WmVybygpIHsgcmV0dXJuIDA7IH1cblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBvZiB6ZXJvcy5cbmpTdGF0Lnplcm9zID0gZnVuY3Rpb24gemVyb3Mocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIHJldFplcm8pO1xufTtcblxuXG5mdW5jdGlvbiByZXRPbmUoKSB7IHJldHVybiAxOyB9XG5cblxuLy8gR2VuZXJhdGUgYSByb3dzIHggY29scyBtYXRyaXggb2Ygb25lcy5cbmpTdGF0Lm9uZXMgPSBmdW5jdGlvbiBvbmVzKHJvd3MsIGNvbHMpIHtcbiAgaWYgKCFpc051bWJlcihjb2xzKSlcbiAgICBjb2xzID0gcm93cztcbiAgcmV0dXJuIGpTdGF0LmNyZWF0ZShyb3dzLCBjb2xzLCByZXRPbmUpO1xufTtcblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBvZiB1bmlmb3JtbHkgcmFuZG9tIG51bWJlcnMuXG5qU3RhdC5yYW5kID0gZnVuY3Rpb24gcmFuZChyb3dzLCBjb2xzKSB7XG4gIGlmICghaXNOdW1iZXIoY29scykpXG4gICAgY29scyA9IHJvd3M7XG4gIHJldHVybiBqU3RhdC5jcmVhdGUocm93cywgY29scywgTWF0aC5yYW5kb20pO1xufTtcblxuXG5mdW5jdGlvbiByZXRJZGVudChpLCBqKSB7IHJldHVybiBpID09PSBqID8gMSA6IDA7IH1cblxuXG4vLyBHZW5lcmF0ZSBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSByb3cgeCBjb2xzLlxualN0YXQuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShyb3dzLCBjb2xzKSB7XG4gIGlmICghaXNOdW1iZXIoY29scykpXG4gICAgY29scyA9IHJvd3M7XG4gIHJldHVybiBqU3RhdC5jcmVhdGUocm93cywgY29scywgcmV0SWRlbnQpO1xufTtcblxuXG4vLyBUZXN0cyB3aGV0aGVyIGEgbWF0cml4IGlzIHN5bW1ldHJpY1xualN0YXQuc3ltbWV0cmljID0gZnVuY3Rpb24gc3ltbWV0cmljKGFycikge1xuICB2YXIgaXNzeW1tZXRyaWMgPSB0cnVlO1xuICB2YXIgc2l6ZSA9IGFyci5sZW5ndGg7XG4gIHZhciByb3csIGNvbDtcblxuICBpZiAoYXJyLmxlbmd0aCAhPT0gYXJyWzBdLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChyb3cgPSAwOyByb3cgPCBzaXplOyByb3crKykge1xuICAgIGZvciAoY29sID0gMDsgY29sIDwgc2l6ZTsgY29sKyspXG4gICAgICBpZiAoYXJyW2NvbF1bcm93XSAhPT0gYXJyW3Jvd11bY29sXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFNldCBhbGwgdmFsdWVzIHRvIHplcm8uXG5qU3RhdC5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKGFycikge1xuICByZXR1cm4galN0YXQuYWx0ZXIoYXJyLCByZXRaZXJvKTtcbn07XG5cblxuLy8gR2VuZXJhdGUgc2VxdWVuY2UuXG5qU3RhdC5zZXEgPSBmdW5jdGlvbiBzZXEobWluLCBtYXgsIGxlbmd0aCwgZnVuYykge1xuICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpXG4gICAgZnVuYyA9IGZhbHNlO1xuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhpdmFsID0gY2FsY1JkeChtaW4sIG1heCk7XG4gIHZhciBzdGVwID0gKG1heCAqIGhpdmFsIC0gbWluICogaGl2YWwpIC8gKChsZW5ndGggLSAxKSAqIGhpdmFsKTtcbiAgdmFyIGN1cnJlbnQgPSBtaW47XG4gIHZhciBjbnQ7XG5cbiAgLy8gQ3VycmVudCBpcyBhc3NpZ25lZCB1c2luZyBhIHRlY2huaXF1ZSB0byBjb21wZW5zYXRlIGZvciBJRUVFIGVycm9yLlxuICAvLyBUT0RPOiBOZWVkcyBiZXR0ZXIgaW1wbGVtZW50YXRpb24uXG4gIGZvciAoY250ID0gMDtcbiAgICAgICBjdXJyZW50IDw9IG1heDtcbiAgICAgICBjbnQrKywgY3VycmVudCA9IChtaW4gKiBoaXZhbCArIHN0ZXAgKiBoaXZhbCAqIGNudCkgLyBoaXZhbCkge1xuICAgIGFyci5wdXNoKChmdW5jID8gZnVuYyhjdXJyZW50LCBjbnQpIDogY3VycmVudCkpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuLy8gVE9ETzogR28gb3ZlciB0aGlzIGVudGlyZSBpbXBsZW1lbnRhdGlvbi4gU2VlbXMgYSB0cmFnaWMgd2FzdGUgb2YgcmVzb3VyY2VzXG4vLyBkb2luZyBhbGwgdGhpcyB3b3JrLiBJbnN0ZWFkLCBhbmQgd2hpbGUgdWdseSwgdXNlIG5ldyBGdW5jdGlvbigpIHRvIGdlbmVyYXRlXG4vLyBhIGN1c3RvbSBmdW5jdGlvbiBmb3IgZWFjaCBzdGF0aWMgbWV0aG9kLlxuXG4vLyBRdWljayByZWZlcmVuY2UuXG52YXIgalByb3RvID0galN0YXQucHJvdG90eXBlO1xuXG4vLyBEZWZhdWx0IGxlbmd0aC5cbmpQcm90by5sZW5ndGggPSAwO1xuXG4vLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4vLyBUT0RPOiBDaGVjayBpZiB0aGV5J3JlIGFjdHVhbGx5IHVzZWQsIGFuZCBpZiB0aGV5IGFyZSB0aGVuIHJlbmFtZSB0aGVtXG4vLyB0byBfKlxualByb3RvLnB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmpQcm90by5zb3J0ID0gQXJyYXkucHJvdG90eXBlLnNvcnQ7XG5qUHJvdG8uc3BsaWNlID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcbmpQcm90by5zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuXG4vLyBSZXR1cm4gYSBjbGVhbiBhcnJheS5cbmpQcm90by50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwodGhpcykgOiBzbGljZS5jYWxsKHRoaXMpWzBdO1xufTtcblxuXG4vLyBNYXAgYSBmdW5jdGlvbiB0byBhIG1hdHJpeCBvciB2ZWN0b3IuXG5qUHJvdG8ubWFwID0gZnVuY3Rpb24gbWFwKGZ1bmMsIHRvQWx0ZXIpIHtcbiAgcmV0dXJuIGpTdGF0KGpTdGF0Lm1hcCh0aGlzLCBmdW5jLCB0b0FsdGVyKSk7XG59O1xuXG5cbi8vIERlc3RydWN0aXZlbHkgYWx0ZXIgYW4gYXJyYXkuXG5qUHJvdG8uYWx0ZXIgPSBmdW5jdGlvbiBhbHRlcihmdW5jKSB7XG4gIGpTdGF0LmFsdGVyKHRoaXMsIGZ1bmMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLy8gRXh0ZW5kIHByb3RvdHlwZSB3aXRoIG1ldGhvZHMgdGhhdCBoYXZlIG5vIGFyZ3VtZW50LlxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICByZXN1bHRzO1xuICAgICAgLy8gQ2hlY2sgZm9yIGNhbGxiYWNrLlxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwoc2VsZiwgalByb3RvW3Bhc3NmdW5jXS5jYWxsKHNlbGYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmVzdWx0cyA9IGpTdGF0W3Bhc3NmdW5jXSh0aGlzKTtcbiAgICAgIHJldHVybiBpc0FycmF5KHJlc3VsdHMpID8galN0YXQocmVzdWx0cykgOiByZXN1bHRzO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCd0cmFuc3Bvc2UgY2xlYXIgc3ltbWV0cmljIHJvd3MgY29scyBkaW1lbnNpb25zIGRpYWcgYW50aWRpYWcnLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4dGVuZCBwcm90b3R5cGUgd2l0aCBtZXRob2RzIHRoYXQgaGF2ZSBvbmUgYXJndW1lbnQuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalByb3RvW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKGluZGV4LCBmdW5jKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvLyBjaGVjayBmb3IgY2FsbGJhY2tcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKHNlbGYsIGpQcm90b1twYXNzZnVuY10uY2FsbChzZWxmLCBpbmRleCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4galN0YXQoalN0YXRbcGFzc2Z1bmNdKHRoaXMsIGluZGV4KSk7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ3JvdyBjb2wnLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4dGVuZCBwcm90b3R5cGUgd2l0aCBzaW1wbGUgc2hvcnRjdXQgbWV0aG9kcy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gbmV3IEZ1bmN0aW9uKFxuICAgICAgICAncmV0dXJuIGpTdGF0KGpTdGF0LicgKyBwYXNzZnVuYyArICcuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7Jyk7XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCdjcmVhdGUgemVyb3Mgb25lcyByYW5kIGlkZW50aXR5Jy5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHBvc2luZyBqU3RhdC5cbnJldHVybiBqU3RhdDtcblxufShNYXRoKSk7XG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxudmFyIGlzRnVuY3Rpb24gPSBqU3RhdC51dGlscy5pc0Z1bmN0aW9uO1xuXG4vLyBBc2NlbmRpbmcgZnVuY3Rpb25zIGZvciBzb3J0XG5mdW5jdGlvbiBhc2NOdW0oYSwgYikgeyByZXR1cm4gYSAtIGI7IH1cblxuZnVuY3Rpb24gY2xpcChhcmcsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKGFyZywgbWF4KSk7XG59XG5cblxuLy8gc3VtIG9mIGFuIGFycmF5XG5qU3RhdC5zdW0gPSBmdW5jdGlvbiBzdW0oYXJyKSB7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHZhciB0bXA7XG4gIHdoaWxlICgtLWkgPj0gMClcbiAgICBzdW0gKz0gYXJyW2ldO1xuICByZXR1cm4gc3VtO1xufTtcblxuXG4vLyBzdW0gc3F1YXJlZFxualN0YXQuc3Vtc3FyZCA9IGZ1bmN0aW9uIHN1bXNxcmQoYXJyKSB7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlICgtLWkgPj0gMClcbiAgICBzdW0gKz0gYXJyW2ldICogYXJyW2ldO1xuICByZXR1cm4gc3VtO1xufTtcblxuXG4vLyBzdW0gb2Ygc3F1YXJlZCBlcnJvcnMgb2YgcHJlZGljdGlvbiAoU1NFKVxualN0YXQuc3Vtc3FlcnIgPSBmdW5jdGlvbiBzdW1zcWVycihhcnIpIHtcbiAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKGFycik7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHZhciB0bXA7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIHRtcCA9IGFycltpXSAtIG1lYW47XG4gICAgc3VtICs9IHRtcCAqIHRtcDtcbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuXG4vLyBwcm9kdWN0IG9mIGFuIGFycmF5XG5qU3RhdC5wcm9kdWN0ID0gZnVuY3Rpb24gcHJvZHVjdChhcnIpIHtcbiAgdmFyIHByb2QgPSAxO1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlICgtLWkgPj0gMClcbiAgICBwcm9kICo9IGFycltpXTtcbiAgcmV0dXJuIHByb2Q7XG59O1xuXG5cbi8vIG1pbmltdW0gdmFsdWUgb2YgYW4gYXJyYXlcbmpTdGF0Lm1pbiA9IGZ1bmN0aW9uIG1pbihhcnIpIHtcbiAgdmFyIGxvdyA9IGFyclswXTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYXJyLmxlbmd0aClcbiAgICBpZiAoYXJyW2ldIDwgbG93KVxuICAgICAgbG93ID0gYXJyW2ldO1xuICByZXR1cm4gbG93O1xufTtcblxuXG4vLyBtYXhpbXVtIHZhbHVlIG9mIGFuIGFycmF5XG5qU3RhdC5tYXggPSBmdW5jdGlvbiBtYXgoYXJyKSB7XG4gIHZhciBoaWdoID0gYXJyWzBdO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBhcnIubGVuZ3RoKVxuICAgIGlmIChhcnJbaV0gPiBoaWdoKVxuICAgICAgaGlnaCA9IGFycltpXTtcbiAgcmV0dXJuIGhpZ2g7XG59O1xuXG5cbi8vIG1lYW4gdmFsdWUgb2YgYW4gYXJyYXlcbmpTdGF0Lm1lYW4gPSBmdW5jdGlvbiBtZWFuKGFycikge1xuICByZXR1cm4galN0YXQuc3VtKGFycikgLyBhcnIubGVuZ3RoO1xufTtcblxuXG4vLyBtZWFuIHNxdWFyZWQgZXJyb3IgKE1TRSlcbmpTdGF0Lm1lYW5zcWVyciA9IGZ1bmN0aW9uIG1lYW5zcWVycihhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LnN1bXNxZXJyKGFycikgLyBhcnIubGVuZ3RoO1xufTtcblxuXG4vLyBnZW9tZXRyaWMgbWVhbiBvZiBhbiBhcnJheVxualN0YXQuZ2VvbWVhbiA9IGZ1bmN0aW9uIGdlb21lYW4oYXJyKSB7XG4gIHJldHVybiBNYXRoLnBvdyhqU3RhdC5wcm9kdWN0KGFyciksIDEgLyBhcnIubGVuZ3RoKTtcbn07XG5cblxuLy8gbWVkaWFuIG9mIGFuIGFycmF5XG5qU3RhdC5tZWRpYW4gPSBmdW5jdGlvbiBtZWRpYW4oYXJyKSB7XG4gIHZhciBhcnJsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgLy8gY2hlY2sgaWYgYXJyYXkgaXMgZXZlbiBvciBvZGQsIHRoZW4gcmV0dXJuIHRoZSBhcHByb3ByaWF0ZVxuICByZXR1cm4gIShhcnJsZW4gJiAxKVxuICAgID8gKF9hcnJbKGFycmxlbiAvIDIpIC0gMSBdICsgX2FyclsoYXJybGVuIC8gMildKSAvIDJcbiAgICA6IF9hcnJbKGFycmxlbiAvIDIpIHwgMCBdO1xufTtcblxuXG4vLyBjdW11bGF0aXZlIHN1bSBvZiBhbiBhcnJheVxualN0YXQuY3Vtc3VtID0gZnVuY3Rpb24gY3Vtc3VtKGFycikge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHN1bXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIGk7XG4gIHN1bXNbMF0gPSBhcnJbMF07XG4gIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICBzdW1zW2ldID0gc3Vtc1tpIC0gMV0gKyBhcnJbaV07XG4gIHJldHVybiBzdW1zO1xufTtcblxuXG4vLyBzdWNjZXNzaXZlIGRpZmZlcmVuY2VzIG9mIGEgc2VxdWVuY2VcbmpTdGF0LmRpZmYgPSBmdW5jdGlvbiBkaWZmKGFycikge1xuICB2YXIgZGlmZnMgPSBbXTtcbiAgdmFyIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAxOyBpIDwgYXJyTGVuOyBpKyspXG4gICAgZGlmZnMucHVzaChhcnJbaV0gLSBhcnJbaSAtIDFdKTtcbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vLyBtb2RlIG9mIGFuIGFycmF5XG4vLyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbW9kZXMgb2YgYW4gYXJyYXksIHJldHVybiBhbGwgb2YgdGhlbVxuLy8gaXMgdGhpcyB0aGUgYXBwcm9wcmlhdGUgd2F5IG9mIGhhbmRsaW5nIGl0P1xualN0YXQubW9kZSA9IGZ1bmN0aW9uIG1vZGUoYXJyKSB7XG4gIHZhciBhcnJMZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgdmFyIGNvdW50ID0gMTtcbiAgdmFyIG1heENvdW50ID0gMDtcbiAgdmFyIG51bU1heENvdW50ID0gMDtcbiAgdmFyIG1vZGVfYXJyID0gW107XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47IGkrKykge1xuICAgIGlmIChfYXJyW2ldID09PSBfYXJyW2kgKyAxXSkge1xuICAgICAgY291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvdW50ID4gbWF4Q291bnQpIHtcbiAgICAgICAgbW9kZV9hcnIgPSBbX2FycltpXV07XG4gICAgICAgIG1heENvdW50ID0gY291bnQ7XG4gICAgICAgIG51bU1heENvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIGFyZSB0aGVyZSBtdWx0aXBsZSBtYXggY291bnRzXG4gICAgICBlbHNlIGlmIChjb3VudCA9PT0gbWF4Q291bnQpIHtcbiAgICAgICAgbW9kZV9hcnIucHVzaChfYXJyW2ldKTtcbiAgICAgICAgbnVtTWF4Q291bnQrKztcbiAgICAgIH1cbiAgICAgIC8vIHJlc2V0dGluZyBjb3VudCBmb3IgbmV3IHZhbHVlIGluIGFycmF5XG4gICAgICBjb3VudCA9IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bU1heENvdW50ID09PSAwID8gbW9kZV9hcnJbMF0gOiBtb2RlX2Fycjtcbn07XG5cblxuLy8gcmFuZ2Ugb2YgYW4gYXJyYXlcbmpTdGF0LnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoYXJyKSB7XG4gIHJldHVybiBqU3RhdC5tYXgoYXJyKSAtIGpTdGF0Lm1pbihhcnIpO1xufTtcblxuLy8gdmFyaWFuY2Ugb2YgYW4gYXJyYXlcbi8vIGZsYWcgaW5kaWNhdGVzIHBvcHVsYXRpb24gdnMgc2FtcGxlXG5qU3RhdC52YXJpYW5jZSA9IGZ1bmN0aW9uIHZhcmlhbmNlKGFyciwgZmxhZykge1xuICByZXR1cm4galN0YXQuc3Vtc3FlcnIoYXJyKSAvIChhcnIubGVuZ3RoIC0gKGZsYWcgPyAxIDogMCkpO1xufTtcblxuXG4vLyBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXlcbi8vIGZsYWcgaW5kaWNhdGVzIHBvcHVsYXRpb24gdnMgc2FtcGxlXG5qU3RhdC5zdGRldiA9IGZ1bmN0aW9uIHN0ZGV2KGFyciwgZmxhZykge1xuICByZXR1cm4gTWF0aC5zcXJ0KGpTdGF0LnZhcmlhbmNlKGFyciwgZmxhZykpO1xufTtcblxuXG4vLyBtZWFuIGRldmlhdGlvbiAobWVhbiBhYnNvbHV0ZSBkZXZpYXRpb24pIG9mIGFuIGFycmF5XG5qU3RhdC5tZWFuZGV2ID0gZnVuY3Rpb24gbWVhbmRldihhcnIpIHtcbiAgdmFyIGRldlN1bSA9IDA7XG4gIHZhciBtZWFuID0galN0YXQubWVhbihhcnIpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIGRldlN1bSArPSBNYXRoLmFicyhhcnJbaV0gLSBtZWFuKTtcbiAgcmV0dXJuIGRldlN1bSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIG1lZGlhbiBkZXZpYXRpb24gKG1lZGlhbiBhYnNvbHV0ZSBkZXZpYXRpb24pIG9mIGFuIGFycmF5XG5qU3RhdC5tZWRkZXYgPSBmdW5jdGlvbiBtZWRkZXYoYXJyKSB7XG4gIHZhciBkZXZTdW0gPSAwO1xuICB2YXIgbWVkaWFuID0galN0YXQubWVkaWFuKGFycik7XG4gIHZhciBpO1xuICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgZGV2U3VtICs9IE1hdGguYWJzKGFycltpXSAtIG1lZGlhbik7XG4gIHJldHVybiBkZXZTdW0gLyBhcnIubGVuZ3RoO1xufTtcblxuXG4vLyBjb2VmZmljaWVudCBvZiB2YXJpYXRpb25cbmpTdGF0LmNvZWZmdmFyID0gZnVuY3Rpb24gY29lZmZ2YXIoYXJyKSB7XG4gIHJldHVybiBqU3RhdC5zdGRldihhcnIpIC8galN0YXQubWVhbihhcnIpO1xufTtcblxuXG4vLyBxdWFydGlsZXMgb2YgYW4gYXJyYXlcbmpTdGF0LnF1YXJ0aWxlcyA9IGZ1bmN0aW9uIHF1YXJ0aWxlcyhhcnIpIHtcbiAgdmFyIGFycmxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBfYXJyID0gYXJyLnNsaWNlKCkuc29ydChhc2NOdW0pO1xuICByZXR1cm4gW1xuICAgIF9hcnJbIE1hdGgucm91bmQoKGFycmxlbikgLyA0KSAtIDEgXSxcbiAgICBfYXJyWyBNYXRoLnJvdW5kKChhcnJsZW4pIC8gMikgLSAxIF0sXG4gICAgX2FyclsgTWF0aC5yb3VuZCgoYXJybGVuKSAqIDMgLyA0KSAtIDEgXVxuICBdO1xufTtcblxuXG4vLyBBcmJpdGFyeSBxdWFudGlsZXMgb2YgYW4gYXJyYXkuIERpcmVjdCBwb3J0IG9mIHRoZSBzY2lweS5zdGF0c1xuLy8gaW1wbGVtZW50YXRpb24gYnkgUGllcnJlIEdGIEdlcmFyZC1NYXJjaGFudC5cbmpTdGF0LnF1YW50aWxlcyA9IGZ1bmN0aW9uIHF1YW50aWxlcyhhcnIsIHF1YW50aWxlc0FycmF5LCBhbHBoYXAsIGJldGFwKSB7XG4gIHZhciBzb3J0ZWRBcnJheSA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgdmFyIHF1YW50aWxlVmFscyA9IFtxdWFudGlsZXNBcnJheS5sZW5ndGhdO1xuICB2YXIgbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpLCBwLCBtLCBhbGVwaCwgaywgZ2FtbWE7XG5cbiAgaWYgKHR5cGVvZiBhbHBoYXAgPT09ICd1bmRlZmluZWQnKVxuICAgIGFscGhhcCA9IDMgLyA4O1xuICBpZiAodHlwZW9mIGJldGFwID09PSAndW5kZWZpbmVkJylcbiAgICBiZXRhcCA9IDMgLyA4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBxdWFudGlsZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHAgPSBxdWFudGlsZXNBcnJheVtpXTtcbiAgICBtID0gYWxwaGFwICsgcCAqICgxIC0gYWxwaGFwIC0gYmV0YXApO1xuICAgIGFsZXBoID0gbiAqIHAgKyBtO1xuICAgIGsgPSBNYXRoLmZsb29yKGNsaXAoYWxlcGgsIDEsIG4gLSAxKSk7XG4gICAgZ2FtbWEgPSBjbGlwKGFsZXBoIC0gaywgMCwgMSk7XG4gICAgcXVhbnRpbGVWYWxzW2ldID0gKDEgLSBnYW1tYSkgKiBzb3J0ZWRBcnJheVtrIC0gMV0gKyBnYW1tYSAqIHNvcnRlZEFycmF5W2tdO1xuICB9XG5cbiAgcmV0dXJuIHF1YW50aWxlVmFscztcbn07XG5cbi8vIFRoZSBwZXJjZW50aWxlIHJhbmsgb2Ygc2NvcmUgaW4gYSBnaXZlbiBhcnJheS4gUmV0dXJucyB0aGUgcGVyY2VudGFnZVxuLy8gb2YgYWxsIHZhbHVlcyBpbiB0aGUgaW5wdXQgYXJyYXkgdGhhdCBhcmUgbGVzcyB0aGFuIChraW5kPSdzdHJpY3QnKSBvclxuLy8gbGVzcyBvciBlcXVhbCB0aGFuIChraW5kPSd3ZWFrJykgc2NvcmUuIERlZmF1bHQgaXMgd2Vhay5cbmpTdGF0LnBlcmNlbnRpbGVPZlNjb3JlID0gZnVuY3Rpb24gcGVyY2VudGlsZU9mU2NvcmUoYXJyLCBzY29yZSwga2luZCkge1xuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgc3RyaWN0ID0gZmFsc2U7XG4gIHZhciB2YWx1ZSwgaTtcblxuICBpZiAoa2luZCA9PT0gJ3N0cmljdCcpXG4gICAgc3RyaWN0ID0gdHJ1ZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycltpXTtcbiAgICBpZiAoKHN0cmljdCAmJiB2YWx1ZSA8IHNjb3JlKSB8fFxuICAgICAgICAoIXN0cmljdCAmJiB2YWx1ZSA8PSBzY29yZSkpIHtcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY291bnRlciAvIGxlbjtcbn07XG5cbi8vIGNvdmFyaWFuY2Ugb2YgdHdvIGFycmF5c1xualN0YXQuY292YXJpYW5jZSA9IGZ1bmN0aW9uIGNvdmFyaWFuY2UoYXJyMSwgYXJyMikge1xuICB2YXIgdSA9IGpTdGF0Lm1lYW4oYXJyMSk7XG4gIHZhciB2ID0galN0YXQubWVhbihhcnIyKTtcbiAgdmFyIGFycjFMZW4gPSBhcnIxLmxlbmd0aDtcbiAgdmFyIHNxX2RldiA9IG5ldyBBcnJheShhcnIxTGVuKTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGFycjFMZW47IGkrKylcbiAgICBzcV9kZXZbaV0gPSAoYXJyMVtpXSAtIHUpICogKGFycjJbaV0gLSB2KTtcblxuICByZXR1cm4galN0YXQuc3VtKHNxX2RldikgLyAoYXJyMUxlbiAtIDEpO1xufTtcblxuXG4vLyAocGVhcnNvbidzKSBwb3B1bGF0aW9uIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50LCByaG9cbmpTdGF0LmNvcnJjb2VmZiA9IGZ1bmN0aW9uIGNvcnJjb2VmZihhcnIxLCBhcnIyKSB7XG4gIHJldHVybiBqU3RhdC5jb3ZhcmlhbmNlKGFycjEsIGFycjIpIC9cbiAgICAgIGpTdGF0LnN0ZGV2KGFycjEsIDEpIC9cbiAgICAgIGpTdGF0LnN0ZGV2KGFycjIsIDEpO1xufTtcblxuXG52YXIgalByb3RvID0galN0YXQucHJvdG90eXBlO1xuXG5cbi8vIEV4dGVuZCBqUHJvdG8gd2l0aCBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIGN1bXVsYXRpdmUgc3VtcywgYXMgaXQgZG9lcyBub3Rcbi8vIHJ1biBhZ2FpbiBpbiBjYXNlIG9mIHRydWUuXG4vLyBJZiBhIG1hdHJpeCBpcyBwYXNzZWQsIGF1dG9tYXRpY2FsbHkgYXNzdW1lIG9wZXJhdGlvbiBzaG91bGQgYmUgZG9uZSBvbiB0aGVcbi8vIGNvbHVtbnMuXG5qUHJvdG8uY3Vtc3VtID0gZnVuY3Rpb24oZnVsbGJvb2wsIGZ1bmMpIHtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciB0bXB0aGlzID0gdGhpcztcblxuICAvLyBBc3NpZ25tZW50IHJlYXNzaWduYXRpb24gZGVwZW5kaW5nIG9uIGhvdyBwYXJhbWV0ZXJzIHdlcmUgcGFzc2VkIGluLlxuICBpZiAoaXNGdW5jdGlvbihmdWxsYm9vbCkpIHtcbiAgICBmdW5jID0gZnVsbGJvb2w7XG4gICAgZnVsbGJvb2wgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGEgY2FsbGJhY2sgd2FzIHBhc3NlZCB3aXRoIHRoZSBmdW5jdGlvbi5cbiAgaWYgKGZ1bmMpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZnVuYy5jYWxsKHRtcHRoaXMsIGpQcm90by5jdW1zdW0uY2FsbCh0bXB0aGlzLCBmdWxsYm9vbCkpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgbWF0cml4IGFuZCBydW4gY2FsY3VsYXRpb25zLlxuICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgdG1wdGhpcyA9IGZ1bGxib29sID09PSB0cnVlID8gdGhpcyA6IHRoaXMudHJhbnNwb3NlKCk7XG4gICAgZm9yICg7IGkgPCB0bXB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgYXJyW2ldID0galN0YXQuY3Vtc3VtKHRtcHRoaXNbaV0pO1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICByZXR1cm4galN0YXQuY3Vtc3VtKHRoaXNbMF0sIGZ1bGxib29sKTtcbn07XG5cblxuLy8gRXh0ZW5kIGpQcm90byB3aXRoIG1ldGhvZHMgd2hpY2ggZG9uJ3QgcmVxdWlyZSBhcmd1bWVudHMgYW5kIHdvcmsgb24gY29sdW1ucy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICAvLyBJZiBhIG1hdHJpeCBpcyBwYXNzZWQsIGF1dG9tYXRpY2FsbHkgYXNzdW1lIG9wZXJhdGlvbiBzaG91bGQgYmUgZG9uZSBvblxuICAgIC8vIHRoZSBjb2x1bW5zLlxuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihmdWxsYm9vbCwgZnVuYykge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHRtcHRoaXMgPSB0aGlzO1xuICAgICAgLy8gQXNzaWdubWVudCByZWFzc2lnbmF0aW9uIGRlcGVuZGluZyBvbiBob3cgcGFyYW1ldGVycyB3ZXJlIHBhc3NlZCBpbi5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bGxib29sKSkge1xuICAgICAgICBmdW5jID0gZnVsbGJvb2w7XG4gICAgICAgIGZ1bGxib29sID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBhIGNhbGxiYWNrIHdhcyBwYXNzZWQgd2l0aCB0aGUgZnVuY3Rpb24uXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbCh0bXB0aGlzLCBqUHJvdG9bcGFzc2Z1bmNdLmNhbGwodG1wdGhpcywgZnVsbGJvb2wpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgbWF0cml4IGFuZCBydW4gY2FsY3VsYXRpb25zLlxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0bXB0aGlzID0gZnVsbGJvb2wgPT09IHRydWUgPyB0aGlzIDogdGhpcy50cmFuc3Bvc2UoKTtcbiAgICAgICAgZm9yICg7IGkgPCB0bXB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIGFycltpXSA9IGpTdGF0W3Bhc3NmdW5jXSh0bXB0aGlzW2ldKTtcbiAgICAgICAgcmV0dXJuIGZ1bGxib29sID09PSB0cnVlXG4gICAgICAgICAgICA/IGpTdGF0W3Bhc3NmdW5jXShqU3RhdC51dGlscy50b1ZlY3RvcihhcnIpKVxuICAgICAgICAgICAgOiBhcnI7XG4gICAgICB9XG4gICAgICAvLyBQYXNzIGZ1bGxib29sIGlmIG9ubHkgdmVjdG9yLCBub3QgYSBtYXRyaXguIGZvciB2YXJpYW5jZSBhbmQgc3RkZXYuXG4gICAgICByZXR1cm4galN0YXRbcGFzc2Z1bmNdKHRoaXNbMF0sIGZ1bGxib29sKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgoJ3N1bSBzdW1zcXJkIHN1bXNxZXJyIHByb2R1Y3QgbWluIG1heCBtZWFuIG1lYW5zcWVyciBnZW9tZWFuIG1lZGlhbiBkaWZmICcgK1xuICAgICdtb2RlIHJhbmdlIHZhcmlhbmNlIHN0ZGV2IG1lYW5kZXYgbWVkZGV2IGNvZWZmdmFyIHF1YXJ0aWxlcycpLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4dGVuZCBqUHJvdG8gd2l0aCBmdW5jdGlvbnMgdGhhdCB0YWtlIGFyZ3VtZW50cy4gT3BlcmF0aW9ucyBvbiBtYXRyaWNlcyBhcmVcbi8vIGRvbmUgb24gY29sdW1ucy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgdG1wdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIElmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIHdlIGFzc3VtZSBpdCdzIGEgY2FsbGJhY2s7IHdlXG4gICAgICAvLyBzdHJpcCB0aGUgY2FsbGJhY2sgb3V0IGFuZCBjYWxsIHRoZSBmdW5jdGlvbiBhZ2Fpbi5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrRnVuY3Rpb24gPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBhcmdzVG9QYXNzID0gYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2tGdW5jdGlvbi5jYWxsKHRtcHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpQcm90b1twYXNzZnVuY10uYXBwbHkodG1wdGhpcywgYXJnc1RvUGFzcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIE90aGVyd2lzZSB3ZSBjdXJyeSB0aGUgZnVuY3Rpb24gYXJncyBhbmQgY2FsbCBub3JtYWxseS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjYWxsYmFja0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY3VycmllZEZ1bmN0aW9uID0gZnVuY3Rpb24gY3VycmllZEZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10uYXBwbHkodG1wdGhpcywgW3ZlY3Rvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgbWF0cml4LCBydW4gY29sdW1uLWJ5LWNvbHVtbi5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdG1wdGhpcyA9IHRtcHRoaXMudHJhbnNwb3NlKCk7XG4gICAgICAgIGZvciAoOyBpIDwgdG1wdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcnJbaV0gPSBjdXJyaWVkRnVuY3Rpb24odG1wdGhpc1tpXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSBydW4gb24gdGhlIHZlY3Rvci5cbiAgICAgIHJldHVybiBjdXJyaWVkRnVuY3Rpb24odGhpc1swXSk7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ3F1YW50aWxlcyBwZXJjZW50aWxlT2ZTY29yZScuc3BsaXQoJyAnKSk7XG5cbn0odGhpcy5qU3RhdCwgTWF0aCkpO1xuLy8gU3BlY2lhbCBmdW5jdGlvbnMgLy9cbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG4vLyBMb2ctZ2FtbWEgZnVuY3Rpb25cbmpTdGF0LmdhbW1hbG4gPSBmdW5jdGlvbiBnYW1tYWxuKHgpIHtcbiAgdmFyIGogPSAwO1xuICB2YXIgY29mID0gW1xuICAgIDc2LjE4MDA5MTcyOTQ3MTQ2LCAtODYuNTA1MzIwMzI5NDE2NzcsIDI0LjAxNDA5ODI0MDgzMDkxLFxuICAgIC0xLjIzMTczOTU3MjQ1MDE1NSwgMC4xMjA4NjUwOTczODY2MTc5ZS0yLCAtMC41Mzk1MjM5Mzg0OTUzZS01XG4gIF07XG4gIHZhciBzZXIgPSAxLjAwMDAwMDAwMDE5MDAxNTtcbiAgdmFyIHh4LCB5LCB0bXA7XG4gIHRtcCA9ICh5ID0geHggPSB4KSArIDUuNTtcbiAgdG1wIC09ICh4eCArIDAuNSkgKiBNYXRoLmxvZyh0bXApO1xuICBmb3IgKDsgaiA8IDY7IGorKylcbiAgICBzZXIgKz0gY29mW2pdIC8gKyt5O1xuICByZXR1cm4gTWF0aC5sb2coMi41MDY2MjgyNzQ2MzEwMDA1ICogc2VyIC8geHgpIC0gdG1wO1xufTtcblxuXG4vLyBnYW1tYSBvZiB4XG5qU3RhdC5nYW1tYWZuID0gZnVuY3Rpb24gZ2FtbWFmbih4KSB7XG4gIHZhciBwID0gWy0xLjcxNjE4NTEzODg2NTQ5NSwgMjQuNzY1NjUwODA1NTc1OTIsIC0zNzkuODA0MjU2NDcwOTQ1NjMsXG4gICAgICAgICAgIDYyOS4zMzExNTUzMTI4MTg0LCA4NjYuOTY2MjAyNzkwNDEzMywgLTMxNDUxLjI3Mjk2ODg0ODM2NyxcbiAgICAgICAgICAgLTM2MTQ0LjQxMzQxODY5MTE3NiwgNjY0NTYuMTQzODIwMjQwNTRcbiAgXTtcbiAgdmFyIHEgPSBbLTMwLjg0MDIzMDAxMTk3MzksIDMxNS4zNTA2MjY5Nzk2MDQxNiwgLTEwMTUuMTU2MzY3NDkwMjE5MixcbiAgICAgICAgICAgLTMxMDcuNzcxNjcxNTcyMzExLCAyMjUzOC4xMTg0MjA5ODAxNTEsIDQ3NTUuODQ2Mjc3NTI3ODgxMSxcbiAgICAgICAgICAgLTEzNDY1OS45NTk4NjQ5NjkzLCAtMTE1MTMyLjI1OTY3NTU1MzVdO1xuICB2YXIgZmFjdCA9IGZhbHNlO1xuICB2YXIgbiA9IDA7XG4gIHZhciB4ZGVuID0gMDtcbiAgdmFyIHhudW0gPSAwO1xuICB2YXIgeSA9IHg7XG4gIHZhciBpLCB6LCB5aSwgcmVzLCBzdW0sIHlzcTtcbiAgaWYgKHkgPD0gMCkge1xuICAgIHJlcyA9IHkgJSAxICsgMy42ZS0xNjtcbiAgICBpZiAocmVzKSB7XG4gICAgICBmYWN0ID0gKCEoeSAmIDEpID8gMSA6IC0xKSAqIE1hdGguUEkgLyBNYXRoLnNpbihNYXRoLlBJICogcmVzKTtcbiAgICAgIHkgPSAxIC0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfVxuICB5aSA9IHk7XG4gIGlmICh5IDwgMSkge1xuICAgIHogPSB5Kys7XG4gIH0gZWxzZSB7XG4gICAgeiA9ICh5IC09IG4gPSAoeSB8IDApIC0gMSkgLSAxO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICB4bnVtID0gKHhudW0gKyBwW2ldKSAqIHo7XG4gICAgeGRlbiA9IHhkZW4gKiB6ICsgcVtpXTtcbiAgfVxuICByZXMgPSB4bnVtIC8geGRlbiArIDE7XG4gIGlmICh5aSA8IHkpIHtcbiAgICByZXMgLz0geWk7XG4gIH0gZWxzZSBpZiAoeWkgPiB5KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgcmVzICo9IHk7XG4gICAgICB5Kys7XG4gICAgfVxuICB9XG4gIGlmIChmYWN0KSB7XG4gICAgcmVzID0gZmFjdCAvIHJlcztcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG4vLyBsb3dlciBpbmNvbXBsZXRlIGdhbW1hIGZ1bmN0aW9uIFAoYSx4KVxualN0YXQuZ2FtbWFwID0gZnVuY3Rpb24gZ2FtbWFwKGEsIHgpIHtcbiAgdmFyIGFsbiA9IGpTdGF0LmdhbW1hbG4oYSk7XG4gIHZhciBhcCA9IGE7XG4gIHZhciBzdW0gPSAxIC8gYTtcbiAgdmFyIGRlbCA9IHN1bTtcbiAgdmFyIGIgPSB4ICsgMSAtIGE7XG4gIHZhciBjID0gMSAvIDEuMGUtMzA7XG4gIHZhciBkID0gMSAvIGI7XG4gIHZhciBoID0gZDtcbiAgdmFyIGkgPSAxO1xuICAvLyBjYWxjdWxhdGUgbWF4aW11bSBudW1iZXIgb2YgaXR0ZXJhdGlvbnMgcmVxdWlyZWQgZm9yIGFcbiAgdmFyIElUTUFYID0gLX4oTWF0aC5sb2coKGEgPj0gMSkgPyBhIDogMSAvIGEpICogOC41ICsgYSAqIDAuNCArIDE3KTtcbiAgdmFyIGFuLCBlbmR2YWw7XG5cbiAgaWYgKHggPCAwIHx8IGEgPD0gMCkge1xuICAgIHJldHVybiBOYU47XG4gIH0gZWxzZSBpZiAoeCA8IGEgKyAxKSB7XG4gICAgZm9yICg7IGkgPD0gSVRNQVg7IGkrKykge1xuICAgICAgc3VtICs9IGRlbCAqPSB4IC8gKythcDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSAqIE1hdGguZXhwKC14ICsgYSAqIE1hdGgubG9nKHgpIC0gKGFsbikpO1xuICB9XG5cbiAgZm9yICg7IGkgPD0gSVRNQVg7IGkrKykge1xuICAgIGFuID0gLWkgKiAoaSAtIGEpO1xuICAgIGIgKz0gMjtcbiAgICBkID0gYW4gKiBkICsgYjtcbiAgICBjID0gYiArIGFuIC8gYztcbiAgICBkID0gMSAvIGQ7XG4gICAgaCAqPSBkICogYztcbiAgfVxuXG4gIHJldHVybiAxIC0gaCAqIE1hdGguZXhwKC14ICsgYSAqIE1hdGgubG9nKHgpIC0gKGFsbikpO1xufTtcblxuXG4vLyBuYXR1cmFsIGxvZyBmYWN0b3JpYWwgb2YgblxualN0YXQuZmFjdG9yaWFsbG4gPSBmdW5jdGlvbiBmYWN0b3JpYWxsbihuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGpTdGF0LmdhbW1hbG4obiArIDEpO1xufTtcblxuLy8gZmFjdG9yaWFsIG9mIG5cbmpTdGF0LmZhY3RvcmlhbCA9IGZ1bmN0aW9uIGZhY3RvcmlhbChuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGpTdGF0LmdhbW1hZm4obiArIDEpO1xufTtcblxuLy8gY29tYmluYXRpb25zIG9mIG4sIG1cbmpTdGF0LmNvbWJpbmF0aW9uID0gZnVuY3Rpb24gY29tYmluYXRpb24obiwgbSkge1xuICAvLyBtYWtlIHN1cmUgbiBvciBtIGRvbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXQgb2YgdXNhYmxlIHZhbHVlc1xuICByZXR1cm4gKG4gPiAxNzAgfHwgbSA+IDE3MClcbiAgICAgID8gTWF0aC5leHAoalN0YXQuY29tYmluYXRpb25sbihuLCBtKSlcbiAgICAgIDogKGpTdGF0LmZhY3RvcmlhbChuKSAvIGpTdGF0LmZhY3RvcmlhbChtKSkgLyBqU3RhdC5mYWN0b3JpYWwobiAtIG0pO1xufTtcblxuXG5qU3RhdC5jb21iaW5hdGlvbmxuID0gZnVuY3Rpb24gY29tYmluYXRpb25sbihuLCBtKXtcbiAgcmV0dXJuIGpTdGF0LmZhY3RvcmlhbGxuKG4pIC0galN0YXQuZmFjdG9yaWFsbG4obSkgLSBqU3RhdC5mYWN0b3JpYWxsbihuIC0gbSk7XG59O1xuXG5cbi8vIHBlcm11dGF0aW9ucyBvZiBuLCBtXG5qU3RhdC5wZXJtdXRhdGlvbiA9IGZ1bmN0aW9uIHBlcm11dGF0aW9uKG4sIG0pIHtcbiAgcmV0dXJuIGpTdGF0LmZhY3RvcmlhbChuKSAvIGpTdGF0LmZhY3RvcmlhbChuIC0gbSk7XG59O1xuXG5cbi8vIGJldGEgZnVuY3Rpb25cbmpTdGF0LmJldGFmbiA9IGZ1bmN0aW9uIGJldGFmbih4LCB5KSB7XG4gIC8vIGVuc3VyZSBhcmd1bWVudHMgYXJlIHBvc2l0aXZlXG4gIGlmICh4IDw9IDAgfHwgeSA8PSAwKVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIC8vIG1ha2Ugc3VyZSB4ICsgeSBkb2Vzbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXQgb2YgdXNhYmxlIHZhbHVlc1xuICByZXR1cm4gKHggKyB5ID4gMTcwKVxuICAgICAgPyBNYXRoLmV4cChqU3RhdC5iZXRhbG4oeCwgeSkpXG4gICAgICA6IGpTdGF0LmdhbW1hZm4oeCkgKiBqU3RhdC5nYW1tYWZuKHkpIC8galN0YXQuZ2FtbWFmbih4ICsgeSk7XG59O1xuXG5cbi8vIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGJldGEgZnVuY3Rpb25cbmpTdGF0LmJldGFsbiA9IGZ1bmN0aW9uIGJldGFsbih4LCB5KSB7XG4gIHJldHVybiBqU3RhdC5nYW1tYWxuKHgpICsgalN0YXQuZ2FtbWFsbih5KSAtIGpTdGF0LmdhbW1hbG4oeCArIHkpO1xufTtcblxuXG4vLyBFdmFsdWF0ZXMgdGhlIGNvbnRpbnVlZCBmcmFjdGlvbiBmb3IgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uIGJ5IG1vZGlmaWVkXG4vLyBMZW50eidzIG1ldGhvZC5cbmpTdGF0LmJldGFjZiA9IGZ1bmN0aW9uIGJldGFjZih4LCBhLCBiKSB7XG4gIHZhciBmcG1pbiA9IDFlLTMwO1xuICB2YXIgbSA9IDE7XG4gIHZhciBxYWIgPSBhICsgYjtcbiAgdmFyIHFhcCA9IGEgKyAxO1xuICB2YXIgcWFtID0gYSAtIDE7XG4gIHZhciBjID0gMTtcbiAgdmFyIGQgPSAxIC0gcWFiICogeCAvIHFhcDtcbiAgdmFyIG0yLCBhYSwgZGVsLCBoO1xuXG4gIC8vIFRoZXNlIHEncyB3aWxsIGJlIHVzZWQgaW4gZmFjdG9ycyB0aGF0IG9jY3VyIGluIHRoZSBjb2VmZmljaWVudHNcbiAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgZCA9IGZwbWluO1xuICBkID0gMSAvIGQ7XG4gIGggPSBkO1xuXG4gIGZvciAoOyBtIDw9IDEwMDsgbSsrKSB7XG4gICAgbTIgPSAyICogbTtcbiAgICBhYSA9IG0gKiAoYiAtIG0pICogeCAvICgocWFtICsgbTIpICogKGEgKyBtMikpO1xuICAgIC8vIE9uZSBzdGVwICh0aGUgZXZlbiBvbmUpIG9mIHRoZSByZWN1cnJlbmNlXG4gICAgZCA9IDEgKyBhYSAqIGQ7XG4gICAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgICBkID0gZnBtaW47XG4gICAgYyA9IDEgKyBhYSAvIGM7XG4gICAgaWYgKE1hdGguYWJzKGMpIDwgZnBtaW4pXG4gICAgICBjID0gZnBtaW47XG4gICAgZCA9IDEgLyBkO1xuICAgIGggKj0gZCAqIGM7XG4gICAgYWEgPSAtKGEgKyBtKSAqIChxYWIgKyBtKSAqIHggLyAoKGEgKyBtMikgKiAocWFwICsgbTIpKTtcbiAgICAvLyBOZXh0IHN0ZXAgb2YgdGhlIHJlY3VycmVuY2UgKHRoZSBvZGQgb25lKVxuICAgIGQgPSAxICsgYWEgKiBkO1xuICAgIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKVxuICAgICAgZCA9IGZwbWluO1xuICAgIGMgPSAxICsgYWEgLyBjO1xuICAgIGlmIChNYXRoLmFicyhjKSA8IGZwbWluKVxuICAgICAgYyA9IGZwbWluO1xuICAgIGQgPSAxIC8gZDtcbiAgICBkZWwgPSBkICogYztcbiAgICBoICo9IGRlbDtcbiAgICBpZiAoTWF0aC5hYnMoZGVsIC0gMS4wKSA8IDNlLTcpXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBoO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIGluY29tcGx0ZSBnYW1tYSBmdW5jdGlvblxualN0YXQuZ2FtbWFwaW52ID0gZnVuY3Rpb24gZ2FtbWFwaW52KHAsIGEpIHtcbiAgdmFyIGogPSAwO1xuICB2YXIgYTEgPSBhIC0gMTtcbiAgdmFyIEVQUyA9IDFlLTg7XG4gIHZhciBnbG4gPSBqU3RhdC5nYW1tYWxuKGEpO1xuICB2YXIgeCwgZXJyLCB0LCB1LCBwcCwgbG5hMSwgYWZhYztcblxuICBpZiAocCA+PSAxKVxuICAgIHJldHVybiBNYXRoLm1heCgxMDAsIGEgKyAxMDAgKiBNYXRoLnNxcnQoYSkpO1xuICBpZiAocCA8PSAwKVxuICAgIHJldHVybiAwO1xuICBpZiAoYSA+IDEpIHtcbiAgICBsbmExID0gTWF0aC5sb2coYTEpO1xuICAgIGFmYWMgPSBNYXRoLmV4cChhMSAqIChsbmExIC0gMSkgLSBnbG4pO1xuICAgIHBwID0gKHAgPCAwLjUpID8gcCA6IDEgLSBwO1xuICAgIHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhwcCkpO1xuICAgIHggPSAoMi4zMDc1MyArIHQgKiAwLjI3MDYxKSAvICgxICsgdCAqICgwLjk5MjI5ICsgdCAqIDAuMDQ0ODEpKSAtIHQ7XG4gICAgaWYgKHAgPCAwLjUpXG4gICAgICB4ID0gLXg7XG4gICAgeCA9IE1hdGgubWF4KDFlLTMsXG4gICAgICAgICAgICAgICAgIGEgKiBNYXRoLnBvdygxIC0gMSAvICg5ICogYSkgLSB4IC8gKDMgKiBNYXRoLnNxcnQoYSkpLCAzKSk7XG4gIH0gZWxzZSB7XG4gICAgdCA9IDEgLSBhICogKDAuMjUzICsgYSAqIDAuMTIpO1xuICAgIGlmIChwIDwgdClcbiAgICAgIHggPSBNYXRoLnBvdyhwIC8gdCwgMSAvIGEpO1xuICAgIGVsc2VcbiAgICAgIHggPSAxIC0gTWF0aC5sb2coMSAtIChwIC0gdCkgLyAoMSAtIHQpKTtcbiAgfVxuXG4gIGZvcig7IGogPCAxMjsgaisrKSB7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIGVyciA9IGpTdGF0LmdhbW1hcChhLCB4KSAtIHA7XG4gICAgaWYgKGEgPiAxKVxuICAgICAgdCA9IGFmYWMgKiBNYXRoLmV4cCgtKHggLSBhMSkgKyBhMSAqIChNYXRoLmxvZyh4KSAtIGxuYTEpKTtcbiAgICBlbHNlXG4gICAgICB0ID0gTWF0aC5leHAoLXggKyBhMSAqIE1hdGgubG9nKHgpIC0gZ2xuKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09ICh0ID0gdSAvICgxIC0gMC41ICogTWF0aC5taW4oMSwgdSAqICgoYSAtIDEpIC8geCAtIDEpKSkpO1xuICAgIGlmICh4IDw9IDApXG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICBpZiAoTWF0aC5hYnModCkgPCBFUFMgKiB4KVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4geDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgZXJyb3IgZnVuY3Rpb24gZXJmKHgpXG5qU3RhdC5lcmYgPSBmdW5jdGlvbiBlcmYoeCkge1xuICB2YXIgY29mID0gWy0xLjMwMjY1MzcxOTc4MTcwOTQsIDYuNDE5Njk3OTIzNTY0OTAyNmUtMSwgMS45NDc2NDczMjA0MTg1ODM2ZS0yLFxuICAgICAgICAgICAgIC05LjU2MTUxNDc4NjgwODYzMWUtMywgLTkuNDY1OTUzNDQ0ODIwMzZlLTQsIDMuNjY4Mzk0OTc4NTI3NjFlLTQsXG4gICAgICAgICAgICAgNC4yNTIzMzI0ODA2OTA3ZS01LCAtMi4wMjc4NTc4MTEyNTM0ZS01LCAtMS42MjQyOTAwMDQ2NDdlLTYsXG4gICAgICAgICAgICAgMS4zMDM2NTU4MzU1ODBlLTYsIDEuNTYyNjQ0MTcyMmUtOCwgLTguNTIzODA5NTkxNWUtOCxcbiAgICAgICAgICAgICA2LjUyOTA1NDQzOWUtOSwgNS4wNTkzNDM0OTVlLTksIC05LjkxMzY0MTU2ZS0xMCxcbiAgICAgICAgICAgICAtMi4yNzM2NTEyMmUtMTAsIDkuNjQ2NzkxMWUtMTEsIDIuMzk0MDM4ZS0xMixcbiAgICAgICAgICAgICAtNi44ODYwMjdlLTEyLCA4Ljk0NDg3ZS0xMywgMy4xMzA5MmUtMTMsXG4gICAgICAgICAgICAgLTEuMTI3MDhlLTEzLCAzLjgxZS0xNiwgNy4xMDZlLTE1LFxuICAgICAgICAgICAgIC0xLjUyM2UtMTUsIC05LjRlLTE3LCAxLjIxZS0xNixcbiAgICAgICAgICAgICAtMi44ZS0xN107XG4gIHZhciBqID0gY29mLmxlbmd0aCAtIDE7XG4gIHZhciBpc25lZyA9IGZhbHNlO1xuICB2YXIgZCA9IDA7XG4gIHZhciBkZCA9IDA7XG4gIHZhciB0LCB0eSwgdG1wLCByZXM7XG5cbiAgaWYgKHggPCAwKSB7XG4gICAgeCA9IC14O1xuICAgIGlzbmVnID0gdHJ1ZTtcbiAgfVxuXG4gIHQgPSAyIC8gKDIgKyB4KTtcbiAgdHkgPSA0ICogdCAtIDI7XG5cbiAgZm9yKDsgaiA+IDA7IGotLSkge1xuICAgIHRtcCA9IGQ7XG4gICAgZCA9IHR5ICogZCAtIGRkICsgY29mW2pdO1xuICAgIGRkID0gdG1wO1xuICB9XG5cbiAgcmVzID0gdCAqIE1hdGguZXhwKC14ICogeCArIDAuNSAqIChjb2ZbMF0gKyB0eSAqIGQpIC0gZGQpO1xuICByZXR1cm4gaXNuZWcgPyByZXMgLSAxIDogMSAtIHJlcztcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgY29tcGxtZW50YXJ5IGVycm9yIGZ1bmN0aW9uIGVyZmMoeClcbmpTdGF0LmVyZmMgPSBmdW5jdGlvbiBlcmZjKHgpIHtcbiAgcmV0dXJuIDEgLSBqU3RhdC5lcmYoeCk7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBsZW1lbnRhcnkgZXJyb3IgZnVuY3Rpb25cbmpTdGF0LmVyZmNpbnYgPSBmdW5jdGlvbiBlcmZjaW52KHApIHtcbiAgdmFyIGogPSAwO1xuICB2YXIgeCwgZXJyLCB0LCBwcDtcbiAgaWYgKHAgPj0gMilcbiAgICByZXR1cm4gLTEwMDtcbiAgaWYgKHAgPD0gMClcbiAgICByZXR1cm4gMTAwO1xuICBwcCA9IChwIDwgMSkgPyBwIDogMiAtIHA7XG4gIHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhwcCAvIDIpKTtcbiAgeCA9IC0wLjcwNzExICogKCgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC9cbiAgICAgICAgICAgICAgICAgICgxICsgdCAqICgwLjk5MjI5ICsgdCAqIDAuMDQ0ODEpKSAtIHQpO1xuICBmb3IgKDsgaiA8IDI7IGorKykge1xuICAgIGVyciA9IGpTdGF0LmVyZmMoeCkgLSBwcDtcbiAgICB4ICs9IGVyciAvICgxLjEyODM3OTE2NzA5NTUxMjU3ICogTWF0aC5leHAoLXggKiB4KSAtIHggKiBlcnIpO1xuICB9XG4gIHJldHVybiAocCA8IDEpID8geCA6IC14O1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBpbmNvbXBsZXRlIGJldGEgZnVuY3Rpb25cbmpTdGF0LmliZXRhaW52ID0gZnVuY3Rpb24gaWJldGFpbnYocCwgYSwgYikge1xuICB2YXIgRVBTID0gMWUtODtcbiAgdmFyIGExID0gYSAtIDE7XG4gIHZhciBiMSA9IGIgLSAxO1xuICB2YXIgaiA9IDA7XG4gIHZhciBsbmEsIGxuYiwgcHAsIHQsIHUsIGVyciwgeCwgYWwsIGgsIHcsIGFmYWM7XG4gIGlmIChwIDw9IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmIChwID49IDEpXG4gICAgcmV0dXJuIDE7XG4gIGlmIChhID49IDEgJiYgYiA+PSAxKSB7XG4gICAgcHAgPSAocCA8IDAuNSkgPyBwIDogMSAtIHA7XG4gICAgdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHBwKSk7XG4gICAgeCA9ICgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC8gKDEgKyB0KiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KVxuICAgICAgeCA9IC14O1xuICAgIGFsID0gKHggKiB4IC0gMykgLyA2O1xuICAgIGggPSAyIC8gKDEgLyAoMiAqIGEgLSAxKSAgKyAxIC8gKDIgKiBiIC0gMSkpO1xuICAgIHcgPSAoeCAqIE1hdGguc3FydChhbCArIGgpIC8gaCkgLSAoMSAvICgyICogYiAtIDEpIC0gMSAvICgyICogYSAtIDEpKSAqXG4gICAgICAgIChhbCArIDUgLyA2IC0gMiAvICgzICogaCkpO1xuICAgIHggPSBhIC8gKGEgKyBiICogTWF0aC5leHAoMiAqIHcpKTtcbiAgfSBlbHNlIHtcbiAgICBsbmEgPSBNYXRoLmxvZyhhIC8gKGEgKyBiKSk7XG4gICAgbG5iID0gTWF0aC5sb2coYiAvIChhICsgYikpO1xuICAgIHQgPSBNYXRoLmV4cChhICogbG5hKSAvIGE7XG4gICAgdSA9IE1hdGguZXhwKGIgKiBsbmIpIC8gYjtcbiAgICB3ID0gdCArIHU7XG4gICAgaWYgKHAgPCB0IC8gdylcbiAgICAgIHggPSBNYXRoLnBvdyhhICogdyAqIHAsIDEgLyBhKTtcbiAgICBlbHNlXG4gICAgICB4ID0gMSAtIE1hdGgucG93KGIgKiB3ICogKDEgLSBwKSwgMSAvIGIpO1xuICB9XG4gIGFmYWMgPSAtalN0YXQuZ2FtbWFsbihhKSAtIGpTdGF0LmdhbW1hbG4oYikgKyBqU3RhdC5nYW1tYWxuKGEgKyBiKTtcbiAgZm9yKDsgaiA8IDEwOyBqKyspIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSAxKVxuICAgICAgcmV0dXJuIHg7XG4gICAgZXJyID0galN0YXQuaWJldGEoeCwgYSwgYikgLSBwO1xuICAgIHQgPSBNYXRoLmV4cChhMSAqIE1hdGgubG9nKHgpICsgYjEgKiBNYXRoLmxvZygxIC0geCkgKyBhZmFjKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09ICh0ID0gdSAvICgxIC0gMC41ICogTWF0aC5taW4oMSwgdSAqIChhMSAvIHggLSBiMSAvICgxIC0geCkpKSkpO1xuICAgIGlmICh4IDw9IDApXG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICBpZiAoeCA+PSAxKVxuICAgICAgeCA9IDAuNSAqICh4ICsgdCArIDEpO1xuICAgIGlmIChNYXRoLmFicyh0KSA8IEVQUyAqIHggJiYgaiA+IDApXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uIElfeChhLGIpXG5qU3RhdC5pYmV0YSA9IGZ1bmN0aW9uIGliZXRhKHgsIGEsIGIpIHtcbiAgLy8gRmFjdG9ycyBpbiBmcm9udCBvZiB0aGUgY29udGludWVkIGZyYWN0aW9uLlxuICB2YXIgYnQgPSAoeCA9PT0gMCB8fCB4ID09PSAxKSA/ICAwIDpcbiAgICBNYXRoLmV4cChqU3RhdC5nYW1tYWxuKGEgKyBiKSAtIGpTdGF0LmdhbW1hbG4oYSkgLVxuICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oYikgKyBhICogTWF0aC5sb2coeCkgKyBiICpcbiAgICAgICAgICAgICBNYXRoLmxvZygxIC0geCkpO1xuICBpZiAoeCA8IDAgfHwgeCA+IDEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoeCA8IChhICsgMSkgLyAoYSArIGIgKyAyKSlcbiAgICAvLyBVc2UgY29udGludWVkIGZyYWN0aW9uIGRpcmVjdGx5LlxuICAgIHJldHVybiBidCAqIGpTdGF0LmJldGFjZih4LCBhLCBiKSAvIGE7XG4gIC8vIGVsc2UgdXNlIGNvbnRpbnVlZCBmcmFjdGlvbiBhZnRlciBtYWtpbmcgdGhlIHN5bW1ldHJ5IHRyYW5zZm9ybWF0aW9uLlxuICByZXR1cm4gMSAtIGJ0ICogalN0YXQuYmV0YWNmKDEgLSB4LCBiLCBhKSAvIGI7XG59O1xuXG5cbi8vIFJldHVybnMgYSBub3JtYWwgZGV2aWF0ZSAobXU9MCwgc2lnbWE9MSkuXG4vLyBJZiBuIGFuZCBtIGFyZSBzcGVjaWZpZWQgaXQgcmV0dXJucyBhIG9iamVjdCBvZiBub3JtYWwgZGV2aWF0ZXMuXG5qU3RhdC5yYW5kbiA9IGZ1bmN0aW9uIHJhbmRuKG4sIG0pIHtcbiAgdmFyIHUsIHYsIHgsIHksIHEsIG1hdDtcbiAgaWYgKCFtKVxuICAgIG0gPSBuO1xuICBpZiAobilcbiAgICByZXR1cm4galN0YXQuY3JlYXRlKG4sIG0sIGZ1bmN0aW9uKCkgeyByZXR1cm4galN0YXQucmFuZG4oKTsgfSk7XG4gIGRvIHtcbiAgICB1ID0gTWF0aC5yYW5kb20oKTtcbiAgICB2ID0gMS43MTU2ICogKE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuICAgIHggPSB1IC0gMC40NDk4NzE7XG4gICAgeSA9IE1hdGguYWJzKHYpICsgMC4zODY1OTU7XG4gICAgcSA9IHggKiB4ICsgeSAqICgwLjE5NjAwICogeSAtIDAuMjU0NzIgKiB4KTtcbiAgfSB3aGlsZSAocSA+IDAuMjc1OTcgJiYgKHEgPiAwLjI3ODQ2IHx8IHYgKiB2ID4gLTQgKiBNYXRoLmxvZyh1KSAqIHUgKiB1KSk7XG4gIHJldHVybiB2IC8gdTtcbn07XG5cblxuLy8gUmV0dXJucyBhIGdhbW1hIGRldmlhdGUgYnkgdGhlIG1ldGhvZCBvZiBNYXJzYWdsaWEgYW5kIFRzYW5nLlxualN0YXQucmFuZGcgPSBmdW5jdGlvbiByYW5kZyhzaGFwZSwgbiwgbSkge1xuICB2YXIgb2FscGggPSBzaGFwZTtcbiAgdmFyIGExLCBhMiwgdSwgdiwgeCwgbWF0O1xuICBpZiAoIW0pXG4gICAgbSA9IG47XG4gIGlmICghc2hhcGUpXG4gICAgc2hhcGUgPSAxO1xuICBpZiAobikge1xuICAgIG1hdCA9IGpTdGF0Lnplcm9zKG4sbSk7XG4gICAgbWF0LmFsdGVyKGZ1bmN0aW9uKCkgeyByZXR1cm4galN0YXQucmFuZGcoc2hhcGUpOyB9KTtcbiAgICByZXR1cm4gbWF0O1xuICB9XG4gIGlmIChzaGFwZSA8IDEpXG4gICAgc2hhcGUgKz0gMTtcbiAgYTEgPSBzaGFwZSAtIDEgLyAzO1xuICBhMiA9IDEgLyBNYXRoLnNxcnQoOSAqIGExKTtcbiAgZG8ge1xuICAgIGRvIHtcbiAgICAgIHggPSBqU3RhdC5yYW5kbigpO1xuICAgICAgdiA9IDEgKyBhMiAqIHg7XG4gICAgfSB3aGlsZSh2IDw9IDApO1xuICAgIHYgPSB2ICogdiAqIHY7XG4gICAgdSA9IE1hdGgucmFuZG9tKCk7XG4gIH0gd2hpbGUodSA+IDEgLSAwLjMzMSAqIE1hdGgucG93KHgsIDQpICYmXG4gICAgICAgICAgTWF0aC5sb2codSkgPiAwLjUgKiB4KnggKyBhMSAqICgxIC0gdiArIE1hdGgubG9nKHYpKSk7XG4gIC8vIGFscGhhID4gMVxuICBpZiAoc2hhcGUgPT0gb2FscGgpXG4gICAgcmV0dXJuIGExICogdjtcbiAgLy8gYWxwaGEgPCAxXG4gIGRvIHtcbiAgICB1ID0gTWF0aC5yYW5kb20oKTtcbiAgfSB3aGlsZSh1ID09PSAwKTtcbiAgcmV0dXJuIE1hdGgucG93KHUsIDEgLyBvYWxwaCkgKiBhMSAqIHY7XG59O1xuXG5cbi8vIG1ha2luZyB1c2Ugb2Ygc3RhdGljIG1ldGhvZHMgb24gdGhlIGluc3RhbmNlXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalN0YXQuZm5bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4galN0YXQoXG4gICAgICAgICAgalN0YXQubWFwKHRoaXMsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBqU3RhdFtwYXNzZnVuY10odmFsdWUpOyB9KSk7XG4gICAgfVxuICB9KShmdW5jc1tpXSk7XG59KSgnZ2FtbWFsbiBnYW1tYWZuIGZhY3RvcmlhbCBmYWN0b3JpYWxsbicuc3BsaXQoJyAnKSk7XG5cblxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpTdGF0LmZuW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgncmFuZG4nLnNwbGl0KCcgJykpO1xuXG59KHRoaXMualN0YXQsIE1hdGgpKTtcbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG4vLyBnZW5lcmF0ZSBhbGwgZGlzdHJpYnV0aW9uIGluc3RhbmNlIG1ldGhvZHNcbihmdW5jdGlvbihsaXN0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBkaXN0cmlidXRpb24gaW5zdGFuY2UgbWV0aG9kXG4gICAgalN0YXRbZnVuY10gPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYXJndW1lbnRzLmNhbGxlZSkpXG4gICAgICAgIHJldHVybiBuZXcgYXJndW1lbnRzLmNhbGxlZShhLCBiLCBjKTtcbiAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gZGlzdHJpYnV0aW9uIG1ldGhvZCB0byBiZSB1c2VkIG9uIGEgalN0YXQgaW5zdGFuY2VcbiAgICBqU3RhdC5mbltmdW5jXSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHZhciBuZXd0aGlzID0galN0YXRbZnVuY10oYSwgYiwgYyk7XG4gICAgICBuZXd0aGlzLmRhdGEgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ld3RoaXM7XG4gICAgfTtcbiAgICAvLyBzYW1wbGUgaW5zdGFuY2UgbWV0aG9kXG4gICAgalN0YXRbZnVuY10ucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hO1xuICAgICAgdmFyIGIgPSB0aGlzLl9iO1xuICAgICAgdmFyIGMgPSB0aGlzLl9jO1xuICAgICAgaWYgKGFycilcbiAgICAgICAgcmV0dXJuIGpTdGF0LmFsdGVyKGFyciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdLnNhbXBsZShhLCBiLCBjKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBqU3RhdFtmdW5jXS5zYW1wbGUoYSwgYiwgYyk7XG4gICAgfTtcbiAgICAvLyBnZW5lcmF0ZSB0aGUgcGRmLCBjZGYgYW5kIGludiBpbnN0YW5jZSBtZXRob2RzXG4gICAgKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKGZuZnVuYykge1xuICAgICAgICBqU3RhdFtmdW5jXS5wcm90b3R5cGVbZm5mdW5jXSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuX2E7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLl9iO1xuICAgICAgICAgIHZhciBjID0gdGhpcy5fYztcbiAgICAgICAgICBpZiAoIXggJiYgeCAhPT0gMClcbiAgICAgICAgICAgIHggPSB0aGlzLmRhdGE7XG4gICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGpTdGF0LmZuLm1hcC5jYWxsKHgsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10oeCwgYSwgYiwgYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10oeCwgYSwgYiwgYyk7XG4gICAgICAgIH07XG4gICAgICB9KSh2YWxzW2ldKTtcbiAgICB9KSgncGRmIGNkZiBpbnYnLnNwbGl0KCcgJykpO1xuICAgIC8vIGdlbmVyYXRlIHRoZSBtZWFuLCBtZWRpYW4sIG1vZGUgYW5kIHZhcmlhbmNlIGluc3RhbmNlIG1ldGhvZHNcbiAgICAoZnVuY3Rpb24odmFscykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24oZm5mdW5jKSB7XG4gICAgICAgIGpTdGF0W2Z1bmNdLnByb3RvdHlwZVtmbmZ1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10odGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYyk7XG4gICAgICAgIH07XG4gICAgICB9KSh2YWxzW2ldKTtcbiAgICB9KSgnbWVhbiBtZWRpYW4gbW9kZSB2YXJpYW5jZScuc3BsaXQoJyAnKSk7XG4gIH0pKGxpc3RbaV0pO1xufSkoKFxuICAnYmV0YSBjZW50cmFsRiBjYXVjaHkgY2hpc3F1YXJlIGV4cG9uZW50aWFsIGdhbW1hIGludmdhbW1hIGt1bWFyYXN3YW15ICcgK1xuICAnbG9nbm9ybWFsIG5vcm1hbCBwYXJldG8gc3R1ZGVudHQgd2VpYnVsbCB1bmlmb3JtICBiaW5vbWlhbCBuZWdiaW4gaHlwZ2VvbSAnICtcbiAgJ3BvaXNzb24gdHJpYW5ndWxhcidcbikuc3BsaXQoJyAnKSk7XG5cblxuXG4vLyBleHRlbmQgYmV0YSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuYmV0YSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIC8vIFBERiBpcyB6ZXJvIG91dHNpZGUgdGhlIHN1cHBvcnRcbiAgICBpZiAoeCA+IDEgfHwgeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICAvLyBQREYgaXMgb25lIGZvciB0aGUgdW5pZm9ybSBjYXNlXG4gICAgaWYgKGFscGhhID09IDEgJiYgYmV0YSA9PSAxKVxuICAgICAgcmV0dXJuIDE7XG5cbiAgICBpZiAoYWxwaGEgPCA1MTIgfHwgYmV0YSA8IDUxMikge1xuICAgICAgcmV0dXJuIChNYXRoLnBvdyh4LCBhbHBoYSAtIDEpICogTWF0aC5wb3coMSAtIHgsIGJldGEgLSAxKSkgL1xuICAgICAgICAgIGpTdGF0LmJldGFmbihhbHBoYSwgYmV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmV4cCgoYWxwaGEgLSAxKSAqIE1hdGgubG9nKHgpICtcbiAgICAgICAgICAgICAgICAgICAgICAoYmV0YSAtIDEpICogTWF0aC5sb2coMSAtIHgpIC1cbiAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5iZXRhbG4oYWxwaGEsIGJldGEpKTtcbiAgICB9XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKHggPiAxIHx8IHggPCAwKSA/ICh4ID4gMSkgKiAxIDogalN0YXQuaWJldGEoeCwgYWxwaGEsIGJldGEpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHgsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIGpTdGF0LmliZXRhaW52KHgsIGFscGhhLCBiZXRhKTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIGFscGhhIC8gKGFscGhhICsgYmV0YSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oYWxwaGEsIGJldGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lZGlhbiBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYWxwaGEgKiBiZXRhKSAvIChNYXRoLnBvdyhhbHBoYSArIGJldGEsIDIpICogKGFscGhhICsgYmV0YSArIDEpKTtcbiAgfSxcblxuICAvLyByZXR1cm4gYSByYW5kb20gc2FtcGxlXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGFscGhhLCBiZXRhKSB7XG4gICAgdmFyIHUgPSBqU3RhdC5yYW5kZyhhbHBoYSk7XG4gICAgcmV0dXJuIHUgLyAodSArIGpTdGF0LnJhbmRnKGJldGEpKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKGFscGhhICogYmV0YSkgLyAoTWF0aC5wb3coYWxwaGEgKyBiZXRhLCAyKSAqIChhbHBoYSArIGJldGEgKyAxKSk7XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgRiBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuY2VudHJhbEYsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgZGYxLCBkZjIpIHtcbiAgICBpZiAoeCA8IDApXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBNYXRoLnNxcnQoKE1hdGgucG93KGRmMSAqIHgsIGRmMSkgKiBNYXRoLnBvdyhkZjIsIGRmMikpIC9cbiAgICAgICAgICAgICAgICAgICAgIChNYXRoLnBvdyhkZjEgKiB4ICsgZGYyLCBkZjEgKyBkZjIpKSkgL1xuICAgICAgICAgICAgICAgICAgICAgKHggKiBqU3RhdC5iZXRhZm4oZGYxLzIsIGRmMi8yKSk7XG5cbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkZjEsIGRmMikge1xuICAgIHJldHVybiBqU3RhdC5pYmV0YSgoZGYxICogeCkgLyAoZGYxICogeCArIGRmMiksIGRmMSAvIDIsIGRmMiAvIDIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHgsIGRmMSwgZGYyKSB7XG4gICAgcmV0dXJuIGRmMiAvIChkZjEgKiAoMSAvIGpTdGF0LmliZXRhaW52KHgsIGRmMSAvIDIsIGRmMiAvIDIpIC0gMSkpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gKGRmMiA+IDIpID8gZGYyIC8gKGRmMiAtIDIpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gKGRmMSA+IDIpID8gKGRmMiAqIChkZjEgLSAyKSkgLyAoZGYxICogKGRmMiArIDIpKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvLyByZXR1cm4gYSByYW5kb20gc2FtcGxlXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGRmMSwgZGYyKSB7XG4gICAgdmFyIHgxID0galN0YXQucmFuZGcoZGYxIC8gMikgKiAyO1xuICAgIHZhciB4MiA9IGpTdGF0LnJhbmRnKGRmMiAvIDIpICogMjtcbiAgICByZXR1cm4gKHgxIC8gZGYxKSAvICh4MiAvIGRmMik7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRmMSwgZGYyKSB7XG4gICAgaWYgKGRmMiA8PSA0KVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gMiAqIGRmMiAqIGRmMiAqIChkZjEgKyBkZjIgLSAyKSAvXG4gICAgICAgIChkZjEgKiAoZGYyIC0gMikgKiAoZGYyIC0gMikgKiAoZGYyIC0gNCkpO1xuICB9XG59KTtcblxuXG4vLyBleHRlbmQgY2F1Y2h5IGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jYXVjaHksIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIChzY2FsZSAvIChNYXRoLnBvdyh4IC0gbG9jYWwsIDIpICsgTWF0aC5wb3coc2NhbGUsIDIpKSkgLyBNYXRoLlBJO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiBNYXRoLmF0YW4oKHggLSBsb2NhbCkgLyBzY2FsZSkgLyBNYXRoLlBJICsgMC41O1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsICsgc2NhbGUgKiBNYXRoLnRhbihNYXRoLlBJICogKHAgLSAwLjUpKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWw7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWw7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRuKCkgKlxuICAgICAgICBNYXRoLnNxcnQoMSAvICgyICogalN0YXQucmFuZGcoMC41KSkpICogc2NhbGUgKyBsb2NhbDtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgY2hpc3F1YXJlIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jaGlzcXVhcmUsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgZG9mKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKChkb2YgLyAyIC0gMSkgKiBNYXRoLmxvZyh4KSAtIHggLyAyIC0gKGRvZiAvIDIpICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coMikgLSBqU3RhdC5nYW1tYWxuKGRvZiAvIDIpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkb2YpIHtcbiAgICByZXR1cm4galN0YXQuZ2FtbWFwKGRvZiAvIDIsIHggLyAyKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIGRvZikge1xuICAgIHJldHVybiAyICogalN0YXQuZ2FtbWFwaW52KHAsIDAuNSAqIGRvZik7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKGRvZikge1xuICAgIHJldHVybiBkb2Y7XG4gIH0sXG5cbiAgLy8gVE9ETzogdGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uIChpcyB0aGVyZSBhIGJldHRlciB3YXk/KVxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihkb2YpIHtcbiAgICByZXR1cm4gZG9mICogTWF0aC5wb3coMSAtICgyIC8gKDkgKiBkb2YpKSwgMyk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShkb2YpIHtcbiAgICByZXR1cm4gKGRvZiAtIDIgPiAwKSA/IGRvZiAtIDIgOiAwO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGRvZikge1xuICAgIHJldHVybiBqU3RhdC5yYW5kZyhkb2YgLyAyKSAqIDI7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRvZikge1xuICAgIHJldHVybiAyICogZG9mO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBleHBvbmVudGlhbCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuZXhwb25lbnRpYWwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgcmF0ZSkge1xuICAgIHJldHVybiB4IDwgMCA/IDAgOiByYXRlICogTWF0aC5leHAoLXJhdGUgKiB4KTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCByYXRlKSB7XG4gICAgcmV0dXJuIHggPCAwID8gMCA6IDEgLSBNYXRoLmV4cCgtcmF0ZSAqIHgpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgcmF0ZSkge1xuICAgIHJldHVybiAtTWF0aC5sb2coMSAtIHApIC8gcmF0ZTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24ocmF0ZSkge1xuICAgIHJldHVybiAxIC8gcmF0ZTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIChyYXRlKSB7XG4gICAgcmV0dXJuICgxIC8gcmF0ZSkgKiBNYXRoLmxvZygyKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHJhdGUpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShyYXRlKSB7XG4gICAgcmV0dXJuIC0xIC8gcmF0ZSAqIE1hdGgubG9nKE1hdGgucmFuZG9tKCkpO1xuICB9LFxuXG4gIHZhcmlhbmNlIDogZnVuY3Rpb24ocmF0ZSkge1xuICAgIHJldHVybiBNYXRoLnBvdyhyYXRlLCAtMik7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIGdhbW1hIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5nYW1tYSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoKHNoYXBlIC0gMSkgKiBNYXRoLmxvZyh4KSAtIHggLyBzY2FsZSAtXG4gICAgICAgICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oc2hhcGUpIC0gc2hhcGUgKiBNYXRoLmxvZyhzY2FsZSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5nYW1tYXAoc2hhcGUsIHggLyBzY2FsZSk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4galN0YXQuZ2FtbWFwaW52KHAsIHNoYXBlKSAqIHNjYWxlO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2hhcGUgKiBzY2FsZTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNoYXBlLCBzY2FsZSkge1xuICAgIGlmKHNoYXBlID4gMSkgcmV0dXJuIChzaGFwZSAtIDEpICogc2NhbGU7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4galN0YXQucmFuZGcoc2hhcGUpICogc2NhbGU7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzaGFwZSAqIHNjYWxlICogc2NhbGU7XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgaW52ZXJzZSBnYW1tYSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuaW52Z2FtbWEsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0oc2hhcGUgKyAxKSAqIE1hdGgubG9nKHgpIC0gc2NhbGUgLyB4IC1cbiAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbihzaGFwZSkgKyBzaGFwZSAqIE1hdGgubG9nKHNjYWxlKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIDEgLSBqU3RhdC5nYW1tYXAoc2hhcGUsIHNjYWxlIC8geCk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgLyBqU3RhdC5nYW1tYXBpbnYoMSAtIHAsIHNoYXBlKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIChzaGFwZSA+IDEpID8gc2NhbGUgLyAoc2hhcGUgLSAxKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIChzaGFwZSArIDEpO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIGpTdGF0LnJhbmRnKHNoYXBlKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDIpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2FsZSAqIHNjYWxlIC8gKChzaGFwZSAtIDEpICogKHNoYXBlIC0gMSkgKiAoc2hhcGUgLSAyKSk7XG4gIH1cbn0pO1xuXG5cbi8vIGV4dGVuZCBrdW1hcmFzd2FteSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQua3VtYXJhc3dhbXksIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoTWF0aC5sb2coYWxwaGEpICsgTWF0aC5sb2coYmV0YSkgKyAoYWxwaGEgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKHgpICsgKGJldGEgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKDEgLSBNYXRoLnBvdyh4LCBhbHBoYSkpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoMSAtIE1hdGgucG93KDEgLSBNYXRoLnBvdyh4LCBhbHBoYSksIGJldGEpKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKGJldGEgKiBqU3RhdC5nYW1tYWZuKDEgKyAxIC8gYWxwaGEpICpcbiAgICAgICAgICAgIGpTdGF0LmdhbW1hZm4oYmV0YSkpIC8gKGpTdGF0LmdhbW1hZm4oMSArIDEgLyBhbHBoYSArIGJldGEpKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiBNYXRoLnBvdygxIC0gTWF0aC5wb3coMiwgLTEgLyBiZXRhKSwgMSAvIGFscGhhKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGFscGhhLCBiZXRhKSB7XG4gICAgaWYgKCEoYWxwaGEgPj0gMSAmJiBiZXRhID49IDEgJiYgKGFscGhhICE9PSAxICYmIGJldGEgIT09IDEpKSlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIE1hdGgucG93KChhbHBoYSAtIDEpIC8gKGFscGhhICogYmV0YSAtIDEpLCAxIC8gYWxwaGEpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhbHBoYSwgYmV0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFuY2Ugbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIC8vIFRPRE86IGNvbXBsZXRlIHRoaXNcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgbG9nbm9ybWFsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5sb2dub3JtYWwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC1NYXRoLmxvZyh4KSAtIDAuNSAqIE1hdGgubG9nKDIgKiBNYXRoLlBJKSAtXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKHNpZ21hKSAtIE1hdGgucG93KE1hdGgubG9nKHgpIC0gbXUsIDIpIC9cbiAgICAgICAgICAgICAgICAgICAgKDIgKiBzaWdtYSAqIHNpZ21hKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIDAuNSArXG4gICAgICAgICgwLjUgKiBqU3RhdC5lcmYoKE1hdGgubG9nKHgpIC0gbXUpIC8gTWF0aC5zcXJ0KDIgKiBzaWdtYSAqIHNpZ21hKSkpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgbXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0xLjQxNDIxMzU2MjM3MzA5NTA1ICogc2lnbWEgKiBqU3RhdC5lcmZjaW52KDIgKiBwKSArIG11KTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cChtdSArIHNpZ21hICogc2lnbWEgLyAyKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAobXUpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUobXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKG11IC0gc2lnbWEgKiBzaWdtYSk7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIE1hdGguZXhwKGpTdGF0LnJhbmRuKCkgKiBzaWdtYSArIG11KTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UobXUsIHNpZ21hKSB7XG4gICAgcmV0dXJuIChNYXRoLmV4cChzaWdtYSAqIHNpZ21hKSAtIDEpICogTWF0aC5leHAoMiAqIG11ICsgc2lnbWEgKiBzaWdtYSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQubm9ybWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtMC41ICogTWF0aC5sb2coMiAqIE1hdGguUEkpIC1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coc3RkKSAtIE1hdGgucG93KHggLSBtZWFuLCAyKSAvICgyICogc3RkICogc3RkKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxICsgalN0YXQuZXJmKCh4IC0gbWVhbikgLyBNYXRoLnNxcnQoMiAqIHN0ZCAqIHN0ZCkpKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiAtMS40MTQyMTM1NjIzNzMwOTUwNSAqIHN0ZCAqIGpTdGF0LmVyZmNpbnYoMiAqIHApICsgbWVhbjtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24obWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIG1lYW47XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4obWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIG1lYW47XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBtZWFuO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBqU3RhdC5yYW5kbigpICogc3RkICsgbWVhbjtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBzdGQgKiBzdGQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHBhcmV0byBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQucGFyZXRvLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIGlmICh4IDw9IHNjYWxlKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKHNoYXBlICogTWF0aC5wb3coc2NhbGUsIHNoYXBlKSkgLyBNYXRoLnBvdyh4LCBzaGFwZSArIDEpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coc2NhbGUgLyB4LCBzaGFwZSk7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihzY2FsZSwgc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUgPD0gMSlcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChzaGFwZSAqIE1hdGgucG93KHNjYWxlLCBzaGFwZSkpIC8gKHNoYXBlIC0gMSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogKHNoYXBlICogTWF0aC5TUVJUMik7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH0sXG5cbiAgdmFyaWFuY2UgOiBmdW5jdGlvbihzY2FsZSwgc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUgPD0gMilcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChzY2FsZSpzY2FsZSAqIHNoYXBlKSAvIChNYXRoLnBvdyhzaGFwZSAtIDEsIDIpICogKHNoYXBlIC0gMikpO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBzdHVkZW50dCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuc3R1ZGVudHQsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgZG9mKSB7XG4gICAgcmV0dXJuIChqU3RhdC5nYW1tYWZuKChkb2YgKyAxKSAvIDIpIC8gKE1hdGguc3FydChkb2YgKiBNYXRoLlBJKSAqXG4gICAgICAgIGpTdGF0LmdhbW1hZm4oZG9mIC8gMikpKSAqXG4gICAgICAgIE1hdGgucG93KDEgKyAoKHggKiB4KSAvIGRvZiksIC0oKGRvZiArIDEpIC8gMikpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGRvZikge1xuICAgIHZhciBkb2YyID0gZG9mIC8gMjtcbiAgICByZXR1cm4galN0YXQuaWJldGEoKHggKyBNYXRoLnNxcnQoeCAqIHggKyBkb2YpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICgyICogTWF0aC5zcXJ0KHggKiB4ICsgZG9mKSksIGRvZjIsIGRvZjIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgZG9mKSB7XG4gICAgdmFyIHggPSBqU3RhdC5pYmV0YWludigyICogTWF0aC5taW4ocCwgMSAtIHApLCAwLjUgKiBkb2YsIDAuNSk7XG4gICAgeCA9IE1hdGguc3FydChkb2YgKiAoMSAtIHgpIC8geCk7XG4gICAgcmV0dXJuIChwID4gMC41KSA/IHggOiAteDtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGRvZikge1xuICAgIHJldHVybiAoZG9mID4gMSkgPyAwIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGRvZikge1xuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoZG9mKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoZG9mKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRuKCkgKiBNYXRoLnNxcnQoZG9mIC8gKDIgKiBqU3RhdC5yYW5kZyhkb2YgLyAyKSkpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShkb2YpIHtcbiAgICByZXR1cm4gKGRvZiAgPiAyKSA/IGRvZiAvIChkb2YgLSAyKSA6IChkb2YgPiAxKSA/IEluZmluaXR5IDogdW5kZWZpbmVkO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB3ZWlidWxsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC53ZWlidWxsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAoc2hhcGUgLyBzY2FsZSkgKiBNYXRoLnBvdygoeCAvIHNjYWxlKSwgKHNoYXBlIC0gMSkpICpcbiAgICAgICAgTWF0aC5leHAoLShNYXRoLnBvdygoeCAvIHNjYWxlKSwgc2hhcGUpKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHggPCAwID8gMCA6IDEgLSBNYXRoLmV4cCgtTWF0aC5wb3coKHggLyBzY2FsZSksIHNoYXBlKSk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdygtTWF0aC5sb2coMSAtIHApLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBqU3RhdC5nYW1tYWZuKDEgKyAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIE1hdGgucG93KE1hdGgubG9nKDIpLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDEpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2FsZSAqIE1hdGgucG93KChzaGFwZSAtIDEpIC8gc2hhcGUsIDEgLyBzaGFwZSk7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coLU1hdGgubG9nKE1hdGgucmFuZG9tKCkpLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBzY2FsZSAqIGpTdGF0LmdhbW1hZm4oMSArIDIgLyBzaGFwZSkgLVxuICAgICAgICBNYXRoLnBvdyh0aGlzLm1lYW4oc2NhbGUsIHNoYXBlKSwgMik7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LnVuaWZvcm0sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgYSwgYikge1xuICAgIHJldHVybiAoeCA8IGEgfHwgeCA+IGIpID8gMCA6IDEgLyAoYiAtIGEpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGEsIGIpIHtcbiAgICBpZiAoeCA8IGEpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmICh4IDwgYilcbiAgICAgIHJldHVybiAoeCAtIGEpIC8gKGIgLSBhKTtcbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGEsIGIpIHtcbiAgICByZXR1cm4gMC41ICogKGEgKyBiKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhLCBiKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm1lYW4oYSwgYik7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShhLCBiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShhLCBiKSB7XG4gICAgcmV0dXJuIChhIC8gMiArIGIgLyAyKSArIChiIC8gMiAtIGEgLyAyKSAqICgyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGIgLSBhLCAyKSAvIDEyO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5iaW5vbWlhbCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZihrLCBuLCBwKSB7XG4gICAgcmV0dXJuIChwID09PSAwIHx8IHAgPT09IDEpID9cbiAgICAgICgobiAqIHApID09PSBrID8gMSA6IDApIDpcbiAgICAgIGpTdGF0LmNvbWJpbmF0aW9uKG4sIGspICogTWF0aC5wb3cocCwgaykgKiBNYXRoLnBvdygxIC0gcCwgbiAtIGspO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIG4sIHApIHtcbiAgICB2YXIgYmlub21hcnIgPSBbXSxcbiAgICBrID0gMDtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoeCA8IG4pIHtcbiAgICAgIGZvciAoOyBrIDw9IHg7IGsrKykge1xuICAgICAgICBiaW5vbWFyclsgayBdID0galN0YXQuYmlub21pYWwucGRmKGssIG4sIHApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpTdGF0LnN1bShiaW5vbWFycik7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5uZWdiaW4sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgciwgcCkge1xuICAgIHJldHVybiBrICE9PSBrIHwgMFxuICAgICAgPyBmYWxzZVxuICAgICAgOiBrIDwgMFxuICAgICAgICA/IDBcbiAgICAgICAgOiBqU3RhdC5jb21iaW5hdGlvbihrICsgciAtIDEsIHIgLSAxKSAqIE1hdGgucG93KDEgLSBwLCBrKSAqIE1hdGgucG93KHAsIHIpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHIsIHApIHtcbiAgICB2YXIgc3VtID0gMCxcbiAgICBrID0gMDtcbiAgICBpZiAoeCA8IDApIHJldHVybiAwO1xuICAgIGZvciAoOyBrIDw9IHg7IGsrKykge1xuICAgICAgc3VtICs9IGpTdGF0Lm5lZ2Jpbi5wZGYoaywgciwgcCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0Lmh5cGdlb20sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgTiwgbSwgbikge1xuICAgIC8vIEh5cGVyZ2VvbWV0cmljIFBERi5cblxuICAgIC8vIEEgc2ltcGxpZmljYXRpb24gb2YgdGhlIENERiBhbGdvcml0aG0gYmVsb3cuXG5cbiAgICAvLyBrID0gbnVtYmVyIG9mIHN1Y2Nlc3NlcyBkcmF3blxuICAgIC8vIE4gPSBwb3B1bGF0aW9uIHNpemVcbiAgICAvLyBtID0gbnVtYmVyIG9mIHN1Y2Nlc3NlcyBpbiBwb3B1bGF0aW9uXG4gICAgLy8gbiA9IG51bWJlciBvZiBpdGVtcyBkcmF3biBmcm9tIHBvcHVsYXRpb25cblxuICAgIGlmKGsgIT09IGsgfCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmKGsgPCAwIHx8IGsgPCBtIC0gKE4gLSBuKSkge1xuICAgICAgLy8gSXQncyBpbXBvc3NpYmxlIHRvIGhhdmUgdGhpcyBmZXcgc3VjY2Vzc2VzIGRyYXduLlxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmKGsgPiBuIHx8IGsgPiBtKSB7XG4gICAgICAvLyBJdCdzIGltcG9zc2libGUgdG8gaGF2ZSB0aGlzIG1hbnkgc3VjY2Vzc2VzIGRyYXduLlxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChtICogMiA+IE4pIHtcbiAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHN1Y2Nlc3Nlcy5cblxuICAgICAgaWYobiAqIDIgPiBOKSB7XG4gICAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHNhbXBsZWQuXG5cbiAgICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20ucGRmKE4gLSBtIC0gbiArIGssIE4sIE4gLSBtLCBOIC0gbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihuIC0gaywgTiwgTiAtIG0sIG4pO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKG4gKiAyID4gTikge1xuICAgICAgLy8gSGFsZiBvciBsZXNzIGlzIHN1Y2Nlc3Nlcy5cblxuICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20ucGRmKG0gLSBrLCBOLCBtLCBOIC0gbik7XG5cbiAgICB9IGVsc2UgaWYobSA8IG4pIHtcbiAgICAgIC8vIFdlIHdhbnQgdG8gaGF2ZSB0aGUgbnVtYmVyIG9mIHRoaW5ncyBzYW1wbGVkIHRvIGJlIGxlc3MgdGhhbiB0aGVcbiAgICAgIC8vIHN1Y2Nlc3NlcyBhdmFpbGFibGUuIFNvIHN3YXAgdGhlIGRlZmluaXRpb25zIG9mIHN1Y2Nlc3NmdWwgYW5kIHNhbXBsZWQuXG4gICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5wZGYoaywgTiwgbiwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBoYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gd2FzIHNhbXBsZWQsIGhhbGYgb3JcbiAgICAgIC8vIGxlc3Mgb2YgaXQgd2FzIHN1Y2Nlc3NlcywgYW5kIHdlIGhhZCBmZXdlciBzYW1wbGVkIHRoaW5ncyB0aGFuXG4gICAgICAvLyBzdWNjZXNzZXMuIE5vdyB3ZSBjYW4gZG8gdGhpcyBjb21wbGljYXRlZCBpdGVyYXRpdmUgYWxnb3JpdGhtIGluIGFuXG4gICAgICAvLyBlZmZpY2llbnQgd2F5LlxuXG4gICAgICAvLyBUaGUgYmFzaWMgcHJlbWlzZSBvZiB0aGUgYWxnb3JpdGhtIGlzIHRoYXQgd2UgcGFydGlhbGx5IG5vcm1hbGl6ZSBvdXJcbiAgICAgIC8vIGludGVybWVkaWF0ZSBwcm9kdWN0IHRvIGtlZXAgaXQgaW4gYSBudW1lcmljYWxseSBnb29kIHJlZ2lvbiwgYW5kIHRoZW5cbiAgICAgIC8vIGZpbmlzaCB0aGUgbm9ybWFsaXphdGlvbiBhdCB0aGUgZW5kLlxuXG4gICAgICAvLyBUaGlzIHZhcmlhYmxlIGhvbGRzIHRoZSBzY2FsZWQgcHJvYmFiaWxpdHkgb2YgdGhlIGN1cnJlbnQgbnVtYmVyIG9mXG4gICAgICAvLyBzdWNjZXNzZXMuXG4gICAgICB2YXIgc2NhbGVkUERGID0gMTtcblxuICAgICAgLy8gVGhpcyBrZWVwcyB0cmFjayBvZiBob3cgbXVjaCB3ZSBoYXZlIG5vcm1hbGl6ZWQuXG4gICAgICB2YXIgc2FtcGxlc0RvbmUgPSAwO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgIC8vIEZvciBldmVyeSBwb3NzaWJsZSBudW1iZXIgb2Ygc3VjY2Vzc2VzIHVwIHRvIHRoYXQgb2JzZXJ2ZWQuLi5cblxuICAgICAgICB3aGlsZShzY2FsZWRQREYgPiAxICYmIHNhbXBsZXNEb25lIDwgbikge1xuICAgICAgICAgIC8vIEludGVybWVkaWF0ZSByZXN1bHQgaXMgZ3Jvd2luZyB0b28gYmlnLiBBcHBseSBzb21lIG9mIHRoZVxuICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24gdG8gc2hyaW5rIGV2ZXJ5dGhpbmcuXG5cbiAgICAgICAgICBzY2FsZWRQREYgKj0gMSAtIChtIC8gKE4gLSBzYW1wbGVzRG9uZSkpO1xuXG4gICAgICAgICAgLy8gU2F5IHdlJ3ZlIG5vcm1hbGl6ZWQgYnkgdGhpcyBzYW1wbGUgYWxyZWFkeS5cbiAgICAgICAgICBzYW1wbGVzRG9uZSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV29yayBvdXQgdGhlIHBhcnRpYWxseS1ub3JtYWxpemVkIGh5cGVyZ2VvbWV0cmljIFBERiBmb3IgdGhlIG5leHRcbiAgICAgICAgLy8gbnVtYmVyIG9mIHN1Y2Nlc3Nlc1xuICAgICAgICBzY2FsZWRQREYgKj0gKG4gLSBpKSAqIChtIC0gaSkgLyAoKGkgKyAxKSAqIChOIC0gbSAtIG4gKyBpICsgMSkpO1xuICAgICAgfVxuXG4gICAgICBmb3IoOyBzYW1wbGVzRG9uZSA8IG47IHNhbXBsZXNEb25lKyspIHtcbiAgICAgICAgLy8gQXBwbHkgYWxsIHRoZSByZXN0IG9mIHRoZSBub3JtYWxpemF0aW9uXG4gICAgICAgIHNjYWxlZFBERiAqPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIGFuc3dlciBzYW5lbHkgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBzY2FsZWRQREYpKTtcbiAgICB9XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgTiwgbSwgbikge1xuICAgIC8vIEh5cGVyZ2VvbWV0cmljIENERi5cblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGlzIGR1ZSB0byBQcm9mLiBUaG9tYXMgUy4gRmVyZ3Vzb24sIDx0b21AbWF0aC51Y2xhLmVkdT4sXG4gICAgLy8gYW5kIGNvbWVzIGZyb20gaGlzIGh5cGVyZ2VvbWV0cmljIHRlc3QgY2FsY3VsYXRvciBhdFxuICAgIC8vIDxodHRwOi8vd3d3Lm1hdGgudWNsYS5lZHUvfnRvbS9kaXN0cmlidXRpb25zL0h5cGVyZ2VvbWV0cmljLmh0bWw+LlxuXG4gICAgLy8geCA9IG51bWJlciBvZiBzdWNjZXNzZXMgZHJhd25cbiAgICAvLyBOID0gcG9wdWxhdGlvbiBzaXplXG4gICAgLy8gbSA9IG51bWJlciBvZiBzdWNjZXNzZXMgaW4gcG9wdWxhdGlvblxuICAgIC8vIG4gPSBudW1iZXIgb2YgaXRlbXMgZHJhd24gZnJvbSBwb3B1bGF0aW9uXG5cbiAgICBpZih4IDwgMCB8fCB4IDwgbSAtIChOIC0gbikpIHtcbiAgICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIHRoaXMgZmV3IHN1Y2Nlc3NlcyBkcmF3biBvciBmZXdlci5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZih4ID49IG4gfHwgeCA+PSBtKSB7XG4gICAgICAvLyBXZSB3aWxsIGFsd2F5cyBoYXZlIHRoaXMgbWFueSBzdWNjZXNzZXMgb3IgZmV3ZXIuXG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKG0gKiAyID4gTikge1xuICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgdGhlIHBvcHVsYXRpb24gaXMgc3VjY2Vzc2VzLlxuXG4gICAgICBpZihuICogMiA+IE4pIHtcbiAgICAgICAgLy8gTW9yZSB0aGFuIGhhbGYgdGhlIHBvcHVsYXRpb24gaXMgc2FtcGxlZC5cblxuICAgICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5jZGYoTiAtIG0gLSBuICsgeCwgTiwgTiAtIG0sIE4gLSBuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIGlzIHNhbXBsZWQuXG5cbiAgICAgICAgcmV0dXJuIDEgLSBqU3RhdC5oeXBnZW9tLmNkZihuIC0geCAtIDEsIE4sIE4gLSBtLCBuKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZihuICogMiA+IE4pIHtcbiAgICAgIC8vIEhhbGYgb3IgbGVzcyBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIHJldHVybiAxIC0galN0YXQuaHlwZ2VvbS5jZGYobSAtIHggLSAxLCBOLCBtLCBOIC0gbik7XG5cbiAgICB9IGVsc2UgaWYobSA8IG4pIHtcbiAgICAgIC8vIFdlIHdhbnQgdG8gaGF2ZSB0aGUgbnVtYmVyIG9mIHRoaW5ncyBzYW1wbGVkIHRvIGJlIGxlc3MgdGhhbiB0aGVcbiAgICAgIC8vIHN1Y2Nlc3NlcyBhdmFpbGFibGUuIFNvIHN3YXAgdGhlIGRlZmluaXRpb25zIG9mIHN1Y2Nlc3NmdWwgYW5kIHNhbXBsZWQuXG4gICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5jZGYoeCwgTiwgbiwgbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBoYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gd2FzIHNhbXBsZWQsIGhhbGYgb3JcbiAgICAgIC8vIGxlc3Mgb2YgaXQgd2FzIHN1Y2Nlc3NlcywgYW5kIHdlIGhhZCBmZXdlciBzYW1wbGVkIHRoaW5ncyB0aGFuXG4gICAgICAvLyBzdWNjZXNzZXMuIE5vdyB3ZSBjYW4gZG8gdGhpcyBjb21wbGljYXRlZCBpdGVyYXRpdmUgYWxnb3JpdGhtIGluIGFuXG4gICAgICAvLyBlZmZpY2llbnQgd2F5LlxuXG4gICAgICAvLyBUaGUgYmFzaWMgcHJlbWlzZSBvZiB0aGUgYWxnb3JpdGhtIGlzIHRoYXQgd2UgcGFydGlhbGx5IG5vcm1hbGl6ZSBvdXJcbiAgICAgIC8vIGludGVybWVkaWF0ZSBzdW0gdG8ga2VlcCBpdCBpbiBhIG51bWVyaWNhbGx5IGdvb2QgcmVnaW9uLCBhbmQgdGhlblxuICAgICAgLy8gZmluaXNoIHRoZSBub3JtYWxpemF0aW9uIGF0IHRoZSBlbmQuXG5cbiAgICAgIC8vIEhvbGRzIHRoZSBpbnRlcm1lZGlhdGUsIHNjYWxlZCB0b3RhbCBDREYuXG4gICAgICB2YXIgc2NhbGVkQ0RGID0gMTtcblxuICAgICAgLy8gVGhpcyB2YXJpYWJsZSBob2xkcyB0aGUgc2NhbGVkIHByb2JhYmlsaXR5IG9mIHRoZSBjdXJyZW50IG51bWJlciBvZlxuICAgICAgLy8gc3VjY2Vzc2VzLlxuICAgICAgdmFyIHNjYWxlZFBERiA9IDE7XG5cbiAgICAgIC8vIFRoaXMga2VlcHMgdHJhY2sgb2YgaG93IG11Y2ggd2UgaGF2ZSBub3JtYWxpemVkLlxuICAgICAgdmFyIHNhbXBsZXNEb25lID0gMDtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHg7IGkrKykge1xuICAgICAgICAvLyBGb3IgZXZlcnkgcG9zc2libGUgbnVtYmVyIG9mIHN1Y2Nlc3NlcyB1cCB0byB0aGF0IG9ic2VydmVkLi4uXG5cbiAgICAgICAgd2hpbGUoc2NhbGVkQ0RGID4gMSAmJiBzYW1wbGVzRG9uZSA8IG4pIHtcbiAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgcmVzdWx0IGlzIGdyb3dpbmcgdG9vIGJpZy4gQXBwbHkgc29tZSBvZiB0aGVcbiAgICAgICAgICAvLyBub3JtYWxpemF0aW9uIHRvIHNocmluayBldmVyeXRoaW5nLlxuXG4gICAgICAgICAgdmFyIGZhY3RvciA9IDEgLSAobSAvIChOIC0gc2FtcGxlc0RvbmUpKTtcblxuICAgICAgICAgIHNjYWxlZFBERiAqPSBmYWN0b3I7XG4gICAgICAgICAgc2NhbGVkQ0RGICo9IGZhY3RvcjtcblxuICAgICAgICAgIC8vIFNheSB3ZSd2ZSBub3JtYWxpemVkIGJ5IHRoaXMgc2FtcGxlIGFscmVhZHkuXG4gICAgICAgICAgc2FtcGxlc0RvbmUrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBwYXJ0aWFsbHktbm9ybWFsaXplZCBoeXBlcmdlb21ldHJpYyBQREYgZm9yIHRoZSBuZXh0XG4gICAgICAgIC8vIG51bWJlciBvZiBzdWNjZXNzZXNcbiAgICAgICAgc2NhbGVkUERGICo9IChuIC0gaSkgKiAobSAtIGkpIC8gKChpICsgMSkgKiAoTiAtIG0gLSBuICsgaSArIDEpKTtcblxuICAgICAgICAvLyBBZGQgdG8gdGhlIENERiBhbnN3ZXIuXG4gICAgICAgIHNjYWxlZENERiArPSBzY2FsZWRQREY7XG4gICAgICB9XG5cbiAgICAgIGZvcig7IHNhbXBsZXNEb25lIDwgbjsgc2FtcGxlc0RvbmUrKykge1xuICAgICAgICAvLyBBcHBseSBhbGwgdGhlIHJlc3Qgb2YgdGhlIG5vcm1hbGl6YXRpb25cbiAgICAgICAgc2NhbGVkQ0RGICo9IDEgLSAobSAvIChOIC0gc2FtcGxlc0RvbmUpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQm91bmQgYW5zd2VyIHNhbmVseSBiZWZvcmUgcmV0dXJuaW5nLlxuICAgICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHNjYWxlZENERikpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgdW5pZm9ybSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQucG9pc3Nvbiwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZihrLCBsKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGwsIGspICogTWF0aC5leHAoLWwpIC8galN0YXQuZmFjdG9yaWFsKGspO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGwpIHtcbiAgICB2YXIgc3VtYXJyID0gW10sXG4gICAgayA9IDA7XG4gICAgaWYgKHggPCAwKSByZXR1cm4gMDtcbiAgICBmb3IgKDsgayA8PSB4OyBrKyspIHtcbiAgICAgIHN1bWFyci5wdXNoKGpTdGF0LnBvaXNzb24ucGRmKGssIGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0LnN1bShzdW1hcnIpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGw7XG4gIH0sXG5cbiAgdmFyaWFuY2UgOiBmdW5jdGlvbihsKSB7XG4gICAgcmV0dXJuIGw7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobCkge1xuICAgIHZhciBwID0gMSwgayA9IDAsIEwgPSBNYXRoLmV4cCgtbCk7XG4gICAgZG8ge1xuICAgICAgaysrO1xuICAgICAgcCAqPSBNYXRoLnJhbmRvbSgpO1xuICAgIH0gd2hpbGUgKHAgPiBMKTtcbiAgICByZXR1cm4gayAtIDE7XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgdHJpYW5ndWxhciBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQudHJpYW5ndWxhciwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChiIDw9IGEgfHwgYyA8IGEgfHwgYyA+IGIpXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiAoeCA8IGEgfHwgeCA+IGIpXG4gICAgICAgID8gMFxuICAgICAgICA6ICh4IDw9IGMpXG4gICAgICAgICAgPyAoMiAqICh4IC0gYSkpIC8gKChiIC0gYSkgKiAoYyAtIGEpKVxuICAgICAgICAgIDogKDIgKiAoYiAtIHgpKSAvICgoYiAtIGEpICogKGIgLSBjKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYSwgYiwgYykge1xuICAgIGlmIChiIDw9IGEgfHwgYyA8IGEgfHwgYyA+IGIpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh4IDwgYSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4IDw9IGMpXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyh4IC0gYSwgMikgLyAoKGIgLSBhKSAqIChjIC0gYSkpO1xuICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdyhiIC0geCwgMikgLyAoKGIgLSBhKSAqIChiIC0gYykpO1xuICAgIH1cbiAgICAvLyBuZXZlciByZWFjaCB0aGlzXG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICsgYiArIGMpIC8gMztcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhLCBiLCBjKSB7XG4gICAgaWYgKGMgPD0gKGEgKyBiKSAvIDIpIHtcbiAgICAgIHJldHVybiBiIC0gTWF0aC5zcXJ0KChiIC0gYSkgKiAoYiAtIGMpKSAvIE1hdGguc3FydCgyKTtcbiAgICB9IGVsc2UgaWYgKGMgPiAoYSArIGIpIC8gMikge1xuICAgICAgcmV0dXJuIGEgKyBNYXRoLnNxcnQoKGIgLSBhKSAqIChjIC0gYSkpIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH1cbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYztcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShhLCBiLCBjKSB7XG4gICAgdmFyIHUgPSBNYXRoLnJhbmRvbSgpO1xuICAgIGlmICh1IDwgKChjIC0gYSkgLyAoYiAtIGEpKSlcbiAgICAgIHJldHVybiBhICsgTWF0aC5zcXJ0KHUgKiAoYiAtIGEpICogKGMgLSBhKSlcbiAgICByZXR1cm4gYiAtIE1hdGguc3FydCgoMSAtIHUpICogKGIgLSBhKSAqIChiIC0gYykpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICogYSArIGIgKiBiICsgYyAqIGMgLSBhICogYiAtIGEgKiBjIC0gYiAqIGMpIC8gMTg7XG4gIH1cbn0pO1xuXG59KHRoaXMualN0YXQsIE1hdGgpKTtcbi8qIFByb3ZpZGVzIGZ1bmN0aW9ucyBmb3IgdGhlIHNvbHV0aW9uIG9mIGxpbmVhciBzeXN0ZW0gb2YgZXF1YXRpb25zLCBpbnRlZ3JhdGlvbiwgZXh0cmFwb2xhdGlvbixcbiAqIGludGVycG9sYXRpb24sIGVpZ2VudmFsdWUgcHJvYmxlbXMsIGRpZmZlcmVudGlhbCBlcXVhdGlvbnMgYW5kIFBDQSBhbmFseXNpcy4gKi9cblxuKGZ1bmN0aW9uKGpTdGF0LCBNYXRoKSB7XG5cbnZhciBwdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG52YXIgaXNBcnJheSA9IGpTdGF0LnV0aWxzLmlzQXJyYXk7XG5cbmpTdGF0LmV4dGVuZCh7XG5cbiAgLy8gYWRkIGEgdmVjdG9yL21hdHJpeCB0byBhIHZlY3Rvci9tYXRyaXggb3Igc2NhbGFyXG4gIGFkZDogZnVuY3Rpb24gYWRkKGFyciwgYXJnKSB7XG4gICAgLy8gY2hlY2sgaWYgYXJnIGlzIGEgdmVjdG9yIG9yIHNjYWxhclxuICAgIGlmIChpc0FycmF5KGFyZykpIHtcbiAgICAgIGlmICghaXNBcnJheShhcmdbMF0pKSBhcmcgPSBbIGFyZyBdO1xuICAgICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlLCByb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgKyBhcmdbcm93XVtjb2xdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKyBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIHN1YnRyYWN0IGEgdmVjdG9yIG9yIHNjYWxhciBmcm9tIHRoZSB2ZWN0b3JcbiAgc3VidHJhY3Q6IGZ1bmN0aW9uIHN1YnRyYWN0KGFyciwgYXJnKSB7XG4gICAgLy8gY2hlY2sgaWYgYXJnIGlzIGEgdmVjdG9yIG9yIHNjYWxhclxuICAgIGlmIChpc0FycmF5KGFyZykpIHtcbiAgICAgIGlmICghaXNBcnJheShhcmdbMF0pKSBhcmcgPSBbIGFyZyBdO1xuICAgICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlLCByb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgLSBhcmdbcm93XVtjb2xdIHx8IDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAtIGFyZzsgfSk7XG4gIH0sXG5cbiAgLy8gbWF0cml4IGRpdmlzaW9uXG4gIGRpdmlkZTogZnVuY3Rpb24gZGl2aWRlKGFyciwgYXJnKSB7XG4gICAgaWYgKGlzQXJyYXkoYXJnKSkge1xuICAgICAgaWYgKCFpc0FycmF5KGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgICByZXR1cm4galN0YXQubXVsdGlwbHkoYXJyLCBqU3RhdC5pbnYoYXJnKSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgLyBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkoYXJyLCBhcmcpIHtcbiAgICB2YXIgcm93LCBjb2wsIG5yZXNjb2xzLCBzdW0sXG4gICAgbnJvdyA9IGFyci5sZW5ndGgsXG4gICAgbmNvbCA9IGFyclswXS5sZW5ndGgsXG4gICAgcmVzID0galN0YXQuemVyb3MobnJvdywgbnJlc2NvbHMgPSAoaXNBcnJheShhcmcpKSA/IGFyZ1swXS5sZW5ndGggOiBuY29sKSxcbiAgICByZXNjb2xzID0gMDtcbiAgICBpZiAoaXNBcnJheShhcmcpKSB7XG4gICAgICBmb3IgKDsgcmVzY29scyA8IG5yZXNjb2xzOyByZXNjb2xzKyspIHtcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCBucm93OyByb3crKykge1xuICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgICAgICBzdW0gKz0gYXJyW3Jvd11bY29sXSAqIGFyZ1tjb2xdW3Jlc2NvbHNdO1xuICAgICAgICAgIHJlc1tyb3ddW3Jlc2NvbHNdID0gc3VtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKG5yb3cgPT09IDEgJiYgcmVzY29scyA9PT0gMSkgPyByZXNbMF1bMF0gOiByZXM7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKiBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBtYXRyaWNpZXNcbiAgZG90OiBmdW5jdGlvbiBkb3QoYXJyLCBhcmcpIHtcbiAgICBpZiAoIWlzQXJyYXkoYXJyWzBdKSkgYXJyID0gWyBhcnIgXTtcbiAgICBpZiAoIWlzQXJyYXkoYXJnWzBdKSkgYXJnID0gWyBhcmcgXTtcbiAgICAvLyBjb252ZXJ0IGNvbHVtbiB0byByb3cgdmVjdG9yXG4gICAgdmFyIGxlZnQgPSAoYXJyWzBdLmxlbmd0aCA9PT0gMSAmJiBhcnIubGVuZ3RoICE9PSAxKSA/IGpTdGF0LnRyYW5zcG9zZShhcnIpIDogYXJyLFxuICAgIHJpZ2h0ID0gKGFyZ1swXS5sZW5ndGggPT09IDEgJiYgYXJnLmxlbmd0aCAhPT0gMSkgPyBqU3RhdC50cmFuc3Bvc2UoYXJnKSA6IGFyZyxcbiAgICByZXMgPSBbXSxcbiAgICByb3cgPSAwLFxuICAgIG5yb3cgPSBsZWZ0Lmxlbmd0aCxcbiAgICBuY29sID0gbGVmdFswXS5sZW5ndGgsXG4gICAgc3VtLCBjb2w7XG4gICAgZm9yICg7IHJvdyA8IG5yb3c7IHJvdysrKSB7XG4gICAgICByZXNbcm93XSA9IFtdO1xuICAgICAgc3VtID0gMDtcbiAgICAgIGZvciAoY29sID0gMDsgY29sIDwgbmNvbDsgY29sKyspXG4gICAgICBzdW0gKz0gbGVmdFtyb3ddW2NvbF0gKiByaWdodFtyb3ddW2NvbF07XG4gICAgICByZXNbcm93XSA9IHN1bTtcbiAgICB9XG4gICAgcmV0dXJuIChyZXMubGVuZ3RoID09PSAxKSA/IHJlc1swXSA6IHJlcztcbiAgfSxcblxuICAvLyByYWlzZSBldmVyeSBlbGVtZW50IGJ5IGEgc2NhbGFyXG4gIHBvdzogZnVuY3Rpb24gcG93KGFyciwgYXJnKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBNYXRoLnBvdyh2YWx1ZSwgYXJnKTsgfSk7XG4gIH0sXG5cbiAgLy8gZ2VuZXJhdGUgdGhlIGFic29sdXRlIHZhbHVlcyBvZiB0aGUgdmVjdG9yXG4gIGFiczogZnVuY3Rpb24gYWJzKGFycikge1xuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gTWF0aC5hYnModmFsdWUpOyB9KTtcbiAgfSxcblxuICAvLyBjb21wdXRlcyB0aGUgcC1ub3JtIG9mIHRoZSB2ZWN0b3JcbiAgLy8gSW4gdGhlIGNhc2UgdGhhdCBhIG1hdHJpeCBpcyBwYXNzZWQsIHVzZXMgdGhlIGZpcnN0IHJvdyBhcyB0aGUgdmVjdG9yXG4gIG5vcm06IGZ1bmN0aW9uIG5vcm0oYXJyLCBwKSB7XG4gICAgdmFyIG5ub3JtID0gMCxcbiAgICBpID0gMDtcbiAgICAvLyBjaGVjayB0aGUgcC12YWx1ZSBvZiB0aGUgbm9ybSwgYW5kIHNldCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICAgIGlmIChpc05hTihwKSkgcCA9IDI7XG4gICAgLy8gY2hlY2sgaWYgbXVsdGktZGltZW5zaW9uYWwgYXJyYXksIGFuZCBtYWtlIHZlY3RvciBjb3JyZWN0aW9uXG4gICAgaWYgKGlzQXJyYXkoYXJyWzBdKSkgYXJyID0gYXJyWzBdO1xuICAgIC8vIHZlY3RvciBub3JtXG4gICAgZm9yICg7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ub3JtICs9IE1hdGgucG93KE1hdGguYWJzKGFycltpXSksIHApO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5wb3cobm5vcm0sIDEgLyBwKTtcbiAgfSxcblxuICAvLyBUT0RPOiBtYWtlIGNvbXBhdGlibGUgd2l0aCBtYXRyaWNlc1xuICAvLyBjb21wdXRlcyB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyBpbiByYWRzXG4gIGFuZ2xlOiBmdW5jdGlvbiBhbmdsZShhcnIsIGFyZykge1xuICAgIHJldHVybiBNYXRoLmFjb3MoalN0YXQuZG90KGFyciwgYXJnKSAvIChqU3RhdC5ub3JtKGFycikgKiBqU3RhdC5ub3JtKGFyZykpKTtcbiAgfSxcblxuICAvLyBhdWdtZW50IG9uZSBtYXRyaXggYnkgYW5vdGhlclxuICBhdWc6IGZ1bmN0aW9uIGF1ZyhhLCBiKSB7XG4gICAgdmFyIG5ld2FyciA9IGEuc2xpY2UoKSxcbiAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IG5ld2Fyci5sZW5ndGg7IGkrKykge1xuICAgICAgcHVzaC5hcHBseShuZXdhcnJbaV0sIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3YXJyO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KGEpIHtcbiAgICB2YXIgcm93cyA9IGEubGVuZ3RoLFxuICAgIGNvbHMgPSBhWzBdLmxlbmd0aCxcbiAgICBiID0galN0YXQuaWRlbnRpdHkocm93cywgY29scyksXG4gICAgYyA9IGpTdGF0LmdhdXNzX2pvcmRhbihhLCBiKSxcbiAgICBvYmogPSBbXSxcbiAgICBpID0gMCxcbiAgICBqO1xuICAgIGZvciAoOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICBvYmpbaV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IGNvbHMgLSAxOyBqIDwgY1swXS5sZW5ndGg7IGorKylcbiAgICAgIG9ialtpXVtqIC0gY29sc10gPSBjW2ldW2pdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAgZGV0OiBmdW5jdGlvbiBkZXQoYSkge1xuICAgIHZhciBhbGVuID0gYS5sZW5ndGgsXG4gICAgYWxlbmQgPSBhbGVuICogMixcbiAgICB2YWxzID0gbmV3IEFycmF5KGFsZW5kKSxcbiAgICByb3dzaGlmdCA9IGFsZW4gLSAxLFxuICAgIGNvbHNoaWZ0ID0gYWxlbmQgLSAxLFxuICAgIG1yb3cgPSByb3dzaGlmdCAtIGFsZW4gKyAxLFxuICAgIG1jb2wgPSBjb2xzaGlmdCxcbiAgICBpID0gMCxcbiAgICByZXN1bHQgPSAwLFxuICAgIGo7XG4gICAgLy8gY2hlY2sgZm9yIHNwZWNpYWwgMngyIGNhc2VcbiAgICBpZiAoYWxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIGFbMF1bMF0gKiBhWzFdWzFdIC0gYVswXVsxXSAqIGFbMV1bMF07XG4gICAgfVxuICAgIGZvciAoOyBpIDwgYWxlbmQ7IGkrKykge1xuICAgICAgdmFsc1tpXSA9IDE7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhbGVuOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhbGVuOyBqKyspIHtcbiAgICAgICAgdmFsc1sobXJvdyA8IDApID8gbXJvdyArIGFsZW4gOiBtcm93IF0gKj0gYVtpXVtqXTtcbiAgICAgICAgdmFsc1sobWNvbCA8IGFsZW4pID8gbWNvbCArIGFsZW4gOiBtY29sIF0gKj0gYVtpXVtqXTtcbiAgICAgICAgbXJvdysrO1xuICAgICAgICBtY29sLS07XG4gICAgICB9XG4gICAgICBtcm93ID0gLS1yb3dzaGlmdCAtIGFsZW4gKyAxO1xuICAgICAgbWNvbCA9IC0tY29sc2hpZnQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSB2YWxzW2ldO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGFsZW5kOyBpKyspIHtcbiAgICAgIHJlc3VsdCAtPSB2YWxzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGdhdXNzX2VsaW1pbmF0aW9uOiBmdW5jdGlvbiBnYXVzc19lbGltaW5hdGlvbihhLCBiKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgIGogPSAwLFxuICAgIG4gPSBhLmxlbmd0aCxcbiAgICBtID0gYVswXS5sZW5ndGgsXG4gICAgZmFjdG9yID0gMSxcbiAgICBzdW0gPSAwLFxuICAgIHggPSBbXSxcbiAgICBtYXVnLCBwaXZvdCwgdGVtcCwgaztcbiAgICBhID0galN0YXQuYXVnKGEsIGIpO1xuICAgIG1hdWcgPSBhWzBdLmxlbmd0aDtcbiAgICBmb3IoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBwaXZvdCA9IGFbaV1baV07XG4gICAgICBqID0gaTtcbiAgICAgIGZvciAoayA9IGkgKyAxOyBrIDwgbTsgaysrKSB7XG4gICAgICAgIGlmIChwaXZvdCA8IE1hdGguYWJzKGFba11baV0pKSB7XG4gICAgICAgICAgcGl2b3QgPSBhW2tdW2ldO1xuICAgICAgICAgIGogPSBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaiAhPSBpKSB7XG4gICAgICAgIGZvcihrID0gMDsgayA8IG1hdWc7IGsrKykge1xuICAgICAgICAgIHRlbXAgPSBhW2ldW2tdO1xuICAgICAgICAgIGFbaV1ba10gPSBhW2pdW2tdO1xuICAgICAgICAgIGFbal1ba10gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICBmYWN0b3IgPSBhW2pdW2ldIC8gYVtpXVtpXTtcbiAgICAgICAgZm9yKGsgPSBpOyBrIDwgbWF1ZzsgaysrKSB7XG4gICAgICAgICAgYVtqXVtrXSA9IGFbal1ba10gLSBmYWN0b3IgKiBhW2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgc3VtID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqPD0gbiAtIDE7IGorKykge1xuICAgICAgICBzdW0gPSB4W2pdICogYVtpXVtqXTtcbiAgICAgIH1cbiAgICAgIHhbaV0gPShhW2ldW21hdWcgLSAxXSAtIHN1bSkgLyBhW2ldW2ldO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfSxcblxuICBnYXVzc19qb3JkYW46IGZ1bmN0aW9uIGdhdXNzX2pvcmRhbihhLCBiKSB7XG4gICAgdmFyIG0gPSBqU3RhdC5hdWcoYSwgYiksXG4gICAgaCA9IG0ubGVuZ3RoLFxuICAgIHcgPSBtWzBdLmxlbmd0aDtcbiAgICAvLyBmaW5kIG1heCBwaXZvdFxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICB2YXIgbWF4cm93ID0geTtcbiAgICAgIGZvciAodmFyIHkyID0geSsxOyB5MiA8IGg7IHkyKyspIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKG1beTJdW3ldKSA+IE1hdGguYWJzKG1bbWF4cm93XVt5XSkpXG4gICAgICAgICAgbWF4cm93ID0geTI7XG4gICAgICB9XG4gICAgICB2YXIgdG1wID0gbVt5XTtcbiAgICAgIG1beV0gPSBtW21heHJvd107XG4gICAgICBtW21heHJvd10gPSB0bXBcbiAgICAgIGZvciAodmFyIHkyID0geSsxOyB5MiA8IGg7IHkyKyspIHtcbiAgICAgICAgYyA9IG1beTJdW3ldIC8gbVt5XVt5XTtcbiAgICAgICAgZm9yICh2YXIgeCA9IHk7IHggPCB3OyB4KyspIHtcbiAgICAgICAgICBtW3kyXVt4XSAtPSBtW3ldW3hdICogYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBiYWNrc3Vic3RpdHV0ZVxuICAgIGZvciAodmFyIHkgPSBoLTE7IHkgPj0gMDsgeS0tKSB7XG4gICAgICBjID0gbVt5XVt5XTtcbiAgICAgIGZvciAodmFyIHkyID0gMDsgeTIgPCB5OyB5MisrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSB3LTE7IHggPiB5LTE7IHgtLSkge1xuICAgICAgICAgIG1beTJdW3hdIC09IG1beV1beF0gKiBtW3kyXVt5XSAvIGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1beV1beV0gLz0gYztcbiAgICAgIGZvciAodmFyIHggPSBoOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgIG1beV1beF0gLz0gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH0sXG5cbiAgbHU6IGZ1bmN0aW9uIGx1KGEsIGIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2x1IG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBjaG9sZXNreTogZnVuY3Rpb24gY2hvbGVza3koYSwgYikge1xuICAgIHRocm93IG5ldyBFcnJvcignY2hvbGVza3kgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuXG4gIGdhdXNzX2phY29iaTogZnVuY3Rpb24gZ2F1c3NfamFjb2JpKGEsIGIsIHgsIHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIHh2LCBjLCBoLCB4aztcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbFtpXSA9IFtdO1xuICAgICAgdVtpXSA9IFtdO1xuICAgICAgZFtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICBsW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICB1W2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IGopIHtcbiAgICAgICAgICB1W2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IHVbaV1bal0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGggPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoZCksIGpTdGF0LmFkZChsLCB1KSksIC0xKTtcbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQuaW52KGQpLCBiKTtcbiAgICB4diA9IHg7XG4gICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeCksIGMpO1xuICAgIGkgPSAyO1xuICAgIHdoaWxlIChNYXRoLmFicyhqU3RhdC5ub3JtKGpTdGF0LnN1YnRyYWN0KHhrLHh2KSkpID4gcikge1xuICAgICAgeHYgPSB4aztcbiAgICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHh2KSwgYyk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB4aztcbiAgfSxcblxuICBnYXVzc19zZWlkZWw6IGZ1bmN0aW9uIGdhdXNzX3NlaWRlbChhLCBiLCB4LCByKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIGosIHh2LCBjLCBoLCB4aztcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbFtpXSA9IFtdO1xuICAgICAgdVtpXSA9IFtdO1xuICAgICAgZFtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICBsW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICB1W2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IGopIHtcbiAgICAgICAgICB1W2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IHVbaV1bal0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGggPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsIGwpKSwgdSksIC0xKTtcbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQuaW52KGpTdGF0LmFkZChkLCBsKSksIGIpO1xuICAgIHh2ID0geDtcbiAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4KSwgYyk7XG4gICAgaSA9IDI7XG4gICAgd2hpbGUgKE1hdGguYWJzKGpTdGF0Lm5vcm0oalN0YXQuc3VidHJhY3QoeGssIHh2KSkpID4gcikge1xuICAgICAgeHYgPSB4aztcbiAgICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHh2KSwgYyk7XG4gICAgICBpID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiB4aztcbiAgfSxcblxuICBTT1I6IGZ1bmN0aW9uIFNPUihhLCBiLCB4LCByLCB3KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIGosIHh2LCBjLCBoLCB4aztcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbFtpXSA9IFtdO1xuICAgICAgdVtpXSA9IFtdO1xuICAgICAgZFtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICBsW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICB1W2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA8IGopIHtcbiAgICAgICAgICB1W2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gZFtpXVtqXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZFtpXVtqXSA9IGFbaV1bal07XG4gICAgICAgICAgbFtpXVtqXSA9IHVbaV1bal0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGggPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsIGpTdGF0Lm11bHRpcGx5KGwsIHcpKSksXG4gICAgICAgICAgICAgICAgICAgICAgIGpTdGF0LnN1YnRyYWN0KGpTdGF0Lm11bHRpcGx5KGQsIDEgLSB3KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalN0YXQubXVsdGlwbHkodSwgdykpKTtcbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkoalN0YXQuaW52KGpTdGF0LmFkZChkLFxuICAgICAgICBqU3RhdC5tdWx0aXBseShsLCB3KSkpLCBiKSwgdyk7XG4gICAgeHYgPSB4O1xuICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHgpLCBjKTtcbiAgICBpID0gMjtcbiAgICB3aGlsZSAoTWF0aC5hYnMoalN0YXQubm9ybShqU3RhdC5zdWJ0cmFjdCh4aywgeHYpKSkgPiByKSB7XG4gICAgICB4diA9IHhrO1xuICAgICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeHYpLCBjKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHhrO1xuICB9LFxuXG4gIGhvdXNlaG9sZGVyOiBmdW5jdGlvbiBob3VzZWhvbGRlcihhKSB7XG4gICAgdmFyIG0gPSBhLmxlbmd0aDtcbiAgICB2YXIgbiA9IGFbMF0ubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdyA9IFtdO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIGFscGhhLCByLCBrLCBqLCBmYWN0b3I7XG4gICAgZm9yICg7IGkgPCBtIC0gMTsgaSsrKSB7XG4gICAgICBhbHBoYSA9IDA7XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKylcbiAgICAgIGFscGhhICs9IChhW2pdW2ldICogYVtqXVtpXSk7XG4gICAgICBmYWN0b3IgPSAoYVtpICsgMV1baV0gPiAwKSA/IC0xIDogMTtcbiAgICAgIGFscGhhID0gZmFjdG9yICogTWF0aC5zcXJ0KGFscGhhKTtcbiAgICAgIHIgPSBNYXRoLnNxcnQoKCgoYWxwaGEgKiBhbHBoYSkgLSBhW2kgKyAxXVtpXSAqIGFscGhhKSAvIDIpKTtcbiAgICAgIHcgPSBqU3RhdC56ZXJvcyhtLCAxKTtcbiAgICAgIHdbaSArIDFdWzBdID0gKGFbaSArIDFdW2ldIC0gYWxwaGEpIC8gKDIgKiByKTtcbiAgICAgIGZvciAoayA9IGkgKyAyOyBrIDwgbTsgaysrKSB3W2tdWzBdID0gYVtrXVtpXSAvICgyICogcik7XG4gICAgICBwID0galN0YXQuc3VidHJhY3QoalN0YXQuaWRlbnRpdHkobSwgbiksXG4gICAgICAgICAgalN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkodywgalN0YXQudHJhbnNwb3NlKHcpKSwgMikpO1xuICAgICAgYSA9IGpTdGF0Lm11bHRpcGx5KHAsIGpTdGF0Lm11bHRpcGx5KGEsIHApKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH0sXG5cbiAgLy8gVE9ETzogbm90IHdvcmtpbmcgcHJvcGVybHkuXG4gIFFSOiBmdW5jdGlvbiBRUihhLCBiKSB7XG4gICAgdmFyIG0gPSBhLmxlbmd0aDtcbiAgICB2YXIgbiA9IGFbMF0ubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdyA9IFtdO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIHggPSBbXTtcbiAgICB2YXIgaiwgYWxwaGEsIHIsIGssIGZhY3Rvciwgc3VtO1xuICAgIGZvciAoOyBpIDwgbSAtIDE7IGkrKykge1xuICAgICAgYWxwaGEgPSAwO1xuICAgICAgZm9yIChqID0gaSArIDE7IGogPCBuOyBqKyspXG4gICAgICAgIGFscGhhICs9IChhW2pdW2ldICogYVtqXVtpXSk7XG4gICAgICBmYWN0b3IgPSAoYVtpICsgMV1baV0gPiAwKSA/IC0xIDogMTtcbiAgICAgIGFscGhhID0gZmFjdG9yICogTWF0aC5zcXJ0KGFscGhhKTtcbiAgICAgIHIgPSBNYXRoLnNxcnQoKCgoYWxwaGEgKiBhbHBoYSkgLSBhW2kgKyAxXVtpXSAqIGFscGhhKSAvIDIpKTtcbiAgICAgIHcgPSBqU3RhdC56ZXJvcyhtLCAxKTtcbiAgICAgIHdbaSArIDFdWzBdID0gKGFbaSArIDFdW2ldIC0gYWxwaGEpIC8gKDIgKiByKTtcbiAgICAgIGZvciAoayA9IGkgKyAyOyBrIDwgbTsgaysrKVxuICAgICAgICB3W2tdWzBdID0gYVtrXVtpXSAvICgyICogcik7XG4gICAgICBwID0galN0YXQuc3VidHJhY3QoalN0YXQuaWRlbnRpdHkobSwgbiksXG4gICAgICAgICAgalN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkodywgalN0YXQudHJhbnNwb3NlKHcpKSwgMikpO1xuICAgICAgYSA9IGpTdGF0Lm11bHRpcGx5KHAsIGEpO1xuICAgICAgYiA9IGpTdGF0Lm11bHRpcGx5KHAsIGIpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBtIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHN1bSA9IDA7XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8PSBuIC0gMTsgaisrKVxuICAgICAgc3VtID0geFtqXSAqIGFbaV1bal07XG4gICAgICB4W2ldID0gYltpXVswXSAvIGFbaV1baV07XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9LFxuXG4gIGphY29iaTogZnVuY3Rpb24gamFjb2JpKGEpIHtcbiAgICB2YXIgY29uZGl0aW9uID0gMTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGUgPSBqU3RhdC5pZGVudGl0eShuLCBuKTtcbiAgICB2YXIgZXYgPSBbXTtcbiAgICB2YXIgYiwgaSwgaiwgcCwgcSwgbWF4aW0sIHRoZXRhLCBzO1xuICAgIC8vIGNvbmRpdGlvbiA9PT0gMSBvbmx5IGlmIHRvbGVyYW5jZSBpcyBub3QgcmVhY2hlZFxuICAgIHdoaWxlIChjb25kaXRpb24gPT09IDEpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgICBtYXhpbSA9IGFbMF1bMV07XG4gICAgICBwID0gMDtcbiAgICAgIHEgPSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgaWYgKGkgIT0gaikge1xuICAgICAgICAgICAgaWYgKG1heGltIDwgTWF0aC5hYnMoYVtpXVtqXSkpIHtcbiAgICAgICAgICAgICAgbWF4aW0gPSBNYXRoLmFicyhhW2ldW2pdKTtcbiAgICAgICAgICAgICAgcCA9IGk7XG4gICAgICAgICAgICAgIHEgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFbcF1bcF0gPT09IGFbcV1bcV0pXG4gICAgICAgIHRoZXRhID0gKGFbcF1bcV0gPiAwKSA/IE1hdGguUEkgLyA0IDogLU1hdGguUEkgLyA0O1xuICAgICAgZWxzZVxuICAgICAgICB0aGV0YSA9IE1hdGguYXRhbigyICogYVtwXVtxXSAvIChhW3BdW3BdIC0gYVtxXVtxXSkpIC8gMjtcbiAgICAgIHMgPSBqU3RhdC5pZGVudGl0eShuLCBuKTtcbiAgICAgIHNbcF1bcF0gPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICBzW3BdW3FdID0gLU1hdGguc2luKHRoZXRhKTtcbiAgICAgIHNbcV1bcF0gPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICBzW3FdW3FdID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgLy8gZWlnZW4gdmVjdG9yIG1hdHJpeFxuICAgICAgZSA9IGpTdGF0Lm11bHRpcGx5KGUsIHMpO1xuICAgICAgYiA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihzKSwgYSksIHMpO1xuICAgICAgYSA9IGI7XG4gICAgICBjb25kaXRpb24gPSAwO1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgaWYgKGkgIT0gaiAmJiBNYXRoLmFicyhhW2ldW2pdKSA+IDAuMDAxKSB7XG4gICAgICAgICAgICBjb25kaXRpb24gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBldi5wdXNoKGFbaV1baV0pO1xuICAgIC8vcmV0dXJucyBib3RoIHRoZSBlaWdlbnZhbHVlIGFuZCBlaWdlbm1hdHJpeFxuICAgIHJldHVybiBbZSwgZXZdO1xuICB9LFxuXG4gIHJ1bmdla3V0dGE6IGZ1bmN0aW9uIHJ1bmdla3V0dGEoZiwgaCwgcCwgdF9qLCB1X2osIG9yZGVyKSB7XG4gICAgdmFyIGsxLCBrMiwgdV9qMSwgazMsIGs0O1xuICAgIGlmIChvcmRlciA9PT0gMikge1xuICAgICAgd2hpbGUgKHRfaiA8PSBwKSB7XG4gICAgICAgIGsxID0gaCAqIGYodF9qLCB1X2opO1xuICAgICAgICBrMiA9IGggKiBmKHRfaiArIGgsIHVfaiArIGsxKTtcbiAgICAgICAgdV9qMSA9IHVfaiArIChrMSArIGsyKSAvIDI7XG4gICAgICAgIHVfaiA9IHVfajE7XG4gICAgICAgIHRfaiA9IHRfaiArIGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcmRlciA9PT0gNCkge1xuICAgICAgd2hpbGUgKHRfaiA8PSBwKSB7XG4gICAgICAgIGsxID0gaCAqIGYodF9qLCB1X2opO1xuICAgICAgICBrMiA9IGggKiBmKHRfaiArIGggLyAyLCB1X2ogKyBrMSAvIDIpO1xuICAgICAgICBrMyA9IGggKiBmKHRfaiArIGggLyAyLCB1X2ogKyBrMiAvIDIpO1xuICAgICAgICBrNCA9IGggKiBmKHRfaiAraCwgdV9qICsgazMpO1xuICAgICAgICB1X2oxID0gdV9qICsgKGsxICsgMiAqIGsyICsgMiAqIGszICsgazQpIC8gNjtcbiAgICAgICAgdV9qID0gdV9qMTtcbiAgICAgICAgdF9qID0gdF9qICsgaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVfajtcbiAgfSxcblxuICByb21iZXJnOiBmdW5jdGlvbiByb21iZXJnKGYsIGEsIGIsIG9yZGVyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBoID0gKGIgLSBhKSAvIDI7XG4gICAgdmFyIHggPSBbXTtcbiAgICB2YXIgaDEgPSBbXTtcbiAgICB2YXIgZyA9IFtdO1xuICAgIHZhciBtLCBhMSwgaiwgaywgSSwgZDtcbiAgICB3aGlsZSAoaSA8IG9yZGVyIC8gMikge1xuICAgICAgSSA9IGYoYSk7XG4gICAgICBmb3IgKGogPSBhLCBrID0gMDsgaiA8PSBiOyBqID0gaiArIGgsIGsrKykgeFtrXSA9IGo7XG4gICAgICBtID0geC5sZW5ndGg7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgbSAtIDE7IGorKykge1xuICAgICAgICBJICs9ICgoKGogJSAyKSAhPT0gMCkgPyA0IDogMikgKiBmKHhbal0pO1xuICAgICAgfVxuICAgICAgSSA9IChoIC8gMykgKiAoSSArIGYoYikpO1xuICAgICAgZ1tpXSA9IEk7XG4gICAgICBoIC89IDI7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGExID0gZy5sZW5ndGg7XG4gICAgbSA9IDE7XG4gICAgd2hpbGUgKGExICE9PSAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYTEgLSAxOyBqKyspXG4gICAgICBoMVtqXSA9ICgoTWF0aC5wb3coNCwgbSkpICogZ1tqICsgMV0gLSBnW2pdKSAvIChNYXRoLnBvdyg0LCBtKSAtIDEpO1xuICAgICAgYTEgPSBoMS5sZW5ndGg7XG4gICAgICBnID0gaDE7XG4gICAgICBoMSA9IFtdO1xuICAgICAgbSsrO1xuICAgIH1cbiAgICByZXR1cm4gZztcbiAgfSxcblxuICByaWNoYXJkc29uOiBmdW5jdGlvbiByaWNoYXJkc29uKFgsIGYsIHgsIGgpIHtcbiAgICBmdW5jdGlvbiBwb3MoWCwgeCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIG4gPSBYLmxlbmd0aDtcbiAgICAgIHZhciBwO1xuICAgICAgZm9yICg7IGkgPCBuOyBpKyspXG4gICAgICAgIGlmIChYW2ldID09PSB4KSBwID0gaTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICB2YXIgbiA9IFgubGVuZ3RoLFxuICAgIGhfbWluID0gTWF0aC5hYnMoeCAtIFhbcG9zKFgsIHgpICsgMV0pLFxuICAgIGkgPSAwLFxuICAgIGcgPSBbXSxcbiAgICBoMSA9IFtdLFxuICAgIHkxLCB5MiwgbSwgYSwgajtcbiAgICB3aGlsZSAoaCA+PSBoX21pbikge1xuICAgICAgeTEgPSBwb3MoWCwgeCArIGgpO1xuICAgICAgeTIgPSBwb3MoWCwgeCk7XG4gICAgICBnW2ldID0gKGZbeTFdIC0gMiAqIGZbeTJdICsgZlsyICogeTIgLSB5MV0pIC8gKGggKiBoKTtcbiAgICAgIGggLz0gMjtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgYSA9IGcubGVuZ3RoO1xuICAgIG0gPSAxO1xuICAgIHdoaWxlIChhICE9IDEpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhIC0gMTsgaisrKVxuICAgICAgaDFbal0gPSAoKE1hdGgucG93KDQsIG0pKSAqIGdbaiArIDFdIC0gZ1tqXSkgLyAoTWF0aC5wb3coNCwgbSkgLSAxKTtcbiAgICAgIGEgPSBoMS5sZW5ndGg7XG4gICAgICBnID0gaDE7XG4gICAgICBoMSA9IFtdO1xuICAgICAgbSsrO1xuICAgIH1cbiAgICByZXR1cm4gZztcbiAgfSxcblxuICBzaW1wc29uOiBmdW5jdGlvbiBzaW1wc29uKGYsIGEsIGIsIG4pIHtcbiAgICB2YXIgaCA9IChiIC0gYSkgLyBuO1xuICAgIHZhciBJID0gZihhKTtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHZhciBqID0gYTtcbiAgICB2YXIgayA9IDA7XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBtO1xuICAgIGZvciAoOyBqIDw9IGI7IGogPSBqICsgaCwgaysrKVxuICAgICAgeFtrXSA9IGo7XG4gICAgbSA9IHgubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbSAtIDE7IGkrKykge1xuICAgICAgSSArPSAoKGkgJSAyICE9PSAwKSA/IDQgOiAyKSAqIGYoeFtpXSk7XG4gICAgfVxuICAgIHJldHVybiAoaCAvIDMpICogKEkgKyBmKGIpKTtcbiAgfSxcblxuICBoZXJtaXRlOiBmdW5jdGlvbiBoZXJtaXRlKFgsIEYsIGRGLCB2YWx1ZSkge1xuICAgIHZhciBuID0gWC5sZW5ndGg7XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciBkbCA9IFtdO1xuICAgIHZhciBBID0gW107XG4gICAgdmFyIEIgPSBbXTtcbiAgICB2YXIgajtcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbFtpXSA9IDE7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpICE9IGopIGxbaV0gKj0gKHZhbHVlIC0gWFtqXSkgLyAoWFtpXSAtIFhbal0pO1xuICAgICAgfVxuICAgICAgZGxbaV0gPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSAhPSBqKSBkbFtpXSArPSAxIC8gKFggW2ldIC0gWFtqXSk7XG4gICAgICB9XG4gICAgICBBW2ldID0gKDEgLSAyICogKHZhbHVlIC0gWFtpXSkgKiBkbFtpXSkgKiAobFtpXSAqIGxbaV0pO1xuICAgICAgQltpXSA9ICh2YWx1ZSAtIFhbaV0pICogKGxbaV0gKiBsW2ldKTtcbiAgICAgIHAgKz0gKEFbaV0gKiBGW2ldICsgQltpXSAqIGRGW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgbGFncmFuZ2U6IGZ1bmN0aW9uIGxhZ3JhbmdlKFgsIEYsIHZhbHVlKSB7XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiwgbDtcbiAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsID0gRltpXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgLy8gY2FsY3VsYXRpbmcgdGhlIGxhZ3JhbmdlIHBvbHlub21pYWwgTF9pXG4gICAgICAgIGlmIChpICE9IGopIGwgKj0gKHZhbHVlIC0gWFtqXSkgLyAoWFtpXSAtIFhbal0pO1xuICAgICAgfVxuICAgICAgLy8gYWRkaW5nIHRoZSBsYWdyYW5nZSBwb2x5bm9taWFscyBmb3VuZCBhYm92ZVxuICAgICAgcCArPSBsO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICBjdWJpY19zcGxpbmU6IGZ1bmN0aW9uIGN1YmljX3NwbGluZShYLCBGLCB2YWx1ZSkge1xuICAgIHZhciBuID0gWC5sZW5ndGg7XG4gICAgdmFyIGkgPSAwLCBqO1xuICAgIHZhciBBID0gW107XG4gICAgdmFyIEIgPSBbXTtcbiAgICB2YXIgYWxwaGEgPSBbXTtcbiAgICB2YXIgYyA9IFtdO1xuICAgIHZhciBoID0gW107XG4gICAgdmFyIGIgPSBbXTtcbiAgICB2YXIgZCA9IFtdO1xuICAgIGZvciAoOyBpIDwgbiAtIDE7IGkrKylcbiAgICAgIGhbaV0gPSBYW2kgKyAxXSAtIFhbaV07XG4gICAgYWxwaGFbMF0gPSAwO1xuICAgIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICBhbHBoYVtpXSA9ICgzIC8gaFtpXSkgKiAoRltpICsgMV0gLSBGW2ldKSAtXG4gICAgICAgICAgKDMgLyBoW2ktMV0pICogKEZbaV0gLSBGW2ktMV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgQVtpXSA9IFtdO1xuICAgICAgQltpXSA9IFtdO1xuICAgICAgQVtpXVtpLTFdID0gaFtpLTFdO1xuICAgICAgQVtpXVtpXSA9IDIgKiAoaFtpIC0gMV0gKyBoW2ldKTtcbiAgICAgIEFbaV1baSsxXSA9IGhbaV07XG4gICAgICBCW2ldWzBdID0gYWxwaGFbaV07XG4gICAgfVxuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoQSksIEIpO1xuICAgIGZvciAoaiA9IDA7IGogPCBuIC0gMTsgaisrKSB7XG4gICAgICBiW2pdID0gKEZbaiArIDFdIC0gRltqXSkgLyBoW2pdIC0gaFtqXSAqIChjW2ogKyAxXVswXSArIDIgKiBjW2pdWzBdKSAvIDM7XG4gICAgICBkW2pdID0gKGNbaiArIDFdWzBdIC0gY1tqXVswXSkgLyAoMyAqIGhbal0pO1xuICAgIH1cbiAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBpZiAoWFtqXSA+IHZhbHVlKSBicmVhaztcbiAgICB9XG4gICAgaiAtPSAxO1xuICAgIHJldHVybiBGW2pdICsgKHZhbHVlIC0gWFtqXSkgKiBiW2pdICsgalN0YXQuc3EodmFsdWUtWFtqXSkgKlxuICAgICAgICBjW2pdICsgKHZhbHVlIC0gWFtqXSkgKiBqU3RhdC5zcSh2YWx1ZSAtIFhbal0pICogZFtqXTtcbiAgfSxcblxuICBnYXVzc19xdWFkcmF0dXJlOiBmdW5jdGlvbiBnYXVzc19xdWFkcmF0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2F1c3NfcXVhZHJhdHVyZSBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgUENBOiBmdW5jdGlvbiBQQ0EoWCkge1xuICAgIHZhciBtID0gWC5sZW5ndGg7XG4gICAgdmFyIG4gPSBYWzBdLmxlbmd0aDtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiwgdGVtcDE7XG4gICAgdmFyIHUgPSBbXTtcbiAgICB2YXIgRCA9IFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgdGVtcDIgPSBbXTtcbiAgICB2YXIgWSA9IFtdO1xuICAgIHZhciBCdCA9IFtdO1xuICAgIHZhciBCID0gW107XG4gICAgdmFyIEMgPSBbXTtcbiAgICB2YXIgViA9IFtdO1xuICAgIHZhciBWdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgIHVbaV0gPSBqU3RhdC5zdW0oWFtpXSkgLyBuO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBCW2ldID0gW107XG4gICAgICBmb3IoaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgQltpXVtqXSA9IFhbal1baV0gLSB1W2pdO1xuICAgICAgfVxuICAgIH1cbiAgICBCID0galN0YXQudHJhbnNwb3NlKEIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgIENbaV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgQ1tpXVtqXSA9IChqU3RhdC5kb3QoW0JbaV1dLCBbQltqXV0pKSAvIChuIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IGpTdGF0LmphY29iaShDKTtcbiAgICBWID0gcmVzdWx0WzBdO1xuICAgIEQgPSByZXN1bHRbMV07XG4gICAgVnQgPSBqU3RhdC50cmFuc3Bvc2UoVik7XG4gICAgZm9yIChpID0gMDsgaSA8IEQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IGk7IGogPCBELmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmKERbaV0gPCBEW2pdKSAge1xuICAgICAgICAgIHRlbXAxID0gRFtpXTtcbiAgICAgICAgICBEW2ldID0gRFtqXTtcbiAgICAgICAgICBEW2pdID0gdGVtcDE7XG4gICAgICAgICAgdGVtcDIgPSBWdFtpXTtcbiAgICAgICAgICBWdFtpXSA9IFZ0W2pdO1xuICAgICAgICAgIFZ0W2pdID0gdGVtcDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgQnQgPSBqU3RhdC50cmFuc3Bvc2UoQik7XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgWVtpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IEJ0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIFlbaV1bal0gPSBqU3RhdC5kb3QoW1Z0W2ldXSwgW0J0W2pdXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbWCwgRCwgVnQsIFldO1xuICB9XG59KTtcblxuLy8gZXh0ZW5kIGpTdGF0LmZuIHdpdGggbWV0aG9kcyB0aGF0IHJlcXVpcmUgb25lIGFyZ3VtZW50XG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalN0YXQuZm5bcGFzc2Z1bmNdID0gZnVuY3Rpb24oYXJnLCBmdW5jKSB7XG4gICAgICB2YXIgdG1wdGhpcyA9IHRoaXM7XG4gICAgICAvLyBjaGVjayBmb3IgY2FsbGJhY2tcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKHRtcHRoaXMsIGpTdGF0LmZuW3Bhc3NmdW5jXS5jYWxsKHRtcHRoaXMsIGFyZykpO1xuICAgICAgICB9LCAxNSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBqU3RhdFtwYXNzZnVuY10odGhpcywgYXJnKSA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10odGhpcywgYXJnKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBhcmcpKTtcbiAgICB9O1xuICB9KGZ1bmNzW2ldKSk7XG59KCdhZGQgZGl2aWRlIG11bHRpcGx5IHN1YnRyYWN0IGRvdCBwb3cgYWJzIG5vcm0gYW5nbGUnLnNwbGl0KCcgJykpKTtcblxufSh0aGlzLmpTdGF0LCBNYXRoKSk7XG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgaXNOdW1iZXIgPSBqU3RhdC51dGlscy5pc051bWJlcjtcblxuLy8gZmxhZz09dHJ1ZSBkZW5vdGVzIHVzZSBvZiBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uXG4vLyBaIFN0YXRpc3RpY3NcbmpTdGF0LmV4dGVuZCh7XG4gIC8vIDIgZGlmZmVyZW50IHBhcmFtZXRlciBsaXN0czpcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZClcbiAgLy8gKHZhbHVlLCBhcnJheSwgZmxhZylcbiAgenNjb3JlOiBmdW5jdGlvbiB6c2NvcmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKGlzTnVtYmVyKGFyZ3NbMV0pKSB7XG4gICAgICByZXR1cm4gKGFyZ3NbMF0gLSBhcmdzWzFdKSAvIGFyZ3NbMl07XG4gICAgfVxuICAgIHJldHVybiAoYXJnc1swXSAtIGpTdGF0Lm1lYW4oYXJnc1sxXSkpIC8galN0YXQuc3RkZXYoYXJnc1sxXSwgYXJnc1syXSk7XG4gIH0sXG5cbiAgLy8gMyBkaWZmZXJlbnQgcGFyYW10ZXIgbGlzdHM6XG4gIC8vICh2YWx1ZSwgbWVhbiwgc2QsIHNpZGVzKVxuICAvLyAoenNjb3JlLCBzaWRlcylcbiAgLy8gKHZhbHVlLCBhcnJheSwgc2lkZXMsIGZsYWcpXG4gIHp0ZXN0OiBmdW5jdGlvbiB6dGVzdCgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGlmKGlzTnVtYmVyKGFyZ3NbMV0pKSB7XG4gICAgICAgIHZhciB6ID0galN0YXQuenNjb3JlKGFyZ3NbMF0sYXJnc1sxXSxhcmdzWzJdKVxuICAgICAgICByZXR1cm4gKGFyZ3NbM10gPT09IDEpID9cbiAgICAgICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksMCwxKSkgOlxuICAgICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKiAyKTtcbiAgICAgIH1cbiAgICAgIHZhciB6ID0gYXJnc1swXVxuICAgICAgcmV0dXJuIChhcmdzWzJdID09PSAxKSA/XG4gICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKSA6XG4gICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKjIpO1xuICAgIH1cbiAgICB2YXIgeiA9IGpTdGF0LnpzY29yZShhcmdzWzBdLGFyZ3NbMV0sYXJnc1szXSlcbiAgICByZXR1cm4gKGFyZ3NbMV0gPT09IDEpID9cbiAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwgMCwgMSkpIDpcbiAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwgMCwgMSkqMik7XG4gIH1cbn0pO1xuXG5qU3RhdC5leHRlbmQoalN0YXQuZm4sIHtcbiAgenNjb3JlOiBmdW5jdGlvbiB6c2NvcmUodmFsdWUsIGZsYWcpIHtcbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5tZWFuKCkpIC8gdGhpcy5zdGRldihmbGFnKTtcbiAgfSxcblxuICB6dGVzdDogZnVuY3Rpb24genRlc3QodmFsdWUsIHNpZGVzLCBmbGFnKSB7XG4gICAgdmFyIHpzY29yZSA9IE1hdGguYWJzKHRoaXMuenNjb3JlKHZhbHVlLCBmbGFnKSk7XG4gICAgcmV0dXJuIChzaWRlcyA9PT0gMSkgP1xuICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLXpzY29yZSwgMCwgMSkpIDpcbiAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC16c2NvcmUsIDAsIDEpICogMik7XG4gIH1cbn0pO1xuXG4vLyBUIFN0YXRpc3RpY3NcbmpTdGF0LmV4dGVuZCh7XG4gIC8vIDIgcGFyYW1ldGVyIGxpc3RzXG4gIC8vICh2YWx1ZSwgbWVhbiwgc2QsIG4pXG4gIC8vICh2YWx1ZSwgYXJyYXkpXG4gIHRzY29yZTogZnVuY3Rpb24gdHNjb3JlKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHJldHVybiAoYXJncy5sZW5ndGggPT09IDQpID9cbiAgICAgICgoYXJnc1swXSAtIGFyZ3NbMV0pIC8gKGFyZ3NbMl0gLyBNYXRoLnNxcnQoYXJnc1szXSkpKSA6XG4gICAgICAoKGFyZ3NbMF0gLSBqU3RhdC5tZWFuKGFyZ3NbMV0pKSAvXG4gICAgICAgKGpTdGF0LnN0ZGV2KGFyZ3NbMV0sIHRydWUpIC8gTWF0aC5zcXJ0KGFyZ3NbMV0ubGVuZ3RoKSkpO1xuICB9LFxuXG4gIC8vIDMgZGlmZmVyZW50IHBhcmFtdGVyIGxpc3RzOlxuICAvLyAodmFsdWUsIG1lYW4sIHNkLCBuLCBzaWRlcylcbiAgLy8gKHRzY29yZSwgbiwgc2lkZXMpXG4gIC8vICh2YWx1ZSwgYXJyYXksIHNpZGVzKVxuICB0dGVzdDogZnVuY3Rpb24gdHRlc3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHRzY29yZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDUpIHtcbiAgICAgIHRzY29yZSA9IE1hdGguYWJzKGpTdGF0LnRzY29yZShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKSk7XG4gICAgICByZXR1cm4gKGFyZ3NbNF0gPT09IDEpID9cbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzNdLTEpKSA6XG4gICAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1szXS0xKSoyKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGFyZ3NbMV0pKSB7XG4gICAgICB0c2NvcmUgPSBNYXRoLmFicyhhcmdzWzBdKVxuICAgICAgcmV0dXJuIChhcmdzWzJdID09IDEpID9cbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLTEpKSA6XG4gICAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1sxXS0xKSAqIDIpO1xuICAgIH1cbiAgICB0c2NvcmUgPSBNYXRoLmFicyhqU3RhdC50c2NvcmUoYXJnc1swXSwgYXJnc1sxXSkpXG4gICAgcmV0dXJuIChhcmdzWzJdID09IDEpID9cbiAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1sxXS5sZW5ndGgtMSkpIDpcbiAgICAgIChqU3RhdC5zdHVkZW50dC5jZGYoLXRzY29yZSwgYXJnc1sxXS5sZW5ndGgtMSkgKiAyKTtcbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICB0c2NvcmU6IGZ1bmN0aW9uIHRzY29yZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1lYW4oKSkgLyAodGhpcy5zdGRldih0cnVlKSAvIE1hdGguc3FydCh0aGlzLmNvbHMoKSkpO1xuICB9LFxuXG4gIHR0ZXN0OiBmdW5jdGlvbiB0dGVzdCh2YWx1ZSwgc2lkZXMpIHtcbiAgICByZXR1cm4gKHNpZGVzID09PSAxKSA/XG4gICAgICAoMSAtIGpTdGF0LnN0dWRlbnR0LmNkZihNYXRoLmFicyh0aGlzLnRzY29yZSh2YWx1ZSkpLCB0aGlzLmNvbHMoKS0xKSkgOlxuICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtTWF0aC5hYnModGhpcy50c2NvcmUodmFsdWUpKSwgdGhpcy5jb2xzKCktMSkqMik7XG4gIH1cbn0pO1xuXG4vLyBGIFN0YXRpc3RpY3NcbmpTdGF0LmV4dGVuZCh7XG4gIC8vIFBhcmFtdGVyIGxpc3QgaXMgYXMgZm9sbG93czpcbiAgLy8gKGFycmF5MSwgYXJyYXkyLCBhcnJheTMsIC4uLilcbiAgLy8gb3IgaXQgaXMgYW4gYXJyYXkgb2YgYXJyYXlzXG4gIC8vIGFycmF5IG9mIGFycmF5cyBjb252ZXJzaW9uXG4gIGFub3ZhZnNjb3JlOiBmdW5jdGlvbiBhbm92YWZzY29yZSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBleHBWYXIsIHNhbXBsZSwgc2FtcE1lYW4sIHNhbXBTYW1wTWVhbiwgdG1wYXJncywgdW5leHBWYXIsIGksIGo7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICB0bXBhcmdzID0gbmV3IEFycmF5KGFyZ3NbMF0ubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRtcGFyZ3NbaV0gPSBhcmdzWzBdW2ldO1xuICAgICAgfVxuICAgICAgYXJncyA9IHRtcGFyZ3M7XG4gICAgfVxuICAgIC8vIDIgc2FtcGxlIGNhc2VcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldHVybiBqU3RhdC52YXJpYW5jZShhcmdzWzBdKSAvIGpTdGF0LnZhcmlhbmNlKGFyZ3NbMV0pO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgc2FtcGxlIGFycmF5XG4gICAgc2FtcGxlID0gbmV3IEFycmF5KCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZS5jb25jYXQoYXJnc1tpXSk7XG4gICAgfVxuICAgIHNhbXBNZWFuID0galN0YXQubWVhbihzYW1wbGUpO1xuICAgIC8vIENvbXB1dGVzIHRoZSBleHBsYWluZWQgdmFyaWFuY2VcbiAgICBleHBWYXIgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHBWYXIgPSBleHBWYXIgKyBhcmdzW2ldLmxlbmd0aCAqIE1hdGgucG93KGpTdGF0Lm1lYW4oYXJnc1tpXSkgLSBzYW1wTWVhbiwgMik7XG4gICAgfVxuICAgIGV4cFZhciAvPSAoYXJncy5sZW5ndGggLSAxKTtcbiAgICAvLyBDb21wdXRlcyB1bmV4cGxhaW5lZCB2YXJpYW5jZVxuICAgIHVuZXhwVmFyID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgc2FtcFNhbXBNZWFuID0galN0YXQubWVhbihhcmdzW2ldKTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhcmdzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVuZXhwVmFyICs9IE1hdGgucG93KGFyZ3NbaV1bal0gLSBzYW1wU2FtcE1lYW4sIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bmV4cFZhciAvPSAoc2FtcGxlLmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICByZXR1cm4gZXhwVmFyIC8gdW5leHBWYXI7XG4gIH0sXG5cbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW10ZXIgc2V0dXBzXG4gIC8vIChhcnJheTEsIGFycmF5MiwgYXJyYXkzLCAuLi4pXG4gIC8vIChhbm92YWZzY29yZSwgZGYxLCBkZjIpXG4gIGFub3ZhZnRlc3Q6IGZ1bmN0aW9uIGFub3ZhZnRlc3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgZGYxLCBkZjIsIG4sIGk7XG4gICAgaWYgKGlzTnVtYmVyKGFyZ3NbMF0pKSB7XG4gICAgICByZXR1cm4gMSAtIGpTdGF0LmNlbnRyYWxGLmNkZihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgYW5vdmFmc2NvcmUgPSBqU3RhdC5hbm92YWZzY29yZShhcmdzKTtcbiAgICBkZjEgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgbiA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBuICsgYXJnc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIGRmMiA9IG4gLSBkZjEgLSAxO1xuICAgIHJldHVybiAxIC0galN0YXQuY2VudHJhbEYuY2RmKGFub3ZhZnNjb3JlLCBkZjEsIGRmMik7XG4gIH0sXG5cbiAgZnRlc3Q6IGZ1bmN0aW9uIGZ0ZXN0KGZzY29yZSwgZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gMSAtIGpTdGF0LmNlbnRyYWxGLmNkZihmc2NvcmUsIGRmMSwgZGYyKTtcbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICBhbm92YWZzY29yZTogZnVuY3Rpb24gYW5vdmFmc2NvcmUoKSB7XG4gICAgcmV0dXJuIGpTdGF0LmFub3ZhZnNjb3JlKHRoaXMudG9BcnJheSgpKTtcbiAgfSxcblxuICBhbm92YWZ0ZXM6IGZ1bmN0aW9uIGFub3ZhZnRlcygpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBuICsgdGhpc1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5mdGVzdCh0aGlzLmFub3ZhZnNjb3JlKCksIHRoaXMubGVuZ3RoIC0gMSwgbiAtIHRoaXMubGVuZ3RoKTtcbiAgfVxufSk7XG5cbi8vIEVycm9yIEJvdW5kc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW1ldGVyIHNldHVwc1xuICAvLyAodmFsdWUsIGFscGhhLCBzZCwgbilcbiAgLy8gKHZhbHVlLCBhbHBoYSwgYXJyYXkpXG4gIG5vcm1hbGNpOiBmdW5jdGlvbiBub3JtYWxjaSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBhbnMgPSBuZXcgQXJyYXkoMiksXG4gICAgY2hhbmdlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQubm9ybWFsLmludihhcmdzWzFdIC8gMiwgMCwgMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1syXSAvIE1hdGguc3FydChhcmdzWzNdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZSA9IE1hdGguYWJzKGpTdGF0Lm5vcm1hbC5pbnYoYXJnc1sxXSAvIDIsIDAsIDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpTdGF0LnN0ZGV2KGFyZ3NbMl0pIC8gTWF0aC5zcXJ0KGFyZ3NbMl0ubGVuZ3RoKSk7XG4gICAgfVxuICAgIGFuc1swXSA9IGFyZ3NbMF0gLSBjaGFuZ2U7XG4gICAgYW5zWzFdID0gYXJnc1swXSArIGNoYW5nZTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIC8vIDIgZGlmZmVyZW50IHBhcmFtZXRlciBzZXR1cHNcbiAgLy8gKHZhbHVlLCBhbHBoYSwgc2QsIG4pXG4gIC8vICh2YWx1ZSwgYWxwaGEsIGFycmF5KVxuICB0Y2k6IGZ1bmN0aW9uIHRjaSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBhbnMgPSBuZXcgQXJyYXkoMiksXG4gICAgY2hhbmdlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQuc3R1ZGVudHQuaW52KGFyZ3NbMV0gLyAyLCBhcmdzWzNdIC0gMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1syXSAvIE1hdGguc3FydChhcmdzWzNdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZSA9IE1hdGguYWJzKGpTdGF0LnN0dWRlbnR0LmludihhcmdzWzFdIC8gMiwgYXJnc1syXS5sZW5ndGggLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5zdGRldihhcmdzWzJdLCB0cnVlKSAvIE1hdGguc3FydChhcmdzWzJdLmxlbmd0aCkpO1xuICAgIH1cbiAgICBhbnNbMF0gPSBhcmdzWzBdIC0gY2hhbmdlO1xuICAgIGFuc1sxXSA9IGFyZ3NbMF0gKyBjaGFuZ2U7XG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICBzaWduaWZpY2FudDogZnVuY3Rpb24gc2lnbmlmaWNhbnQocHZhbHVlLCBhbHBoYSkge1xuICAgIHJldHVybiBwdmFsdWUgPCBhbHBoYTtcbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICBub3JtYWxjaTogZnVuY3Rpb24gbm9ybWFsY2kodmFsdWUsIGFscGhhKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm5vcm1hbGNpKHZhbHVlLCBhbHBoYSwgdGhpcy50b0FycmF5KCkpO1xuICB9LFxuXG4gIHRjaTogZnVuY3Rpb24gdGNpKHZhbHVlLCBhbHBoYSkge1xuICAgIHJldHVybiBqU3RhdC50Y2kodmFsdWUsIGFscGhhLCB0aGlzLnRvQXJyYXkoKSk7XG4gIH1cbn0pO1xuXG59KHRoaXMualN0YXQsIE1hdGgpKTtcbiIsIi8qIVxuICogbnVtZXJhbC5qc1xuICogdmVyc2lvbiA6IDEuNS4zXG4gKiBhdXRob3IgOiBBZGFtIERyYXBlclxuICogbGljZW5zZSA6IE1JVFxuICogaHR0cDovL2FkYW13ZHJhcGVyLmdpdGh1Yi5jb20vTnVtZXJhbC1qcy9cbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdGFudHNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbnVtZXJhbCxcbiAgICAgICAgVkVSU0lPTiA9ICcxLjUuMycsXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxhbmd1YWdlIGNvbmZpZyBmaWxlc1xuICAgICAgICBsYW5ndWFnZXMgPSB7fSxcbiAgICAgICAgY3VycmVudExhbmd1YWdlID0gJ2VuJyxcbiAgICAgICAgemVyb0Zvcm1hdCA9IG51bGwsXG4gICAgICAgIGRlZmF1bHRGb3JtYXQgPSAnMCwwJyxcbiAgICAgICAgLy8gY2hlY2sgZm9yIG5vZGVKU1xuICAgICAgICBoYXNNb2R1bGUgPSAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0cnVjdG9yc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gTnVtZXJhbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtZXJhbCAobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICpcbiAgICAgKiBGaXhlcyBiaW5hcnkgcm91bmRpbmcgaXNzdWVzIChlZy4gKDAuNjE1KS50b0ZpeGVkKDIpID09PSAnMC42MScpIHRoYXQgcHJlc2VudFxuICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRml4ZWQgKHZhbHVlLCBwcmVjaXNpb24sIHJvdW5kaW5nRnVuY3Rpb24sIG9wdGlvbmFscykge1xuICAgICAgICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCxcbiAgICAgICAgICAgIG91dHB1dDtcbiAgICAgICAgICAgIFxuICAgICAgICAvL3JvdW5kaW5nRnVuY3Rpb24gPSAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmQpO1xuICAgICAgICAvLyBNdWx0aXBseSB1cCBieSBwcmVjaXNpb24sIHJvdW5kIGFjY3VyYXRlbHksIHRoZW4gZGl2aWRlIGFuZCB1c2UgbmF0aXZlIHRvRml4ZWQoKTpcbiAgICAgICAgb3V0cHV0ID0gKHJvdW5kaW5nRnVuY3Rpb24odmFsdWUgKiBwb3dlcikgLyBwb3dlcikudG9GaXhlZChwcmVjaXNpb24pO1xuXG4gICAgICAgIGlmIChvcHRpb25hbHMpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCA9IG5ldyBSZWdFeHAoJzB7MSwnICsgb3B0aW9uYWxzICsgJ30kJyk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShvcHRpb25hbHNSZWdFeHAsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGb3JtYXR0aW5nXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoYXQgdHlwZSBvZiBmb3JtYXR0aW5nIHdlIG5lZWQgdG8gZG9cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1lcmFsIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG91dHB1dDtcblxuICAgICAgICAvLyBmaWd1cmUgb3V0IHdoYXQga2luZCBvZiBmb3JtYXQgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyQnKSA+IC0xKSB7IC8vIGN1cnJlbmN5ISEhISFcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEN1cnJlbmN5KG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJyUnKSA+IC0xKSB7IC8vIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFBlcmNlbnRhZ2UobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignOicpID4gLTEpIHsgLy8gdGltZVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0VGltZShuLCBmb3JtYXQpO1xuICAgICAgICB9IGVsc2UgeyAvLyBwbGFpbiBvbCcgbnVtYmVycyBvciBieXRlc1xuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKG4uX3ZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHN0cmluZ1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8vIHJldmVydCB0byBudW1iZXJcbiAgICBmdW5jdGlvbiB1bmZvcm1hdE51bWVyYWwgKG4sIHN0cmluZykge1xuICAgICAgICB2YXIgc3RyaW5nT3JpZ2luYWwgPSBzdHJpbmcsXG4gICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCxcbiAgICAgICAgICAgIG1pbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBiaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgdHJpbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBzdWZmaXhlcyA9IFsnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IGZhbHNlLFxuICAgICAgICAgICAgcG93ZXI7XG5cbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgbi5fdmFsdWUgPSB1bmZvcm1hdFRpbWUoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcgPT09IHplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwuL2csJycpLnJlcGxhY2UobGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsLCAnLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb25zIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICBtaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgYmlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLmJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIHRyaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIGJ5dGVzIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IChzdHJpbmcuaW5kZXhPZihzdWZmaXhlc1twb3dlcl0pID4gLTEpID8gTWF0aC5wb3coMTAyNCwgcG93ZXIgKyAxKSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlc011bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gc29tZSBtYXRoIHRvIGNyZWF0ZSBvdXIgbnVtYmVyXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoKGJ5dGVzTXVsdGlwbGllcikgPyBieXRlc011bHRpcGxpZXIgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2godGhvdXNhbmRSZWdFeHApKSA/IE1hdGgucG93KDEwLCAzKSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaChtaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgNikgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2goYmlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDkpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKHRyaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgMTIpIDogMSkgKiAoKHN0cmluZy5pbmRleE9mKCclJykgPiAtMSkgPyAwLjAxIDogMSkgKiAoKChzdHJpbmcuc3BsaXQoJy0nKS5sZW5ndGggKyBNYXRoLm1pbihzdHJpbmcuc3BsaXQoJygnKS5sZW5ndGgtMSwgc3RyaW5nLnNwbGl0KCcpJykubGVuZ3RoLTEpKSAlIDIpPyAxOiAtMSkgKiBOdW1iZXIoc3RyaW5nLnJlcGxhY2UoL1teMC05XFwuXSsvZywgJycpKTtcblxuICAgICAgICAgICAgICAgIC8vIHJvdW5kIGlmIHdlIGFyZSB0YWxraW5nIGFib3V0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoYnl0ZXNNdWx0aXBsaWVyKSA/IE1hdGguY2VpbChuLl92YWx1ZSkgOiBuLl92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5fdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0Q3VycmVuY3kgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgc3ltYm9sSW5kZXggPSBmb3JtYXQuaW5kZXhPZignJCcpLFxuICAgICAgICAgICAgb3BlblBhcmVuSW5kZXggPSBmb3JtYXQuaW5kZXhPZignKCcpLFxuICAgICAgICAgICAgbWludXNTaWduSW5kZXggPSBmb3JtYXQuaW5kZXhPZignLScpLFxuICAgICAgICAgICAgc3BhY2UgPSAnJyxcbiAgICAgICAgICAgIHNwbGljZUluZGV4LFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgb3IgYWZ0ZXIgY3VycmVuY3lcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJCcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAkJywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCckICcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQgJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JtYXQgdGhlIG51bWJlclxuICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIobi5fdmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5bWJvbFxuICAgICAgICBpZiAoc3ltYm9sSW5kZXggPD0gMSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcoJykgPiAtMSB8fCBvdXRwdXQuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sSW5kZXggPCBvcGVuUGFyZW5JbmRleCB8fCBzeW1ib2xJbmRleCA8IG1pbnVzU2lnbkluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5bWJvbCBhcHBlYXJzIGJlZm9yZSB0aGUgXCIoXCIgb3IgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKHNwbGljZUluZGV4LCAwLCBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSArIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQZXJjZW50YWdlIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHNwYWNlID0gJycsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB2YWx1ZSA9IG4uX3ZhbHVlICogMTAwO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgJVxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyAlJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnICUnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEgKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgb3V0cHV0LnNwbGljZSgtMSwgMCwgc3BhY2UgKyAnJScpO1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgc3BhY2UgKyAnJSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWUgKG4pIHtcbiAgICAgICAgdmFyIGhvdXJzID0gTWF0aC5mbG9vcihuLl92YWx1ZS82MC82MCksXG4gICAgICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcigobi5fdmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSkvNjApLFxuICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgucm91bmQobi5fdmFsdWUgLSAoaG91cnMgKiA2MCAqIDYwKSAtIChtaW51dGVzICogNjApKTtcbiAgICAgICAgcmV0dXJuIGhvdXJzICsgJzonICsgKChtaW51dGVzIDwgMTApID8gJzAnICsgbWludXRlcyA6IG1pbnV0ZXMpICsgJzonICsgKChzZWNvbmRzIDwgMTApID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZm9ybWF0VGltZSAoc3RyaW5nKSB7XG4gICAgICAgIHZhciB0aW1lQXJyYXkgPSBzdHJpbmcuc3BsaXQoJzonKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSAwO1xuICAgICAgICAvLyB0dXJuIGhvdXJzIGFuZCBtaW51dGVzIGludG8gc2Vjb25kcyBhbmQgYWRkIHRoZW0gYWxsIHVwXG4gICAgICAgIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVswXSkgKiA2MCAqIDYwKTtcbiAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMV0pICogNjApO1xuICAgICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzJdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwKTtcbiAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgTnVtYmVyKHRpbWVBcnJheVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIgKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG5lZ1AgPSBmYWxzZSxcbiAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlLFxuICAgICAgICAgICAgb3B0RGVjID0gZmFsc2UsXG4gICAgICAgICAgICBhYmJyID0gJycsXG4gICAgICAgICAgICBhYmJySyA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gdGhvdXNhbmRzXG4gICAgICAgICAgICBhYmJyTSA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gbWlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJCID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byBiaWxsaW9uc1xuICAgICAgICAgICAgYWJiclQgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIHRyaWxsaW9uc1xuICAgICAgICAgICAgYWJickZvcmNlID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgYnl0ZXMgPSAnJyxcbiAgICAgICAgICAgIG9yZCA9ICcnLFxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnModmFsdWUpLFxuICAgICAgICAgICAgc3VmZml4ZXMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAgIHRob3VzYW5kcyxcbiAgICAgICAgICAgIGQgPSAnJyxcbiAgICAgICAgICAgIG5lZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIG51bWJlciBpcyB6ZXJvIGFuZCBhIGN1c3RvbSB6ZXJvIGZvcm1hdCBoYXMgYmVlbiBzZXRcbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHplcm9Gb3JtYXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRm9ybWF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2VlIGlmIHdlIHNob3VsZCB1c2UgcGFyZW50aGVzZXMgZm9yIG5lZ2F0aXZlIG51bWJlciBvciBpZiB3ZSBzaG91bGQgcHJlZml4IHdpdGggYSBzaWduXG4gICAgICAgICAgICAvLyBpZiBib3RoIGFyZSBwcmVzZW50IHdlIGRlZmF1bHQgdG8gcGFyZW50aGVzZXNcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignKCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBuZWdQID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignKycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBzaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXCsvZywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWUgaWYgYWJicmV2aWF0aW9uIGlzIHdhbnRlZFxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdhJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFiYnJldmlhdGlvbiBpcyBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICBhYmJySyA9IGZvcm1hdC5pbmRleE9mKCdhSycpID49IDA7XG4gICAgICAgICAgICAgICAgYWJick0gPSBmb3JtYXQuaW5kZXhPZignYU0nKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJCID0gZm9ybWF0LmluZGV4T2YoJ2FCJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyVCA9IGZvcm1hdC5pbmRleE9mKCdhVCcpID49IDA7XG4gICAgICAgICAgICAgICAgYWJickZvcmNlID0gYWJicksgfHwgYWJick0gfHwgYWJickIgfHwgYWJiclQ7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYmVmb3JlIGFiYnJldmlhdGlvblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGEnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgYScsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnYScsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWJzID49IE1hdGgucG93KDEwLCAxMikgJiYgIWFiYnJGb3JjZSB8fCBhYmJyVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgMTIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgTWF0aC5wb3coMTAsIDEyKSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDkpICYmICFhYmJyRm9yY2UgfHwgYWJickIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMuYmlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA5KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDYpICYmICFhYmJyRm9yY2UgfHwgYWJick0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyID0gYWJiciArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCA2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCA2KSAmJiBhYnMgPj0gTWF0aC5wb3coMTAsIDMpICYmICFhYmJyRm9yY2UgfHwgYWJickspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhvdXNhbmRcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIHdlIGFyZSBmb3JtYXR0aW5nIGJ5dGVzXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ2InKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIGInKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGInLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2InLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChwb3dlciA9IDA7IHBvd2VyIDw9IHN1ZmZpeGVzLmxlbmd0aDsgcG93ZXIrKykge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLnBvdygxMDI0LCBwb3dlcik7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgucG93KDEwMjQsIHBvd2VyKzEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMgKyBzdWZmaXhlc1twb3dlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIG9yZGluYWwgaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ28nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignIG8nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBvJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdvJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9yZCA9IG9yZCArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLm9yZGluYWwodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ1suXScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvcHREZWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdbLl0nLCAnLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gZm9ybWF0LnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICB0aG91c2FuZHMgPSBmb3JtYXQuaW5kZXhPZignLCcpO1xuXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbi5pbmRleE9mKCdbJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ucmVwbGFjZSgnXScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnNwbGl0KCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB0b0ZpeGVkKHZhbHVlLCAocHJlY2lzaW9uWzBdLmxlbmd0aCArIHByZWNpc2lvblsxXS5sZW5ndGgpLCByb3VuZGluZ0Z1bmN0aW9uLCBwcmVjaXNpb25bMV0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uLmxlbmd0aCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdyA9IGQuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChkLnNwbGl0KCcuJylbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgKyBkLnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHREZWMgJiYgTnVtYmVyKGQuc2xpY2UoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSB0b0ZpeGVkKHZhbHVlLCBudWxsLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9ybWF0IG51bWJlclxuICAgICAgICAgICAgaWYgKHcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB3ID0gdy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBuZWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhvdXNhbmRzID4gLTEpIHtcbiAgICAgICAgICAgICAgICB3ID0gdy50b1N0cmluZygpLnJlcGxhY2UoLyhcXGQpKD89KFxcZHszfSkrKD8hXFxkKSkvZywgJyQxJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmRlbGltaXRlcnMudGhvdXNhbmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoKG5lZ1AgJiYgbmVnKSA/ICcoJyA6ICcnKSArICgoIW5lZ1AgJiYgbmVnKSA/ICctJyA6ICcnKSArICgoIW5lZyAmJiBzaWduZWQpID8gJysnIDogJycpICsgdyArIGQgKyAoKG9yZCkgPyBvcmQgOiAnJykgKyAoKGFiYnIpID8gYWJiciA6ICcnKSArICgoYnl0ZXMpID8gYnl0ZXMgOiAnJykgKyAoKG5lZ1AgJiYgbmVnKSA/ICcpJyA6ICcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgVG9wIExldmVsIEZ1bmN0aW9uc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIG51bWVyYWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKG51bWVyYWwuaXNOdW1lcmFsKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAwIHx8IHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBudW1lcmFsLmZuLnVuZm9ybWF0KGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTnVtZXJhbChOdW1iZXIoaW5wdXQpKTtcbiAgICB9O1xuXG4gICAgLy8gdmVyc2lvbiBudW1iZXJcbiAgICBudW1lcmFsLnZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgLy8gY29tcGFyZSBudW1lcmFsIG9iamVjdFxuICAgIG51bWVyYWwuaXNOdW1lcmFsID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtZXJhbDtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbGFuZ3VhZ2VzIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxhbmd1YWdlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxhbmd1YWdlIGtleS5cbiAgICBudW1lcmFsLmxhbmd1YWdlID0gZnVuY3Rpb24gKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudExhbmd1YWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSAmJiAhdmFsdWVzKSB7XG4gICAgICAgICAgICBpZighbGFuZ3VhZ2VzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMYW5ndWFnZSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZXMgfHwgIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgbG9hZGVkIGxhbmd1YWdlIGRhdGEuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnRcbiAgICAvLyBnbG9iYWwgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgIG51bWVyYWwubGFuZ3VhZ2VEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgOiAnICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1trZXldO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmxhbmd1YWdlKCdlbicsIHtcbiAgICAgICAgZGVsaW1pdGVyczoge1xuICAgICAgICAgICAgdGhvdXNhbmRzOiAnLCcsXG4gICAgICAgICAgICBkZWNpbWFsOiAnLidcbiAgICAgICAgfSxcbiAgICAgICAgYWJicmV2aWF0aW9uczoge1xuICAgICAgICAgICAgdGhvdXNhbmQ6ICdrJyxcbiAgICAgICAgICAgIG1pbGxpb246ICdtJyxcbiAgICAgICAgICAgIGJpbGxpb246ICdiJyxcbiAgICAgICAgICAgIHRyaWxsaW9uOiAndCdcbiAgICAgICAgfSxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgICAgIHJldHVybiAofn4gKG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVuY3k6IHtcbiAgICAgICAgICAgIHN5bWJvbDogJyQnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG51bWVyYWwuemVyb0Zvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgemVyb0Zvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6IG51bGw7XG4gICAgfTtcblxuICAgIG51bWVyYWwuZGVmYXVsdEZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgZGVmYXVsdEZvcm1hdCA9IHR5cGVvZihmb3JtYXQpID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6ICcwLjAnO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgbGFuZ3VhZ2VzW2tleV0gPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGbG9hdGluZy1wb2ludCBoZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gVGhlIGZsb2F0aW5nLXBvaW50IGhlbHBlciBmdW5jdGlvbnMgYW5kIGltcGxlbWVudGF0aW9uXG4gICAgLy8gYm9ycm93cyBoZWF2aWx5IGZyb20gc2luZnVsLmpzOiBodHRwOi8vZ3VpcG4uZ2l0aHViLmlvL3NpbmZ1bC5qcy9cblxuICAgIC8qKlxuICAgICAqIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdFxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L1JlZHVjZSNDb21wYXRpYmlsaXR5XG4gICAgICovXG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMgfHwgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIG1vbWVudCBhbGwgbW9kZXJuIGJyb3dzZXJzLCB0aGF0IHN1cHBvcnQgc3RyaWN0IG1vZGUsIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZS4gRm9yIGluc3RhbmNlLCBJRThcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBzbyB0aGlzIGNoZWNrIGlzIGFjdHVhbGx5IHVzZWxlc3MuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0X2luaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGxlbmd0aCA+IGluZGV4OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbXVsdGlwbGllciBuZWNlc3NhcnkgdG8gbWFrZSB4ID49IDEsXG4gICAgICogZWZmZWN0aXZlbHkgZWxpbWluYXRpbmcgbWlzY2FsY3VsYXRpb25zIGNhdXNlZCBieVxuICAgICAqIGZpbml0ZSBwcmVjaXNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbXVsdGlwbGllcih4KSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBwYXJ0c1sxXS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgcmV0dXJucyB0aGUgbWF4aW11bVxuICAgICAqIG11bHRpcGxpZXIgdGhhdCBtdXN0IGJlIHVzZWQgdG8gbm9ybWFsaXplIGFuIG9wZXJhdGlvbiBpbnZvbHZpbmdcbiAgICAgKiBhbGwgb2YgdGhlbS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3JyZWN0aW9uRmFjdG9yKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgICAgICAgdmFyIG1wID0gbXVsdGlwbGllcihwcmV2KSxcbiAgICAgICAgICAgICAgICBtbiA9IG11bHRpcGxpZXIobmV4dCk7XG4gICAgICAgIHJldHVybiBtcCA+IG1uID8gbXAgOiBtbjtcbiAgICAgICAgfSwgLUluZmluaXR5KTtcbiAgICB9ICAgICAgICBcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBOdW1lcmFsIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgbnVtZXJhbC5mbiA9IE51bWVyYWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nLCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtZXJhbCh0aGlzLCBcbiAgICAgICAgICAgICAgICAgIGlucHV0U3RyaW5nID8gaW5wdXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0LCBcbiAgICAgICAgICAgICAgICAgIChyb3VuZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bmZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dFN0cmluZykgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7IFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFN0cmluZzsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5mb3JtYXROdW1lcmFsKHRoaXMsIGlucHV0U3RyaW5nID8gaW5wdXRTdHJpbmcgOiBkZWZhdWx0Rm9ybWF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZU9mIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgY29yckZhY3RvciAqIGN1cnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMCkgLyBjb3JyRmFjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3QgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gLSBjb3JyRmFjdG9yICogY3VycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3ZhbHVlXS5yZWR1Y2UoY2JhY2ssIHRoaXMuX3ZhbHVlICogY29yckZhY3RvcikgLyBjb3JyRmFjdG9yOyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbXVsdGlwbHkgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpICogKGN1cnIgKiBjb3JyRmFjdG9yKSAvXG4gICAgICAgICAgICAgICAgICAgIChjb3JyRmFjdG9yICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXZpZGUgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpIC8gKGN1cnIgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpZmZlcmVuY2UgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhudW1lcmFsKHRoaXMuX3ZhbHVlKS5zdWJ0cmFjdCh2YWx1ZSkudmFsdWUoKSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEV4cG9zaW5nIE51bWVyYWxcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBDb21tb25KUyBtb2R1bGUgaXMgZGVmaW5lZFxuICAgIGlmIChoYXNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBudW1lcmFsO1xuICAgIH1cblxuICAgIC8qZ2xvYmFsIGVuZGVyOmZhbHNlICovXG4gICAgaWYgKHR5cGVvZiBlbmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gaGVyZSwgYHRoaXNgIG1lYW5zIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFkZCBgbnVtZXJhbGAgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAgICAgICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciAnYWR2YW5jZWQnIG1vZGVcbiAgICAgICAgdGhpc1snbnVtZXJhbCddID0gbnVtZXJhbDtcbiAgICB9XG5cbiAgICAvKmdsb2JhbCBkZWZpbmU6ZmFsc2UgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG51bWVyaWMgPSAodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIpPyhmdW5jdGlvbiBudW1lcmljKCkge30pOihleHBvcnRzKTtcbmlmKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHsgZ2xvYmFsLm51bWVyaWMgPSBudW1lcmljOyB9XG5cbm51bWVyaWMudmVyc2lvbiA9IFwiMS4yLjZcIjtcblxuLy8gMS4gVXRpbGl0eSBmdW5jdGlvbnNcbm51bWVyaWMuYmVuY2ggPSBmdW5jdGlvbiBiZW5jaCAoZixpbnRlcnZhbCkge1xuICAgIHZhciB0MSx0MixuLGk7XG4gICAgaWYodHlwZW9mIGludGVydmFsID09PSBcInVuZGVmaW5lZFwiKSB7IGludGVydmFsID0gMTU7IH1cbiAgICBuID0gMC41O1xuICAgIHQxID0gbmV3IERhdGUoKTtcbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIG4qPTI7XG4gICAgICAgIGZvcihpPW47aT4zO2ktPTQpIHsgZigpOyBmKCk7IGYoKTsgZigpOyB9XG4gICAgICAgIHdoaWxlKGk+MCkgeyBmKCk7IGktLTsgfVxuICAgICAgICB0MiA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmKHQyLXQxID4gaW50ZXJ2YWwpIGJyZWFrO1xuICAgIH1cbiAgICBmb3IoaT1uO2k+MztpLT00KSB7IGYoKTsgZigpOyBmKCk7IGYoKTsgfVxuICAgIHdoaWxlKGk+MCkgeyBmKCk7IGktLTsgfVxuICAgIHQyID0gbmV3IERhdGUoKTtcbiAgICByZXR1cm4gMTAwMCooMypuLTEpLyh0Mi10MSk7XG59XG5cbm51bWVyaWMuX215SW5kZXhPZiA9IChmdW5jdGlvbiBfbXlJbmRleE9mKHcpIHtcbiAgICB2YXIgbiA9IHRoaXMubGVuZ3RoLGs7XG4gICAgZm9yKGs9MDtrPG47KytrKSBpZih0aGlzW2tdPT09dykgcmV0dXJuIGs7XG4gICAgcmV0dXJuIC0xO1xufSk7XG5udW1lcmljLm15SW5kZXhPZiA9IChBcnJheS5wcm90b3R5cGUuaW5kZXhPZik/QXJyYXkucHJvdG90eXBlLmluZGV4T2Y6bnVtZXJpYy5fbXlJbmRleE9mO1xuXG5udW1lcmljLkZ1bmN0aW9uID0gRnVuY3Rpb247XG5udW1lcmljLnByZWNpc2lvbiA9IDQ7XG5udW1lcmljLmxhcmdlQXJyYXkgPSA1MDtcblxubnVtZXJpYy5wcmV0dHlQcmludCA9IGZ1bmN0aW9uIHByZXR0eVByaW50KHgpIHtcbiAgICBmdW5jdGlvbiBmbXRudW0oeCkge1xuICAgICAgICBpZih4ID09PSAwKSB7IHJldHVybiAnMCc7IH1cbiAgICAgICAgaWYoaXNOYU4oeCkpIHsgcmV0dXJuICdOYU4nOyB9XG4gICAgICAgIGlmKHg8MCkgeyByZXR1cm4gJy0nK2ZtdG51bSgteCk7IH1cbiAgICAgICAgaWYoaXNGaW5pdGUoeCkpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGguZmxvb3IoTWF0aC5sb2coeCkgLyBNYXRoLmxvZygxMCkpO1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB4IC8gTWF0aC5wb3coMTAsc2NhbGUpO1xuICAgICAgICAgICAgdmFyIGJhc2ljID0gbm9ybWFsaXplZC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7XG4gICAgICAgICAgICBpZihwYXJzZUZsb2F0KGJhc2ljKSA9PT0gMTApIHsgc2NhbGUrKzsgbm9ybWFsaXplZCA9IDE7IGJhc2ljID0gbm9ybWFsaXplZC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGJhc2ljKS50b1N0cmluZygpKydlJytzY2FsZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnSW5maW5pdHknO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gW107XG4gICAgZnVuY3Rpb24gZm9vKHgpIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldC5wdXNoKEFycmF5KG51bWVyaWMucHJlY2lzaW9uKzgpLmpvaW4oJyAnKSk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikgeyByZXQucHVzaCgnXCInK3grJ1wiJyk7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJib29sZWFuXCIpIHsgcmV0LnB1c2goeC50b1N0cmluZygpKTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGlmKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGZtdG51bSh4KTtcbiAgICAgICAgICAgIHZhciBiID0geC50b1ByZWNpc2lvbihudW1lcmljLnByZWNpc2lvbik7XG4gICAgICAgICAgICB2YXIgYyA9IHBhcnNlRmxvYXQoeC50b1N0cmluZygpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGQgPSBbYSxiLGMscGFyc2VGbG9hdChiKS50b1N0cmluZygpLHBhcnNlRmxvYXQoYykudG9TdHJpbmcoKV07XG4gICAgICAgICAgICBmb3Ioaz0xO2s8ZC5sZW5ndGg7aysrKSB7IGlmKGRba10ubGVuZ3RoIDwgYS5sZW5ndGgpIGEgPSBkW2tdOyB9XG4gICAgICAgICAgICByZXQucHVzaChBcnJheShudW1lcmljLnByZWNpc2lvbis4LWEubGVuZ3RoKS5qb2luKCcgJykrYSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCA9PT0gbnVsbCkgeyByZXQucHVzaChcIm51bGxcIik7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICBpZih0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSB7IFxuICAgICAgICAgICAgcmV0LnB1c2goeC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IoayBpbiB4KSB7IGlmKHguaGFzT3duUHJvcGVydHkoaykpIHsgXG4gICAgICAgICAgICAgICAgaWYoZmxhZykgcmV0LnB1c2goJyxcXG4nKTtcbiAgICAgICAgICAgICAgICBlbHNlIHJldC5wdXNoKCdcXG57Jyk7XG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7IFxuICAgICAgICAgICAgICAgIHJldC5wdXNoKGspOyBcbiAgICAgICAgICAgICAgICByZXQucHVzaCgnOiBcXG4nKTsgXG4gICAgICAgICAgICAgICAgZm9vKHhba10pOyBcbiAgICAgICAgICAgIH0gfVxuICAgICAgICAgICAgaWYoZmxhZykgcmV0LnB1c2goJ31cXG4nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYoeC5sZW5ndGggPiBudW1lcmljLmxhcmdlQXJyYXkpIHsgcmV0LnB1c2goJy4uLkxhcmdlIEFycmF5Li4uJyk7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0LnB1c2goJ1snKTtcbiAgICAgICAgICAgIGZvcihrPTA7azx4Lmxlbmd0aDtrKyspIHsgaWYoaz4wKSB7IHJldC5wdXNoKCcsJyk7IGlmKGZsYWcpIHJldC5wdXNoKCdcXG4gJyk7IH0gZmxhZyA9IGZvbyh4W2tdKTsgfVxuICAgICAgICAgICAgcmV0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldC5wdXNoKCd7Jyk7XG4gICAgICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvcihrIGluIHgpIHsgaWYoeC5oYXNPd25Qcm9wZXJ0eShrKSkgeyBpZihmbGFnKSByZXQucHVzaCgnLFxcbicpOyBmbGFnID0gdHJ1ZTsgcmV0LnB1c2goayk7IHJldC5wdXNoKCc6IFxcbicpOyBmb28oeFtrXSk7IH0gfVxuICAgICAgICByZXQucHVzaCgnfScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9vKHgpO1xuICAgIHJldHVybiByZXQuam9pbignJyk7XG59XG5cbm51bWVyaWMucGFyc2VEYXRlID0gZnVuY3Rpb24gcGFyc2VEYXRlKGQpIHtcbiAgICBmdW5jdGlvbiBmb28oZCkge1xuICAgICAgICBpZih0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIERhdGUucGFyc2UoZC5yZXBsYWNlKC8tL2csJy8nKSk7IH1cbiAgICAgICAgaWYoIShkIGluc3RhbmNlb2YgQXJyYXkpKSB7IHRocm93IG5ldyBFcnJvcihcInBhcnNlRGF0ZTogcGFyYW1ldGVyIG11c3QgYmUgYXJyYXlzIG9mIHN0cmluZ3NcIik7IH1cbiAgICAgICAgdmFyIHJldCA9IFtdLGs7XG4gICAgICAgIGZvcihrPTA7azxkLmxlbmd0aDtrKyspIHsgcmV0W2tdID0gZm9vKGRba10pOyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBmb28oZCk7XG59XG5cbm51bWVyaWMucGFyc2VGbG9hdCA9IGZ1bmN0aW9uIHBhcnNlRmxvYXRfKGQpIHtcbiAgICBmdW5jdGlvbiBmb28oZCkge1xuICAgICAgICBpZih0eXBlb2YgZCA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHBhcnNlRmxvYXQoZCk7IH1cbiAgICAgICAgaWYoIShkIGluc3RhbmNlb2YgQXJyYXkpKSB7IHRocm93IG5ldyBFcnJvcihcInBhcnNlRmxvYXQ6IHBhcmFtZXRlciBtdXN0IGJlIGFycmF5cyBvZiBzdHJpbmdzXCIpOyB9XG4gICAgICAgIHZhciByZXQgPSBbXSxrO1xuICAgICAgICBmb3Ioaz0wO2s8ZC5sZW5ndGg7aysrKSB7IHJldFtrXSA9IGZvbyhkW2tdKTsgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gZm9vKGQpO1xufVxuXG5udW1lcmljLnBhcnNlQ1NWID0gZnVuY3Rpb24gcGFyc2VDU1YodCkge1xuICAgIHZhciBmb28gPSB0LnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgaixrO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgcGF0ID0gLygoW14nXCIsXSopfCgnW14nXSonKXwoXCJbXlwiXSpcIikpLC9nO1xuICAgIHZhciBwYXRudW0gPSAvXlxccyooKFsrLV0/WzAtOV0rKFxcLlswLTldKik/KGVbKy1dP1swLTldKyk/KXwoWystXT9bMC05XSooXFwuWzAtOV0rKT8oZVsrLV0/WzAtOV0rKT8pKVxccyokLztcbiAgICB2YXIgc3RyaXBwZXIgPSBmdW5jdGlvbihuKSB7IHJldHVybiBuLnN1YnN0cigwLG4ubGVuZ3RoLTEpOyB9XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3Ioaz0wO2s8Zm9vLmxlbmd0aDtrKyspIHtcbiAgICAgIHZhciBiYXIgPSAoZm9vW2tdK1wiLFwiKS5tYXRjaChwYXQpLGJhejtcbiAgICAgIGlmKGJhci5sZW5ndGg+MCkge1xuICAgICAgICAgIHJldFtjb3VudF0gPSBbXTtcbiAgICAgICAgICBmb3Ioaj0wO2o8YmFyLmxlbmd0aDtqKyspIHtcbiAgICAgICAgICAgICAgYmF6ID0gc3RyaXBwZXIoYmFyW2pdKTtcbiAgICAgICAgICAgICAgaWYocGF0bnVtLnRlc3QoYmF6KSkgeyByZXRbY291bnRdW2pdID0gcGFyc2VGbG9hdChiYXopOyB9XG4gICAgICAgICAgICAgIGVsc2UgcmV0W2NvdW50XVtqXSA9IGJhejtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy50b0NTViA9IGZ1bmN0aW9uIHRvQ1NWKEEpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKEEpO1xuICAgIHZhciBpLGosbSxuLHJvdyxyZXQ7XG4gICAgbSA9IHNbMF07XG4gICAgbiA9IHNbMV07XG4gICAgcmV0ID0gW107XG4gICAgZm9yKGk9MDtpPG07aSsrKSB7XG4gICAgICAgIHJvdyA9IFtdO1xuICAgICAgICBmb3Ioaj0wO2o8bTtqKyspIHsgcm93W2pdID0gQVtpXVtqXS50b1N0cmluZygpOyB9XG4gICAgICAgIHJldFtpXSA9IHJvdy5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpKydcXG4nO1xufVxuXG5udW1lcmljLmdldFVSTCA9IGZ1bmN0aW9uIGdldFVSTCh1cmwpIHtcbiAgICB2YXIgY2xpZW50ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY2xpZW50Lm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO1xuICAgIGNsaWVudC5zZW5kKCk7XG4gICAgcmV0dXJuIGNsaWVudDtcbn1cblxubnVtZXJpYy5pbWFnZVVSTCA9IGZ1bmN0aW9uIGltYWdlVVJMKGltZykge1xuICAgIGZ1bmN0aW9uIGJhc2U2NChBKSB7XG4gICAgICAgIHZhciBuID0gQS5sZW5ndGgsIGkseCx5LHoscCxxLHIscztcbiAgICAgICAgdmFyIGtleSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgIGZvcihpPTA7aTxuO2krPTMpIHtcbiAgICAgICAgICAgIHggPSBBW2ldO1xuICAgICAgICAgICAgeSA9IEFbaSsxXTtcbiAgICAgICAgICAgIHogPSBBW2krMl07XG4gICAgICAgICAgICBwID0geCA+PiAyO1xuICAgICAgICAgICAgcSA9ICgoeCAmIDMpIDw8IDQpICsgKHkgPj4gNCk7XG4gICAgICAgICAgICByID0gKCh5ICYgMTUpIDw8IDIpICsgKHogPj4gNik7XG4gICAgICAgICAgICBzID0geiAmIDYzO1xuICAgICAgICAgICAgaWYoaSsxPj1uKSB7IHIgPSBzID0gNjQ7IH1cbiAgICAgICAgICAgIGVsc2UgaWYoaSsyPj1uKSB7IHMgPSA2NDsgfVxuICAgICAgICAgICAgcmV0ICs9IGtleS5jaGFyQXQocCkgKyBrZXkuY2hhckF0KHEpICsga2V5LmNoYXJBdChyKSArIGtleS5jaGFyQXQocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyYzMyQXJyYXkgKGEsZnJvbSx0bykge1xuICAgICAgICBpZih0eXBlb2YgZnJvbSA9PT0gXCJ1bmRlZmluZWRcIikgeyBmcm9tID0gMDsgfVxuICAgICAgICBpZih0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpIHsgdG8gPSBhLmxlbmd0aDsgfVxuICAgICAgICB2YXIgdGFibGUgPSBbMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhFRTBFNjEyQywgMHg5OTA5NTFCQSwgMHgwNzZEQzQxOSwgMHg3MDZBRjQ4RiwgMHhFOTYzQTUzNSwgMHg5RTY0OTVBMyxcbiAgICAgICAgICAgICAgICAgICAgIDB4MEVEQjg4MzIsIDB4NzlEQ0I4QTQsIDB4RTBENUU5MUUsIDB4OTdEMkQ5ODgsIDB4MDlCNjRDMkIsIDB4N0VCMTdDQkQsIDB4RTdCODJEMDcsIDB4OTBCRjFEOTEsIFxuICAgICAgICAgICAgICAgICAgICAgMHgxREI3MTA2NCwgMHg2QUIwMjBGMiwgMHhGM0I5NzE0OCwgMHg4NEJFNDFERSwgMHgxQURBRDQ3RCwgMHg2RERERTRFQiwgMHhGNEQ0QjU1MSwgMHg4M0QzODVDNyxcbiAgICAgICAgICAgICAgICAgICAgIDB4MTM2Qzk4NTYsIDB4NjQ2QkE4QzAsIDB4RkQ2MkY5N0EsIDB4OEE2NUM5RUMsIDB4MTQwMTVDNEYsIDB4NjMwNjZDRDksIDB4RkEwRjNENjMsIDB4OEQwODBERjUsIFxuICAgICAgICAgICAgICAgICAgICAgMHgzQjZFMjBDOCwgMHg0QzY5MTA1RSwgMHhENTYwNDFFNCwgMHhBMjY3NzE3MiwgMHgzQzAzRTREMSwgMHg0QjA0RDQ0NywgMHhEMjBEODVGRCwgMHhBNTBBQjU2QiwgXG4gICAgICAgICAgICAgICAgICAgICAweDM1QjVBOEZBLCAweDQyQjI5ODZDLCAweERCQkJDOUQ2LCAweEFDQkNGOTQwLCAweDMyRDg2Q0UzLCAweDQ1REY1Qzc1LCAweERDRDYwRENGLCAweEFCRDEzRDU5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4MjZEOTMwQUMsIDB4NTFERTAwM0EsIDB4QzhENzUxODAsIDB4QkZEMDYxMTYsIDB4MjFCNEY0QjUsIDB4NTZCM0M0MjMsIDB4Q0ZCQTk1OTksIDB4QjhCREE1MEYsXG4gICAgICAgICAgICAgICAgICAgICAweDI4MDJCODlFLCAweDVGMDU4ODA4LCAweEM2MENEOUIyLCAweEIxMEJFOTI0LCAweDJGNkY3Qzg3LCAweDU4Njg0QzExLCAweEMxNjExREFCLCAweEI2NjYyRDNELFxuICAgICAgICAgICAgICAgICAgICAgMHg3NkRDNDE5MCwgMHgwMURCNzEwNiwgMHg5OEQyMjBCQywgMHhFRkQ1MTAyQSwgMHg3MUIxODU4OSwgMHgwNkI2QjUxRiwgMHg5RkJGRTRBNSwgMHhFOEI4RDQzMyxcbiAgICAgICAgICAgICAgICAgICAgIDB4NzgwN0M5QTIsIDB4MEYwMEY5MzQsIDB4OTYwOUE4OEUsIDB4RTEwRTk4MTgsIDB4N0Y2QTBEQkIsIDB4MDg2RDNEMkQsIDB4OTE2NDZDOTcsIDB4RTY2MzVDMDEsIFxuICAgICAgICAgICAgICAgICAgICAgMHg2QjZCNTFGNCwgMHgxQzZDNjE2MiwgMHg4NTY1MzBEOCwgMHhGMjYyMDA0RSwgMHg2QzA2OTVFRCwgMHgxQjAxQTU3QiwgMHg4MjA4RjRDMSwgMHhGNTBGQzQ1NywgXG4gICAgICAgICAgICAgICAgICAgICAweDY1QjBEOUM2LCAweDEyQjdFOTUwLCAweDhCQkVCOEVBLCAweEZDQjk4ODdDLCAweDYyREQxRERGLCAweDE1REEyRDQ5LCAweDhDRDM3Q0YzLCAweEZCRDQ0QzY1LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NERCMjYxNTgsIDB4M0FCNTUxQ0UsIDB4QTNCQzAwNzQsIDB4RDRCQjMwRTIsIDB4NEFERkE1NDEsIDB4M0REODk1RDcsIDB4QTREMUM0NkQsIDB4RDNENkY0RkIsIFxuICAgICAgICAgICAgICAgICAgICAgMHg0MzY5RTk2QSwgMHgzNDZFRDlGQywgMHhBRDY3ODg0NiwgMHhEQTYwQjhEMCwgMHg0NDA0MkQ3MywgMHgzMzAzMURFNSwgMHhBQTBBNEM1RiwgMHhERDBEN0NDOSwgXG4gICAgICAgICAgICAgICAgICAgICAweDUwMDU3MTNDLCAweDI3MDI0MUFBLCAweEJFMEIxMDEwLCAweEM5MEMyMDg2LCAweDU3NjhCNTI1LCAweDIwNkY4NUIzLCAweEI5NjZENDA5LCAweENFNjFFNDlGLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4NUVERUY5MEUsIDB4MjlEOUM5OTgsIDB4QjBEMDk4MjIsIDB4QzdEN0E4QjQsIDB4NTlCMzNEMTcsIDB4MkVCNDBEODEsIDB4QjdCRDVDM0IsIDB4QzBCQTZDQUQsIFxuICAgICAgICAgICAgICAgICAgICAgMHhFREI4ODMyMCwgMHg5QUJGQjNCNiwgMHgwM0I2RTIwQywgMHg3NEIxRDI5QSwgMHhFQUQ1NDczOSwgMHg5REQyNzdBRiwgMHgwNERCMjYxNSwgMHg3M0RDMTY4MywgXG4gICAgICAgICAgICAgICAgICAgICAweEUzNjMwQjEyLCAweDk0NjQzQjg0LCAweDBENkQ2QTNFLCAweDdBNkE1QUE4LCAweEU0MEVDRjBCLCAweDkzMDlGRjlELCAweDBBMDBBRTI3LCAweDdEMDc5RUIxLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RjAwRjkzNDQsIDB4ODcwOEEzRDIsIDB4MUUwMUYyNjgsIDB4NjkwNkMyRkUsIDB4Rjc2MjU3NUQsIDB4ODA2NTY3Q0IsIDB4MTk2QzM2NzEsIDB4NkU2QjA2RTcsIFxuICAgICAgICAgICAgICAgICAgICAgMHhGRUQ0MUI3NiwgMHg4OUQzMkJFMCwgMHgxMERBN0E1QSwgMHg2N0RENEFDQywgMHhGOUI5REY2RiwgMHg4RUJFRUZGOSwgMHgxN0I3QkU0MywgMHg2MEIwOEVENSwgXG4gICAgICAgICAgICAgICAgICAgICAweEQ2RDZBM0U4LCAweEExRDE5MzdFLCAweDM4RDhDMkM0LCAweDRGREZGMjUyLCAweEQxQkI2N0YxLCAweEE2QkM1NzY3LCAweDNGQjUwNkRELCAweDQ4QjIzNjRCLCBcbiAgICAgICAgICAgICAgICAgICAgIDB4RDgwRDJCREEsIDB4QUYwQTFCNEMsIDB4MzYwMzRBRjYsIDB4NDEwNDdBNjAsIDB4REY2MEVGQzMsIDB4QTg2N0RGNTUsIDB4MzE2RThFRUYsIDB4NDY2OUJFNzksIFxuICAgICAgICAgICAgICAgICAgICAgMHhDQjYxQjM4QywgMHhCQzY2ODMxQSwgMHgyNTZGRDJBMCwgMHg1MjY4RTIzNiwgMHhDQzBDNzc5NSwgMHhCQjBCNDcwMywgMHgyMjAyMTZCOSwgMHg1NTA1MjYyRiwgXG4gICAgICAgICAgICAgICAgICAgICAweEM1QkEzQkJFLCAweEIyQkQwQjI4LCAweDJCQjQ1QTkyLCAweDVDQjM2QTA0LCAweEMyRDdGRkE3LCAweEI1RDBDRjMxLCAweDJDRDk5RThCLCAweDVCREVBRTFELCBcbiAgICAgICAgICAgICAgICAgICAgIDB4OUI2NEMyQjAsIDB4RUM2M0YyMjYsIDB4NzU2QUEzOUMsIDB4MDI2RDkzMEEsIDB4OUMwOTA2QTksIDB4RUIwRTM2M0YsIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsIFxuICAgICAgICAgICAgICAgICAgICAgMHg5NUJGNEE4MiwgMHhFMkI4N0ExNCwgMHg3QkIxMkJBRSwgMHgwQ0I2MUIzOCwgMHg5MkQyOEU5QiwgMHhFNUQ1QkUwRCwgMHg3Q0RDRUZCNywgMHgwQkRCREYyMSwgXG4gICAgICAgICAgICAgICAgICAgICAweDg2RDNEMkQ0LCAweEYxRDRFMjQyLCAweDY4RERCM0Y4LCAweDFGREE4MzZFLCAweDgxQkUxNkNELCAweEY2QjkyNjVCLCAweDZGQjA3N0UxLCAweDE4Qjc0Nzc3LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4ODgwODVBRTYsIDB4RkYwRjZBNzAsIDB4NjYwNjNCQ0EsIDB4MTEwMTBCNUMsIDB4OEY2NTlFRkYsIDB4Rjg2MkFFNjksIDB4NjE2QkZGRDMsIDB4MTY2Q0NGNDUsIFxuICAgICAgICAgICAgICAgICAgICAgMHhBMDBBRTI3OCwgMHhENzBERDJFRSwgMHg0RTA0ODM1NCwgMHgzOTAzQjNDMiwgMHhBNzY3MjY2MSwgMHhEMDYwMTZGNywgMHg0OTY5NDc0RCwgMHgzRTZFNzdEQiwgXG4gICAgICAgICAgICAgICAgICAgICAweEFFRDE2QTRBLCAweEQ5RDY1QURDLCAweDQwREYwQjY2LCAweDM3RDgzQkYwLCAweEE5QkNBRTUzLCAweERFQkI5RUM1LCAweDQ3QjJDRjdGLCAweDMwQjVGRkU5LCBcbiAgICAgICAgICAgICAgICAgICAgIDB4QkRCREYyMUMsIDB4Q0FCQUMyOEEsIDB4NTNCMzkzMzAsIDB4MjRCNEEzQTYsIDB4QkFEMDM2MDUsIDB4Q0RENzA2OTMsIDB4NTRERTU3MjksIDB4MjNEOTY3QkYsIFxuICAgICAgICAgICAgICAgICAgICAgMHhCMzY2N0EyRSwgMHhDNDYxNEFCOCwgMHg1RDY4MUIwMiwgMHgyQTZGMkI5NCwgMHhCNDBCQkUzNywgMHhDMzBDOEVBMSwgMHg1QTA1REYxQiwgMHgyRDAyRUY4RF07XG4gICAgIFxuICAgICAgICB2YXIgY3JjID0gLTEsIHkgPSAwLCBuID0gYS5sZW5ndGgsaTtcblxuICAgICAgICBmb3IgKGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgeSA9IChjcmMgXiBhW2ldKSAmIDB4RkY7XG4gICAgICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRhYmxlW3ldO1xuICAgICAgICB9XG4gICAgIFxuICAgICAgICByZXR1cm4gY3JjIF4gKC0xKTtcbiAgICB9XG5cbiAgICB2YXIgaCA9IGltZ1swXS5sZW5ndGgsIHcgPSBpbWdbMF1bMF0ubGVuZ3RoLCBzMSwgczIsIG5leHQsayxsZW5ndGgsYSxiLGksaixhZGxlcjMyLGNyYzMyO1xuICAgIHZhciBzdHJlYW0gPSBbXG4gICAgICAgICAgICAgICAgICAxMzcsIDgwLCA3OCwgNzEsIDEzLCAxMCwgMjYsIDEwLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAwOiBQTkcgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAwLDAsMCwxMywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICA4OiBJSERSIENodW5rIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgNzMsIDcyLCA2OCwgODIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMjogXCJJSERSXCIgXG4gICAgICAgICAgICAgICAgICAodyA+PiAyNCkgJiAyNTUsICh3ID4+IDE2KSAmIDI1NSwgKHcgPj4gOCkgJiAyNTUsIHcmMjU1LCAgIC8vIDE2OiBXaWR0aFxuICAgICAgICAgICAgICAgICAgKGggPj4gMjQpICYgMjU1LCAoaCA+PiAxNikgJiAyNTUsIChoID4+IDgpICYgMjU1LCBoJjI1NSwgICAvLyAyMDogSGVpZ2h0XG4gICAgICAgICAgICAgICAgICA4LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI0OiBiaXQgZGVwdGhcbiAgICAgICAgICAgICAgICAgIDIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjU6IFJHQlxuICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNjogZGVmbGF0ZVxuICAgICAgICAgICAgICAgICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyNzogbm8gZmlsdGVyXG4gICAgICAgICAgICAgICAgICAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDI4OiBubyBpbnRlcmxhY2VcbiAgICAgICAgICAgICAgICAgIC0xLC0yLC0zLC00LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjk6IENSQ1xuICAgICAgICAgICAgICAgICAgLTUsLTYsLTcsLTgsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzMzogSURBVCBDaHVuayBsZW5ndGhcbiAgICAgICAgICAgICAgICAgIDczLCA2OCwgNjUsIDg0LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzc6IFwiSURBVFwiXG4gICAgICAgICAgICAgICAgICAvLyBSRkMgMTk1MCBoZWFkZXIgc3RhcnRzIGhlcmVcbiAgICAgICAgICAgICAgICAgIDgsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDE6IFJGQzE5NTAgQ01GXG4gICAgICAgICAgICAgICAgICAyOSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDQyOiBSRkMxOTUwIEZMR1xuICAgICAgICAgICAgICAgICAgXTtcbiAgICBjcmMzMiA9IGNyYzMyQXJyYXkoc3RyZWFtLDEyLDI5KTtcbiAgICBzdHJlYW1bMjldID0gKGNyYzMyPj4yNCkmMjU1O1xuICAgIHN0cmVhbVszMF0gPSAoY3JjMzI+PjE2KSYyNTU7XG4gICAgc3RyZWFtWzMxXSA9IChjcmMzMj4+OCkmMjU1O1xuICAgIHN0cmVhbVszMl0gPSAoY3JjMzIpJjI1NTtcbiAgICBzMSA9IDE7XG4gICAgczIgPSAwO1xuICAgIGZvcihpPTA7aTxoO2krKykge1xuICAgICAgICBpZihpPGgtMSkgeyBzdHJlYW0ucHVzaCgwKTsgfVxuICAgICAgICBlbHNlIHsgc3RyZWFtLnB1c2goMSk7IH1cbiAgICAgICAgYSA9ICgzKncrMSsoaT09PTApKSYyNTU7IGIgPSAoKDMqdysxKyhpPT09MCkpPj44KSYyNTU7XG4gICAgICAgIHN0cmVhbS5wdXNoKGEpOyBzdHJlYW0ucHVzaChiKTtcbiAgICAgICAgc3RyZWFtLnB1c2goKH5hKSYyNTUpOyBzdHJlYW0ucHVzaCgofmIpJjI1NSk7XG4gICAgICAgIGlmKGk9PT0wKSBzdHJlYW0ucHVzaCgwKTtcbiAgICAgICAgZm9yKGo9MDtqPHc7aisrKSB7XG4gICAgICAgICAgICBmb3Ioaz0wO2s8MztrKyspIHtcbiAgICAgICAgICAgICAgICBhID0gaW1nW2tdW2ldW2pdO1xuICAgICAgICAgICAgICAgIGlmKGE+MjU1KSBhID0gMjU1O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYoYTwwKSBhPTA7XG4gICAgICAgICAgICAgICAgZWxzZSBhID0gTWF0aC5yb3VuZChhKTtcbiAgICAgICAgICAgICAgICBzMSA9IChzMSArIGEgKSU2NTUyMTtcbiAgICAgICAgICAgICAgICBzMiA9IChzMiArIHMxKSU2NTUyMTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICB9XG4gICAgYWRsZXIzMiA9IChzMjw8MTYpK3MxO1xuICAgIHN0cmVhbS5wdXNoKChhZGxlcjMyPj4yNCkmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgoYWRsZXIzMj4+MTYpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzI+PjgpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGFkbGVyMzIpJjI1NSk7XG4gICAgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aCAtIDQxO1xuICAgIHN0cmVhbVszM10gPSAobGVuZ3RoPj4yNCkmMjU1O1xuICAgIHN0cmVhbVszNF0gPSAobGVuZ3RoPj4xNikmMjU1O1xuICAgIHN0cmVhbVszNV0gPSAobGVuZ3RoPj44KSYyNTU7XG4gICAgc3RyZWFtWzM2XSA9IChsZW5ndGgpJjI1NTtcbiAgICBjcmMzMiA9IGNyYzMyQXJyYXkoc3RyZWFtLDM3KTtcbiAgICBzdHJlYW0ucHVzaCgoY3JjMzI+PjI0KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMj4+MTYpJjI1NSk7XG4gICAgc3RyZWFtLnB1c2goKGNyYzMyPj44KSYyNTUpO1xuICAgIHN0cmVhbS5wdXNoKChjcmMzMikmMjU1KTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbiAgICBzdHJlYW0ucHVzaCgwKTtcbi8vICAgIGEgPSBzdHJlYW0ubGVuZ3RoO1xuICAgIHN0cmVhbS5wdXNoKDczKTsgIC8vIElcbiAgICBzdHJlYW0ucHVzaCg2OSk7ICAvLyBFXG4gICAgc3RyZWFtLnB1c2goNzgpOyAgLy8gTlxuICAgIHN0cmVhbS5wdXNoKDY4KTsgIC8vIERcbiAgICBzdHJlYW0ucHVzaCgxNzQpOyAvLyBDUkMxXG4gICAgc3RyZWFtLnB1c2goNjYpOyAgLy8gQ1JDMlxuICAgIHN0cmVhbS5wdXNoKDk2KTsgIC8vIENSQzNcbiAgICBzdHJlYW0ucHVzaCgxMzApOyAvLyBDUkM0XG4gICAgcmV0dXJuICdkYXRhOmltYWdlL3BuZztiYXNlNjQsJytiYXNlNjQoc3RyZWFtKTtcbn1cblxuLy8gMi4gTGluZWFyIGFsZ2VicmEgd2l0aCBBcnJheXMuXG5udW1lcmljLl9kaW0gPSBmdW5jdGlvbiBfZGltKHgpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgd2hpbGUodHlwZW9mIHggPT09IFwib2JqZWN0XCIpIHsgcmV0LnB1c2goeC5sZW5ndGgpOyB4ID0geFswXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZGltID0gZnVuY3Rpb24gZGltKHgpIHtcbiAgICB2YXIgeSx6O1xuICAgIGlmKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHkgPSB4WzBdO1xuICAgICAgICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgeiA9IHlbMF07XG4gICAgICAgICAgICBpZih0eXBlb2YgeiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1lcmljLl9kaW0oeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3gubGVuZ3RoLHkubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gubGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5udW1lcmljLm1hcHJlZHVjZSA9IGZ1bmN0aW9uIG1hcHJlZHVjZShib2R5LGluaXQpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3gnLCdhY2N1bScsJ19zJywnX2snLFxuICAgICAgICAgICAgJ2lmKHR5cGVvZiBhY2N1bSA9PT0gXCJ1bmRlZmluZWRcIikgYWNjdW0gPSAnK2luaXQrJztcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7IHZhciB4aSA9IHg7ICcrYm9keSsnOyByZXR1cm4gYWNjdW07IH1cXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfcyA9PT0gXCJ1bmRlZmluZWRcIikgX3MgPSBudW1lcmljLmRpbSh4KTtcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfayA9PT0gXCJ1bmRlZmluZWRcIikgX2sgPSAwO1xcbicrXG4gICAgICAgICAgICAndmFyIF9uID0gX3NbX2tdO1xcbicrXG4gICAgICAgICAgICAndmFyIGkseGk7XFxuJytcbiAgICAgICAgICAgICdpZihfayA8IF9zLmxlbmd0aC0xKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgZm9yKGk9X24tMTtpPj0wO2ktLSkge1xcbicrXG4gICAgICAgICAgICAnICAgICAgICBhY2N1bSA9IGFyZ3VtZW50cy5jYWxsZWUoeFtpXSxhY2N1bSxfcyxfaysxKTtcXG4nK1xuICAgICAgICAgICAgJyAgICB9JytcbiAgICAgICAgICAgICcgICAgcmV0dXJuIGFjY3VtO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnZm9yKGk9X24tMTtpPj0xO2ktPTIpIHsgXFxuJytcbiAgICAgICAgICAgICcgICAgeGkgPSB4W2ldO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnO1xcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpLTFdO1xcbicrXG4gICAgICAgICAgICAnICAgICcrYm9keSsnO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnaWYoaSA9PT0gMCkge1xcbicrXG4gICAgICAgICAgICAnICAgIHhpID0geFtpXTtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJ1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIGFjY3VtOydcbiAgICAgICAgICAgICk7XG59XG5udW1lcmljLm1hcHJlZHVjZTIgPSBmdW5jdGlvbiBtYXByZWR1Y2UyKGJvZHksc2V0dXApIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oJ3gnLFxuICAgICAgICAgICAgJ3ZhciBuID0geC5sZW5ndGg7XFxuJytcbiAgICAgICAgICAgICd2YXIgaSx4aTtcXG4nK3NldHVwKyc7XFxuJytcbiAgICAgICAgICAgICdmb3IoaT1uLTE7aSE9PS0xOy0taSkgeyBcXG4nK1xuICAgICAgICAgICAgJyAgICB4aSA9IHhbaV07XFxuJytcbiAgICAgICAgICAgICcgICAgJytib2R5Kyc7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gYWNjdW07J1xuICAgICAgICAgICAgKTtcbn1cblxuXG5udW1lcmljLnNhbWUgPSBmdW5jdGlvbiBzYW1lKHgseSkge1xuICAgIHZhciBpLG47XG4gICAgaWYoISh4IGluc3RhbmNlb2YgQXJyYXkpIHx8ICEoeSBpbnN0YW5jZW9mIEFycmF5KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBuID0geC5sZW5ndGg7XG4gICAgaWYobiAhPT0geS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yKGk9MDtpPG47aSsrKSB7XG4gICAgICAgIGlmKHhbaV0gPT09IHlbaV0pIHsgY29udGludWU7IH1cbiAgICAgICAgaWYodHlwZW9mIHhbaV0gPT09IFwib2JqZWN0XCIpIHsgaWYoIXNhbWUoeFtpXSx5W2ldKSkgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbm51bWVyaWMucmVwID0gZnVuY3Rpb24gcmVwKHMsdixrKSB7XG4gICAgaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIHsgaz0wOyB9XG4gICAgdmFyIG4gPSBzW2tdLCByZXQgPSBBcnJheShuKSwgaTtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7XG4gICAgICAgIGZvcihpPW4tMjtpPj0wO2ktPTIpIHsgcmV0W2krMV0gPSB2OyByZXRbaV0gPSB2OyB9XG4gICAgICAgIGlmKGk9PT0tMSkgeyByZXRbMF0gPSB2OyB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyByZXRbaV0gPSBudW1lcmljLnJlcChzLHYsaysxKTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblxubnVtZXJpYy5kb3RNTXNtYWxsID0gZnVuY3Rpb24gZG90TU1zbWFsbCh4LHkpIHtcbiAgICB2YXIgaSxqLGsscCxxLHIscmV0LGZvbyxiYXIsd29vLGkwLGswLHAwLHIwO1xuICAgIHAgPSB4Lmxlbmd0aDsgcSA9IHkubGVuZ3RoOyByID0geVswXS5sZW5ndGg7XG4gICAgcmV0ID0gQXJyYXkocCk7XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7XG4gICAgICAgIGZvbyA9IEFycmF5KHIpO1xuICAgICAgICBiYXIgPSB4W2ldO1xuICAgICAgICBmb3Ioaz1yLTE7az49MDtrLS0pIHtcbiAgICAgICAgICAgIHdvbyA9IGJhcltxLTFdKnlbcS0xXVtrXTtcbiAgICAgICAgICAgIGZvcihqPXEtMjtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgICAgICBpMCA9IGotMTtcbiAgICAgICAgICAgICAgICB3b28gKz0gYmFyW2pdKnlbal1ba10gKyBiYXJbaTBdKnlbaTBdW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaj09PTApIHsgd29vICs9IGJhclswXSp5WzBdW2tdOyB9XG4gICAgICAgICAgICBmb29ba10gPSB3b287XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldID0gZm9vO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5fZ2V0Q29sID0gZnVuY3Rpb24gX2dldENvbChBLGoseCkge1xuICAgIHZhciBuID0gQS5sZW5ndGgsIGk7XG4gICAgZm9yKGk9bi0xO2k+MDstLWkpIHtcbiAgICAgICAgeFtpXSA9IEFbaV1bal07XG4gICAgICAgIC0taTtcbiAgICAgICAgeFtpXSA9IEFbaV1bal07XG4gICAgfVxuICAgIGlmKGk9PT0wKSB4WzBdID0gQVswXVtqXTtcbn1cbm51bWVyaWMuZG90TU1iaWcgPSBmdW5jdGlvbiBkb3RNTWJpZyh4LHkpe1xuICAgIHZhciBnYyA9IG51bWVyaWMuX2dldENvbCwgcCA9IHkubGVuZ3RoLCB2ID0gQXJyYXkocCk7XG4gICAgdmFyIG0gPSB4Lmxlbmd0aCwgbiA9IHlbMF0ubGVuZ3RoLCBBID0gbmV3IEFycmF5KG0pLCB4ajtcbiAgICB2YXIgVlYgPSBudW1lcmljLmRvdFZWO1xuICAgIHZhciBpLGosayx6O1xuICAgIC0tcDtcbiAgICAtLW07XG4gICAgZm9yKGk9bTtpIT09LTE7LS1pKSBBW2ldID0gQXJyYXkobik7XG4gICAgLS1uO1xuICAgIGZvcihpPW47aSE9PS0xOy0taSkge1xuICAgICAgICBnYyh5LGksdik7XG4gICAgICAgIGZvcihqPW07aiE9PS0xOy0taikge1xuICAgICAgICAgICAgej0wO1xuICAgICAgICAgICAgeGogPSB4W2pdO1xuICAgICAgICAgICAgQVtqXVtpXSA9IFZWKHhqLHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG5udW1lcmljLmRvdE1WID0gZnVuY3Rpb24gZG90TVYoeCx5KSB7XG4gICAgdmFyIHAgPSB4Lmxlbmd0aCwgcSA9IHkubGVuZ3RoLGk7XG4gICAgdmFyIHJldCA9IEFycmF5KHApLCBkb3RWViA9IG51bWVyaWMuZG90VlY7XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7IHJldFtpXSA9IGRvdFZWKHhbaV0seSk7IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRvdFZNID0gZnVuY3Rpb24gZG90Vk0oeCx5KSB7XG4gICAgdmFyIGksaixrLHAscSxyLHJldCxmb28sYmFyLHdvbyxpMCxrMCxwMCxyMCxzMSxzMixzMyxiYXosYWNjdW07XG4gICAgcCA9IHgubGVuZ3RoOyBxID0geVswXS5sZW5ndGg7XG4gICAgcmV0ID0gQXJyYXkocSk7XG4gICAgZm9yKGs9cS0xO2s+PTA7ay0tKSB7XG4gICAgICAgIHdvbyA9IHhbcC0xXSp5W3AtMV1ba107XG4gICAgICAgIGZvcihqPXAtMjtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgIGkwID0gai0xO1xuICAgICAgICAgICAgd29vICs9IHhbal0qeVtqXVtrXSArIHhbaTBdKnlbaTBdW2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IHdvbyArPSB4WzBdKnlbMF1ba107IH1cbiAgICAgICAgcmV0W2tdID0gd29vO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLmRvdFZWID0gZnVuY3Rpb24gZG90VlYoeCx5KSB7XG4gICAgdmFyIGksbj14Lmxlbmd0aCxpMSxyZXQgPSB4W24tMV0qeVtuLTFdO1xuICAgIGZvcihpPW4tMjtpPj0xO2ktPTIpIHtcbiAgICAgICAgaTEgPSBpLTE7XG4gICAgICAgIHJldCArPSB4W2ldKnlbaV0gKyB4W2kxXSp5W2kxXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHsgcmV0ICs9IHhbMF0qeVswXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZG90ID0gZnVuY3Rpb24gZG90KHgseSkge1xuICAgIHZhciBkID0gbnVtZXJpYy5kaW07XG4gICAgc3dpdGNoKGQoeCkubGVuZ3RoKjEwMDArZCh5KS5sZW5ndGgpIHtcbiAgICBjYXNlIDIwMDI6XG4gICAgICAgIGlmKHkubGVuZ3RoIDwgMTApIHJldHVybiBudW1lcmljLmRvdE1Nc21hbGwoeCx5KTtcbiAgICAgICAgZWxzZSByZXR1cm4gbnVtZXJpYy5kb3RNTWJpZyh4LHkpO1xuICAgIGNhc2UgMjAwMTogcmV0dXJuIG51bWVyaWMuZG90TVYoeCx5KTtcbiAgICBjYXNlIDEwMDI6IHJldHVybiBudW1lcmljLmRvdFZNKHgseSk7XG4gICAgY2FzZSAxMDAxOiByZXR1cm4gbnVtZXJpYy5kb3RWVih4LHkpO1xuICAgIGNhc2UgMTAwMDogcmV0dXJuIG51bWVyaWMubXVsVlMoeCx5KTtcbiAgICBjYXNlIDE6IHJldHVybiBudW1lcmljLm11bFNWKHgseSk7XG4gICAgY2FzZSAwOiByZXR1cm4geCp5O1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignbnVtZXJpYy5kb3Qgb25seSB3b3JrcyBvbiB2ZWN0b3JzIGFuZCBtYXRyaWNlcycpO1xuICAgIH1cbn1cblxubnVtZXJpYy5kaWFnID0gZnVuY3Rpb24gZGlhZyhkKSB7XG4gICAgdmFyIGksaTEsaixuID0gZC5sZW5ndGgsIEEgPSBBcnJheShuKSwgQWk7XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQXJyYXkobik7XG4gICAgICAgIGkxID0gaSsyO1xuICAgICAgICBmb3Ioaj1uLTE7aj49aTE7ai09Mikge1xuICAgICAgICAgICAgQWlbal0gPSAwO1xuICAgICAgICAgICAgQWlbai0xXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj5pKSB7IEFpW2pdID0gMDsgfVxuICAgICAgICBBaVtpXSA9IGRbaV07XG4gICAgICAgIGZvcihqPWktMTtqPj0xO2otPTIpIHtcbiAgICAgICAgICAgIEFpW2pdID0gMDtcbiAgICAgICAgICAgIEFpW2otMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IEFpWzBdID0gMDsgfVxuICAgICAgICBBW2ldID0gQWk7XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxubnVtZXJpYy5nZXREaWFnID0gZnVuY3Rpb24oQSkge1xuICAgIHZhciBuID0gTWF0aC5taW4oQS5sZW5ndGgsQVswXS5sZW5ndGgpLGkscmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTE7LS1pKSB7XG4gICAgICAgIHJldFtpXSA9IEFbaV1baV07XG4gICAgICAgIC0taTtcbiAgICAgICAgcmV0W2ldID0gQVtpXVtpXTtcbiAgICB9XG4gICAgaWYoaT09PTApIHtcbiAgICAgICAgcmV0WzBdID0gQVswXVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5pZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KG4pIHsgcmV0dXJuIG51bWVyaWMuZGlhZyhudW1lcmljLnJlcChbbl0sMSkpOyB9XG5udW1lcmljLnBvaW50d2lzZSA9IGZ1bmN0aW9uIHBvaW50d2lzZShwYXJhbXMsYm9keSxzZXR1cCkge1xuICAgIGlmKHR5cGVvZiBzZXR1cCA9PT0gXCJ1bmRlZmluZWRcIikgeyBzZXR1cCA9IFwiXCI7IH1cbiAgICB2YXIgZnVuID0gW107XG4gICAgdmFyIGs7XG4gICAgdmFyIGF2ZWMgPSAvXFxbaVxcXSQvLHAsdGhldmVjID0gJyc7XG4gICAgdmFyIGhhdmVyZXQgPSBmYWxzZTtcbiAgICBmb3Ioaz0wO2s8cGFyYW1zLmxlbmd0aDtrKyspIHtcbiAgICAgICAgaWYoYXZlYy50ZXN0KHBhcmFtc1trXSkpIHtcbiAgICAgICAgICAgIHAgPSBwYXJhbXNba10uc3Vic3RyaW5nKDAscGFyYW1zW2tdLmxlbmd0aC0zKTtcbiAgICAgICAgICAgIHRoZXZlYyA9IHA7XG4gICAgICAgIH0gZWxzZSB7IHAgPSBwYXJhbXNba107IH1cbiAgICAgICAgaWYocD09PSdyZXQnKSBoYXZlcmV0ID0gdHJ1ZTtcbiAgICAgICAgZnVuLnB1c2gocCk7XG4gICAgfVxuICAgIGZ1bltwYXJhbXMubGVuZ3RoXSA9ICdfcyc7XG4gICAgZnVuW3BhcmFtcy5sZW5ndGgrMV0gPSAnX2snO1xuICAgIGZ1bltwYXJhbXMubGVuZ3RoKzJdID0gKFxuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfcyA9PT0gXCJ1bmRlZmluZWRcIikgX3MgPSBudW1lcmljLmRpbSgnK3RoZXZlYysnKTtcXG4nK1xuICAgICAgICAgICAgJ2lmKHR5cGVvZiBfayA9PT0gXCJ1bmRlZmluZWRcIikgX2sgPSAwO1xcbicrXG4gICAgICAgICAgICAndmFyIF9uID0gX3NbX2tdO1xcbicrXG4gICAgICAgICAgICAndmFyIGknKyhoYXZlcmV0PycnOicsIHJldCA9IEFycmF5KF9uKScpKyc7XFxuJytcbiAgICAgICAgICAgICdpZihfayA8IF9zLmxlbmd0aC0xKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgZm9yKGk9X24tMTtpPj0wO2ktLSkgcmV0W2ldID0gYXJndW1lbnRzLmNhbGxlZSgnK3BhcmFtcy5qb2luKCcsJykrJyxfcyxfaysxKTtcXG4nK1xuICAgICAgICAgICAgJyAgICByZXR1cm4gcmV0O1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICBzZXR1cCsnXFxuJytcbiAgICAgICAgICAgICdmb3IoaT1fbi0xO2khPT0tMTstLWkpIHtcXG4nK1xuICAgICAgICAgICAgJyAgICAnK2JvZHkrJ1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAncmV0dXJuIHJldDsnXG4gICAgICAgICAgICApO1xuICAgIHJldHVybiBGdW5jdGlvbi5hcHBseShudWxsLGZ1bik7XG59XG5udW1lcmljLnBvaW50d2lzZTIgPSBmdW5jdGlvbiBwb2ludHdpc2UyKHBhcmFtcyxib2R5LHNldHVwKSB7XG4gICAgaWYodHlwZW9mIHNldHVwID09PSBcInVuZGVmaW5lZFwiKSB7IHNldHVwID0gXCJcIjsgfVxuICAgIHZhciBmdW4gPSBbXTtcbiAgICB2YXIgaztcbiAgICB2YXIgYXZlYyA9IC9cXFtpXFxdJC8scCx0aGV2ZWMgPSAnJztcbiAgICB2YXIgaGF2ZXJldCA9IGZhbHNlO1xuICAgIGZvcihrPTA7azxwYXJhbXMubGVuZ3RoO2srKykge1xuICAgICAgICBpZihhdmVjLnRlc3QocGFyYW1zW2tdKSkge1xuICAgICAgICAgICAgcCA9IHBhcmFtc1trXS5zdWJzdHJpbmcoMCxwYXJhbXNba10ubGVuZ3RoLTMpO1xuICAgICAgICAgICAgdGhldmVjID0gcDtcbiAgICAgICAgfSBlbHNlIHsgcCA9IHBhcmFtc1trXTsgfVxuICAgICAgICBpZihwPT09J3JldCcpIGhhdmVyZXQgPSB0cnVlO1xuICAgICAgICBmdW4ucHVzaChwKTtcbiAgICB9XG4gICAgZnVuW3BhcmFtcy5sZW5ndGhdID0gKFxuICAgICAgICAgICAgJ3ZhciBfbiA9ICcrdGhldmVjKycubGVuZ3RoO1xcbicrXG4gICAgICAgICAgICAndmFyIGknKyhoYXZlcmV0PycnOicsIHJldCA9IEFycmF5KF9uKScpKyc7XFxuJytcbiAgICAgICAgICAgIHNldHVwKydcXG4nK1xuICAgICAgICAgICAgJ2ZvcihpPV9uLTE7aSE9PS0xOy0taSkge1xcbicrXG4gICAgICAgICAgICBib2R5KydcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiByZXQ7J1xuICAgICAgICAgICAgKTtcbiAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkobnVsbCxmdW4pO1xufVxubnVtZXJpYy5fYmlmb3JlYWNoID0gKGZ1bmN0aW9uIF9iaWZvcmVhY2goeCx5LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyBmKHgseSk7IHJldHVybjsgfVxuICAgIHZhciBpLG49c1trXTtcbiAgICBmb3IoaT1uLTE7aT49MDtpLS0pIHsgX2JpZm9yZWFjaCh0eXBlb2YgeD09PVwib2JqZWN0XCI/eFtpXTp4LHR5cGVvZiB5PT09XCJvYmplY3RcIj95W2ldOnkscyxrKzEsZik7IH1cbn0pO1xubnVtZXJpYy5fYmlmb3JlYWNoMiA9IChmdW5jdGlvbiBfYmlmb3JlYWNoMih4LHkscyxrLGYpIHtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7IHJldHVybiBmKHgseSk7IH1cbiAgICB2YXIgaSxuPXNba10scmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTA7LS1pKSB7IHJldFtpXSA9IF9iaWZvcmVhY2gyKHR5cGVvZiB4PT09XCJvYmplY3RcIj94W2ldOngsdHlwZW9mIHk9PT1cIm9iamVjdFwiP3lbaV06eSxzLGsrMSxmKTsgfVxuICAgIHJldHVybiByZXQ7XG59KTtcbm51bWVyaWMuX2ZvcmVhY2ggPSAoZnVuY3Rpb24gX2ZvcmVhY2goeCxzLGssZikge1xuICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgZih4KTsgcmV0dXJuOyB9XG4gICAgdmFyIGksbj1zW2tdO1xuICAgIGZvcihpPW4tMTtpPj0wO2ktLSkgeyBfZm9yZWFjaCh4W2ldLHMsaysxLGYpOyB9XG59KTtcbm51bWVyaWMuX2ZvcmVhY2gyID0gKGZ1bmN0aW9uIF9mb3JlYWNoMih4LHMsayxmKSB7XG4gICAgaWYoayA9PT0gcy5sZW5ndGgtMSkgeyByZXR1cm4gZih4KTsgfVxuICAgIHZhciBpLG49c1trXSwgcmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSB7IHJldFtpXSA9IF9mb3JlYWNoMih4W2ldLHMsaysxLGYpOyB9XG4gICAgcmV0dXJuIHJldDtcbn0pO1xuXG4vKm51bWVyaWMuYW55ViA9IG51bWVyaWMubWFwcmVkdWNlKCdpZih4aSkgcmV0dXJuIHRydWU7JywnZmFsc2UnKTtcbm51bWVyaWMuYWxsViA9IG51bWVyaWMubWFwcmVkdWNlKCdpZigheGkpIHJldHVybiBmYWxzZTsnLCd0cnVlJyk7XG5udW1lcmljLmFueSA9IGZ1bmN0aW9uKHgpIHsgaWYodHlwZW9mIHgubGVuZ3RoID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4geDsgcmV0dXJuIG51bWVyaWMuYW55Vih4KTsgfVxubnVtZXJpYy5hbGwgPSBmdW5jdGlvbih4KSB7IGlmKHR5cGVvZiB4Lmxlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHg7IHJldHVybiBudW1lcmljLmFsbFYoeCk7IH0qL1xuXG5udW1lcmljLm9wczIgPSB7XG4gICAgICAgIGFkZDogJysnLFxuICAgICAgICBzdWI6ICctJyxcbiAgICAgICAgbXVsOiAnKicsXG4gICAgICAgIGRpdjogJy8nLFxuICAgICAgICBtb2Q6ICclJyxcbiAgICAgICAgYW5kOiAnJiYnLFxuICAgICAgICBvcjogICd8fCcsXG4gICAgICAgIGVxOiAgJz09PScsXG4gICAgICAgIG5lcTogJyE9PScsXG4gICAgICAgIGx0OiAgJzwnLFxuICAgICAgICBndDogICc+JyxcbiAgICAgICAgbGVxOiAnPD0nLFxuICAgICAgICBnZXE6ICc+PScsXG4gICAgICAgIGJhbmQ6ICcmJyxcbiAgICAgICAgYm9yOiAnfCcsXG4gICAgICAgIGJ4b3I6ICdeJyxcbiAgICAgICAgbHNoaWZ0OiAnPDwnLFxuICAgICAgICByc2hpZnQ6ICc+PicsXG4gICAgICAgIHJyc2hpZnQ6ICc+Pj4nXG59O1xubnVtZXJpYy5vcHNlcSA9IHtcbiAgICAgICAgYWRkZXE6ICcrPScsXG4gICAgICAgIHN1YmVxOiAnLT0nLFxuICAgICAgICBtdWxlcTogJyo9JyxcbiAgICAgICAgZGl2ZXE6ICcvPScsXG4gICAgICAgIG1vZGVxOiAnJT0nLFxuICAgICAgICBsc2hpZnRlcTogJzw8PScsXG4gICAgICAgIHJzaGlmdGVxOiAnPj49JyxcbiAgICAgICAgcnJzaGlmdGVxOiAnPj4+PScsXG4gICAgICAgIGJhbmRlcTogJyY9JyxcbiAgICAgICAgYm9yZXE6ICd8PScsXG4gICAgICAgIGJ4b3JlcTogJ149J1xufTtcbm51bWVyaWMubWF0aGZ1bnMgPSBbJ2FicycsJ2Fjb3MnLCdhc2luJywnYXRhbicsJ2NlaWwnLCdjb3MnLFxuICAgICAgICAgICAgICAgICAgICAnZXhwJywnZmxvb3InLCdsb2cnLCdyb3VuZCcsJ3NpbicsJ3NxcnQnLCd0YW4nLFxuICAgICAgICAgICAgICAgICAgICAnaXNOYU4nLCdpc0Zpbml0ZSddO1xubnVtZXJpYy5tYXRoZnVuczIgPSBbJ2F0YW4yJywncG93JywnbWF4JywnbWluJ107XG5udW1lcmljLm9wczEgPSB7XG4gICAgICAgIG5lZzogJy0nLFxuICAgICAgICBub3Q6ICchJyxcbiAgICAgICAgYm5vdDogJ34nLFxuICAgICAgICBjbG9uZTogJydcbn07XG5udW1lcmljLm1hcHJlZHVjZXJzID0ge1xuICAgICAgICBhbnk6IFsnaWYoeGkpIHJldHVybiB0cnVlOycsJ3ZhciBhY2N1bSA9IGZhbHNlOyddLFxuICAgICAgICBhbGw6IFsnaWYoIXhpKSByZXR1cm4gZmFsc2U7JywndmFyIGFjY3VtID0gdHJ1ZTsnXSxcbiAgICAgICAgc3VtOiBbJ2FjY3VtICs9IHhpOycsJ3ZhciBhY2N1bSA9IDA7J10sXG4gICAgICAgIHByb2Q6IFsnYWNjdW0gKj0geGk7JywndmFyIGFjY3VtID0gMTsnXSxcbiAgICAgICAgbm9ybTJTcXVhcmVkOiBbJ2FjY3VtICs9IHhpKnhpOycsJ3ZhciBhY2N1bSA9IDA7J10sXG4gICAgICAgIG5vcm1pbmY6IFsnYWNjdW0gPSBtYXgoYWNjdW0sYWJzKHhpKSk7JywndmFyIGFjY3VtID0gMCwgbWF4ID0gTWF0aC5tYXgsIGFicyA9IE1hdGguYWJzOyddLFxuICAgICAgICBub3JtMTogWydhY2N1bSArPSBhYnMoeGkpJywndmFyIGFjY3VtID0gMCwgYWJzID0gTWF0aC5hYnM7J10sXG4gICAgICAgIHN1cDogWydhY2N1bSA9IG1heChhY2N1bSx4aSk7JywndmFyIGFjY3VtID0gLUluZmluaXR5LCBtYXggPSBNYXRoLm1heDsnXSxcbiAgICAgICAgaW5mOiBbJ2FjY3VtID0gbWluKGFjY3VtLHhpKTsnLCd2YXIgYWNjdW0gPSBJbmZpbml0eSwgbWluID0gTWF0aC5taW47J11cbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksbztcbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVuczIubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuczJbaV07XG4gICAgICAgIG51bWVyaWMub3BzMltvXSA9IG87XG4gICAgfVxuICAgIGZvcihpIGluIG51bWVyaWMub3BzMikge1xuICAgICAgICBpZihudW1lcmljLm9wczIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG8gPSBudW1lcmljLm9wczJbaV07XG4gICAgICAgICAgICB2YXIgY29kZSwgY29kZWVxLCBzZXR1cCA9ICcnO1xuICAgICAgICAgICAgaWYobnVtZXJpYy5teUluZGV4T2YuY2FsbChudW1lcmljLm1hdGhmdW5zMixpKSE9PS0xKSB7XG4gICAgICAgICAgICAgICAgc2V0dXAgPSAndmFyICcrbysnID0gTWF0aC4nK28rJztcXG4nO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBmdW5jdGlvbihyLHgseSkgeyByZXR1cm4gcisnID0gJytvKycoJyt4KycsJyt5KycpJzsgfTtcbiAgICAgICAgICAgICAgICBjb2RlZXEgPSBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHgrJyA9ICcrbysnKCcreCsnLCcreSsnKSc7IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBmdW5jdGlvbihyLHgseSkgeyByZXR1cm4gcisnID0gJyt4KycgJytvKycgJyt5OyB9O1xuICAgICAgICAgICAgICAgIGlmKG51bWVyaWMub3BzZXEuaGFzT3duUHJvcGVydHkoaSsnZXEnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlZXEgPSBmdW5jdGlvbih4LHkpIHsgcmV0dXJuIHgrJyAnK28rJz0gJyt5OyB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVlcSA9IGZ1bmN0aW9uKHgseSkgeyByZXR1cm4geCsnID0gJyt4KycgJytvKycgJyt5OyB9OyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtZXJpY1tpKydWViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneFtpXScsJ3lbaV0nXSxjb2RlKCdyZXRbaV0nLCd4W2ldJywneVtpXScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnU1YnXSA9IG51bWVyaWMucG9pbnR3aXNlMihbJ3gnLCd5W2ldJ10sY29kZSgncmV0W2ldJywneCcsJ3lbaV0nKSxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ1ZTJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWyd4W2ldJywneSddLGNvZGUoJ3JldFtpXScsJ3hbaV0nLCd5Jyksc2V0dXApO1xuICAgICAgICAgICAgbnVtZXJpY1tpXSA9IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAndmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBpLCB4ID0gYXJndW1lbnRzWzBdLCB5O1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgVlYgPSBudW1lcmljLicraSsnVlYsIFZTID0gbnVtZXJpYy4nK2krJ1ZTLCBTViA9IG51bWVyaWMuJytpKydTVjtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIGRpbSA9IG51bWVyaWMuZGltO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdmb3IoaT0xO2khPT1uOysraSkgeyBcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICB5ID0gYXJndW1lbnRzW2ldO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGlmKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiKSB7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgICAgIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSB4ID0gbnVtZXJpYy5fYmlmb3JlYWNoMih4LHksZGltKHgpLDAsVlYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICAgICBlbHNlIHggPSBudW1lcmljLl9iaWZvcmVhY2gyKHgseSxkaW0oeCksMCxWUyk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgfSBlbHNlIGlmKHR5cGVvZiB5ID09PSBcIm9iamVjdFwiKSB4ID0gbnVtZXJpYy5fYmlmb3JlYWNoMih4LHksZGltKHkpLDAsU1YpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGVsc2UgJytjb2RlZXEoJ3gnLCd5JykrJ1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9XFxucmV0dXJuIHg7XFxuJyk7XG4gICAgICAgICAgICBudW1lcmljW29dID0gbnVtZXJpY1tpXTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXFWJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWydyZXRbaV0nLCd4W2ldJ10sIGNvZGVlcSgncmV0W2ldJywneFtpXScpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXFTJ10gPSBudW1lcmljLnBvaW50d2lzZTIoWydyZXRbaV0nLCd4J10sIGNvZGVlcSgncmV0W2ldJywneCcpLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnZXEnXSA9IEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAndmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBpLCB4ID0gYXJndW1lbnRzWzBdLCB5O1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgViA9IG51bWVyaWMuJytpKydlcVYsIFMgPSBudW1lcmljLicraSsnZXFTXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBzID0gbnVtZXJpYy5kaW0oeCk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2ZvcihpPTE7aSE9PW47KytpKSB7IFxcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIHkgPSBhcmd1bWVudHNbaV07XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJyAgaWYodHlwZW9mIHkgPT09IFwib2JqZWN0XCIpIG51bWVyaWMuX2JpZm9yZWFjaCh4LHkscywwLFYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgIGVsc2UgbnVtZXJpYy5fYmlmb3JlYWNoKHgseSxzLDAsUyk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ31cXG5yZXR1cm4geDtcXG4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IoaT0wO2k8bnVtZXJpYy5tYXRoZnVuczIubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuczJbaV07XG4gICAgICAgIGRlbGV0ZSBudW1lcmljLm9wczJbb107XG4gICAgfVxuICAgIGZvcihpPTA7aTxudW1lcmljLm1hdGhmdW5zLmxlbmd0aDsrK2kpIHtcbiAgICAgICAgbyA9IG51bWVyaWMubWF0aGZ1bnNbaV07XG4gICAgICAgIG51bWVyaWMub3BzMVtvXSA9IG87XG4gICAgfVxuICAgIGZvcihpIGluIG51bWVyaWMub3BzMSkge1xuICAgICAgICBpZihudW1lcmljLm9wczEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHNldHVwID0gJyc7XG4gICAgICAgICAgICBvID0gbnVtZXJpYy5vcHMxW2ldO1xuICAgICAgICAgICAgaWYobnVtZXJpYy5teUluZGV4T2YuY2FsbChudW1lcmljLm1hdGhmdW5zLGkpIT09LTEpIHtcbiAgICAgICAgICAgICAgICBpZihNYXRoLmhhc093blByb3BlcnR5KG8pKSBzZXR1cCA9ICd2YXIgJytvKycgPSBNYXRoLicrbysnO1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsncmV0W2ldJ10sJ3JldFtpXSA9ICcrbysnKHJldFtpXSk7JyxzZXR1cCk7XG4gICAgICAgICAgICBudW1lcmljW2krJ2VxJ10gPSBGdW5jdGlvbigneCcsXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgcmV0dXJuICcrbysneFxcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgaTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIFYgPSBudW1lcmljLicraSsnZXFWO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdudW1lcmljLl9mb3JlYWNoKHgscywwLFYpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4geDtcXG4nKTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnViddID0gbnVtZXJpYy5wb2ludHdpc2UyKFsneFtpXSddLCdyZXRbaV0gPSAnK28rJyh4W2ldKTsnLHNldHVwKTtcbiAgICAgICAgICAgIG51bWVyaWNbaV0gPSBGdW5jdGlvbigneCcsXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgcmV0dXJuICcrbysnKHgpXFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3ZhciBpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgViA9IG51bWVyaWMuJytpKydWO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4gbnVtZXJpYy5fZm9yZWFjaDIoeCxzLDAsVik7XFxuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGk9MDtpPG51bWVyaWMubWF0aGZ1bnMubGVuZ3RoOysraSkge1xuICAgICAgICBvID0gbnVtZXJpYy5tYXRoZnVuc1tpXTtcbiAgICAgICAgZGVsZXRlIG51bWVyaWMub3BzMVtvXTtcbiAgICB9XG4gICAgZm9yKGkgaW4gbnVtZXJpYy5tYXByZWR1Y2Vycykge1xuICAgICAgICBpZihudW1lcmljLm1hcHJlZHVjZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBvID0gbnVtZXJpYy5tYXByZWR1Y2Vyc1tpXTtcbiAgICAgICAgICAgIG51bWVyaWNbaSsnViddID0gbnVtZXJpYy5tYXByZWR1Y2UyKG9bMF0sb1sxXSk7XG4gICAgICAgICAgICBudW1lcmljW2ldID0gRnVuY3Rpb24oJ3gnLCdzJywnaycsXG4gICAgICAgICAgICAgICAgICAgIG9bMV0rXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgeCAhPT0gXCJvYmplY3RcIikgeycrXG4gICAgICAgICAgICAgICAgICAgICcgICAgeGkgPSB4O1xcbicrXG4gICAgICAgICAgICAgICAgICAgIG9bMF0rJztcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnICAgIHJldHVybiBhY2N1bTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAnfScrXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgcyA9PT0gXCJ1bmRlZmluZWRcIikgcyA9IG51bWVyaWMuZGltKHgpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdpZih0eXBlb2YgayA9PT0gXCJ1bmRlZmluZWRcIikgayA9IDA7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ2lmKGsgPT09IHMubGVuZ3RoLTEpIHJldHVybiBudW1lcmljLicraSsnVih4KTtcXG4nK1xuICAgICAgICAgICAgICAgICAgICAndmFyIHhpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd2YXIgbiA9IHgubGVuZ3RoLCBpO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICdmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xcbicrXG4gICAgICAgICAgICAgICAgICAgICcgICB4aSA9IGFyZ3VtZW50cy5jYWxsZWUoeFtpXSk7XFxuJytcbiAgICAgICAgICAgICAgICAgICAgb1swXSsnO1xcbicrXG4gICAgICAgICAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybiBhY2N1bTtcXG4nKTtcbiAgICAgICAgfVxuICAgIH1cbn0oKSk7XG5cbm51bWVyaWMudHJ1bmNWViA9IG51bWVyaWMucG9pbnR3aXNlKFsneFtpXScsJ3lbaV0nXSwncmV0W2ldID0gcm91bmQoeFtpXS95W2ldKSp5W2ldOycsJ3ZhciByb3VuZCA9IE1hdGgucm91bmQ7Jyk7XG5udW1lcmljLnRydW5jVlMgPSBudW1lcmljLnBvaW50d2lzZShbJ3hbaV0nLCd5J10sJ3JldFtpXSA9IHJvdW5kKHhbaV0veSkqeTsnLCd2YXIgcm91bmQgPSBNYXRoLnJvdW5kOycpO1xubnVtZXJpYy50cnVuY1NWID0gbnVtZXJpYy5wb2ludHdpc2UoWyd4JywneVtpXSddLCdyZXRbaV0gPSByb3VuZCh4L3lbaV0pKnlbaV07JywndmFyIHJvdW5kID0gTWF0aC5yb3VuZDsnKTtcbm51bWVyaWMudHJ1bmMgPSBmdW5jdGlvbiB0cnVuYyh4LHkpIHtcbiAgICBpZih0eXBlb2YgeCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZih0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIG51bWVyaWMudHJ1bmNWVih4LHkpO1xuICAgICAgICByZXR1cm4gbnVtZXJpYy50cnVuY1ZTKHgseSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIG51bWVyaWMudHJ1bmNTVih4LHkpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHgveSkqeTtcbn1cblxubnVtZXJpYy5pbnYgPSBmdW5jdGlvbiBpbnYoeCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oeCksIGFicyA9IE1hdGguYWJzLCBtID0gc1swXSwgbiA9IHNbMV07XG4gICAgdmFyIEEgPSBudW1lcmljLmNsb25lKHgpLCBBaSwgQWo7XG4gICAgdmFyIEkgPSBudW1lcmljLmlkZW50aXR5KG0pLCBJaSwgSWo7XG4gICAgdmFyIGksaixrLHg7XG4gICAgZm9yKGo9MDtqPG47KytqKSB7XG4gICAgICAgIHZhciBpMCA9IC0xO1xuICAgICAgICB2YXIgdjAgPSAtMTtcbiAgICAgICAgZm9yKGk9ajtpIT09bTsrK2kpIHsgayA9IGFicyhBW2ldW2pdKTsgaWYoaz52MCkgeyBpMCA9IGk7IHYwID0gazsgfSB9XG4gICAgICAgIEFqID0gQVtpMF07IEFbaTBdID0gQVtqXTsgQVtqXSA9IEFqO1xuICAgICAgICBJaiA9IElbaTBdOyBJW2kwXSA9IElbal07IElbal0gPSBJajtcbiAgICAgICAgeCA9IEFqW2pdO1xuICAgICAgICBmb3Ioaz1qO2shPT1uOysraykgICAgQWpba10gLz0geDsgXG4gICAgICAgIGZvcihrPW4tMTtrIT09LTE7LS1rKSBJaltrXSAvPSB4O1xuICAgICAgICBmb3IoaT1tLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAgICAgaWYoaSE9PWopIHtcbiAgICAgICAgICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgICAgICAgICAgSWkgPSBJW2ldO1xuICAgICAgICAgICAgICAgIHggPSBBaVtqXTtcbiAgICAgICAgICAgICAgICBmb3Ioaz1qKzE7ayE9PW47KytrKSAgQWlba10gLT0gQWpba10qeDtcbiAgICAgICAgICAgICAgICBmb3Ioaz1uLTE7az4wOy0taykgeyBJaVtrXSAtPSBJaltrXSp4OyAtLWs7IElpW2tdIC09IElqW2tdKng7IH1cbiAgICAgICAgICAgICAgICBpZihrPT09MCkgSWlbMF0gLT0gSWpbMF0qeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSTtcbn1cblxubnVtZXJpYy5kZXQgPSBmdW5jdGlvbiBkZXQoeCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oeCk7XG4gICAgaWYocy5sZW5ndGggIT09IDIgfHwgc1swXSAhPT0gc1sxXSkgeyB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWM6IGRldCgpIG9ubHkgd29ya3Mgb24gc3F1YXJlIG1hdHJpY2VzJyk7IH1cbiAgICB2YXIgbiA9IHNbMF0sIHJldCA9IDEsaSxqLGssQSA9IG51bWVyaWMuY2xvbmUoeCksQWosQWksYWxwaGEsdGVtcCxrMSxrMixrMztcbiAgICBmb3Ioaj0wO2o8bi0xO2orKykge1xuICAgICAgICBrPWo7XG4gICAgICAgIGZvcihpPWorMTtpPG47aSsrKSB7IGlmKE1hdGguYWJzKEFbaV1bal0pID4gTWF0aC5hYnMoQVtrXVtqXSkpIHsgayA9IGk7IH0gfVxuICAgICAgICBpZihrICE9PSBqKSB7XG4gICAgICAgICAgICB0ZW1wID0gQVtrXTsgQVtrXSA9IEFbal07IEFbal0gPSB0ZW1wO1xuICAgICAgICAgICAgcmV0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIEFqID0gQVtqXTtcbiAgICAgICAgZm9yKGk9aisxO2k8bjtpKyspIHtcbiAgICAgICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgICAgIGFscGhhID0gQWlbal0vQWpbal07XG4gICAgICAgICAgICBmb3Ioaz1qKzE7azxuLTE7ays9Mikge1xuICAgICAgICAgICAgICAgIGsxID0gaysxO1xuICAgICAgICAgICAgICAgIEFpW2tdIC09IEFqW2tdKmFscGhhO1xuICAgICAgICAgICAgICAgIEFpW2sxXSAtPSBBaltrMV0qYWxwaGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihrIT09bikgeyBBaVtrXSAtPSBBaltrXSphbHBoYTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKEFqW2pdID09PSAwKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldCAqPSBBaltqXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldCpBW2pdW2pdO1xufVxuXG5udW1lcmljLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZSh4KSB7XG4gICAgdmFyIGksaixtID0geC5sZW5ndGgsbiA9IHhbMF0ubGVuZ3RoLCByZXQ9QXJyYXkobiksQTAsQTEsQmo7XG4gICAgZm9yKGo9MDtqPG47aisrKSByZXRbal0gPSBBcnJheShtKTtcbiAgICBmb3IoaT1tLTE7aT49MTtpLT0yKSB7XG4gICAgICAgIEExID0geFtpXTtcbiAgICAgICAgQTAgPSB4W2ktMV07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgQmogPSByZXRbal07IEJqW2ldID0gQTFbal07IEJqW2ktMV0gPSBBMFtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEJqID0gcmV0W2pdOyBCaltpXSA9IEExW2pdOyBCaltpLTFdID0gQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHtcbiAgICAgICAgICAgIEJqID0gcmV0WzBdOyBCaltpXSA9IEExWzBdOyBCaltpLTFdID0gQTBbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoaT09PTApIHtcbiAgICAgICAgQTAgPSB4WzBdO1xuICAgICAgICBmb3Ioaj1uLTE7aj49MTstLWopIHtcbiAgICAgICAgICAgIHJldFtqXVswXSA9IEEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHsgcmV0WzBdWzBdID0gQTBbMF07IH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMubmVndHJhbnNwb3NlID0gZnVuY3Rpb24gbmVndHJhbnNwb3NlKHgpIHtcbiAgICB2YXIgaSxqLG0gPSB4Lmxlbmd0aCxuID0geFswXS5sZW5ndGgsIHJldD1BcnJheShuKSxBMCxBMSxCajtcbiAgICBmb3Ioaj0wO2o8bjtqKyspIHJldFtqXSA9IEFycmF5KG0pO1xuICAgIGZvcihpPW0tMTtpPj0xO2ktPTIpIHtcbiAgICAgICAgQTEgPSB4W2ldO1xuICAgICAgICBBMCA9IHhbaS0xXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTE7LS1qKSB7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSAtQTFbal07IEJqW2ktMV0gPSAtQTBbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBCaiA9IHJldFtqXTsgQmpbaV0gPSAtQTFbal07IEJqW2ktMV0gPSAtQTBbal07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaj09PTApIHtcbiAgICAgICAgICAgIEJqID0gcmV0WzBdOyBCaltpXSA9IC1BMVswXTsgQmpbaS0xXSA9IC1BMFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihpPT09MCkge1xuICAgICAgICBBMCA9IHhbMF07XG4gICAgICAgIGZvcihqPW4tMTtqPj0xOy0taikge1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gLUEwW2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgcmV0W2pdWzBdID0gLUEwW2pdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGo9PT0wKSB7IHJldFswXVswXSA9IC1BMFswXTsgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLl9yYW5kb20gPSBmdW5jdGlvbiBfcmFuZG9tKHMsaykge1xuICAgIHZhciBpLG49c1trXSxyZXQ9QXJyYXkobiksIHJuZDtcbiAgICBpZihrID09PSBzLmxlbmd0aC0xKSB7XG4gICAgICAgIHJuZCA9IE1hdGgucmFuZG9tO1xuICAgICAgICBmb3IoaT1uLTE7aT49MTtpLT0yKSB7XG4gICAgICAgICAgICByZXRbaV0gPSBybmQoKTtcbiAgICAgICAgICAgIHJldFtpLTFdID0gcm5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaT09PTApIHsgcmV0WzBdID0gcm5kKCk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yKGk9bi0xO2k+PTA7aS0tKSByZXRbaV0gPSBfcmFuZG9tKHMsaysxKTtcbiAgICByZXR1cm4gcmV0O1xufVxubnVtZXJpYy5yYW5kb20gPSBmdW5jdGlvbiByYW5kb20ocykgeyByZXR1cm4gbnVtZXJpYy5fcmFuZG9tKHMsMCk7IH1cblxubnVtZXJpYy5ub3JtMiA9IGZ1bmN0aW9uIG5vcm0yKHgpIHsgcmV0dXJuIE1hdGguc3FydChudW1lcmljLm5vcm0yU3F1YXJlZCh4KSk7IH1cblxubnVtZXJpYy5saW5zcGFjZSA9IGZ1bmN0aW9uIGxpbnNwYWNlKGEsYixuKSB7XG4gICAgaWYodHlwZW9mIG4gPT09IFwidW5kZWZpbmVkXCIpIG4gPSBNYXRoLm1heChNYXRoLnJvdW5kKGItYSkrMSwxKTtcbiAgICBpZihuPDIpIHsgcmV0dXJuIG49PT0xP1thXTpbXTsgfVxuICAgIHZhciBpLHJldCA9IEFycmF5KG4pO1xuICAgIG4tLTtcbiAgICBmb3IoaT1uO2k+PTA7aS0tKSB7IHJldFtpXSA9IChpKmIrKG4taSkqYSkvbjsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuZ2V0QmxvY2sgPSBmdW5jdGlvbiBnZXRCbG9jayh4LGZyb20sdG8pIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xuICAgIGZ1bmN0aW9uIGZvbyh4LGspIHtcbiAgICAgICAgdmFyIGksYSA9IGZyb21ba10sIG4gPSB0b1trXS1hLCByZXQgPSBBcnJheShuKTtcbiAgICAgICAgaWYoayA9PT0gcy5sZW5ndGgtMSkge1xuICAgICAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyByZXRbaV0gPSB4W2krYV07IH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyByZXRbaV0gPSBmb28oeFtpK2FdLGsrMSk7IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmV0dXJuIGZvbyh4LDApO1xufVxuXG5udW1lcmljLnNldEJsb2NrID0gZnVuY3Rpb24gc2V0QmxvY2soeCxmcm9tLHRvLEIpIHtcbiAgICB2YXIgcyA9IG51bWVyaWMuZGltKHgpO1xuICAgIGZ1bmN0aW9uIGZvbyh4LHksaykge1xuICAgICAgICB2YXIgaSxhID0gZnJvbVtrXSwgbiA9IHRvW2tdLWE7XG4gICAgICAgIGlmKGsgPT09IHMubGVuZ3RoLTEpIHsgZm9yKGk9bjtpPj0wO2ktLSkgeyB4W2krYV0gPSB5W2ldOyB9IH1cbiAgICAgICAgZm9yKGk9bjtpPj0wO2ktLSkgeyBmb28oeFtpK2FdLHlbaV0saysxKTsgfVxuICAgIH1cbiAgICBmb28oeCxCLDApO1xuICAgIHJldHVybiB4O1xufVxuXG5udW1lcmljLmdldFJhbmdlID0gZnVuY3Rpb24gZ2V0UmFuZ2UoQSxJLEopIHtcbiAgICB2YXIgbSA9IEkubGVuZ3RoLCBuID0gSi5sZW5ndGg7XG4gICAgdmFyIGksajtcbiAgICB2YXIgQiA9IEFycmF5KG0pLCBCaSwgQUk7XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgQltpXSA9IEFycmF5KG4pO1xuICAgICAgICBCaSA9IEJbaV07XG4gICAgICAgIEFJID0gQVtJW2ldXTtcbiAgICAgICAgZm9yKGo9bi0xO2ohPT0tMTstLWopIEJpW2pdID0gQUlbSltqXV07XG4gICAgfVxuICAgIHJldHVybiBCO1xufVxuXG5udW1lcmljLmJsb2NrTWF0cml4ID0gZnVuY3Rpb24gYmxvY2tNYXRyaXgoWCkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oWCk7XG4gICAgaWYocy5sZW5ndGg8NCkgcmV0dXJuIG51bWVyaWMuYmxvY2tNYXRyaXgoW1hdKTtcbiAgICB2YXIgbT1zWzBdLG49c1sxXSxNLE4saSxqLFhpajtcbiAgICBNID0gMDsgTiA9IDA7XG4gICAgZm9yKGk9MDtpPG07KytpKSBNKz1YW2ldWzBdLmxlbmd0aDtcbiAgICBmb3Ioaj0wO2o8bjsrK2opIE4rPVhbMF1bal1bMF0ubGVuZ3RoO1xuICAgIHZhciBaID0gQXJyYXkoTSk7XG4gICAgZm9yKGk9MDtpPE07KytpKSBaW2ldID0gQXJyYXkoTik7XG4gICAgdmFyIEk9MCxKLFpJLGssbCxYaWprO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBKPU47XG4gICAgICAgIGZvcihqPW4tMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBYaWogPSBYW2ldW2pdO1xuICAgICAgICAgICAgSiAtPSBYaWpbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKGs9WGlqLmxlbmd0aC0xO2shPT0tMTstLWspIHtcbiAgICAgICAgICAgICAgICBYaWprID0gWGlqW2tdO1xuICAgICAgICAgICAgICAgIFpJID0gWltJK2tdO1xuICAgICAgICAgICAgICAgIGZvcihsID0gWGlqay5sZW5ndGgtMTtsIT09LTE7LS1sKSBaSVtKK2xdID0gWGlqa1tsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBJICs9IFhbaV1bMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gWjtcbn1cblxubnVtZXJpYy50ZW5zb3IgPSBmdW5jdGlvbiB0ZW5zb3IoeCx5KSB7XG4gICAgaWYodHlwZW9mIHggPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHJldHVybiBudW1lcmljLm11bCh4LHkpO1xuICAgIHZhciBzMSA9IG51bWVyaWMuZGltKHgpLCBzMiA9IG51bWVyaWMuZGltKHkpO1xuICAgIGlmKHMxLmxlbmd0aCAhPT0gMSB8fCBzMi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiB0ZW5zb3IgcHJvZHVjdCBpcyBvbmx5IGRlZmluZWQgZm9yIHZlY3RvcnMnKTtcbiAgICB9XG4gICAgdmFyIG0gPSBzMVswXSwgbiA9IHMyWzBdLCBBID0gQXJyYXkobSksIEFpLCBpLGoseGk7XG4gICAgZm9yKGk9bS0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQXJyYXkobik7XG4gICAgICAgIHhpID0geFtpXTtcbiAgICAgICAgZm9yKGo9bi0xO2o+PTM7LS1qKSB7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgIEFpW2pdID0geGkgKiB5W2pdO1xuICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgQWlbal0gPSB4aSAqIHlbal07XG4gICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICBBaVtqXSA9IHhpICogeVtqXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShqPj0wKSB7IEFpW2pdID0geGkgKiB5W2pdOyAtLWo7IH1cbiAgICAgICAgQVtpXSA9IEFpO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbn1cblxuLy8gMy4gVGhlIFRlbnNvciB0eXBlIFRcbm51bWVyaWMuVCA9IGZ1bmN0aW9uIFQoeCx5KSB7IHRoaXMueCA9IHg7IHRoaXMueSA9IHk7IH1cbm51bWVyaWMudCA9IGZ1bmN0aW9uIHQoeCx5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHgseSk7IH1cblxubnVtZXJpYy5UYmlub3AgPSBmdW5jdGlvbiBUYmlub3AocnIscmMsY3IsY2Msc2V0dXApIHtcbiAgICB2YXIgaW8gPSBudW1lcmljLmluZGV4T2Y7XG4gICAgaWYodHlwZW9mIHNldHVwICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBzZXR1cCA9ICcnO1xuICAgICAgICBmb3IoayBpbiBudW1lcmljKSB7XG4gICAgICAgICAgICBpZihudW1lcmljLmhhc093blByb3BlcnR5KGspICYmIChyci5pbmRleE9mKGspPj0wIHx8IHJjLmluZGV4T2Yoayk+PTAgfHwgY3IuaW5kZXhPZihrKT49MCB8fCBjYy5pbmRleE9mKGspPj0wKSAmJiBrLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICAgICAgc2V0dXAgKz0gJ3ZhciAnK2srJyA9IG51bWVyaWMuJytrKyc7XFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRnVuY3Rpb24oWyd5J10sXG4gICAgICAgICAgICAndmFyIHggPSB0aGlzO1xcbicrXG4gICAgICAgICAgICAnaWYoISh5IGluc3RhbmNlb2YgbnVtZXJpYy5UKSkgeyB5ID0gbmV3IG51bWVyaWMuVCh5KTsgfVxcbicrXG4gICAgICAgICAgICBzZXR1cCsnXFxuJytcbiAgICAgICAgICAgICdpZih4LnkpIHsnK1xuICAgICAgICAgICAgJyAgaWYoeS55KSB7JytcbiAgICAgICAgICAgICcgICAgcmV0dXJuIG5ldyBudW1lcmljLlQoJytjYysnKTtcXG4nK1xuICAgICAgICAgICAgJyAgfVxcbicrXG4gICAgICAgICAgICAnICByZXR1cm4gbmV3IG51bWVyaWMuVCgnK2NyKycpO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICAnaWYoeS55KSB7XFxuJytcbiAgICAgICAgICAgICcgIHJldHVybiBuZXcgbnVtZXJpYy5UKCcrcmMrJyk7XFxuJytcbiAgICAgICAgICAgICd9XFxuJytcbiAgICAgICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVCgnK3JyKycpO1xcbidcbiAgICApO1xufVxuXG5udW1lcmljLlQucHJvdG90eXBlLmFkZCA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnYWRkKHgueCx5LngpJyxcbiAgICAgICAgJ2FkZCh4LngseS54KSx5LnknLFxuICAgICAgICAnYWRkKHgueCx5LngpLHgueScsXG4gICAgICAgICdhZGQoeC54LHkueCksYWRkKHgueSx5LnkpJyk7XG5udW1lcmljLlQucHJvdG90eXBlLnN1YiA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnc3ViKHgueCx5LngpJyxcbiAgICAgICAgJ3N1Yih4LngseS54KSxuZWcoeS55KScsXG4gICAgICAgICdzdWIoeC54LHkueCkseC55JyxcbiAgICAgICAgJ3N1Yih4LngseS54KSxzdWIoeC55LHkueSknKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubXVsID0gbnVtZXJpYy5UYmlub3AoXG4gICAgICAgICdtdWwoeC54LHkueCknLFxuICAgICAgICAnbXVsKHgueCx5LngpLG11bCh4LngseS55KScsXG4gICAgICAgICdtdWwoeC54LHkueCksbXVsKHgueSx5LngpJyxcbiAgICAgICAgJ3N1YihtdWwoeC54LHkueCksbXVsKHgueSx5LnkpKSxhZGQobXVsKHgueCx5LnkpLG11bCh4LnkseS54KSknKTtcblxubnVtZXJpYy5ULnByb3RvdHlwZS5yZWNpcHJvY2FsID0gZnVuY3Rpb24gcmVjaXByb2NhbCgpIHtcbiAgICB2YXIgbXVsID0gbnVtZXJpYy5tdWwsIGRpdiA9IG51bWVyaWMuZGl2O1xuICAgIGlmKHRoaXMueSkge1xuICAgICAgICB2YXIgZCA9IG51bWVyaWMuYWRkKG11bCh0aGlzLngsdGhpcy54KSxtdWwodGhpcy55LHRoaXMueSkpO1xuICAgICAgICByZXR1cm4gbmV3IG51bWVyaWMuVChkaXYodGhpcy54LGQpLGRpdihudW1lcmljLm5lZyh0aGlzLnkpLGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUKGRpdigxLHRoaXMueCkpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYoeSkge1xuICAgIGlmKCEoeSBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIHkgPSBuZXcgbnVtZXJpYy5UKHkpO1xuICAgIGlmKHkueSkgeyByZXR1cm4gdGhpcy5tdWwoeS5yZWNpcHJvY2FsKCkpOyB9XG4gICAgdmFyIGRpdiA9IG51bWVyaWMuZGl2O1xuICAgIGlmKHRoaXMueSkgeyByZXR1cm4gbmV3IG51bWVyaWMuVChkaXYodGhpcy54LHkueCksZGl2KHRoaXMueSx5LngpKTsgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpdih0aGlzLngseS54KSk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmRvdCA9IG51bWVyaWMuVGJpbm9wKFxuICAgICAgICAnZG90KHgueCx5LngpJyxcbiAgICAgICAgJ2RvdCh4LngseS54KSxkb3QoeC54LHkueSknLFxuICAgICAgICAnZG90KHgueCx5LngpLGRvdCh4LnkseS54KScsXG4gICAgICAgICdzdWIoZG90KHgueCx5LngpLGRvdCh4LnkseS55KSksYWRkKGRvdCh4LngseS55KSxkb3QoeC55LHkueCkpJ1xuICAgICAgICApO1xubnVtZXJpYy5ULnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoKSB7XG4gICAgdmFyIHQgPSBudW1lcmljLnRyYW5zcG9zZSwgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHQoeCksdCh5KSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUudHJhbnNqdWdhdGUgPSBmdW5jdGlvbiB0cmFuc2p1Z2F0ZSgpIHtcbiAgICB2YXIgdCA9IG51bWVyaWMudHJhbnNwb3NlLCB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQodCh4KSxudW1lcmljLm5lZ3RyYW5zcG9zZSh5KSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh0KHgpKTtcbn1cbm51bWVyaWMuVHVub3AgPSBmdW5jdGlvbiBUdW5vcChyLGMscykge1xuICAgIGlmKHR5cGVvZiBzICE9PSBcInN0cmluZ1wiKSB7IHMgPSAnJzsgfVxuICAgIHJldHVybiBGdW5jdGlvbihcbiAgICAgICAgICAgICd2YXIgeCA9IHRoaXM7XFxuJytcbiAgICAgICAgICAgIHMrJ1xcbicrXG4gICAgICAgICAgICAnaWYoeC55KSB7JytcbiAgICAgICAgICAgICcgICcrYysnO1xcbicrXG4gICAgICAgICAgICAnfVxcbicrXG4gICAgICAgICAgICByKyc7XFxuJ1xuICAgICk7XG59XG5cbm51bWVyaWMuVC5wcm90b3R5cGUuZXhwID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKGV4KScsXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChtdWwoY29zKHgueSksZXgpLG11bChzaW4oeC55KSxleCkpJyxcbiAgICAgICAgJ3ZhciBleCA9IG51bWVyaWMuZXhwKHgueCksIGNvcyA9IG51bWVyaWMuY29zLCBzaW4gPSBudW1lcmljLnNpbiwgbXVsID0gbnVtZXJpYy5tdWw7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmNvbmogPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoeC54KTsnLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQoeC54LG51bWVyaWMubmVnKHgueSkpOycpO1xubnVtZXJpYy5ULnByb3RvdHlwZS5uZWcgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobmVnKHgueCkpOycsXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChuZWcoeC54KSxuZWcoeC55KSk7JyxcbiAgICAgICAgJ3ZhciBuZWcgPSBudW1lcmljLm5lZzsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuc2luID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuc2luKHgueCkpJyxcbiAgICAgICAgJ3JldHVybiB4LmV4cCgpLnN1Yih4Lm5lZygpLmV4cCgpKS5kaXYobmV3IG51bWVyaWMuVCgwLDIpKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuY29zID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuY29zKHgueCkpJyxcbiAgICAgICAgJ3JldHVybiB4LmV4cCgpLmFkZCh4Lm5lZygpLmV4cCgpKS5kaXYoMik7Jyk7XG5udW1lcmljLlQucHJvdG90eXBlLmFicyA9IG51bWVyaWMuVHVub3AoXG4gICAgICAgICdyZXR1cm4gbmV3IG51bWVyaWMuVChudW1lcmljLmFicyh4LngpKTsnLFxuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5zcXJ0KG51bWVyaWMuYWRkKG11bCh4LngseC54KSxtdWwoeC55LHgueSkpKSk7JyxcbiAgICAgICAgJ3ZhciBtdWwgPSBudW1lcmljLm11bDsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubG9nID0gbnVtZXJpYy5UdW5vcChcbiAgICAgICAgJ3JldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMubG9nKHgueCkpOycsXG4gICAgICAgICd2YXIgdGhldGEgPSBuZXcgbnVtZXJpYy5UKG51bWVyaWMuYXRhbjIoeC55LHgueCkpLCByID0geC5hYnMoKTtcXG4nK1xuICAgICAgICAncmV0dXJuIG5ldyBudW1lcmljLlQobnVtZXJpYy5sb2coci54KSx0aGV0YS54KTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUubm9ybTIgPSBudW1lcmljLlR1bm9wKFxuICAgICAgICAncmV0dXJuIG51bWVyaWMubm9ybTIoeC54KTsnLFxuICAgICAgICAndmFyIGYgPSBudW1lcmljLm5vcm0yU3F1YXJlZDtcXG4nK1xuICAgICAgICAncmV0dXJuIE1hdGguc3FydChmKHgueCkrZih4LnkpKTsnKTtcbm51bWVyaWMuVC5wcm90b3R5cGUuaW52ID0gZnVuY3Rpb24gaW52KCkge1xuICAgIHZhciBBID0gdGhpcztcbiAgICBpZih0eXBlb2YgQS55ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuaW52KEEueCkpOyB9XG4gICAgdmFyIG4gPSBBLngubGVuZ3RoLCBpLCBqLCBrO1xuICAgIHZhciBSeCA9IG51bWVyaWMuaWRlbnRpdHkobiksUnkgPSBudW1lcmljLnJlcChbbixuXSwwKTtcbiAgICB2YXIgQXggPSBudW1lcmljLmNsb25lKEEueCksIEF5ID0gbnVtZXJpYy5jbG9uZShBLnkpO1xuICAgIHZhciBBaXgsIEFpeSwgQWp4LCBBanksIFJpeCwgUml5LCBSangsIFJqeTtcbiAgICB2YXIgaSxqLGssZCxkMSxheCxheSxieCxieSx0ZW1wO1xuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICBheCA9IEF4W2ldW2ldOyBheSA9IEF5W2ldW2ldO1xuICAgICAgICBkID0gYXgqYXgrYXkqYXk7XG4gICAgICAgIGsgPSBpO1xuICAgICAgICBmb3Ioaj1pKzE7ajxuO2orKykge1xuICAgICAgICAgICAgYXggPSBBeFtqXVtpXTsgYXkgPSBBeVtqXVtpXTtcbiAgICAgICAgICAgIGQxID0gYXgqYXgrYXkqYXk7XG4gICAgICAgICAgICBpZihkMSA+IGQpIHsgaz1qOyBkID0gZDE7IH1cbiAgICAgICAgfVxuICAgICAgICBpZihrIT09aSkge1xuICAgICAgICAgICAgdGVtcCA9IEF4W2ldOyBBeFtpXSA9IEF4W2tdOyBBeFtrXSA9IHRlbXA7XG4gICAgICAgICAgICB0ZW1wID0gQXlbaV07IEF5W2ldID0gQXlba107IEF5W2tdID0gdGVtcDtcbiAgICAgICAgICAgIHRlbXAgPSBSeFtpXTsgUnhbaV0gPSBSeFtrXTsgUnhba10gPSB0ZW1wO1xuICAgICAgICAgICAgdGVtcCA9IFJ5W2ldOyBSeVtpXSA9IFJ5W2tdOyBSeVtrXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgQWl4ID0gQXhbaV07IEFpeSA9IEF5W2ldO1xuICAgICAgICBSaXggPSBSeFtpXTsgUml5ID0gUnlbaV07XG4gICAgICAgIGF4ID0gQWl4W2ldOyBheSA9IEFpeVtpXTtcbiAgICAgICAgZm9yKGo9aSsxO2o8bjtqKyspIHtcbiAgICAgICAgICAgIGJ4ID0gQWl4W2pdOyBieSA9IEFpeVtqXTtcbiAgICAgICAgICAgIEFpeFtqXSA9IChieCpheCtieSpheSkvZDtcbiAgICAgICAgICAgIEFpeVtqXSA9IChieSpheC1ieCpheSkvZDtcbiAgICAgICAgfVxuICAgICAgICBmb3Ioaj0wO2o8bjtqKyspIHtcbiAgICAgICAgICAgIGJ4ID0gUml4W2pdOyBieSA9IFJpeVtqXTtcbiAgICAgICAgICAgIFJpeFtqXSA9IChieCpheCtieSpheSkvZDtcbiAgICAgICAgICAgIFJpeVtqXSA9IChieSpheC1ieCpheSkvZDtcbiAgICAgICAgfVxuICAgICAgICBmb3Ioaj1pKzE7ajxuO2orKykge1xuICAgICAgICAgICAgQWp4ID0gQXhbal07IEFqeSA9IEF5W2pdO1xuICAgICAgICAgICAgUmp4ID0gUnhbal07IFJqeSA9IFJ5W2pdO1xuICAgICAgICAgICAgYXggPSBBanhbaV07IGF5ID0gQWp5W2ldO1xuICAgICAgICAgICAgZm9yKGs9aSsxO2s8bjtrKyspIHtcbiAgICAgICAgICAgICAgICBieCA9IEFpeFtrXTsgYnkgPSBBaXlba107XG4gICAgICAgICAgICAgICAgQWp4W2tdIC09IGJ4KmF4LWJ5KmF5O1xuICAgICAgICAgICAgICAgIEFqeVtrXSAtPSBieSpheCtieCpheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihrPTA7azxuO2srKykge1xuICAgICAgICAgICAgICAgIGJ4ID0gUml4W2tdOyBieSA9IFJpeVtrXTtcbiAgICAgICAgICAgICAgICBSanhba10gLT0gYngqYXgtYnkqYXk7XG4gICAgICAgICAgICAgICAgUmp5W2tdIC09IGJ5KmF4K2J4KmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihpPW4tMTtpPjA7aS0tKSB7XG4gICAgICAgIFJpeCA9IFJ4W2ldOyBSaXkgPSBSeVtpXTtcbiAgICAgICAgZm9yKGo9aS0xO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBSanggPSBSeFtqXTsgUmp5ID0gUnlbal07XG4gICAgICAgICAgICBheCA9IEF4W2pdW2ldOyBheSA9IEF5W2pdW2ldO1xuICAgICAgICAgICAgZm9yKGs9bi0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICAgICAgYnggPSBSaXhba107IGJ5ID0gUml5W2tdO1xuICAgICAgICAgICAgICAgIFJqeFtrXSAtPSBheCpieCAtIGF5KmJ5O1xuICAgICAgICAgICAgICAgIFJqeVtrXSAtPSBheCpieSArIGF5KmJ4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKFJ4LFJ5KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGkpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgayA9IDAsIGlrLCBuID0gaS5sZW5ndGg7XG4gICAgaWYoeSkge1xuICAgICAgICB3aGlsZShrPG4pIHtcbiAgICAgICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgICAgIHggPSB4W2lrXTtcbiAgICAgICAgICAgIHkgPSB5W2lrXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh4LHkpO1xuICAgIH1cbiAgICB3aGlsZShrPG4pIHtcbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4ID0geFtpa107XG4gICAgICAgIGsrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoeCk7XG59XG5udW1lcmljLlQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChpLHYpIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgayA9IDAsIGlrLCBuID0gaS5sZW5ndGgsIHZ4ID0gdi54LCB2eSA9IHYueTtcbiAgICBpZihuPT09MCkge1xuICAgICAgICBpZih2eSkgeyB0aGlzLnkgPSB2eTsgfVxuICAgICAgICBlbHNlIGlmKHkpIHsgdGhpcy55ID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZih2eSkge1xuICAgICAgICBpZih5KSB7IC8qIG9rICovIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0oeCksMCk7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlKGs8bi0xKSB7XG4gICAgICAgICAgICBpayA9IGlba107XG4gICAgICAgICAgICB4ID0geFtpa107XG4gICAgICAgICAgICB5ID0geVtpa107XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4W2lrXSA9IHZ4O1xuICAgICAgICB5W2lrXSA9IHZ5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYoeSkge1xuICAgICAgICB3aGlsZShrPG4tMSkge1xuICAgICAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICAgICAgeCA9IHhbaWtdO1xuICAgICAgICAgICAgeSA9IHlbaWtdO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICAgIGlrID0gaVtrXTtcbiAgICAgICAgeFtpa10gPSB2eDtcbiAgICAgICAgaWYodnggaW5zdGFuY2VvZiBBcnJheSkgeVtpa10gPSBudW1lcmljLnJlcChudW1lcmljLmRpbSh2eCksMCk7XG4gICAgICAgIGVsc2UgeVtpa10gPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2hpbGUoazxuLTEpIHtcbiAgICAgICAgaWsgPSBpW2tdO1xuICAgICAgICB4ID0geFtpa107XG4gICAgICAgIGsrKztcbiAgICB9XG4gICAgaWsgPSBpW2tdO1xuICAgIHhbaWtdID0gdng7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbiBnZXRSb3dzKGkwLGkxKSB7XG4gICAgdmFyIG4gPSBpMS1pMCsxLCBqO1xuICAgIHZhciByeCA9IEFycmF5KG4pLCByeSwgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnhbai1pMF0gPSB4W2pdOyB9XG4gICAgaWYoeSkge1xuICAgICAgICByeSA9IEFycmF5KG4pO1xuICAgICAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnlbai1pMF0gPSB5W2pdOyB9XG4gICAgICAgIHJldHVybiBuZXcgbnVtZXJpYy5UKHJ4LHJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQocngpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXRSb3dzID0gZnVuY3Rpb24gc2V0Um93cyhpMCxpMSxBKSB7XG4gICAgdmFyIGo7XG4gICAgdmFyIHJ4ID0gdGhpcy54LCByeSA9IHRoaXMueSwgeCA9IEEueCwgeSA9IEEueTtcbiAgICBmb3Ioaj1pMDtqPD1pMTtqKyspIHsgcnhbal0gPSB4W2otaTBdOyB9XG4gICAgaWYoeSkge1xuICAgICAgICBpZighcnkpIHsgcnkgPSBudW1lcmljLnJlcChudW1lcmljLmRpbShyeCksMCk7IHRoaXMueSA9IHJ5OyB9XG4gICAgICAgIGZvcihqPWkwO2o8PWkxO2orKykgeyByeVtqXSA9IHlbai1pMF07IH1cbiAgICB9IGVsc2UgaWYocnkpIHtcbiAgICAgICAgZm9yKGo9aTA7ajw9aTE7aisrKSB7IHJ5W2pdID0gbnVtZXJpYy5yZXAoW3hbai1pMF0ubGVuZ3RoXSwwKTsgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gZ2V0Um93KGspIHtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKHhba10seVtrXSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVCh4W2tdKTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuc2V0Um93ID0gZnVuY3Rpb24gc2V0Um93KGksdikge1xuICAgIHZhciByeCA9IHRoaXMueCwgcnkgPSB0aGlzLnksIHggPSB2LngsIHkgPSB2Lnk7XG4gICAgcnhbaV0gPSB4O1xuICAgIGlmKHkpIHtcbiAgICAgICAgaWYoIXJ5KSB7IHJ5ID0gbnVtZXJpYy5yZXAobnVtZXJpYy5kaW0ocngpLDApOyB0aGlzLnkgPSByeTsgfVxuICAgICAgICByeVtpXSA9IHk7XG4gICAgfSBlbHNlIGlmKHJ5KSB7XG4gICAgICAgIHJ5ID0gbnVtZXJpYy5yZXAoW3gubGVuZ3RoXSwwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbm51bWVyaWMuVC5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbiBnZXRCbG9jayhmcm9tLHRvKSB7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIGIgPSBudW1lcmljLmdldEJsb2NrO1xuICAgIGlmKHkpIHsgcmV0dXJuIG5ldyBudW1lcmljLlQoYih4LGZyb20sdG8pLGIoeSxmcm9tLHRvKSk7IH1cbiAgICByZXR1cm4gbmV3IG51bWVyaWMuVChiKHgsZnJvbSx0bykpO1xufVxubnVtZXJpYy5ULnByb3RvdHlwZS5zZXRCbG9jayA9IGZ1bmN0aW9uIHNldEJsb2NrKGZyb20sdG8sQSkge1xuICAgIGlmKCEoQSBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIEEgPSBuZXcgbnVtZXJpYy5UKEEpO1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCBiID0gbnVtZXJpYy5zZXRCbG9jaywgQXggPSBBLngsIEF5ID0gQS55O1xuICAgIGlmKEF5KSB7XG4gICAgICAgIGlmKCF5KSB7IHRoaXMueSA9IG51bWVyaWMucmVwKG51bWVyaWMuZGltKHRoaXMpLDApOyB5ID0gdGhpcy55OyB9XG4gICAgICAgIGIoeCxmcm9tLHRvLEF4KTtcbiAgICAgICAgYih5LGZyb20sdG8sQXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYih4LGZyb20sdG8sQXgpO1xuICAgIGlmKHkpIGIoeSxmcm9tLHRvLG51bWVyaWMucmVwKG51bWVyaWMuZGltKEF4KSwwKSk7XG59XG5udW1lcmljLlQucmVwID0gZnVuY3Rpb24gcmVwKHMsdikge1xuICAgIHZhciBUID0gbnVtZXJpYy5UO1xuICAgIGlmKCEodiBpbnN0YW5jZW9mIFQpKSB2ID0gbmV3IFQodik7XG4gICAgdmFyIHggPSB2LngsIHkgPSB2LnksIHIgPSBudW1lcmljLnJlcDtcbiAgICBpZih5KSByZXR1cm4gbmV3IFQocihzLHgpLHIocyx5KSk7XG4gICAgcmV0dXJuIG5ldyBUKHIocyx4KSk7XG59XG5udW1lcmljLlQuZGlhZyA9IGZ1bmN0aW9uIGRpYWcoZCkge1xuICAgIGlmKCEoZCBpbnN0YW5jZW9mIG51bWVyaWMuVCkpIGQgPSBuZXcgbnVtZXJpYy5UKGQpO1xuICAgIHZhciB4ID0gZC54LCB5ID0gZC55LCBkaWFnID0gbnVtZXJpYy5kaWFnO1xuICAgIGlmKHkpIHJldHVybiBuZXcgbnVtZXJpYy5UKGRpYWcoeCksZGlhZyh5KSk7XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlQoZGlhZyh4KSk7XG59XG5udW1lcmljLlQuZWlnID0gZnVuY3Rpb24gZWlnKCkge1xuICAgIGlmKHRoaXMueSkgeyB0aHJvdyBuZXcgRXJyb3IoJ2VpZzogbm90IGltcGxlbWVudGVkIGZvciBjb21wbGV4IG1hdHJpY2VzLicpOyB9XG4gICAgcmV0dXJuIG51bWVyaWMuZWlnKHRoaXMueCk7XG59XG5udW1lcmljLlQuaWRlbnRpdHkgPSBmdW5jdGlvbiBpZGVudGl0eShuKSB7IHJldHVybiBuZXcgbnVtZXJpYy5UKG51bWVyaWMuaWRlbnRpdHkobikpOyB9XG5udW1lcmljLlQucHJvdG90eXBlLmdldERpYWcgPSBmdW5jdGlvbiBnZXREaWFnKCkge1xuICAgIHZhciBuID0gbnVtZXJpYztcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcbiAgICBpZih5KSB7IHJldHVybiBuZXcgbi5UKG4uZ2V0RGlhZyh4KSxuLmdldERpYWcoeSkpOyB9XG4gICAgcmV0dXJuIG5ldyBuLlQobi5nZXREaWFnKHgpKTtcbn1cblxuLy8gNC4gRWlnZW52YWx1ZXMgb2YgcmVhbCBtYXRyaWNlc1xuXG5udW1lcmljLmhvdXNlID0gZnVuY3Rpb24gaG91c2UoeCkge1xuICAgIHZhciB2ID0gbnVtZXJpYy5jbG9uZSh4KTtcbiAgICB2YXIgcyA9IHhbMF0gPj0gMCA/IDEgOiAtMTtcbiAgICB2YXIgYWxwaGEgPSBzKm51bWVyaWMubm9ybTIoeCk7XG4gICAgdlswXSArPSBhbHBoYTtcbiAgICB2YXIgZm9vID0gbnVtZXJpYy5ub3JtMih2KTtcbiAgICBpZihmb28gPT09IDApIHsgLyogdGhpcyBzaG91bGQgbm90IGhhcHBlbiAqLyB0aHJvdyBuZXcgRXJyb3IoJ2VpZzogaW50ZXJuYWwgZXJyb3InKTsgfVxuICAgIHJldHVybiBudW1lcmljLmRpdih2LGZvbyk7XG59XG5cbm51bWVyaWMudG9VcHBlckhlc3NlbmJlcmcgPSBmdW5jdGlvbiB0b1VwcGVySGVzc2VuYmVyZyhtZSkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0obWUpO1xuICAgIGlmKHMubGVuZ3RoICE9PSAyIHx8IHNbMF0gIT09IHNbMV0pIHsgdGhyb3cgbmV3IEVycm9yKCdudW1lcmljOiB0b1VwcGVySGVzc2VuYmVyZygpIG9ubHkgd29ya3Mgb24gc3F1YXJlIG1hdHJpY2VzJyk7IH1cbiAgICB2YXIgbSA9IHNbMF0sIGksaixrLHgsdixBID0gbnVtZXJpYy5jbG9uZShtZSksQixDLEFpLENpLFEgPSBudW1lcmljLmlkZW50aXR5KG0pLFFpO1xuICAgIGZvcihqPTA7ajxtLTI7aisrKSB7XG4gICAgICAgIHggPSBBcnJheShtLWotMSk7XG4gICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IHhbaS1qLTFdID0gQVtpXVtqXTsgfVxuICAgICAgICBpZihudW1lcmljLm5vcm0yKHgpPjApIHtcbiAgICAgICAgICAgIHYgPSBudW1lcmljLmhvdXNlKHgpO1xuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soQSxbaisxLGpdLFttLTEsbS0xXSk7XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IEFpID0gQVtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9ajtrPG07aysrKSBBaVtrXSAtPSAyKkNpW2stal07IH1cbiAgICAgICAgICAgIEIgPSBudW1lcmljLmdldEJsb2NrKEEsWzAsaisxXSxbbS0xLG0tMV0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKG51bWVyaWMuZG90KEIsdiksdik7XG4gICAgICAgICAgICBmb3IoaT0wO2k8bTtpKyspIHsgQWkgPSBBW2ldOyBDaSA9IENbaV07IGZvcihrPWorMTtrPG07aysrKSBBaVtrXSAtPSAyKkNpW2stai0xXTsgfVxuICAgICAgICAgICAgQiA9IEFycmF5KG0tai0xKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSBCW2ktai0xXSA9IFFbaV07XG4gICAgICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPG07aSsrKSB7IFFpID0gUVtpXTsgQ2kgPSBDW2ktai0xXTsgZm9yKGs9MDtrPG07aysrKSBRaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtIOkEsIFE6UX07XG59XG5cbm51bWVyaWMuZXBzaWxvbiA9IDIuMjIwNDQ2MDQ5MjUwMzEzZS0xNjtcblxubnVtZXJpYy5RUkZyYW5jaXMgPSBmdW5jdGlvbihILG1heGl0ZXIpIHtcbiAgICBpZih0eXBlb2YgbWF4aXRlciA9PT0gXCJ1bmRlZmluZWRcIikgeyBtYXhpdGVyID0gMTAwMDA7IH1cbiAgICBIID0gbnVtZXJpYy5jbG9uZShIKTtcbiAgICB2YXIgSDAgPSBudW1lcmljLmNsb25lKEgpO1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oSCksbT1zWzBdLHgsdixhLGIsYyxkLGRldCx0ciwgSGxvYywgUSA9IG51bWVyaWMuaWRlbnRpdHkobSksIFFpLCBIaSwgQiwgQywgQ2ksaSxqLGssaXRlcjtcbiAgICBpZihtPDMpIHsgcmV0dXJuIHtROlEsIEI6WyBbMCxtLTFdIF19OyB9XG4gICAgdmFyIGVwc2lsb24gPSBudW1lcmljLmVwc2lsb247XG4gICAgZm9yKGl0ZXI9MDtpdGVyPG1heGl0ZXI7aXRlcisrKSB7XG4gICAgICAgIGZvcihqPTA7ajxtLTE7aisrKSB7XG4gICAgICAgICAgICBpZihNYXRoLmFicyhIW2orMV1bal0pIDwgZXBzaWxvbiooTWF0aC5hYnMoSFtqXVtqXSkrTWF0aC5hYnMoSFtqKzFdW2orMV0pKSkge1xuICAgICAgICAgICAgICAgIHZhciBRSDEgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsWzAsMF0sW2osal0pLG1heGl0ZXIpO1xuICAgICAgICAgICAgICAgIHZhciBRSDIgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsW2orMSxqKzFdLFttLTEsbS0xXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgQiA9IEFycmF5KGorMSk7XG4gICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1qO2krKykgeyBCW2ldID0gUVtpXTsgfVxuICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDEuUSxCKTtcbiAgICAgICAgICAgICAgICBmb3IoaT0wO2k8PWo7aSsrKSB7IFFbaV0gPSBDW2ldOyB9XG4gICAgICAgICAgICAgICAgQiA9IEFycmF5KG0tai0xKTtcbiAgICAgICAgICAgICAgICBmb3IoaT1qKzE7aTxtO2krKykgeyBCW2ktai0xXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICBDID0gbnVtZXJpYy5kb3QoUUgyLlEsQik7XG4gICAgICAgICAgICAgICAgZm9yKGk9aisxO2k8bTtpKyspIHsgUVtpXSA9IENbaS1qLTFdOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtROlEsQjpRSDEuQi5jb25jYXQobnVtZXJpYy5hZGQoUUgyLkIsaisxKSl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGEgPSBIW20tMl1bbS0yXTsgYiA9IEhbbS0yXVttLTFdO1xuICAgICAgICBjID0gSFttLTFdW20tMl07IGQgPSBIW20tMV1bbS0xXTtcbiAgICAgICAgdHIgPSBhK2Q7XG4gICAgICAgIGRldCA9IChhKmQtYipjKTtcbiAgICAgICAgSGxvYyA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsMF0sIFsyLDJdKTtcbiAgICAgICAgaWYodHIqdHI+PTQqZGV0KSB7XG4gICAgICAgICAgICB2YXIgczEsczI7XG4gICAgICAgICAgICBzMSA9IDAuNSoodHIrTWF0aC5zcXJ0KHRyKnRyLTQqZGV0KSk7XG4gICAgICAgICAgICBzMiA9IDAuNSoodHItTWF0aC5zcXJ0KHRyKnRyLTQqZGV0KSk7XG4gICAgICAgICAgICBIbG9jID0gbnVtZXJpYy5hZGQobnVtZXJpYy5zdWIobnVtZXJpYy5kb3QoSGxvYyxIbG9jKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLm11bChIbG9jLHMxK3MyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYy5kaWFnKG51bWVyaWMucmVwKFszXSxzMSpzMikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEhsb2MgPSBudW1lcmljLmFkZChudW1lcmljLnN1YihudW1lcmljLmRvdChIbG9jLEhsb2MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMubXVsKEhsb2MsdHIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljLmRpYWcobnVtZXJpYy5yZXAoWzNdLGRldCkpKTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gW0hsb2NbMF1bMF0sSGxvY1sxXVswXSxIbG9jWzJdWzBdXTtcbiAgICAgICAgdiA9IG51bWVyaWMuaG91c2UoeCk7XG4gICAgICAgIEIgPSBbSFswXSxIWzFdLEhbMl1dO1xuICAgICAgICBDID0gbnVtZXJpYy50ZW5zb3IodixudW1lcmljLmRvdCh2LEIpKTtcbiAgICAgICAgZm9yKGk9MDtpPDM7aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz0wO2s8bTtrKyspIEhpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsMF0sW20tMSwyXSk7XG4gICAgICAgIEMgPSBudW1lcmljLnRlbnNvcihudW1lcmljLmRvdChCLHYpLHYpO1xuICAgICAgICBmb3IoaT0wO2k8bTtpKyspIHsgSGkgPSBIW2ldOyBDaSA9IENbaV07IGZvcihrPTA7azwzO2srKykgSGlba10gLT0gMipDaVtrXTsgfVxuICAgICAgICBCID0gW1FbMF0sUVsxXSxRWzJdXTtcbiAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgIGZvcihpPTA7aTwzO2krKykgeyBRaSA9IFFbaV07IENpID0gQ1tpXTsgZm9yKGs9MDtrPG07aysrKSBRaVtrXSAtPSAyKkNpW2tdOyB9XG4gICAgICAgIHZhciBKO1xuICAgICAgICBmb3Ioaj0wO2o8bS0yO2orKykge1xuICAgICAgICAgICAgZm9yKGs9ajtrPD1qKzE7aysrKSB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoSFtrKzFdW2tdKSA8IGVwc2lsb24qKE1hdGguYWJzKEhba11ba10pK01hdGguYWJzKEhbaysxXVtrKzFdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFFIMSA9IG51bWVyaWMuUVJGcmFuY2lzKG51bWVyaWMuZ2V0QmxvY2soSCxbMCwwXSxbayxrXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBRSDIgPSBudW1lcmljLlFSRnJhbmNpcyhudW1lcmljLmdldEJsb2NrKEgsW2srMSxrKzFdLFttLTEsbS0xXSksbWF4aXRlcik7XG4gICAgICAgICAgICAgICAgICAgIEIgPSBBcnJheShrKzEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wO2k8PWs7aSsrKSB7IEJbaV0gPSBRW2ldOyB9XG4gICAgICAgICAgICAgICAgICAgIEMgPSBudW1lcmljLmRvdChRSDEuUSxCKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9MDtpPD1rO2krKykgeyBRW2ldID0gQ1tpXTsgfVxuICAgICAgICAgICAgICAgICAgICBCID0gQXJyYXkobS1rLTEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT1rKzE7aTxtO2krKykgeyBCW2ktay0xXSA9IFFbaV07IH1cbiAgICAgICAgICAgICAgICAgICAgQyA9IG51bWVyaWMuZG90KFFIMi5RLEIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT1rKzE7aTxtO2krKykgeyBRW2ldID0gQ1tpLWstMV07IH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtROlEsQjpRSDEuQi5jb25jYXQobnVtZXJpYy5hZGQoUUgyLkIsaysxKSl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEogPSBNYXRoLm1pbihtLTEsaiszKTtcbiAgICAgICAgICAgIHggPSBBcnJheShKLWopO1xuICAgICAgICAgICAgZm9yKGk9aisxO2k8PUo7aSsrKSB7IHhbaS1qLTFdID0gSFtpXVtqXTsgfVxuICAgICAgICAgICAgdiA9IG51bWVyaWMuaG91c2UoeCk7XG4gICAgICAgICAgICBCID0gbnVtZXJpYy5nZXRCbG9jayhILCBbaisxLGpdLFtKLG0tMV0pO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIHsgSGkgPSBIW2ldOyBDaSA9IENbaS1qLTFdOyBmb3Ioaz1qO2s8bTtrKyspIEhpW2tdIC09IDIqQ2lbay1qXTsgfVxuICAgICAgICAgICAgQiA9IG51bWVyaWMuZ2V0QmxvY2soSCwgWzAsaisxXSxbbS0xLEpdKTtcbiAgICAgICAgICAgIEMgPSBudW1lcmljLnRlbnNvcihudW1lcmljLmRvdChCLHYpLHYpO1xuICAgICAgICAgICAgZm9yKGk9MDtpPG07aSsrKSB7IEhpID0gSFtpXTsgQ2kgPSBDW2ldOyBmb3Ioaz1qKzE7azw9SjtrKyspIEhpW2tdIC09IDIqQ2lbay1qLTFdOyB9XG4gICAgICAgICAgICBCID0gQXJyYXkoSi1qKTtcbiAgICAgICAgICAgIGZvcihpPWorMTtpPD1KO2krKykgQltpLWotMV0gPSBRW2ldO1xuICAgICAgICAgICAgQyA9IG51bWVyaWMudGVuc29yKHYsbnVtZXJpYy5kb3QodixCKSk7XG4gICAgICAgICAgICBmb3IoaT1qKzE7aTw9SjtpKyspIHsgUWkgPSBRW2ldOyBDaSA9IENbaS1qLTFdOyBmb3Ioaz0wO2s8bTtrKyspIFFpW2tdIC09IDIqQ2lba107IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWVyaWM6IGVpZ2VudmFsdWUgaXRlcmF0aW9uIGRvZXMgbm90IGNvbnZlcmdlIC0tIGluY3JlYXNlIG1heGl0ZXI/Jyk7XG59XG5cbm51bWVyaWMuZWlnID0gZnVuY3Rpb24gZWlnKEEsbWF4aXRlcikge1xuICAgIHZhciBRSCA9IG51bWVyaWMudG9VcHBlckhlc3NlbmJlcmcoQSk7XG4gICAgdmFyIFFCID0gbnVtZXJpYy5RUkZyYW5jaXMoUUguSCxtYXhpdGVyKTtcbiAgICB2YXIgVCA9IG51bWVyaWMuVDtcbiAgICB2YXIgbiA9IEEubGVuZ3RoLGksayxmbGFnID0gZmFsc2UsQiA9IFFCLkIsSCA9IG51bWVyaWMuZG90KFFCLlEsbnVtZXJpYy5kb3QoUUguSCxudW1lcmljLnRyYW5zcG9zZShRQi5RKSkpO1xuICAgIHZhciBRID0gbmV3IFQobnVtZXJpYy5kb3QoUUIuUSxRSC5RKSksUTA7XG4gICAgdmFyIG0gPSBCLmxlbmd0aCxqO1xuICAgIHZhciBhLGIsYyxkLHAxLHAyLGRpc2MseCx5LHAscSxuMSxuMjtcbiAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgICBmb3Ioaz0wO2s8bTtrKyspIHtcbiAgICAgICAgaSA9IEJba11bMF07XG4gICAgICAgIGlmKGkgPT09IEJba11bMV0pIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGogPSBpKzE7XG4gICAgICAgICAgICBhID0gSFtpXVtpXTtcbiAgICAgICAgICAgIGIgPSBIW2ldW2pdO1xuICAgICAgICAgICAgYyA9IEhbal1baV07XG4gICAgICAgICAgICBkID0gSFtqXVtqXTtcbiAgICAgICAgICAgIGlmKGIgPT09IDAgJiYgYyA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgICBwMSA9IC1hLWQ7XG4gICAgICAgICAgICBwMiA9IGEqZC1iKmM7XG4gICAgICAgICAgICBkaXNjID0gcDEqcDEtNCpwMjtcbiAgICAgICAgICAgIGlmKGRpc2M+PTApIHtcbiAgICAgICAgICAgICAgICBpZihwMTwwKSB4ID0gLTAuNSoocDEtc3FydChkaXNjKSk7XG4gICAgICAgICAgICAgICAgZWxzZSAgICAgeCA9IC0wLjUqKHAxK3NxcnQoZGlzYykpO1xuICAgICAgICAgICAgICAgIG4xID0gKGEteCkqKGEteCkrYipiO1xuICAgICAgICAgICAgICAgIG4yID0gYypjKyhkLXgpKihkLXgpO1xuICAgICAgICAgICAgICAgIGlmKG4xPm4yKSB7XG4gICAgICAgICAgICAgICAgICAgIG4xID0gc3FydChuMSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYS14KS9uMTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IGIvbjE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBzcXJ0KG4yKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGMvbjI7XG4gICAgICAgICAgICAgICAgICAgIHEgPSAoZC14KS9uMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUTAgPSBuZXcgVChbW3EsLXBdLFtwLHFdXSk7XG4gICAgICAgICAgICAgICAgUS5zZXRSb3dzKGksaixRMC5kb3QoUS5nZXRSb3dzKGksaikpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IC0wLjUqcDE7XG4gICAgICAgICAgICAgICAgeSA9IDAuNSpzcXJ0KC1kaXNjKTtcbiAgICAgICAgICAgICAgICBuMSA9IChhLXgpKihhLXgpK2IqYjtcbiAgICAgICAgICAgICAgICBuMiA9IGMqYysoZC14KSooZC14KTtcbiAgICAgICAgICAgICAgICBpZihuMT5uMikge1xuICAgICAgICAgICAgICAgICAgICBuMSA9IHNxcnQobjEreSp5KTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChhLXgpL24xO1xuICAgICAgICAgICAgICAgICAgICBxID0gYi9uMTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHkgLz0gbjE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbjIgPSBzcXJ0KG4yK3kqeSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBjL24yO1xuICAgICAgICAgICAgICAgICAgICBxID0gKGQteCkvbjI7XG4gICAgICAgICAgICAgICAgICAgIHggPSB5L24yO1xuICAgICAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUTAgPSBuZXcgVChbW3EsLXBdLFtwLHFdXSxbW3gseV0sW3ksLXhdXSk7XG4gICAgICAgICAgICAgICAgUS5zZXRSb3dzKGksaixRMC5kb3QoUS5nZXRSb3dzKGksaikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgUiA9IFEuZG90KEEpLmRvdChRLnRyYW5zanVnYXRlKCkpLCBuID0gQS5sZW5ndGgsIEUgPSBudW1lcmljLlQuaWRlbnRpdHkobik7XG4gICAgZm9yKGo9MDtqPG47aisrKSB7XG4gICAgICAgIGlmKGo+MCkge1xuICAgICAgICAgICAgZm9yKGs9ai0xO2s+PTA7ay0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIFJrID0gUi5nZXQoW2ssa10pLCBSaiA9IFIuZ2V0KFtqLGpdKTtcbiAgICAgICAgICAgICAgICBpZihudW1lcmljLm5lcShSay54LFJqLngpIHx8IG51bWVyaWMubmVxKFJrLnksUmoueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IFIuZ2V0Um93KGspLmdldEJsb2NrKFtrXSxbai0xXSk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBFLmdldFJvdyhqKS5nZXRCbG9jayhba10sW2otMV0pO1xuICAgICAgICAgICAgICAgICAgICBFLnNldChbaixrXSwoUi5nZXQoW2ssal0pLm5lZygpLnN1Yih4LmRvdCh5KSkpLmRpdihSay5zdWIoUmopKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgRS5zZXRSb3coaixFLmdldFJvdyhrKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3Ioaj0wO2o8bjtqKyspIHtcbiAgICAgICAgeCA9IEUuZ2V0Um93KGopO1xuICAgICAgICBFLnNldFJvdyhqLHguZGl2KHgubm9ybTIoKSkpO1xuICAgIH1cbiAgICBFID0gRS50cmFuc3Bvc2UoKTtcbiAgICBFID0gUS50cmFuc2p1Z2F0ZSgpLmRvdChFKTtcbiAgICByZXR1cm4geyBsYW1iZGE6Ui5nZXREaWFnKCksIEU6RSB9O1xufTtcblxuLy8gNS4gQ29tcHJlc3NlZCBDb2x1bW4gU3RvcmFnZSBtYXRyaWNlc1xubnVtZXJpYy5jY3NTcGFyc2UgPSBmdW5jdGlvbiBjY3NTcGFyc2UoQSkge1xuICAgIHZhciBtID0gQS5sZW5ndGgsbixmb28sIGksaiwgY291bnRzID0gW107XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZm9vID0gQVtpXTtcbiAgICAgICAgZm9yKGogaW4gZm9vKSB7XG4gICAgICAgICAgICBqID0gcGFyc2VJbnQoaik7XG4gICAgICAgICAgICB3aGlsZShqPj1jb3VudHMubGVuZ3RoKSBjb3VudHNbY291bnRzLmxlbmd0aF0gPSAwO1xuICAgICAgICAgICAgaWYoZm9vW2pdIT09MCkgY291bnRzW2pdKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG4gPSBjb3VudHMubGVuZ3RoO1xuICAgIHZhciBBaSA9IEFycmF5KG4rMSk7XG4gICAgQWlbMF0gPSAwO1xuICAgIGZvcihpPTA7aTxuOysraSkgQWlbaSsxXSA9IEFpW2ldICsgY291bnRzW2ldO1xuICAgIHZhciBBaiA9IEFycmF5KEFpW25dKSwgQXYgPSBBcnJheShBaVtuXSk7XG4gICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZm9vID0gQVtpXTtcbiAgICAgICAgZm9yKGogaW4gZm9vKSB7XG4gICAgICAgICAgICBpZihmb29bal0hPT0wKSB7XG4gICAgICAgICAgICAgICAgY291bnRzW2pdLS07XG4gICAgICAgICAgICAgICAgQWpbQWlbal0rY291bnRzW2pdXSA9IGk7XG4gICAgICAgICAgICAgICAgQXZbQWlbal0rY291bnRzW2pdXSA9IGZvb1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW0FpLEFqLEF2XTtcbn1cbm51bWVyaWMuY2NzRnVsbCA9IGZ1bmN0aW9uIGNjc0Z1bGwoQSkge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLCBzID0gbnVtZXJpYy5jY3NEaW0oQSksIG0gPSBzWzBdLCBuID0gc1sxXSwgaSxqLGowLGoxLGs7XG4gICAgdmFyIEIgPSBudW1lcmljLnJlcChbbSxuXSwwKTtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHtcbiAgICAgICAgajAgPSBBaVtpXTtcbiAgICAgICAgajEgPSBBaVtpKzFdO1xuICAgICAgICBmb3Ioaj1qMDtqPGoxOysraikgeyBCW0FqW2pdXVtpXSA9IEF2W2pdOyB9XG4gICAgfVxuICAgIHJldHVybiBCO1xufVxubnVtZXJpYy5jY3NUU29sdmUgPSBmdW5jdGlvbiBjY3NUU29sdmUoQSxiLHgsYmoseGopIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxtID0gQWkubGVuZ3RoLTEsIG1heCA9IE1hdGgubWF4LG49MDtcbiAgICBpZih0eXBlb2YgYmogPT09IFwidW5kZWZpbmVkXCIpIHggPSBudW1lcmljLnJlcChbbV0sMCk7XG4gICAgaWYodHlwZW9mIGJqID09PSBcInVuZGVmaW5lZFwiKSBiaiA9IG51bWVyaWMubGluc3BhY2UoMCx4Lmxlbmd0aC0xKTtcbiAgICBpZih0eXBlb2YgeGogPT09IFwidW5kZWZpbmVkXCIpIHhqID0gW107XG4gICAgZnVuY3Rpb24gZGZzKGopIHtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIGlmKHhbal0gIT09IDApIHJldHVybjtcbiAgICAgICAgeFtqXSA9IDE7XG4gICAgICAgIGZvcihrPUFpW2pdO2s8QWlbaisxXTsrK2spIGRmcyhBaltrXSk7XG4gICAgICAgIHhqW25dID0gajtcbiAgICAgICAgKytuO1xuICAgIH1cbiAgICB2YXIgaSxqLGowLGoxLGssbCxsMCxsMSxhO1xuICAgIGZvcihpPWJqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgZGZzKGJqW2ldKTsgfVxuICAgIHhqLmxlbmd0aCA9IG47XG4gICAgZm9yKGk9eGoubGVuZ3RoLTE7aSE9PS0xOy0taSkgeyB4W3hqW2ldXSA9IDA7IH1cbiAgICBmb3IoaT1iai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7IGogPSBialtpXTsgeFtqXSA9IGJbal07IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGogPSB4altpXTtcbiAgICAgICAgajAgPSBBaVtqXTtcbiAgICAgICAgajEgPSBtYXgoQWlbaisxXSxqMCk7XG4gICAgICAgIGZvcihrPWowO2shPT1qMTsrK2spIHsgaWYoQWpba10gPT09IGopIHsgeFtqXSAvPSBBdltrXTsgYnJlYWs7IH0gfVxuICAgICAgICBhID0geFtqXTtcbiAgICAgICAgZm9yKGs9ajA7ayE9PWoxOysraykge1xuICAgICAgICAgICAgbCA9IEFqW2tdO1xuICAgICAgICAgICAgaWYobCAhPT0gaikgeFtsXSAtPSBhKkF2W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xufVxubnVtZXJpYy5jY3NERlMgPSBmdW5jdGlvbiBjY3NERlMobikge1xuICAgIHRoaXMuayA9IEFycmF5KG4pO1xuICAgIHRoaXMuazEgPSBBcnJheShuKTtcbiAgICB0aGlzLmogPSBBcnJheShuKTtcbn1cbm51bWVyaWMuY2NzREZTLnByb3RvdHlwZS5kZnMgPSBmdW5jdGlvbiBkZnMoSixBaSxBaix4LHhqLFBpbnYpIHtcbiAgICB2YXIgbSA9IDAsZm9vLG49eGoubGVuZ3RoO1xuICAgIHZhciBrID0gdGhpcy5rLCBrMSA9IHRoaXMuazEsIGogPSB0aGlzLmosa20sazExO1xuICAgIGlmKHhbSl0hPT0wKSByZXR1cm47XG4gICAgeFtKXSA9IDE7XG4gICAgalswXSA9IEo7XG4gICAga1swXSA9IGttID0gQWlbSl07XG4gICAgazFbMF0gPSBrMTEgPSBBaVtKKzFdO1xuICAgIHdoaWxlKDEpIHtcbiAgICAgICAgaWYoa20gPj0gazExKSB7XG4gICAgICAgICAgICB4altuXSA9IGpbbV07XG4gICAgICAgICAgICBpZihtPT09MCkgcmV0dXJuO1xuICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgLS1tO1xuICAgICAgICAgICAga20gPSBrW21dO1xuICAgICAgICAgICAgazExID0gazFbbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb28gPSBQaW52W0FqW2ttXV07XG4gICAgICAgICAgICBpZih4W2Zvb10gPT09IDApIHtcbiAgICAgICAgICAgICAgICB4W2Zvb10gPSAxO1xuICAgICAgICAgICAgICAgIGtbbV0gPSBrbTtcbiAgICAgICAgICAgICAgICArK207XG4gICAgICAgICAgICAgICAgalttXSA9IGZvbztcbiAgICAgICAgICAgICAgICBrbSA9IEFpW2Zvb107XG4gICAgICAgICAgICAgICAgazFbbV0gPSBrMTEgPSBBaVtmb28rMV07XG4gICAgICAgICAgICB9IGVsc2UgKytrbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm51bWVyaWMuY2NzTFBTb2x2ZSA9IGZ1bmN0aW9uIGNjc0xQU29sdmUoQSxCLHgseGosSSxQaW52LGRmcykge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdLG0gPSBBaS5sZW5ndGgtMSwgbj0wO1xuICAgIHZhciBCaSA9IEJbMF0sIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIFxuICAgIHZhciBpLGkwLGkxLGosSixqMCxqMSxrLGwsbDAsbDEsYTtcbiAgICBpMCA9IEJpW0ldO1xuICAgIGkxID0gQmlbSSsxXTtcbiAgICB4ai5sZW5ndGggPSAwO1xuICAgIGZvcihpPWkwO2k8aTE7KytpKSB7IGRmcy5kZnMoUGludltCaltpXV0sQWksQWoseCx4aixQaW52KTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgeFt4altpXV0gPSAwOyB9XG4gICAgZm9yKGk9aTA7aSE9PWkxOysraSkgeyBqID0gUGludltCaltpXV07IHhbal0gPSBCdltpXTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgaiA9IHhqW2ldO1xuICAgICAgICBqMCA9IEFpW2pdO1xuICAgICAgICBqMSA9IEFpW2orMV07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB7IGlmKFBpbnZbQWpba11dID09PSBqKSB7IHhbal0gLz0gQXZba107IGJyZWFrOyB9IH1cbiAgICAgICAgYSA9IHhbal07XG4gICAgICAgIGZvcihrPWowO2s8ajE7KytrKSB7XG4gICAgICAgICAgICBsID0gUGludltBaltrXV07XG4gICAgICAgICAgICBpZihsICE9PSBqKSB4W2xdIC09IGEqQXZba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5udW1lcmljLmNjc0xVUDEgPSBmdW5jdGlvbiBjY3NMVVAxKEEsdGhyZXNob2xkKSB7XG4gICAgdmFyIG0gPSBBWzBdLmxlbmd0aC0xO1xuICAgIHZhciBMID0gW251bWVyaWMucmVwKFttKzFdLDApLFtdLFtdXSwgVSA9IFtudW1lcmljLnJlcChbbSsxXSwgMCksW10sW11dO1xuICAgIHZhciBMaSA9IExbMF0sIExqID0gTFsxXSwgTHYgPSBMWzJdLCBVaSA9IFVbMF0sIFVqID0gVVsxXSwgVXYgPSBVWzJdO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLCB4aiA9IG51bWVyaWMucmVwKFttXSwwKTtcbiAgICB2YXIgaSxqLGssajAsajEsYSxlLGMsZCxLO1xuICAgIHZhciBzb2wgPSBudW1lcmljLmNjc0xQU29sdmUsIG1heCA9IE1hdGgubWF4LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgUCA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpLFBpbnYgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTtcbiAgICB2YXIgZGZzID0gbmV3IG51bWVyaWMuY2NzREZTKG0pO1xuICAgIGlmKHR5cGVvZiB0aHJlc2hvbGQgPT09IFwidW5kZWZpbmVkXCIpIHsgdGhyZXNob2xkID0gMTsgfVxuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBzb2woTCxBLHgseGosaSxQaW52LGRmcyk7XG4gICAgICAgIGEgPSAtMTtcbiAgICAgICAgZSA9IC0xO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBpZihrIDw9IGkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYyA9IGFicyh4W2tdKTtcbiAgICAgICAgICAgIGlmKGMgPiBhKSB7IGUgPSBrOyBhID0gYzsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFicyh4W2ldKTx0aHJlc2hvbGQqYSkge1xuICAgICAgICAgICAgaiA9IFBbaV07XG4gICAgICAgICAgICBhID0gUFtlXTtcbiAgICAgICAgICAgIFBbaV0gPSBhOyBQaW52W2FdID0gaTtcbiAgICAgICAgICAgIFBbZV0gPSBqOyBQaW52W2pdID0gZTtcbiAgICAgICAgICAgIGEgPSB4W2ldOyB4W2ldID0geFtlXTsgeFtlXSA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IExpW2ldO1xuICAgICAgICBlID0gVWlbaV07XG4gICAgICAgIGQgPSB4W2ldO1xuICAgICAgICBMalthXSA9IFBbaV07XG4gICAgICAgIEx2W2FdID0gMTtcbiAgICAgICAgKythO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBjID0geFtrXTtcbiAgICAgICAgICAgIHhqW2pdID0gMDtcbiAgICAgICAgICAgIHhba10gPSAwO1xuICAgICAgICAgICAgaWYoazw9aSkgeyBValtlXSA9IGs7IFV2W2VdID0gYzsgICArK2U7IH1cbiAgICAgICAgICAgIGVsc2UgICAgIHsgTGpbYV0gPSBQW2tdOyBMdlthXSA9IGMvZDsgKythOyB9XG4gICAgICAgIH1cbiAgICAgICAgTGlbaSsxXSA9IGE7XG4gICAgICAgIFVpW2krMV0gPSBlO1xuICAgIH1cbiAgICBmb3Ioaj1Mai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7IExqW2pdID0gUGludltMaltqXV07IH1cbiAgICByZXR1cm4ge0w6TCwgVTpVLCBQOlAsIFBpbnY6UGludn07XG59XG5udW1lcmljLmNjc0RGUzAgPSBmdW5jdGlvbiBjY3NERlMwKG4pIHtcbiAgICB0aGlzLmsgPSBBcnJheShuKTtcbiAgICB0aGlzLmsxID0gQXJyYXkobik7XG4gICAgdGhpcy5qID0gQXJyYXkobik7XG59XG5udW1lcmljLmNjc0RGUzAucHJvdG90eXBlLmRmcyA9IGZ1bmN0aW9uIGRmcyhKLEFpLEFqLHgseGosUGludixQKSB7XG4gICAgdmFyIG0gPSAwLGZvbyxuPXhqLmxlbmd0aDtcbiAgICB2YXIgayA9IHRoaXMuaywgazEgPSB0aGlzLmsxLCBqID0gdGhpcy5qLGttLGsxMTtcbiAgICBpZih4W0pdIT09MCkgcmV0dXJuO1xuICAgIHhbSl0gPSAxO1xuICAgIGpbMF0gPSBKO1xuICAgIGtbMF0gPSBrbSA9IEFpW1BpbnZbSl1dO1xuICAgIGsxWzBdID0gazExID0gQWlbUGludltKXSsxXTtcbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIGlmKGlzTmFOKGttKSkgdGhyb3cgbmV3IEVycm9yKFwiT3chXCIpO1xuICAgICAgICBpZihrbSA+PSBrMTEpIHtcbiAgICAgICAgICAgIHhqW25dID0gUGludltqW21dXTtcbiAgICAgICAgICAgIGlmKG09PT0wKSByZXR1cm47XG4gICAgICAgICAgICArK247XG4gICAgICAgICAgICAtLW07XG4gICAgICAgICAgICBrbSA9IGtbbV07XG4gICAgICAgICAgICBrMTEgPSBrMVttXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvbyA9IEFqW2ttXTtcbiAgICAgICAgICAgIGlmKHhbZm9vXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHhbZm9vXSA9IDE7XG4gICAgICAgICAgICAgICAga1ttXSA9IGttO1xuICAgICAgICAgICAgICAgICsrbTtcbiAgICAgICAgICAgICAgICBqW21dID0gZm9vO1xuICAgICAgICAgICAgICAgIGZvbyA9IFBpbnZbZm9vXTtcbiAgICAgICAgICAgICAgICBrbSA9IEFpW2Zvb107XG4gICAgICAgICAgICAgICAgazFbbV0gPSBrMTEgPSBBaVtmb28rMV07XG4gICAgICAgICAgICB9IGVsc2UgKytrbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm51bWVyaWMuY2NzTFBTb2x2ZTAgPSBmdW5jdGlvbiBjY3NMUFNvbHZlMChBLEIseSx4aixJLFBpbnYsUCxkZnMpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxtID0gQWkubGVuZ3RoLTEsIG49MDtcbiAgICB2YXIgQmkgPSBCWzBdLCBCaiA9IEJbMV0sIEJ2ID0gQlsyXTtcbiAgICBcbiAgICB2YXIgaSxpMCxpMSxqLEosajAsajEsayxsLGwwLGwxLGE7XG4gICAgaTAgPSBCaVtJXTtcbiAgICBpMSA9IEJpW0krMV07XG4gICAgeGoubGVuZ3RoID0gMDtcbiAgICBmb3IoaT1pMDtpPGkxOysraSkgeyBkZnMuZGZzKEJqW2ldLEFpLEFqLHkseGosUGludixQKTsgfVxuICAgIGZvcihpPXhqLmxlbmd0aC0xO2khPT0tMTstLWkpIHsgaiA9IHhqW2ldOyB5W1Bbal1dID0gMDsgfVxuICAgIGZvcihpPWkwO2khPT1pMTsrK2kpIHsgaiA9IEJqW2ldOyB5W2pdID0gQnZbaV07IH1cbiAgICBmb3IoaT14ai5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIGogPSB4altpXTtcbiAgICAgICAgbCA9IFBbal07XG4gICAgICAgIGowID0gQWlbal07XG4gICAgICAgIGoxID0gQWlbaisxXTtcbiAgICAgICAgZm9yKGs9ajA7azxqMTsrK2spIHsgaWYoQWpba10gPT09IGwpIHsgeVtsXSAvPSBBdltrXTsgYnJlYWs7IH0gfVxuICAgICAgICBhID0geVtsXTtcbiAgICAgICAgZm9yKGs9ajA7azxqMTsrK2spIHlbQWpba11dIC09IGEqQXZba107XG4gICAgICAgIHlbbF0gPSBhO1xuICAgIH1cbn1cbm51bWVyaWMuY2NzTFVQMCA9IGZ1bmN0aW9uIGNjc0xVUDAoQSx0aHJlc2hvbGQpIHtcbiAgICB2YXIgbSA9IEFbMF0ubGVuZ3RoLTE7XG4gICAgdmFyIEwgPSBbbnVtZXJpYy5yZXAoW20rMV0sMCksW10sW11dLCBVID0gW251bWVyaWMucmVwKFttKzFdLCAwKSxbXSxbXV07XG4gICAgdmFyIExpID0gTFswXSwgTGogPSBMWzFdLCBMdiA9IExbMl0sIFVpID0gVVswXSwgVWogPSBVWzFdLCBVdiA9IFVbMl07XG4gICAgdmFyIHkgPSBudW1lcmljLnJlcChbbV0sMCksIHhqID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIHZhciBpLGosayxqMCxqMSxhLGUsYyxkLEs7XG4gICAgdmFyIHNvbCA9IG51bWVyaWMuY2NzTFBTb2x2ZTAsIG1heCA9IE1hdGgubWF4LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgUCA9IG51bWVyaWMubGluc3BhY2UoMCxtLTEpLFBpbnYgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTtcbiAgICB2YXIgZGZzID0gbmV3IG51bWVyaWMuY2NzREZTMChtKTtcbiAgICBpZih0eXBlb2YgdGhyZXNob2xkID09PSBcInVuZGVmaW5lZFwiKSB7IHRocmVzaG9sZCA9IDE7IH1cbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgc29sKEwsQSx5LHhqLGksUGludixQLGRmcyk7XG4gICAgICAgIGEgPSAtMTtcbiAgICAgICAgZSA9IC0xO1xuICAgICAgICBmb3Ioaj14ai5sZW5ndGgtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBrID0geGpbal07XG4gICAgICAgICAgICBpZihrIDw9IGkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYyA9IGFicyh5W1Bba11dKTtcbiAgICAgICAgICAgIGlmKGMgPiBhKSB7IGUgPSBrOyBhID0gYzsgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFicyh5W1BbaV1dKTx0aHJlc2hvbGQqYSkge1xuICAgICAgICAgICAgaiA9IFBbaV07XG4gICAgICAgICAgICBhID0gUFtlXTtcbiAgICAgICAgICAgIFBbaV0gPSBhOyBQaW52W2FdID0gaTtcbiAgICAgICAgICAgIFBbZV0gPSBqOyBQaW52W2pdID0gZTtcbiAgICAgICAgfVxuICAgICAgICBhID0gTGlbaV07XG4gICAgICAgIGUgPSBVaVtpXTtcbiAgICAgICAgZCA9IHlbUFtpXV07XG4gICAgICAgIExqW2FdID0gUFtpXTtcbiAgICAgICAgTHZbYV0gPSAxO1xuICAgICAgICArK2E7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgIGsgPSB4altqXTtcbiAgICAgICAgICAgIGMgPSB5W1Bba11dO1xuICAgICAgICAgICAgeGpbal0gPSAwO1xuICAgICAgICAgICAgeVtQW2tdXSA9IDA7XG4gICAgICAgICAgICBpZihrPD1pKSB7IFVqW2VdID0gazsgVXZbZV0gPSBjOyAgICsrZTsgfVxuICAgICAgICAgICAgZWxzZSAgICAgeyBMalthXSA9IFBba107IEx2W2FdID0gYy9kOyArK2E7IH1cbiAgICAgICAgfVxuICAgICAgICBMaVtpKzFdID0gYTtcbiAgICAgICAgVWlbaSsxXSA9IGU7XG4gICAgfVxuICAgIGZvcihqPUxqLmxlbmd0aC0xO2ohPT0tMTstLWopIHsgTGpbal0gPSBQaW52W0xqW2pdXTsgfVxuICAgIHJldHVybiB7TDpMLCBVOlUsIFA6UCwgUGludjpQaW52fTtcbn1cbm51bWVyaWMuY2NzTFVQID0gbnVtZXJpYy5jY3NMVVAwO1xuXG5udW1lcmljLmNjc0RpbSA9IGZ1bmN0aW9uIGNjc0RpbShBKSB7IHJldHVybiBbbnVtZXJpYy5zdXAoQVsxXSkrMSxBWzBdLmxlbmd0aC0xXTsgfVxubnVtZXJpYy5jY3NHZXRCbG9jayA9IGZ1bmN0aW9uIGNjc0dldEJsb2NrKEEsaSxqKSB7XG4gICAgdmFyIHMgPSBudW1lcmljLmNjc0RpbShBKSxtPXNbMF0sbj1zWzFdO1xuICAgIGlmKHR5cGVvZiBpID09PSBcInVuZGVmaW5lZFwiKSB7IGkgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKTsgfVxuICAgIGVsc2UgaWYodHlwZW9mIGkgPT09IFwibnVtYmVyXCIpIHsgaSA9IFtpXTsgfVxuICAgIGlmKHR5cGVvZiBqID09PSBcInVuZGVmaW5lZFwiKSB7IGogPSBudW1lcmljLmxpbnNwYWNlKDAsbi0xKTsgfVxuICAgIGVsc2UgaWYodHlwZW9mIGogPT09IFwibnVtYmVyXCIpIHsgaiA9IFtqXTsgfVxuICAgIHZhciBwLHAwLHAxLFAgPSBpLmxlbmd0aCxxLFEgPSBqLmxlbmd0aCxyLGpxLGlwO1xuICAgIHZhciBCaSA9IG51bWVyaWMucmVwKFtuXSwwKSwgQmo9W10sIEJ2PVtdLCBCID0gW0JpLEJqLEJ2XTtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgeCA9IG51bWVyaWMucmVwKFttXSwwKSxjb3VudD0wLGZsYWdzID0gbnVtZXJpYy5yZXAoW21dLDApO1xuICAgIGZvcihxPTA7cTxROysrcSkge1xuICAgICAgICBqcSA9IGpbcV07XG4gICAgICAgIHZhciBxMCA9IEFpW2pxXTtcbiAgICAgICAgdmFyIHExID0gQWlbanErMV07XG4gICAgICAgIGZvcihwPXEwO3A8cTE7KytwKSB7XG4gICAgICAgICAgICByID0gQWpbcF07XG4gICAgICAgICAgICBmbGFnc1tyXSA9IDE7XG4gICAgICAgICAgICB4W3JdID0gQXZbcF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHA9MDtwPFA7KytwKSB7XG4gICAgICAgICAgICBpcCA9IGlbcF07XG4gICAgICAgICAgICBpZihmbGFnc1tpcF0pIHtcbiAgICAgICAgICAgICAgICBCaltjb3VudF0gPSBwO1xuICAgICAgICAgICAgICAgIEJ2W2NvdW50XSA9IHhbaVtwXV07XG4gICAgICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IocD1xMDtwPHExOysrcCkge1xuICAgICAgICAgICAgciA9IEFqW3BdO1xuICAgICAgICAgICAgZmxhZ3Nbcl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIEJpW3ErMV0gPSBjb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIEI7XG59XG5cbm51bWVyaWMuY2NzRG90ID0gZnVuY3Rpb24gY2NzRG90KEEsQikge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdO1xuICAgIHZhciBCaSA9IEJbMF0sIEJqID0gQlsxXSwgQnYgPSBCWzJdO1xuICAgIHZhciBzQSA9IG51bWVyaWMuY2NzRGltKEEpLCBzQiA9IG51bWVyaWMuY2NzRGltKEIpO1xuICAgIHZhciBtID0gc0FbMF0sIG4gPSBzQVsxXSwgbyA9IHNCWzFdO1xuICAgIHZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLCBmbGFncyA9IG51bWVyaWMucmVwKFttXSwwKSwgeGogPSBBcnJheShtKTtcbiAgICB2YXIgQ2kgPSBudW1lcmljLnJlcChbb10sMCksIENqID0gW10sIEN2ID0gW10sIEMgPSBbQ2ksQ2osQ3ZdO1xuICAgIHZhciBpLGosayxqMCxqMSxpMCxpMSxsLHAsYSxiO1xuICAgIGZvcihrPTA7ayE9PW87KytrKSB7XG4gICAgICAgIGowID0gQmlba107XG4gICAgICAgIGoxID0gQmlbaysxXTtcbiAgICAgICAgcCA9IDA7XG4gICAgICAgIGZvcihqPWowO2o8ajE7KytqKSB7XG4gICAgICAgICAgICBhID0gQmpbal07XG4gICAgICAgICAgICBiID0gQnZbal07XG4gICAgICAgICAgICBpMCA9IEFpW2FdO1xuICAgICAgICAgICAgaTEgPSBBaVthKzFdO1xuICAgICAgICAgICAgZm9yKGk9aTA7aTxpMTsrK2kpIHtcbiAgICAgICAgICAgICAgICBsID0gQWpbaV07XG4gICAgICAgICAgICAgICAgaWYoZmxhZ3NbbF09PT0wKSB7XG4gICAgICAgICAgICAgICAgICAgIHhqW3BdID0gbDtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3NbbF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBwID0gcCsxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4W2xdID0geFtsXSArIEF2W2ldKmI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgajAgPSBDaVtrXTtcbiAgICAgICAgajEgPSBqMCtwO1xuICAgICAgICBDaVtrKzFdID0gajE7XG4gICAgICAgIGZvcihqPXAtMTtqIT09LTE7LS1qKSB7XG4gICAgICAgICAgICBiID0gajArajtcbiAgICAgICAgICAgIGkgPSB4altqXTtcbiAgICAgICAgICAgIENqW2JdID0gaTtcbiAgICAgICAgICAgIEN2W2JdID0geFtpXTtcbiAgICAgICAgICAgIGZsYWdzW2ldID0gMDtcbiAgICAgICAgICAgIHhbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIENpW2srMV0gPSBDaVtrXStwO1xuICAgIH1cbiAgICByZXR1cm4gQztcbn1cblxubnVtZXJpYy5jY3NMVVBTb2x2ZSA9IGZ1bmN0aW9uIGNjc0xVUFNvbHZlKExVUCxCKSB7XG4gICAgdmFyIEwgPSBMVVAuTCwgVSA9IExVUC5VLCBQID0gTFVQLlA7XG4gICAgdmFyIEJpID0gQlswXTtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgIGlmKHR5cGVvZiBCaSAhPT0gXCJvYmplY3RcIikgeyBCID0gW1swLEIubGVuZ3RoXSxudW1lcmljLmxpbnNwYWNlKDAsQi5sZW5ndGgtMSksQl07IEJpID0gQlswXTsgZmxhZyA9IHRydWU7IH1cbiAgICB2YXIgQmogPSBCWzFdLCBCdiA9IEJbMl07XG4gICAgdmFyIG4gPSBMWzBdLmxlbmd0aC0xLCBtID0gQmkubGVuZ3RoLTE7XG4gICAgdmFyIHggPSBudW1lcmljLnJlcChbbl0sMCksIHhqID0gQXJyYXkobik7XG4gICAgdmFyIGIgPSBudW1lcmljLnJlcChbbl0sMCksIGJqID0gQXJyYXkobik7XG4gICAgdmFyIFhpID0gbnVtZXJpYy5yZXAoW20rMV0sMCksIFhqID0gW10sIFh2ID0gW107XG4gICAgdmFyIHNvbCA9IG51bWVyaWMuY2NzVFNvbHZlO1xuICAgIHZhciBpLGosajAsajEsayxKLE49MDtcbiAgICBmb3IoaT0wO2k8bTsrK2kpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIGowID0gQmlbaV07XG4gICAgICAgIGoxID0gQmlbaSsxXTtcbiAgICAgICAgZm9yKGo9ajA7ajxqMTsrK2opIHsgXG4gICAgICAgICAgICBKID0gTFVQLlBpbnZbQmpbal1dO1xuICAgICAgICAgICAgYmpba10gPSBKO1xuICAgICAgICAgICAgYltKXSA9IEJ2W2pdO1xuICAgICAgICAgICAgKytrO1xuICAgICAgICB9XG4gICAgICAgIGJqLmxlbmd0aCA9IGs7XG4gICAgICAgIHNvbChMLGIseCxiaix4aik7XG4gICAgICAgIGZvcihqPWJqLmxlbmd0aC0xO2ohPT0tMTstLWopIGJbYmpbal1dID0gMDtcbiAgICAgICAgc29sKFUseCxiLHhqLGJqKTtcbiAgICAgICAgaWYoZmxhZykgcmV0dXJuIGI7XG4gICAgICAgIGZvcihqPXhqLmxlbmd0aC0xO2ohPT0tMTstLWopIHhbeGpbal1dID0gMDtcbiAgICAgICAgZm9yKGo9YmoubGVuZ3RoLTE7aiE9PS0xOy0taikge1xuICAgICAgICAgICAgSiA9IGJqW2pdO1xuICAgICAgICAgICAgWGpbTl0gPSBKO1xuICAgICAgICAgICAgWHZbTl0gPSBiW0pdO1xuICAgICAgICAgICAgYltKXSA9IDA7XG4gICAgICAgICAgICArK047XG4gICAgICAgIH1cbiAgICAgICAgWGlbaSsxXSA9IE47XG4gICAgfVxuICAgIHJldHVybiBbWGksWGosWHZdO1xufVxuXG5udW1lcmljLmNjc2Jpbm9wID0gZnVuY3Rpb24gY2NzYmlub3AoYm9keSxzZXR1cCkge1xuICAgIGlmKHR5cGVvZiBzZXR1cCA9PT0gXCJ1bmRlZmluZWRcIikgc2V0dXA9Jyc7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdYJywnWScsXG4gICAgICAgICAgICAndmFyIFhpID0gWFswXSwgWGogPSBYWzFdLCBYdiA9IFhbMl07XFxuJytcbiAgICAgICAgICAgICd2YXIgWWkgPSBZWzBdLCBZaiA9IFlbMV0sIFl2ID0gWVsyXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciBuID0gWGkubGVuZ3RoLTEsbSA9IE1hdGgubWF4KG51bWVyaWMuc3VwKFhqKSxudW1lcmljLnN1cChZaikpKzE7XFxuJytcbiAgICAgICAgICAgICd2YXIgWmkgPSBudW1lcmljLnJlcChbbisxXSwwKSwgWmogPSBbXSwgWnYgPSBbXTtcXG4nK1xuICAgICAgICAgICAgJ3ZhciB4ID0gbnVtZXJpYy5yZXAoW21dLDApLHkgPSBudW1lcmljLnJlcChbbV0sMCk7XFxuJytcbiAgICAgICAgICAgICd2YXIgeGsseWssems7XFxuJytcbiAgICAgICAgICAgICd2YXIgaSxqLGowLGoxLGsscD0wO1xcbicrXG4gICAgICAgICAgICBzZXR1cCtcbiAgICAgICAgICAgICdmb3IoaT0wO2k8bjsrK2kpIHtcXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBYaVtpXTsgajEgPSBYaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgayA9IFhqW2pdO1xcbicrXG4gICAgICAgICAgICAnICAgIHhba10gPSAxO1xcbicrXG4gICAgICAgICAgICAnICAgIFpqW3BdID0gaztcXG4nK1xuICAgICAgICAgICAgJyAgICArK3A7XFxuJytcbiAgICAgICAgICAgICcgIH1cXG4nK1xuICAgICAgICAgICAgJyAgajAgPSBZaVtpXTsgajEgPSBZaVtpKzFdO1xcbicrXG4gICAgICAgICAgICAnICBmb3Ioaj1qMDtqIT09ajE7KytqKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgayA9IFlqW2pdO1xcbicrXG4gICAgICAgICAgICAnICAgIHlba10gPSBZdltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICBpZih4W2tdID09PSAwKSB7XFxuJytcbiAgICAgICAgICAgICcgICAgICBaaltwXSA9IGs7XFxuJytcbiAgICAgICAgICAgICcgICAgICArK3A7XFxuJytcbiAgICAgICAgICAgICcgICAgfVxcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIFppW2krMV0gPSBwO1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFhpW2ldOyBqMSA9IFhpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHhbWGpbal1dID0gWHZbal07XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWmlbaV07IGoxID0gWmlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikge1xcbicrXG4gICAgICAgICAgICAnICAgIGsgPSBaaltqXTtcXG4nK1xuICAgICAgICAgICAgJyAgICB4ayA9IHhba107XFxuJytcbiAgICAgICAgICAgICcgICAgeWsgPSB5W2tdO1xcbicrXG4gICAgICAgICAgICBib2R5KydcXG4nK1xuICAgICAgICAgICAgJyAgICBadltqXSA9IHprO1xcbicrXG4gICAgICAgICAgICAnICB9XFxuJytcbiAgICAgICAgICAgICcgIGowID0gWGlbaV07IGoxID0gWGlbaSsxXTtcXG4nK1xuICAgICAgICAgICAgJyAgZm9yKGo9ajA7aiE9PWoxOysraikgeFtYaltqXV0gPSAwO1xcbicrXG4gICAgICAgICAgICAnICBqMCA9IFlpW2ldOyBqMSA9IFlpW2krMV07XFxuJytcbiAgICAgICAgICAgICcgIGZvcihqPWowO2ohPT1qMTsrK2opIHlbWWpbal1dID0gMDtcXG4nK1xuICAgICAgICAgICAgJ31cXG4nK1xuICAgICAgICAgICAgJ3JldHVybiBbWmksWmosWnZdOydcbiAgICAgICAgICAgICk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgdmFyIGssQSxCLEM7XG4gICAgZm9yKGsgaW4gbnVtZXJpYy5vcHMyKSB7XG4gICAgICAgIGlmKGlzRmluaXRlKGV2YWwoJzEnK251bWVyaWMub3BzMltrXSsnMCcpKSkgQSA9ICdbWVswXSxZWzFdLG51bWVyaWMuJytrKycoWCxZWzJdKV0nO1xuICAgICAgICBlbHNlIEEgPSAnTmFOJztcbiAgICAgICAgaWYoaXNGaW5pdGUoZXZhbCgnMCcrbnVtZXJpYy5vcHMyW2tdKycxJykpKSBCID0gJ1tYWzBdLFhbMV0sbnVtZXJpYy4nK2srJyhYWzJdLFkpXSc7XG4gICAgICAgIGVsc2UgQiA9ICdOYU4nO1xuICAgICAgICBpZihpc0Zpbml0ZShldmFsKCcxJytudW1lcmljLm9wczJba10rJzAnKSkgJiYgaXNGaW5pdGUoZXZhbCgnMCcrbnVtZXJpYy5vcHMyW2tdKycxJykpKSBDID0gJ251bWVyaWMuY2NzJytrKydNTShYLFkpJztcbiAgICAgICAgZWxzZSBDID0gJ05hTic7XG4gICAgICAgIG51bWVyaWNbJ2NjcycraysnTU0nXSA9IG51bWVyaWMuY2NzYmlub3AoJ3prID0geGsgJytudW1lcmljLm9wczJba10rJ3lrOycpO1xuICAgICAgICBudW1lcmljWydjY3MnK2tdID0gRnVuY3Rpb24oJ1gnLCdZJyxcbiAgICAgICAgICAgICAgICAnaWYodHlwZW9mIFggPT09IFwibnVtYmVyXCIpIHJldHVybiAnK0ErJztcXG4nK1xuICAgICAgICAgICAgICAgICdpZih0eXBlb2YgWSA9PT0gXCJudW1iZXJcIikgcmV0dXJuICcrQisnO1xcbicrXG4gICAgICAgICAgICAgICAgJ3JldHVybiAnK0MrJztcXG4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICB9XG59KCkpO1xuXG5udW1lcmljLmNjc1NjYXR0ZXIgPSBmdW5jdGlvbiBjY3NTY2F0dGVyKEEpIHtcbiAgICB2YXIgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXTtcbiAgICB2YXIgbiA9IG51bWVyaWMuc3VwKEFqKSsxLG09QWkubGVuZ3RoO1xuICAgIHZhciBSaSA9IG51bWVyaWMucmVwKFtuXSwwKSxSaj1BcnJheShtKSwgUnYgPSBBcnJheShtKTtcbiAgICB2YXIgY291bnRzID0gbnVtZXJpYy5yZXAoW25dLDApLGk7XG4gICAgZm9yKGk9MDtpPG07KytpKSBjb3VudHNbQWpbaV1dKys7XG4gICAgZm9yKGk9MDtpPG47KytpKSBSaVtpKzFdID0gUmlbaV0gKyBjb3VudHNbaV07XG4gICAgdmFyIHB0ciA9IFJpLnNsaWNlKDApLGssQWlpO1xuICAgIGZvcihpPTA7aTxtOysraSkge1xuICAgICAgICBBaWkgPSBBaltpXTtcbiAgICAgICAgayA9IHB0cltBaWldO1xuICAgICAgICBSaltrXSA9IEFpW2ldO1xuICAgICAgICBSdltrXSA9IEF2W2ldO1xuICAgICAgICBwdHJbQWlpXT1wdHJbQWlpXSsxO1xuICAgIH1cbiAgICByZXR1cm4gW1JpLFJqLFJ2XTtcbn1cblxubnVtZXJpYy5jY3NHYXRoZXIgPSBmdW5jdGlvbiBjY3NHYXRoZXIoQSkge1xuICAgIHZhciBBaSA9IEFbMF0sIEFqID0gQVsxXSwgQXYgPSBBWzJdO1xuICAgIHZhciBuID0gQWkubGVuZ3RoLTEsbSA9IEFqLmxlbmd0aDtcbiAgICB2YXIgUmkgPSBBcnJheShtKSwgUmogPSBBcnJheShtKSwgUnYgPSBBcnJheShtKTtcbiAgICB2YXIgaSxqLGowLGoxLHA7XG4gICAgcD0wO1xuICAgIGZvcihpPTA7aTxuOysraSkge1xuICAgICAgICBqMCA9IEFpW2ldO1xuICAgICAgICBqMSA9IEFpW2krMV07XG4gICAgICAgIGZvcihqPWowO2ohPT1qMTsrK2opIHtcbiAgICAgICAgICAgIFJqW3BdID0gaTtcbiAgICAgICAgICAgIFJpW3BdID0gQWpbal07XG4gICAgICAgICAgICBSdltwXSA9IEF2W2pdO1xuICAgICAgICAgICAgKytwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbUmksUmosUnZdO1xufVxuXG4vLyBUaGUgZm9sbG93aW5nIHNwYXJzZSBsaW5lYXIgYWxnZWJyYSByb3V0aW5lcyBhcmUgZGVwcmVjYXRlZC5cblxubnVtZXJpYy5zZGltID0gZnVuY3Rpb24gZGltKEEscmV0LGspIHtcbiAgICBpZih0eXBlb2YgcmV0ID09PSBcInVuZGVmaW5lZFwiKSB7IHJldCA9IFtdOyB9XG4gICAgaWYodHlwZW9mIEEgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXQ7XG4gICAgaWYodHlwZW9mIGsgPT09IFwidW5kZWZpbmVkXCIpIHsgaz0wOyB9XG4gICAgaWYoIShrIGluIHJldCkpIHsgcmV0W2tdID0gMDsgfVxuICAgIGlmKEEubGVuZ3RoID4gcmV0W2tdKSByZXRba10gPSBBLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBmb3IoaSBpbiBBKSB7XG4gICAgICAgIGlmKEEuaGFzT3duUHJvcGVydHkoaSkpIGRpbShBW2ldLHJldCxrKzEpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxubnVtZXJpYy5zY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShBLGssbikge1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSB7IGs9MDsgfVxuICAgIGlmKHR5cGVvZiBuID09PSBcInVuZGVmaW5lZFwiKSB7IG4gPSBudW1lcmljLnNkaW0oQSkubGVuZ3RoOyB9XG4gICAgdmFyIGkscmV0ID0gQXJyYXkoQS5sZW5ndGgpO1xuICAgIGlmKGsgPT09IG4tMSkge1xuICAgICAgICBmb3IoaSBpbiBBKSB7IGlmKEEuaGFzT3duUHJvcGVydHkoaSkpIHJldFtpXSA9IEFbaV07IH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZihBLmhhc093blByb3BlcnR5KGkpKSByZXRbaV0gPSBjbG9uZShBW2ldLGsrMSxuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZGlhZyA9IGZ1bmN0aW9uIGRpYWcoZCkge1xuICAgIHZhciBuID0gZC5sZW5ndGgsaSxyZXQgPSBBcnJheShuKSxpMSxpMixpMztcbiAgICBmb3IoaT1uLTE7aT49MTtpLT0yKSB7XG4gICAgICAgIGkxID0gaS0xO1xuICAgICAgICByZXRbaV0gPSBbXTsgcmV0W2ldW2ldID0gZFtpXTtcbiAgICAgICAgcmV0W2kxXSA9IFtdOyByZXRbaTFdW2kxXSA9IGRbaTFdO1xuICAgIH1cbiAgICBpZihpPT09MCkgeyByZXRbMF0gPSBbXTsgcmV0WzBdWzBdID0gZFtpXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2lkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkobikgeyByZXR1cm4gbnVtZXJpYy5zZGlhZyhudW1lcmljLnJlcChbbl0sMSkpOyB9XG5cbm51bWVyaWMuc3RyYW5zcG9zZSA9IGZ1bmN0aW9uIHRyYW5zcG9zZShBKSB7XG4gICAgdmFyIHJldCA9IFtdLCBuID0gQS5sZW5ndGgsIGksaixBaTtcbiAgICBmb3IoaSBpbiBBKSB7XG4gICAgICAgIGlmKCEoQS5oYXNPd25Qcm9wZXJ0eShpKSkpIGNvbnRpbnVlO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGZvcihqIGluIEFpKSB7XG4gICAgICAgICAgICBpZighKEFpLmhhc093blByb3BlcnR5KGopKSkgY29udGludWU7XG4gICAgICAgICAgICBpZih0eXBlb2YgcmV0W2pdICE9PSBcIm9iamVjdFwiKSB7IHJldFtqXSA9IFtdOyB9XG4gICAgICAgICAgICByZXRbal1baV0gPSBBaVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNMVVAgPSBmdW5jdGlvbiBMVVAoQSx0b2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gbnVtZXJpYy5zTFVQIGhhZCBhIGJ1ZyBpbiBpdCBhbmQgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgbmV3IG51bWVyaWMuY2NzTFVQIGZ1bmN0aW9uIGluc3RlYWQuXCIpO1xufTtcblxubnVtZXJpYy5zZG90TU0gPSBmdW5jdGlvbiBkb3RNTShBLEIpIHtcbiAgICB2YXIgcCA9IEEubGVuZ3RoLCBxID0gQi5sZW5ndGgsIEJUID0gbnVtZXJpYy5zdHJhbnNwb3NlKEIpLCByID0gQlQubGVuZ3RoLCBBaSwgQlRrO1xuICAgIHZhciBpLGosayxhY2N1bTtcbiAgICB2YXIgcmV0ID0gQXJyYXkocCkscmV0aTtcbiAgICBmb3IoaT1wLTE7aT49MDtpLS0pIHtcbiAgICAgICAgcmV0aSA9IFtdO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGZvcihrPXItMTtrPj0wO2stLSkge1xuICAgICAgICAgICAgYWNjdW0gPSAwO1xuICAgICAgICAgICAgQlRrID0gQlRba107XG4gICAgICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgICAgIGlmKCEoQWkuaGFzT3duUHJvcGVydHkoaikpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihqIGluIEJUaykgeyBhY2N1bSArPSBBaVtqXSpCVGtbal07IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGFjY3VtKSByZXRpW2tdID0gYWNjdW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldID0gcmV0aTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxubnVtZXJpYy5zZG90TVYgPSBmdW5jdGlvbiBkb3RNVihBLHgpIHtcbiAgICB2YXIgcCA9IEEubGVuZ3RoLCBBaSwgaSxqO1xuICAgIHZhciByZXQgPSBBcnJheShwKSwgYWNjdW07XG4gICAgZm9yKGk9cC0xO2k+PTA7aS0tKSB7XG4gICAgICAgIEFpID0gQVtpXTtcbiAgICAgICAgYWNjdW0gPSAwO1xuICAgICAgICBmb3IoaiBpbiBBaSkge1xuICAgICAgICAgICAgaWYoIShBaS5oYXNPd25Qcm9wZXJ0eShqKSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYoeFtqXSkgYWNjdW0gKz0gQWlbal0qeFtqXTtcbiAgICAgICAgfVxuICAgICAgICBpZihhY2N1bSkgcmV0W2ldID0gYWNjdW07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuc2RvdFZNID0gZnVuY3Rpb24gZG90TVYoeCxBKSB7XG4gICAgdmFyIGksaixBaSxhbHBoYTtcbiAgICB2YXIgcmV0ID0gW10sIGFjY3VtO1xuICAgIGZvcihpIGluIHgpIHtcbiAgICAgICAgaWYoIXguaGFzT3duUHJvcGVydHkoaSkpIGNvbnRpbnVlO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIGFscGhhID0geFtpXTtcbiAgICAgICAgZm9yKGogaW4gQWkpIHtcbiAgICAgICAgICAgIGlmKCFBaS5oYXNPd25Qcm9wZXJ0eShqKSkgY29udGludWU7XG4gICAgICAgICAgICBpZighcmV0W2pdKSB7IHJldFtqXSA9IDA7IH1cbiAgICAgICAgICAgIHJldFtqXSArPSBhbHBoYSpBaVtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3RWViA9IGZ1bmN0aW9uIGRvdFZWKHgseSkge1xuICAgIHZhciBpLHJldD0wO1xuICAgIGZvcihpIGluIHgpIHsgaWYoeFtpXSAmJiB5W2ldKSByZXQrPSB4W2ldKnlbaV07IH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5udW1lcmljLnNkb3QgPSBmdW5jdGlvbiBkb3QoQSxCKSB7XG4gICAgdmFyIG0gPSBudW1lcmljLnNkaW0oQSkubGVuZ3RoLCBuID0gbnVtZXJpYy5zZGltKEIpLmxlbmd0aDtcbiAgICB2YXIgayA9IG0qMTAwMCtuO1xuICAgIHN3aXRjaChrKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gQSpCO1xuICAgIGNhc2UgMTAwMTogcmV0dXJuIG51bWVyaWMuc2RvdFZWKEEsQik7XG4gICAgY2FzZSAyMDAxOiByZXR1cm4gbnVtZXJpYy5zZG90TVYoQSxCKTtcbiAgICBjYXNlIDEwMDI6IHJldHVybiBudW1lcmljLnNkb3RWTShBLEIpO1xuICAgIGNhc2UgMjAwMjogcmV0dXJuIG51bWVyaWMuc2RvdE1NKEEsQik7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdudW1lcmljLnNkb3Qgbm90IGltcGxlbWVudGVkIGZvciB0ZW5zb3JzIG9mIG9yZGVyICcrbSsnIGFuZCAnK24pO1xuICAgIH1cbn1cblxubnVtZXJpYy5zc2NhdHRlciA9IGZ1bmN0aW9uIHNjYXR0ZXIoVikge1xuICAgIHZhciBuID0gVlswXS5sZW5ndGgsIFZpaiwgaSwgaiwgbSA9IFYubGVuZ3RoLCBBID0gW10sIEFqO1xuICAgIGZvcihpPW4tMTtpPj0wOy0taSkge1xuICAgICAgICBpZighVlttLTFdW2ldKSBjb250aW51ZTtcbiAgICAgICAgQWogPSBBO1xuICAgICAgICBmb3Ioaj0wO2o8bS0yO2orKykge1xuICAgICAgICAgICAgVmlqID0gVltqXVtpXTtcbiAgICAgICAgICAgIGlmKCFBaltWaWpdKSBBaltWaWpdID0gW107XG4gICAgICAgICAgICBBaiA9IEFqW1Zpal07XG4gICAgICAgIH1cbiAgICAgICAgQWpbVltqXVtpXV0gPSBWW2orMV1baV07XG4gICAgfVxuICAgIHJldHVybiBBO1xufVxuXG5udW1lcmljLnNnYXRoZXIgPSBmdW5jdGlvbiBnYXRoZXIoQSxyZXQsaykge1xuICAgIGlmKHR5cGVvZiByZXQgPT09IFwidW5kZWZpbmVkXCIpIHJldCA9IFtdO1xuICAgIGlmKHR5cGVvZiBrID09PSBcInVuZGVmaW5lZFwiKSBrID0gW107XG4gICAgdmFyIG4saSxBaTtcbiAgICBuID0gay5sZW5ndGg7XG4gICAgZm9yKGkgaW4gQSkge1xuICAgICAgICBpZihBLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBrW25dID0gcGFyc2VJbnQoaSk7XG4gICAgICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgICAgICBpZih0eXBlb2YgQWkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZihBaSkge1xuICAgICAgICAgICAgICAgICAgICBpZihyZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoaT1uKzE7aT49MDstLWkpIHJldFtpXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcihpPW47aT49MDstLWkpIHJldFtpXS5wdXNoKGtbaV0pO1xuICAgICAgICAgICAgICAgICAgICByZXRbbisxXS5wdXNoKEFpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgZ2F0aGVyKEFpLHJldCxrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihrLmxlbmd0aD5uKSBrLnBvcCgpO1xuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDYuIENvb3JkaW5hdGUgbWF0cmljZXNcbm51bWVyaWMuY0xVID0gZnVuY3Rpb24gTFUoQSkge1xuICAgIHZhciBJID0gQVswXSwgSiA9IEFbMV0sIFYgPSBBWzJdO1xuICAgIHZhciBwID0gSS5sZW5ndGgsIG09MCwgaSxqLGssYSxiLGM7XG4gICAgZm9yKGk9MDtpPHA7aSsrKSBpZihJW2ldPm0pIG09SVtpXTtcbiAgICBtKys7XG4gICAgdmFyIEwgPSBBcnJheShtKSwgVSA9IEFycmF5KG0pLCBsZWZ0ID0gbnVtZXJpYy5yZXAoW21dLEluZmluaXR5KSwgcmlnaHQgPSBudW1lcmljLnJlcChbbV0sLUluZmluaXR5KTtcbiAgICB2YXIgVWksIFVqLGFscGhhO1xuICAgIGZvcihrPTA7azxwO2srKykge1xuICAgICAgICBpID0gSVtrXTtcbiAgICAgICAgaiA9IEpba107XG4gICAgICAgIGlmKGo8bGVmdFtpXSkgbGVmdFtpXSA9IGo7XG4gICAgICAgIGlmKGo+cmlnaHRbaV0pIHJpZ2h0W2ldID0gajtcbiAgICB9XG4gICAgZm9yKGk9MDtpPG0tMTtpKyspIHsgaWYocmlnaHRbaV0gPiByaWdodFtpKzFdKSByaWdodFtpKzFdID0gcmlnaHRbaV07IH1cbiAgICBmb3IoaT1tLTE7aT49MTtpLS0pIHsgaWYobGVmdFtpXTxsZWZ0W2ktMV0pIGxlZnRbaS0xXSA9IGxlZnRbaV07IH1cbiAgICB2YXIgY291bnRMID0gMCwgY291bnRVID0gMDtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgVVtpXSA9IG51bWVyaWMucmVwKFtyaWdodFtpXS1sZWZ0W2ldKzFdLDApO1xuICAgICAgICBMW2ldID0gbnVtZXJpYy5yZXAoW2ktbGVmdFtpXV0sMCk7XG4gICAgICAgIGNvdW50TCArPSBpLWxlZnRbaV0rMTtcbiAgICAgICAgY291bnRVICs9IHJpZ2h0W2ldLWkrMTtcbiAgICB9XG4gICAgZm9yKGs9MDtrPHA7aysrKSB7IGkgPSBJW2tdOyBVW2ldW0pba10tbGVmdFtpXV0gPSBWW2tdOyB9XG4gICAgZm9yKGk9MDtpPG0tMTtpKyspIHtcbiAgICAgICAgYSA9IGktbGVmdFtpXTtcbiAgICAgICAgVWkgPSBVW2ldO1xuICAgICAgICBmb3Ioaj1pKzE7bGVmdFtqXTw9aSAmJiBqPG07aisrKSB7XG4gICAgICAgICAgICBiID0gaS1sZWZ0W2pdO1xuICAgICAgICAgICAgYyA9IHJpZ2h0W2ldLWk7XG4gICAgICAgICAgICBVaiA9IFVbal07XG4gICAgICAgICAgICBhbHBoYSA9IFVqW2JdL1VpW2FdO1xuICAgICAgICAgICAgaWYoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBmb3Ioaz0xO2s8PWM7aysrKSB7IFVqW2srYl0gLT0gYWxwaGEqVWlbaythXTsgfVxuICAgICAgICAgICAgICAgIExbal1baS1sZWZ0W2pdXSA9IGFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBVaSA9IFtdLCBVaiA9IFtdLCBVdiA9IFtdLCBMaSA9IFtdLCBMaiA9IFtdLCBMdiA9IFtdO1xuICAgIHZhciBwLHEsZm9vO1xuICAgIHA9MDsgcT0wO1xuICAgIGZvcihpPTA7aTxtO2krKykge1xuICAgICAgICBhID0gbGVmdFtpXTtcbiAgICAgICAgYiA9IHJpZ2h0W2ldO1xuICAgICAgICBmb28gPSBVW2ldO1xuICAgICAgICBmb3Ioaj1pO2o8PWI7aisrKSB7XG4gICAgICAgICAgICBpZihmb29bai1hXSkge1xuICAgICAgICAgICAgICAgIFVpW3BdID0gaTtcbiAgICAgICAgICAgICAgICBValtwXSA9IGo7XG4gICAgICAgICAgICAgICAgVXZbcF0gPSBmb29bai1hXTtcbiAgICAgICAgICAgICAgICBwKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9vID0gTFtpXTtcbiAgICAgICAgZm9yKGo9YTtqPGk7aisrKSB7XG4gICAgICAgICAgICBpZihmb29bai1hXSkge1xuICAgICAgICAgICAgICAgIExpW3FdID0gaTtcbiAgICAgICAgICAgICAgICBMaltxXSA9IGo7XG4gICAgICAgICAgICAgICAgTHZbcV0gPSBmb29bai1hXTtcbiAgICAgICAgICAgICAgICBxKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTGlbcV0gPSBpO1xuICAgICAgICBMaltxXSA9IGk7XG4gICAgICAgIEx2W3FdID0gMTtcbiAgICAgICAgcSsrO1xuICAgIH1cbiAgICByZXR1cm4ge1U6W1VpLFVqLFV2XSwgTDpbTGksTGosTHZdfTtcbn07XG5cbm51bWVyaWMuY0xVc29sdmUgPSBmdW5jdGlvbiBMVXNvbHZlKGx1LGIpIHtcbiAgICB2YXIgTCA9IGx1LkwsIFUgPSBsdS5VLCByZXQgPSBudW1lcmljLmNsb25lKGIpO1xuICAgIHZhciBMaSA9IExbMF0sIExqID0gTFsxXSwgTHYgPSBMWzJdO1xuICAgIHZhciBVaSA9IFVbMF0sIFVqID0gVVsxXSwgVXYgPSBVWzJdO1xuICAgIHZhciBwID0gVWkubGVuZ3RoLCBxID0gTGkubGVuZ3RoO1xuICAgIHZhciBtID0gcmV0Lmxlbmd0aCxpLGosaztcbiAgICBrID0gMDtcbiAgICBmb3IoaT0wO2k8bTtpKyspIHtcbiAgICAgICAgd2hpbGUoTGpba10gPCBpKSB7XG4gICAgICAgICAgICByZXRbaV0gLT0gTHZba10qcmV0W0xqW2tdXTtcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgfVxuICAgICAgICBrKys7XG4gICAgfVxuICAgIGsgPSBwLTE7XG4gICAgZm9yKGk9bS0xO2k+PTA7aS0tKSB7XG4gICAgICAgIHdoaWxlKFVqW2tdID4gaSkge1xuICAgICAgICAgICAgcmV0W2ldIC09IFV2W2tdKnJldFtValtrXV07XG4gICAgICAgICAgICBrLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0W2ldIC89IFV2W2tdO1xuICAgICAgICBrLS07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5udW1lcmljLmNncmlkID0gZnVuY3Rpb24gZ3JpZChuLHNoYXBlKSB7XG4gICAgaWYodHlwZW9mIG4gPT09IFwibnVtYmVyXCIpIG4gPSBbbixuXTtcbiAgICB2YXIgcmV0ID0gbnVtZXJpYy5yZXAobiwtMSk7XG4gICAgdmFyIGksaixjb3VudDtcbiAgICBpZih0eXBlb2Ygc2hhcGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzd2l0Y2goc2hhcGUpIHtcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBzaGFwZSA9IGZ1bmN0aW9uKGksaikgeyByZXR1cm4gKGk+PW5bMF0vMiB8fCBqPG5bMV0vMik7IH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2hhcGUgPSBmdW5jdGlvbihpLGopIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudD0wO1xuICAgIGZvcihpPTE7aTxuWzBdLTE7aSsrKSBmb3Ioaj0xO2o8blsxXS0xO2orKykgXG4gICAgICAgIGlmKHNoYXBlKGksaikpIHtcbiAgICAgICAgICAgIHJldFtpXVtqXSA9IGNvdW50O1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbm51bWVyaWMuY2RlbHNxID0gZnVuY3Rpb24gZGVsc3EoZykge1xuICAgIHZhciBkaXIgPSBbWy0xLDBdLFswLC0xXSxbMCwxXSxbMSwwXV07XG4gICAgdmFyIHMgPSBudW1lcmljLmRpbShnKSwgbSA9IHNbMF0sIG4gPSBzWzFdLCBpLGosayxwLHE7XG4gICAgdmFyIExpID0gW10sIExqID0gW10sIEx2ID0gW107XG4gICAgZm9yKGk9MTtpPG0tMTtpKyspIGZvcihqPTE7ajxuLTE7aisrKSB7XG4gICAgICAgIGlmKGdbaV1bal08MCkgY29udGludWU7XG4gICAgICAgIGZvcihrPTA7azw0O2srKykge1xuICAgICAgICAgICAgcCA9IGkrZGlyW2tdWzBdO1xuICAgICAgICAgICAgcSA9IGorZGlyW2tdWzFdO1xuICAgICAgICAgICAgaWYoZ1twXVtxXTwwKSBjb250aW51ZTtcbiAgICAgICAgICAgIExpLnB1c2goZ1tpXVtqXSk7XG4gICAgICAgICAgICBMai5wdXNoKGdbcF1bcV0pO1xuICAgICAgICAgICAgTHYucHVzaCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgTGkucHVzaChnW2ldW2pdKTtcbiAgICAgICAgTGoucHVzaChnW2ldW2pdKTtcbiAgICAgICAgTHYucHVzaCg0KTtcbiAgICB9XG4gICAgcmV0dXJuIFtMaSxMaixMdl07XG59XG5cbm51bWVyaWMuY2RvdE1WID0gZnVuY3Rpb24gZG90TVYoQSx4KSB7XG4gICAgdmFyIHJldCwgQWkgPSBBWzBdLCBBaiA9IEFbMV0sIEF2ID0gQVsyXSxrLHA9QWkubGVuZ3RoLE47XG4gICAgTj0wO1xuICAgIGZvcihrPTA7azxwO2srKykgeyBpZihBaVtrXT5OKSBOID0gQWlba107IH1cbiAgICBOKys7XG4gICAgcmV0ID0gbnVtZXJpYy5yZXAoW05dLDApO1xuICAgIGZvcihrPTA7azxwO2srKykgeyByZXRbQWlba11dKz1BdltrXSp4W0FqW2tdXTsgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDcuIFNwbGluZXNcblxubnVtZXJpYy5TcGxpbmUgPSBmdW5jdGlvbiBTcGxpbmUoeCx5bCx5cixrbCxrcikgeyB0aGlzLnggPSB4OyB0aGlzLnlsID0geWw7IHRoaXMueXIgPSB5cjsgdGhpcy5rbCA9IGtsOyB0aGlzLmtyID0ga3I7IH1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5fYXQgPSBmdW5jdGlvbiBfYXQoeDEscCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5bCA9IHRoaXMueWw7XG4gICAgdmFyIHlyID0gdGhpcy55cjtcbiAgICB2YXIga2wgPSB0aGlzLmtsO1xuICAgIHZhciBrciA9IHRoaXMua3I7XG4gICAgdmFyIHgxLGEsYix0O1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgc3ViID0gbnVtZXJpYy5zdWIsIG11bCA9IG51bWVyaWMubXVsO1xuICAgIGEgPSBzdWIobXVsKGtsW3BdLHhbcCsxXS14W3BdKSxzdWIoeXJbcCsxXSx5bFtwXSkpO1xuICAgIGIgPSBhZGQobXVsKGtyW3ArMV0seFtwXS14W3ArMV0pLHN1Yih5cltwKzFdLHlsW3BdKSk7XG4gICAgdCA9ICh4MS14W3BdKS8oeFtwKzFdLXhbcF0pO1xuICAgIHZhciBzID0gdCooMS10KTtcbiAgICByZXR1cm4gYWRkKGFkZChhZGQobXVsKDEtdCx5bFtwXSksbXVsKHQseXJbcCsxXSkpLG11bChhLHMqKDEtdCkpKSxtdWwoYixzKnQpKTtcbn1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0KHgwKSB7XG4gICAgaWYodHlwZW9mIHgwID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgICAgICB2YXIgcCxxLG1pZCxmbG9vciA9IE1hdGguZmxvb3IsYSxiLHQ7XG4gICAgICAgIHAgPSAwO1xuICAgICAgICBxID0gbi0xO1xuICAgICAgICB3aGlsZShxLXA+MSkge1xuICAgICAgICAgICAgbWlkID0gZmxvb3IoKHArcSkvMik7XG4gICAgICAgICAgICBpZih4W21pZF0gPD0geDApIHAgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlIHEgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0KHgwLHApO1xuICAgIH1cbiAgICB2YXIgbiA9IHgwLmxlbmd0aCwgaSwgcmV0ID0gQXJyYXkobik7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHJldFtpXSA9IHRoaXMuYXQoeDBbaV0pO1xuICAgIHJldHVybiByZXQ7XG59XG5udW1lcmljLlNwbGluZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIGRpZmYoKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHlsID0gdGhpcy55bDtcbiAgICB2YXIgeXIgPSB0aGlzLnlyO1xuICAgIHZhciBrbCA9IHRoaXMua2w7XG4gICAgdmFyIGtyID0gdGhpcy5rcjtcbiAgICB2YXIgbiA9IHlsLmxlbmd0aDtcbiAgICB2YXIgaSxkeCxkeTtcbiAgICB2YXIgemwgPSBrbCwgenIgPSBrciwgcGwgPSBBcnJheShuKSwgcHIgPSBBcnJheShuKTtcbiAgICB2YXIgYWRkID0gbnVtZXJpYy5hZGQsIG11bCA9IG51bWVyaWMubXVsLCBkaXYgPSBudW1lcmljLmRpdiwgc3ViID0gbnVtZXJpYy5zdWI7XG4gICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgZHggPSB4W2krMV0teFtpXTtcbiAgICAgICAgZHkgPSBzdWIoeXJbaSsxXSx5bFtpXSk7XG4gICAgICAgIHBsW2ldID0gZGl2KGFkZChtdWwoZHksIDYpLG11bChrbFtpXSwtNCpkeCksbXVsKGtyW2krMV0sLTIqZHgpKSxkeCpkeCk7XG4gICAgICAgIHByW2krMV0gPSBkaXYoYWRkKG11bChkeSwtNiksbXVsKGtsW2ldLCAyKmR4KSxtdWwoa3JbaSsxXSwgNCpkeCkpLGR4KmR4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlNwbGluZSh4LHpsLHpyLHBsLHByKTtcbn1cbm51bWVyaWMuU3BsaW5lLnByb3RvdHlwZS5yb290cyA9IGZ1bmN0aW9uIHJvb3RzKCkge1xuICAgIGZ1bmN0aW9uIHNxcih4KSB7IHJldHVybiB4Kng7IH1cbiAgICBmdW5jdGlvbiBoZXZhbCh5MCx5MSxrMCxrMSx4KSB7XG4gICAgICAgIHZhciBBID0gazAqMi0oeTEteTApO1xuICAgICAgICB2YXIgQiA9IC1rMSoyKyh5MS15MCk7XG4gICAgICAgIHZhciB0ID0gKHgrMSkqMC41O1xuICAgICAgICB2YXIgcyA9IHQqKDEtdCk7XG4gICAgICAgIHJldHVybiAoMS10KSp5MCt0KnkxK0EqcyooMS10KStCKnMqdDtcbiAgICB9XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciB4ID0gdGhpcy54LCB5bCA9IHRoaXMueWwsIHlyID0gdGhpcy55ciwga2wgPSB0aGlzLmtsLCBrciA9IHRoaXMua3I7XG4gICAgaWYodHlwZW9mIHlsWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHlsID0gW3lsXTtcbiAgICAgICAgeXIgPSBbeXJdO1xuICAgICAgICBrbCA9IFtrbF07XG4gICAgICAgIGtyID0gW2tyXTtcbiAgICB9XG4gICAgdmFyIG0gPSB5bC5sZW5ndGgsbj14Lmxlbmd0aC0xLGksaixrLHkscyx0O1xuICAgIHZhciBhaSxiaSxjaSxkaSwgcmV0ID0gQXJyYXkobSkscmksazAsazEseTAseTEsQSxCLEQsZHgsY3gsc3RvcHMsejAsejEsem0sdDAsdDEsdG07XG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgZm9yKGk9MDtpIT09bTsrK2kpIHtcbiAgICAgICAgYWkgPSB5bFtpXTtcbiAgICAgICAgYmkgPSB5cltpXTtcbiAgICAgICAgY2kgPSBrbFtpXTtcbiAgICAgICAgZGkgPSBrcltpXTtcbiAgICAgICAgcmkgPSBbXTtcbiAgICAgICAgZm9yKGo9MDtqIT09bjtqKyspIHtcbiAgICAgICAgICAgIGlmKGo+MCAmJiBiaVtqXSphaVtqXTwwKSByaS5wdXNoKHhbal0pO1xuICAgICAgICAgICAgZHggPSAoeFtqKzFdLXhbal0pO1xuICAgICAgICAgICAgY3ggPSB4W2pdO1xuICAgICAgICAgICAgeTAgPSBhaVtqXTtcbiAgICAgICAgICAgIHkxID0gYmlbaisxXTtcbiAgICAgICAgICAgIGswID0gY2lbal0vZHg7XG4gICAgICAgICAgICBrMSA9IGRpW2orMV0vZHg7XG4gICAgICAgICAgICBEID0gc3FyKGswLWsxKzMqKHkwLXkxKSkgKyAxMiprMSp5MDtcbiAgICAgICAgICAgIEEgPSBrMSszKnkwKzIqazAtMyp5MTtcbiAgICAgICAgICAgIEIgPSAzKihrMStrMCsyKih5MC15MSkpO1xuICAgICAgICAgICAgaWYoRDw9MCkge1xuICAgICAgICAgICAgICAgIHowID0gQS9CO1xuICAgICAgICAgICAgICAgIGlmKHowPnhbal0gJiYgejA8eFtqKzFdKSBzdG9wcyA9IFt4W2pdLHowLHhbaisxXV07XG4gICAgICAgICAgICAgICAgZWxzZSBzdG9wcyA9IFt4W2pdLHhbaisxXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHowID0gKEEtc3FydChEKSkvQjtcbiAgICAgICAgICAgICAgICB6MSA9IChBK3NxcnQoRCkpL0I7XG4gICAgICAgICAgICAgICAgc3RvcHMgPSBbeFtqXV07XG4gICAgICAgICAgICAgICAgaWYoejA+eFtqXSAmJiB6MDx4W2orMV0pIHN0b3BzLnB1c2goejApO1xuICAgICAgICAgICAgICAgIGlmKHoxPnhbal0gJiYgejE8eFtqKzFdKSBzdG9wcy5wdXNoKHoxKTtcbiAgICAgICAgICAgICAgICBzdG9wcy5wdXNoKHhbaisxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MCA9IHN0b3BzWzBdO1xuICAgICAgICAgICAgejAgPSB0aGlzLl9hdCh0MCxqKTtcbiAgICAgICAgICAgIGZvcihrPTA7azxzdG9wcy5sZW5ndGgtMTtrKyspIHtcbiAgICAgICAgICAgICAgICB0MSA9IHN0b3BzW2srMV07XG4gICAgICAgICAgICAgICAgejEgPSB0aGlzLl9hdCh0MSxqKTtcbiAgICAgICAgICAgICAgICBpZih6MCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaS5wdXNoKHQwKTsgXG4gICAgICAgICAgICAgICAgICAgIHQwID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHowID0gejE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih6MSA9PT0gMCB8fCB6MCp6MT4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHowID0gejE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2lkZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUoMSkge1xuICAgICAgICAgICAgICAgICAgICB0bSA9ICh6MCp0MS16MSp0MCkvKHowLXoxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodG0gPD0gdDAgfHwgdG0gPj0gdDEpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgem0gPSB0aGlzLl9hdCh0bSxqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoem0qejE+MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSB0bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHoxID0gem07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzaWRlID09PSAtMSkgejAqPTAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHptKnowPjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQwID0gdG07XG4gICAgICAgICAgICAgICAgICAgICAgICB6MCA9IHptO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gMSkgejEqPTAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJpLnB1c2godG0pO1xuICAgICAgICAgICAgICAgIHQwID0gc3RvcHNbaysxXTtcbiAgICAgICAgICAgICAgICB6MCA9IHRoaXMuX2F0KHQwLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHoxID09PSAwKSByaS5wdXNoKHQxKTtcbiAgICAgICAgfVxuICAgICAgICByZXRbaV0gPSByaTtcbiAgICB9XG4gICAgaWYodHlwZW9mIHRoaXMueWxbMF0gPT09IFwibnVtYmVyXCIpIHJldHVybiByZXRbMF07XG4gICAgcmV0dXJuIHJldDtcbn1cbm51bWVyaWMuc3BsaW5lID0gZnVuY3Rpb24gc3BsaW5lKHgseSxrMSxrbikge1xuICAgIHZhciBuID0geC5sZW5ndGgsIGIgPSBbXSwgZHggPSBbXSwgZHkgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3ViID0gbnVtZXJpYy5zdWIsbXVsID0gbnVtZXJpYy5tdWwsYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgZm9yKGk9bi0yO2k+PTA7aS0tKSB7IGR4W2ldID0geFtpKzFdLXhbaV07IGR5W2ldID0gc3ViKHlbaSsxXSx5W2ldKTsgfVxuICAgIGlmKHR5cGVvZiBrMSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Yga24gPT09IFwic3RyaW5nXCIpIHsgXG4gICAgICAgIGsxID0ga24gPSBcInBlcmlvZGljXCI7XG4gICAgfVxuICAgIC8vIEJ1aWxkIHNwYXJzZSB0cmlkaWFnb25hbCBzeXN0ZW1cbiAgICB2YXIgVCA9IFtbXSxbXSxbXV07XG4gICAgc3dpdGNoKHR5cGVvZiBrMSkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgYlswXSA9IG11bCgzLyhkeFswXSpkeFswXSksZHlbMF0pO1xuICAgICAgICBUWzBdLnB1c2goMCwwKTtcbiAgICAgICAgVFsxXS5wdXNoKDAsMSk7XG4gICAgICAgIFRbMl0ucHVzaCgyL2R4WzBdLDEvZHhbMF0pO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGJbMF0gPSBhZGQobXVsKDMvKGR4W24tMl0qZHhbbi0yXSksZHlbbi0yXSksbXVsKDMvKGR4WzBdKmR4WzBdKSxkeVswXSkpO1xuICAgICAgICBUWzBdLnB1c2goMCwwLDApO1xuICAgICAgICBUWzFdLnB1c2gobi0yLDAsMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxL2R4W24tMl0sMi9keFtuLTJdKzIvZHhbMF0sMS9keFswXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGJbMF0gPSBrMTtcbiAgICAgICAgVFswXS5wdXNoKDApO1xuICAgICAgICBUWzFdLnB1c2goMCk7XG4gICAgICAgIFRbMl0ucHVzaCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvcihpPTE7aTxuLTE7aSsrKSB7XG4gICAgICAgIGJbaV0gPSBhZGQobXVsKDMvKGR4W2ktMV0qZHhbaS0xXSksZHlbaS0xXSksbXVsKDMvKGR4W2ldKmR4W2ldKSxkeVtpXSkpO1xuICAgICAgICBUWzBdLnB1c2goaSxpLGkpO1xuICAgICAgICBUWzFdLnB1c2goaS0xLGksaSsxKTtcbiAgICAgICAgVFsyXS5wdXNoKDEvZHhbaS0xXSwyL2R4W2ktMV0rMi9keFtpXSwxL2R4W2ldKTtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGVvZiBrbikge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgYltuLTFdID0gbXVsKDMvKGR4W24tMl0qZHhbbi0yXSksZHlbbi0yXSk7XG4gICAgICAgIFRbMF0ucHVzaChuLTEsbi0xKTtcbiAgICAgICAgVFsxXS5wdXNoKG4tMixuLTEpO1xuICAgICAgICBUWzJdLnB1c2goMS9keFtuLTJdLDIvZHhbbi0yXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgVFsxXVtUWzFdLmxlbmd0aC0xXSA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIGJbbi0xXSA9IGtuO1xuICAgICAgICBUWzBdLnB1c2gobi0xKTtcbiAgICAgICAgVFsxXS5wdXNoKG4tMSk7XG4gICAgICAgIFRbMl0ucHVzaCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKHR5cGVvZiBiWzBdICE9PSBcIm51bWJlclwiKSBiID0gbnVtZXJpYy50cmFuc3Bvc2UoYik7XG4gICAgZWxzZSBiID0gW2JdO1xuICAgIHZhciBrID0gQXJyYXkoYi5sZW5ndGgpO1xuICAgIGlmKHR5cGVvZiBrMSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3IoaT1rLmxlbmd0aC0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIGtbaV0gPSBudW1lcmljLmNjc0xVUFNvbHZlKG51bWVyaWMuY2NzTFVQKG51bWVyaWMuY2NzU2NhdHRlcihUKSksYltpXSk7XG4gICAgICAgICAgICBrW2ldW24tMV0gPSBrW2ldWzBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGk9ay5sZW5ndGgtMTtpIT09LTE7LS1pKSB7XG4gICAgICAgICAgICBrW2ldID0gbnVtZXJpYy5jTFVzb2x2ZShudW1lcmljLmNMVShUKSxiW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZih0eXBlb2YgeVswXSA9PT0gXCJudW1iZXJcIikgayA9IGtbMF07XG4gICAgZWxzZSBrID0gbnVtZXJpYy50cmFuc3Bvc2Uoayk7XG4gICAgcmV0dXJuIG5ldyBudW1lcmljLlNwbGluZSh4LHkseSxrLGspO1xufVxuXG4vLyA4LiBGRlRcbm51bWVyaWMuZmZ0cG93MiA9IGZ1bmN0aW9uIGZmdHBvdzIoeCx5KSB7XG4gICAgdmFyIG4gPSB4Lmxlbmd0aDtcbiAgICBpZihuID09PSAxKSByZXR1cm47XG4gICAgdmFyIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbiwgaSxqO1xuICAgIHZhciB4ZSA9IEFycmF5KG4vMiksIHllID0gQXJyYXkobi8yKSwgeG8gPSBBcnJheShuLzIpLCB5byA9IEFycmF5KG4vMik7XG4gICAgaiA9IG4vMjtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIHhvW2pdID0geFtpXTtcbiAgICAgICAgeW9bal0gPSB5W2ldO1xuICAgICAgICAtLWk7XG4gICAgICAgIHhlW2pdID0geFtpXTtcbiAgICAgICAgeWVbal0gPSB5W2ldO1xuICAgIH1cbiAgICBmZnRwb3cyKHhlLHllKTtcbiAgICBmZnRwb3cyKHhvLHlvKTtcbiAgICBqID0gbi8yO1xuICAgIHZhciB0LGsgPSAoLTYuMjgzMTg1MzA3MTc5NTg2NDc2OTI1Mjg2NzY2NTU5MDA1NzY4Mzk0MzM4Nzk4NzUwMjExNjQxOS9uKSxjaSxzaTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICAtLWo7XG4gICAgICAgIGlmKGogPT09IC0xKSBqID0gbi8yLTE7XG4gICAgICAgIHQgPSBrKmk7XG4gICAgICAgIGNpID0gY29zKHQpO1xuICAgICAgICBzaSA9IHNpbih0KTtcbiAgICAgICAgeFtpXSA9IHhlW2pdICsgY2kqeG9bal0gLSBzaSp5b1tqXTtcbiAgICAgICAgeVtpXSA9IHllW2pdICsgY2kqeW9bal0gKyBzaSp4b1tqXTtcbiAgICB9XG59XG5udW1lcmljLl9pZmZ0cG93MiA9IGZ1bmN0aW9uIF9pZmZ0cG93Mih4LHkpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgIGlmKG4gPT09IDEpIHJldHVybjtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luLCBpLGo7XG4gICAgdmFyIHhlID0gQXJyYXkobi8yKSwgeWUgPSBBcnJheShuLzIpLCB4byA9IEFycmF5KG4vMiksIHlvID0gQXJyYXkobi8yKTtcbiAgICBqID0gbi8yO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIC0tajtcbiAgICAgICAgeG9bal0gPSB4W2ldO1xuICAgICAgICB5b1tqXSA9IHlbaV07XG4gICAgICAgIC0taTtcbiAgICAgICAgeGVbal0gPSB4W2ldO1xuICAgICAgICB5ZVtqXSA9IHlbaV07XG4gICAgfVxuICAgIF9pZmZ0cG93Mih4ZSx5ZSk7XG4gICAgX2lmZnRwb3cyKHhvLHlvKTtcbiAgICBqID0gbi8yO1xuICAgIHZhciB0LGsgPSAoNi4yODMxODUzMDcxNzk1ODY0NzY5MjUyODY3NjY1NTkwMDU3NjgzOTQzMzg3OTg3NTAyMTE2NDE5L24pLGNpLHNpO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSB7XG4gICAgICAgIC0tajtcbiAgICAgICAgaWYoaiA9PT0gLTEpIGogPSBuLzItMTtcbiAgICAgICAgdCA9IGsqaTtcbiAgICAgICAgY2kgPSBjb3ModCk7XG4gICAgICAgIHNpID0gc2luKHQpO1xuICAgICAgICB4W2ldID0geGVbal0gKyBjaSp4b1tqXSAtIHNpKnlvW2pdO1xuICAgICAgICB5W2ldID0geWVbal0gKyBjaSp5b1tqXSArIHNpKnhvW2pdO1xuICAgIH1cbn1cbm51bWVyaWMuaWZmdHBvdzIgPSBmdW5jdGlvbiBpZmZ0cG93Mih4LHkpIHtcbiAgICBudW1lcmljLl9pZmZ0cG93Mih4LHkpO1xuICAgIG51bWVyaWMuZGl2ZXEoeCx4Lmxlbmd0aCk7XG4gICAgbnVtZXJpYy5kaXZlcSh5LHkubGVuZ3RoKTtcbn1cbm51bWVyaWMuY29udnBvdzIgPSBmdW5jdGlvbiBjb252cG93MihheCxheSxieCxieSkge1xuICAgIG51bWVyaWMuZmZ0cG93MihheCxheSk7XG4gICAgbnVtZXJpYy5mZnRwb3cyKGJ4LGJ5KTtcbiAgICB2YXIgaSxuID0gYXgubGVuZ3RoLGF4aSxieGksYXlpLGJ5aTtcbiAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkge1xuICAgICAgICBheGkgPSBheFtpXTsgYXlpID0gYXlbaV07IGJ4aSA9IGJ4W2ldOyBieWkgPSBieVtpXTtcbiAgICAgICAgYXhbaV0gPSBheGkqYnhpLWF5aSpieWk7XG4gICAgICAgIGF5W2ldID0gYXhpKmJ5aStheWkqYnhpO1xuICAgIH1cbiAgICBudW1lcmljLmlmZnRwb3cyKGF4LGF5KTtcbn1cbm51bWVyaWMuVC5wcm90b3R5cGUuZmZ0ID0gZnVuY3Rpb24gZmZ0KCkge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIHZhciBuID0geC5sZW5ndGgsIGxvZyA9IE1hdGgubG9nLCBsb2cyID0gbG9nKDIpLFxuICAgICAgICBwID0gTWF0aC5jZWlsKGxvZygyKm4tMSkvbG9nMiksIG0gPSBNYXRoLnBvdygyLHApO1xuICAgIHZhciBjeCA9IG51bWVyaWMucmVwKFttXSwwKSwgY3kgPSBudW1lcmljLnJlcChbbV0sMCksIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgaywgYyA9ICgtMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjAvbiksdDtcbiAgICB2YXIgYSA9IG51bWVyaWMucmVwKFttXSwwKSwgYiA9IG51bWVyaWMucmVwKFttXSwwKSxuaGFsZiA9IE1hdGguZmxvb3Iobi8yKTtcbiAgICBmb3Ioaz0wO2s8bjtrKyspIGFba10gPSB4W2tdO1xuICAgIGlmKHR5cGVvZiB5ICE9PSBcInVuZGVmaW5lZFwiKSBmb3Ioaz0wO2s8bjtrKyspIGJba10gPSB5W2tdO1xuICAgIGN4WzBdID0gMTtcbiAgICBmb3Ioaz0xO2s8PW0vMjtrKyspIHtcbiAgICAgICAgdCA9IGMqayprO1xuICAgICAgICBjeFtrXSA9IGNvcyh0KTtcbiAgICAgICAgY3lba10gPSBzaW4odCk7XG4gICAgICAgIGN4W20ta10gPSBjb3ModCk7XG4gICAgICAgIGN5W20ta10gPSBzaW4odClcbiAgICB9XG4gICAgdmFyIFggPSBuZXcgbnVtZXJpYy5UKGEsYiksIFkgPSBuZXcgbnVtZXJpYy5UKGN4LGN5KTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgbnVtZXJpYy5jb252cG93MihYLngsWC55LG51bWVyaWMuY2xvbmUoWS54KSxudW1lcmljLm5lZyhZLnkpKTtcbiAgICBYID0gWC5tdWwoWSk7XG4gICAgWC54Lmxlbmd0aCA9IG47XG4gICAgWC55Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIFg7XG59XG5udW1lcmljLlQucHJvdG90eXBlLmlmZnQgPSBmdW5jdGlvbiBpZmZ0KCkge1xuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuICAgIHZhciBuID0geC5sZW5ndGgsIGxvZyA9IE1hdGgubG9nLCBsb2cyID0gbG9nKDIpLFxuICAgICAgICBwID0gTWF0aC5jZWlsKGxvZygyKm4tMSkvbG9nMiksIG0gPSBNYXRoLnBvdygyLHApO1xuICAgIHZhciBjeCA9IG51bWVyaWMucmVwKFttXSwwKSwgY3kgPSBudW1lcmljLnJlcChbbV0sMCksIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgaywgYyA9ICgzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMC9uKSx0O1xuICAgIHZhciBhID0gbnVtZXJpYy5yZXAoW21dLDApLCBiID0gbnVtZXJpYy5yZXAoW21dLDApLG5oYWxmID0gTWF0aC5mbG9vcihuLzIpO1xuICAgIGZvcihrPTA7azxuO2srKykgYVtrXSA9IHhba107XG4gICAgaWYodHlwZW9mIHkgIT09IFwidW5kZWZpbmVkXCIpIGZvcihrPTA7azxuO2srKykgYltrXSA9IHlba107XG4gICAgY3hbMF0gPSAxO1xuICAgIGZvcihrPTE7azw9bS8yO2srKykge1xuICAgICAgICB0ID0gYyprKms7XG4gICAgICAgIGN4W2tdID0gY29zKHQpO1xuICAgICAgICBjeVtrXSA9IHNpbih0KTtcbiAgICAgICAgY3hbbS1rXSA9IGNvcyh0KTtcbiAgICAgICAgY3lbbS1rXSA9IHNpbih0KVxuICAgIH1cbiAgICB2YXIgWCA9IG5ldyBudW1lcmljLlQoYSxiKSwgWSA9IG5ldyBudW1lcmljLlQoY3gsY3kpO1xuICAgIFggPSBYLm11bChZKTtcbiAgICBudW1lcmljLmNvbnZwb3cyKFgueCxYLnksbnVtZXJpYy5jbG9uZShZLngpLG51bWVyaWMubmVnKFkueSkpO1xuICAgIFggPSBYLm11bChZKTtcbiAgICBYLngubGVuZ3RoID0gbjtcbiAgICBYLnkubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gWC5kaXYobik7XG59XG5cbi8vOS4gVW5jb25zdHJhaW5lZCBvcHRpbWl6YXRpb25cbm51bWVyaWMuZ3JhZGllbnQgPSBmdW5jdGlvbiBncmFkaWVudChmLHgpIHtcbiAgICB2YXIgbiA9IHgubGVuZ3RoO1xuICAgIHZhciBmMCA9IGYoeCk7XG4gICAgaWYoaXNOYU4oZjApKSB0aHJvdyBuZXcgRXJyb3IoJ2dyYWRpZW50OiBmKHgpIGlzIGEgTmFOIScpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgaSx4MCA9IG51bWVyaWMuY2xvbmUoeCksZjEsZjIsIEogPSBBcnJheShuKTtcbiAgICB2YXIgZGl2ID0gbnVtZXJpYy5kaXYsIHN1YiA9IG51bWVyaWMuc3ViLGVycmVzdCxyb3VuZG9mZixtYXggPSBNYXRoLm1heCxlcHMgPSAxZS0zLGFicyA9IE1hdGguYWJzLCBtaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgdDAsdDEsdDIsaXQ9MCxkMSxkMixOO1xuICAgIGZvcihpPTA7aTxuO2krKykge1xuICAgICAgICB2YXIgaCA9IG1heCgxZS02KmYwLDFlLTgpO1xuICAgICAgICB3aGlsZSgxKSB7XG4gICAgICAgICAgICArK2l0O1xuICAgICAgICAgICAgaWYoaXQ+MjApIHsgdGhyb3cgbmV3IEVycm9yKFwiTnVtZXJpY2FsIGdyYWRpZW50IGZhaWxzXCIpOyB9XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV0raDtcbiAgICAgICAgICAgIGYxID0gZih4MCk7XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV0taDtcbiAgICAgICAgICAgIGYyID0gZih4MCk7XG4gICAgICAgICAgICB4MFtpXSA9IHhbaV07XG4gICAgICAgICAgICBpZihpc05hTihmMSkgfHwgaXNOYU4oZjIpKSB7IGgvPTE2OyBjb250aW51ZTsgfVxuICAgICAgICAgICAgSltpXSA9IChmMS1mMikvKDIqaCk7XG4gICAgICAgICAgICB0MCA9IHhbaV0taDtcbiAgICAgICAgICAgIHQxID0geFtpXTtcbiAgICAgICAgICAgIHQyID0geFtpXStoO1xuICAgICAgICAgICAgZDEgPSAoZjEtZjApL2g7XG4gICAgICAgICAgICBkMiA9IChmMC1mMikvaDtcbiAgICAgICAgICAgIE4gPSBtYXgoYWJzKEpbaV0pLGFicyhmMCksYWJzKGYxKSxhYnMoZjIpLGFicyh0MCksYWJzKHQxKSxhYnModDIpLDFlLTgpO1xuICAgICAgICAgICAgZXJyZXN0ID0gbWluKG1heChhYnMoZDEtSltpXSksYWJzKGQyLUpbaV0pLGFicyhkMS1kMikpL04saC9OKTtcbiAgICAgICAgICAgIGlmKGVycmVzdD5lcHMpIHsgaC89MTY7IH1cbiAgICAgICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBKO1xufVxuXG5udW1lcmljLnVuY21pbiA9IGZ1bmN0aW9uIHVuY21pbihmLHgwLHRvbCxncmFkaWVudCxtYXhpdCxjYWxsYmFjayxvcHRpb25zKSB7XG4gICAgdmFyIGdyYWQgPSBudW1lcmljLmdyYWRpZW50O1xuICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIGlmKHR5cGVvZiB0b2wgPT09IFwidW5kZWZpbmVkXCIpIHsgdG9sID0gMWUtODsgfVxuICAgIGlmKHR5cGVvZiBncmFkaWVudCA9PT0gXCJ1bmRlZmluZWRcIikgeyBncmFkaWVudCA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGdyYWQoZix4KTsgfTsgfVxuICAgIGlmKHR5cGVvZiBtYXhpdCA9PT0gXCJ1bmRlZmluZWRcIikgbWF4aXQgPSAxMDAwO1xuICAgIHgwID0gbnVtZXJpYy5jbG9uZSh4MCk7XG4gICAgdmFyIG4gPSB4MC5sZW5ndGg7XG4gICAgdmFyIGYwID0gZih4MCksZjEsZGYwO1xuICAgIGlmKGlzTmFOKGYwKSkgdGhyb3cgbmV3IEVycm9yKCd1bmNtaW46IGYoeDApIGlzIGEgTmFOIScpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heCwgbm9ybTIgPSBudW1lcmljLm5vcm0yO1xuICAgIHRvbCA9IG1heCh0b2wsbnVtZXJpYy5lcHNpbG9uKTtcbiAgICB2YXIgc3RlcCxnMCxnMSxIMSA9IG9wdGlvbnMuSGludiB8fCBudW1lcmljLmlkZW50aXR5KG4pO1xuICAgIHZhciBkb3QgPSBudW1lcmljLmRvdCwgaW52ID0gbnVtZXJpYy5pbnYsIHN1YiA9IG51bWVyaWMuc3ViLCBhZGQgPSBudW1lcmljLmFkZCwgdGVuID0gbnVtZXJpYy50ZW5zb3IsIGRpdiA9IG51bWVyaWMuZGl2LCBtdWwgPSBudW1lcmljLm11bDtcbiAgICB2YXIgYWxsID0gbnVtZXJpYy5hbGwsIGlzZmluaXRlID0gbnVtZXJpYy5pc0Zpbml0ZSwgbmVnID0gbnVtZXJpYy5uZWc7XG4gICAgdmFyIGl0PTAsaSxzLHgxLHksSHksSHMseXMsaTAsdCxuc3RlcCx0MSx0MjtcbiAgICB2YXIgbXNnID0gXCJcIjtcbiAgICBnMCA9IGdyYWRpZW50KHgwKTtcbiAgICB3aGlsZShpdDxtYXhpdCkge1xuICAgICAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgeyBpZihjYWxsYmFjayhpdCx4MCxmMCxnMCxIMSkpIHsgbXNnID0gXCJDYWxsYmFjayByZXR1cm5lZCB0cnVlXCI7IGJyZWFrOyB9IH1cbiAgICAgICAgaWYoIWFsbChpc2Zpbml0ZShnMCkpKSB7IG1zZyA9IFwiR3JhZGllbnQgaGFzIEluZmluaXR5IG9yIE5hTlwiOyBicmVhazsgfVxuICAgICAgICBzdGVwID0gbmVnKGRvdChIMSxnMCkpO1xuICAgICAgICBpZighYWxsKGlzZmluaXRlKHN0ZXApKSkgeyBtc2cgPSBcIlNlYXJjaCBkaXJlY3Rpb24gaGFzIEluZmluaXR5IG9yIE5hTlwiOyBicmVhazsgfVxuICAgICAgICBuc3RlcCA9IG5vcm0yKHN0ZXApO1xuICAgICAgICBpZihuc3RlcCA8IHRvbCkgeyBtc2c9XCJOZXd0b24gc3RlcCBzbWFsbGVyIHRoYW4gdG9sXCI7IGJyZWFrOyB9XG4gICAgICAgIHQgPSAxO1xuICAgICAgICBkZjAgPSBkb3QoZzAsc3RlcCk7XG4gICAgICAgIC8vIGxpbmUgc2VhcmNoXG4gICAgICAgIHgxID0geDA7XG4gICAgICAgIHdoaWxlKGl0IDwgbWF4aXQpIHtcbiAgICAgICAgICAgIGlmKHQqbnN0ZXAgPCB0b2wpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIHMgPSBtdWwoc3RlcCx0KTtcbiAgICAgICAgICAgIHgxID0gYWRkKHgwLHMpO1xuICAgICAgICAgICAgZjEgPSBmKHgxKTtcbiAgICAgICAgICAgIGlmKGYxLWYwID49IDAuMSp0KmRmMCB8fCBpc05hTihmMSkpIHtcbiAgICAgICAgICAgICAgICB0ICo9IDAuNTtcbiAgICAgICAgICAgICAgICArK2l0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYodCpuc3RlcCA8IHRvbCkgeyBtc2cgPSBcIkxpbmUgc2VhcmNoIHN0ZXAgc2l6ZSBzbWFsbGVyIHRoYW4gdG9sXCI7IGJyZWFrOyB9XG4gICAgICAgIGlmKGl0ID09PSBtYXhpdCkgeyBtc2cgPSBcIm1heGl0IHJlYWNoZWQgZHVyaW5nIGxpbmUgc2VhcmNoXCI7IGJyZWFrOyB9XG4gICAgICAgIGcxID0gZ3JhZGllbnQoeDEpO1xuICAgICAgICB5ID0gc3ViKGcxLGcwKTtcbiAgICAgICAgeXMgPSBkb3QoeSxzKTtcbiAgICAgICAgSHkgPSBkb3QoSDEseSk7XG4gICAgICAgIEgxID0gc3ViKGFkZChIMSxcbiAgICAgICAgICAgICAgICBtdWwoXG4gICAgICAgICAgICAgICAgICAgICAgICAoeXMrZG90KHksSHkpKS8oeXMqeXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuKHMscykgICAgKSksXG4gICAgICAgICAgICAgICAgZGl2KGFkZCh0ZW4oSHkscyksdGVuKHMsSHkpKSx5cykpO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICBmMCA9IGYxO1xuICAgICAgICBnMCA9IGcxO1xuICAgICAgICArK2l0O1xuICAgIH1cbiAgICByZXR1cm4ge3NvbHV0aW9uOiB4MCwgZjogZjAsIGdyYWRpZW50OiBnMCwgaW52SGVzc2lhbjogSDEsIGl0ZXJhdGlvbnM6aXQsIG1lc3NhZ2U6IG1zZ307XG59XG5cbi8vIDEwLiBPZGUgc29sdmVyIChEb3JtYW5kLVByaW5jZSlcbm51bWVyaWMuRG9wcmkgPSBmdW5jdGlvbiBEb3ByaSh4LHksZix5bWlkLGl0ZXJhdGlvbnMsbXNnLGV2ZW50cykge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMueW1pZCA9IHltaWQ7XG4gICAgdGhpcy5pdGVyYXRpb25zID0gaXRlcmF0aW9ucztcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG59XG5udW1lcmljLkRvcHJpLnByb3RvdHlwZS5fYXQgPSBmdW5jdGlvbiBfYXQoeGksaikge1xuICAgIGZ1bmN0aW9uIHNxcih4KSB7IHJldHVybiB4Kng7IH1cbiAgICB2YXIgc29sID0gdGhpcztcbiAgICB2YXIgeHMgPSBzb2wueDtcbiAgICB2YXIgeXMgPSBzb2wueTtcbiAgICB2YXIgazEgPSBzb2wuZjtcbiAgICB2YXIgeW1pZCA9IHNvbC55bWlkO1xuICAgIHZhciBuID0geHMubGVuZ3RoO1xuICAgIHZhciB4MCx4MSx4aCx5MCx5MSx5aCx4aTtcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yLGg7XG4gICAgdmFyIGMgPSAwLjU7XG4gICAgdmFyIGFkZCA9IG51bWVyaWMuYWRkLCBtdWwgPSBudW1lcmljLm11bCxzdWIgPSBudW1lcmljLnN1YiwgcCxxLHc7XG4gICAgeDAgPSB4c1tqXTtcbiAgICB4MSA9IHhzW2orMV07XG4gICAgeTAgPSB5c1tqXTtcbiAgICB5MSA9IHlzW2orMV07XG4gICAgaCAgPSB4MS14MDtcbiAgICB4aCA9IHgwK2MqaDtcbiAgICB5aCA9IHltaWRbal07XG4gICAgcCA9IHN1YihrMVtqICBdLG11bCh5MCwxLyh4MC14aCkrMi8oeDAteDEpKSk7XG4gICAgcSA9IHN1YihrMVtqKzFdLG11bCh5MSwxLyh4MS14aCkrMi8oeDEteDApKSk7XG4gICAgdyA9IFtzcXIoeGkgLSB4MSkgKiAoeGkgLSB4aCkgLyBzcXIoeDAgLSB4MSkgLyAoeDAgLSB4aCksXG4gICAgICAgICBzcXIoeGkgLSB4MCkgKiBzcXIoeGkgLSB4MSkgLyBzcXIoeDAgLSB4aCkgLyBzcXIoeDEgLSB4aCksXG4gICAgICAgICBzcXIoeGkgLSB4MCkgKiAoeGkgLSB4aCkgLyBzcXIoeDEgLSB4MCkgLyAoeDEgLSB4aCksXG4gICAgICAgICAoeGkgLSB4MCkgKiBzcXIoeGkgLSB4MSkgKiAoeGkgLSB4aCkgLyBzcXIoeDAteDEpIC8gKHgwIC0geGgpLFxuICAgICAgICAgKHhpIC0geDEpICogc3FyKHhpIC0geDApICogKHhpIC0geGgpIC8gc3FyKHgwLXgxKSAvICh4MSAtIHhoKV07XG4gICAgcmV0dXJuIGFkZChhZGQoYWRkKGFkZChtdWwoeTAsd1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoeWgsd1sxXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsKHkxLHdbMl0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bCggcCx3WzNdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWwoIHEsd1s0XSkpO1xufVxubnVtZXJpYy5Eb3ByaS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCh4KSB7XG4gICAgdmFyIGksaixrLGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICBpZih0eXBlb2YgeCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YXIgbiA9IHgubGVuZ3RoLCByZXQgPSBBcnJheShuKTtcbiAgICAgICAgZm9yKGk9bi0xO2khPT0tMTstLWkpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHRoaXMuYXQoeFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdmFyIHgwID0gdGhpcy54O1xuICAgIGkgPSAwOyBqID0geDAubGVuZ3RoLTE7XG4gICAgd2hpbGUoai1pPjEpIHtcbiAgICAgICAgayA9IGZsb29yKDAuNSooaStqKSk7XG4gICAgICAgIGlmKHgwW2tdIDw9IHgpIGkgPSBrO1xuICAgICAgICBlbHNlIGogPSBrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXQoeCxpKTtcbn1cblxubnVtZXJpYy5kb3ByaSA9IGZ1bmN0aW9uIGRvcHJpKHgwLHgxLHkwLGYsdG9sLG1heGl0LGV2ZW50KSB7XG4gICAgaWYodHlwZW9mIHRvbCA9PT0gXCJ1bmRlZmluZWRcIikgeyB0b2wgPSAxZS02OyB9XG4gICAgaWYodHlwZW9mIG1heGl0ID09PSBcInVuZGVmaW5lZFwiKSB7IG1heGl0ID0gMTAwMDsgfVxuICAgIHZhciB4cyA9IFt4MF0sIHlzID0gW3kwXSwgazEgPSBbZih4MCx5MCldLCBrMixrMyxrNCxrNSxrNixrNywgeW1pZCA9IFtdO1xuICAgIHZhciBBMiA9IDEvNTtcbiAgICB2YXIgQTMgPSBbMy80MCw5LzQwXTtcbiAgICB2YXIgQTQgPSBbNDQvNDUsLTU2LzE1LDMyLzldO1xuICAgIHZhciBBNSA9IFsxOTM3Mi82NTYxLC0yNTM2MC8yMTg3LDY0NDQ4LzY1NjEsLTIxMi83MjldO1xuICAgIHZhciBBNiA9IFs5MDE3LzMxNjgsLTM1NS8zMyw0NjczMi81MjQ3LDQ5LzE3NiwtNTEwMy8xODY1Nl07XG4gICAgdmFyIGIgPSBbMzUvMzg0LDAsNTAwLzExMTMsMTI1LzE5MiwtMjE4Ny82Nzg0LDExLzg0XTtcbiAgICB2YXIgYm0gPSBbMC41KjYwMjUxOTI3NDMvMzAwODU1NTMxNTIsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAuNSo1MTI1MjI5MjkyNS82NTQwMDgyMTU5OCxcbiAgICAgICAgICAgICAgMC41Ki0yNjkxODY4OTI1LzQ1MTI4MzI5NzI4LFxuICAgICAgICAgICAgICAwLjUqMTg3OTQwMzcyMDY3LzE1OTQ1MzQzMTcwNTYsXG4gICAgICAgICAgICAgIDAuNSotMTc3NjA5NDMzMS8xOTc0MzY0NDI1NixcbiAgICAgICAgICAgICAgMC41KjExMjM3MDk5LzIzNTA0MzM4NF07XG4gICAgdmFyIGMgPSBbMS81LDMvMTAsNC81LDgvOSwxLDFdO1xuICAgIHZhciBlID0gWy03MS81NzYwMCwwLDcxLzE2Njk1LC03MS8xOTIwLDE3MjUzLzMzOTIwMCwtMjIvNTI1LDEvNDBdO1xuICAgIHZhciBpID0gMCxlcixqO1xuICAgIHZhciBoID0gKHgxLXgwKS8xMDtcbiAgICB2YXIgaXQgPSAwO1xuICAgIHZhciBhZGQgPSBudW1lcmljLmFkZCwgbXVsID0gbnVtZXJpYy5tdWwsIHkxLGVyaW5mO1xuICAgIHZhciBtYXggPSBNYXRoLm1heCwgbWluID0gTWF0aC5taW4sIGFicyA9IE1hdGguYWJzLCBub3JtaW5mID0gbnVtZXJpYy5ub3JtaW5mLHBvdyA9IE1hdGgucG93O1xuICAgIHZhciBhbnkgPSBudW1lcmljLmFueSwgbHQgPSBudW1lcmljLmx0LCBhbmQgPSBudW1lcmljLmFuZCwgc3ViID0gbnVtZXJpYy5zdWI7XG4gICAgdmFyIGUwLCBlMSwgZXY7XG4gICAgdmFyIHJldCA9IG5ldyBudW1lcmljLkRvcHJpKHhzLHlzLGsxLHltaWQsLTEsXCJcIik7XG4gICAgaWYodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIGUwID0gZXZlbnQoeDAseTApO1xuICAgIHdoaWxlKHgwPHgxICYmIGl0PG1heGl0KSB7XG4gICAgICAgICsraXQ7XG4gICAgICAgIGlmKHgwK2g+eDEpIGggPSB4MS14MDtcbiAgICAgICAgazIgPSBmKHgwK2NbMF0qaCwgICAgICAgICAgICAgICAgYWRkKHkwLG11bCggICBBMipoLGsxW2ldKSkpO1xuICAgICAgICBrMyA9IGYoeDArY1sxXSpoLCAgICAgICAgICAgIGFkZChhZGQoeTAsbXVsKEEzWzBdKmgsazFbaV0pKSxtdWwoQTNbMV0qaCxrMikpKTtcbiAgICAgICAgazQgPSBmKHgwK2NbMl0qaCwgICAgICAgIGFkZChhZGQoYWRkKHkwLG11bChBNFswXSpoLGsxW2ldKSksbXVsKEE0WzFdKmgsazIpKSxtdWwoQTRbMl0qaCxrMykpKTtcbiAgICAgICAgazUgPSBmKHgwK2NbM10qaCwgICAgYWRkKGFkZChhZGQoYWRkKHkwLG11bChBNVswXSpoLGsxW2ldKSksbXVsKEE1WzFdKmgsazIpKSxtdWwoQTVbMl0qaCxrMykpLG11bChBNVszXSpoLGs0KSkpO1xuICAgICAgICBrNiA9IGYoeDArY1s0XSpoLGFkZChhZGQoYWRkKGFkZChhZGQoeTAsbXVsKEE2WzBdKmgsazFbaV0pKSxtdWwoQTZbMV0qaCxrMikpLG11bChBNlsyXSpoLGszKSksbXVsKEE2WzNdKmgsazQpKSxtdWwoQTZbNF0qaCxrNSkpKTtcbiAgICAgICAgeTEgPSBhZGQoYWRkKGFkZChhZGQoYWRkKHkwLG11bChrMVtpXSxoKmJbMF0pKSxtdWwoazMsaCpiWzJdKSksbXVsKGs0LGgqYlszXSkpLG11bChrNSxoKmJbNF0pKSxtdWwoazYsaCpiWzVdKSk7XG4gICAgICAgIGs3ID0gZih4MCtoLHkxKTtcbiAgICAgICAgZXIgPSBhZGQoYWRkKGFkZChhZGQoYWRkKG11bChrMVtpXSxoKmVbMF0pLG11bChrMyxoKmVbMl0pKSxtdWwoazQsaCplWzNdKSksbXVsKGs1LGgqZVs0XSkpLG11bChrNixoKmVbNV0pKSxtdWwoazcsaCplWzZdKSk7XG4gICAgICAgIGlmKHR5cGVvZiBlciA9PT0gXCJudW1iZXJcIikgZXJpbmYgPSBhYnMoZXIpO1xuICAgICAgICBlbHNlIGVyaW5mID0gbm9ybWluZihlcik7XG4gICAgICAgIGlmKGVyaW5mID4gdG9sKSB7IC8vIHJlamVjdFxuICAgICAgICAgICAgaCA9IDAuMipoKnBvdyh0b2wvZXJpbmYsMC4yNSk7XG4gICAgICAgICAgICBpZih4MCtoID09PSB4MCkge1xuICAgICAgICAgICAgICAgIHJldC5tc2cgPSBcIlN0ZXAgc2l6ZSBiZWNhbWUgdG9vIHNtYWxsXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB5bWlkW2ldID0gYWRkKGFkZChhZGQoYWRkKGFkZChhZGQoeTAsXG4gICAgICAgICAgICAgICAgbXVsKGsxW2ldLGgqYm1bMF0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazMgICAsaCpibVsyXSkpLFxuICAgICAgICAgICAgICAgIG11bChrNCAgICxoKmJtWzNdKSksXG4gICAgICAgICAgICAgICAgbXVsKGs1ICAgLGgqYm1bNF0pKSxcbiAgICAgICAgICAgICAgICBtdWwoazYgICAsaCpibVs1XSkpLFxuICAgICAgICAgICAgICAgIG11bChrNyAgICxoKmJtWzZdKSk7XG4gICAgICAgICsraTtcbiAgICAgICAgeHNbaV0gPSB4MCtoO1xuICAgICAgICB5c1tpXSA9IHkxO1xuICAgICAgICBrMVtpXSA9IGs3O1xuICAgICAgICBpZih0eXBlb2YgZXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHlpLHhsID0geDAseHIgPSB4MCswLjUqaCx4aTtcbiAgICAgICAgICAgIGUxID0gZXZlbnQoeHIseW1pZFtpLTFdKTtcbiAgICAgICAgICAgIGV2ID0gYW5kKGx0KGUwLDApLGx0KDAsZTEpKTtcbiAgICAgICAgICAgIGlmKCFhbnkoZXYpKSB7IHhsID0geHI7IHhyID0geDAraDsgZTAgPSBlMTsgZTEgPSBldmVudCh4cix5MSk7IGV2ID0gYW5kKGx0KGUwLDApLGx0KDAsZTEpKTsgfVxuICAgICAgICAgICAgaWYoYW55KGV2KSkge1xuICAgICAgICAgICAgICAgIHZhciB4YywgeWMsIGVuLGVpO1xuICAgICAgICAgICAgICAgIHZhciBzaWRlPTAsIHNsID0gMS4wLCBzciA9IDEuMDtcbiAgICAgICAgICAgICAgICB3aGlsZSgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBlMCA9PT0gXCJudW1iZXJcIikgeGkgPSAoc3IqZTEqeGwtc2wqZTAqeHIpLyhzciplMS1zbCplMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSB4cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqPWUwLmxlbmd0aC0xO2ohPT0tMTstLWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlMFtqXTwwICYmIGUxW2pdPjApIHhpID0gbWluKHhpLChzciplMVtqXSp4bC1zbCplMFtqXSp4cikvKHNyKmUxW2pdLXNsKmUwW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoeGkgPD0geGwgfHwgeGkgPj0geHIpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IHJldC5fYXQoeGksIGktMSk7XG4gICAgICAgICAgICAgICAgICAgIGVpID0gZXZlbnQoeGkseWkpO1xuICAgICAgICAgICAgICAgICAgICBlbiA9IGFuZChsdChlMCwwKSxsdCgwLGVpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGFueShlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhyID0geGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlMSA9IGVpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSBlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gLTEpIHNsICo9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugc2wgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bCA9IHhpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZTAgPSBlaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lkZSA9PT0gMSkgc3IgKj0gMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBzciA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHkxID0gcmV0Ll9hdCgwLjUqKHgwK3hpKSxpLTEpO1xuICAgICAgICAgICAgICAgIHJldC5mW2ldID0gZih4aSx5aSk7XG4gICAgICAgICAgICAgICAgcmV0LnhbaV0gPSB4aTtcbiAgICAgICAgICAgICAgICByZXQueVtpXSA9IHlpO1xuICAgICAgICAgICAgICAgIHJldC55bWlkW2ktMV0gPSB5MTtcbiAgICAgICAgICAgICAgICByZXQuZXZlbnRzID0gZXY7XG4gICAgICAgICAgICAgICAgcmV0Lml0ZXJhdGlvbnMgPSBpdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHgwICs9IGg7XG4gICAgICAgIHkwID0geTE7XG4gICAgICAgIGUwID0gZTE7XG4gICAgICAgIGggPSBtaW4oMC44KmgqcG93KHRvbC9lcmluZiwwLjI1KSw0KmgpO1xuICAgIH1cbiAgICByZXQuaXRlcmF0aW9ucyA9IGl0O1xuICAgIHJldHVybiByZXQ7XG59XG5cbi8vIDExLiBBeCA9IGJcbm51bWVyaWMuTFUgPSBmdW5jdGlvbihBLCBmYXN0KSB7XG4gIGZhc3QgPSBmYXN0IHx8IGZhbHNlO1xuXG4gIHZhciBhYnMgPSBNYXRoLmFicztcbiAgdmFyIGksIGosIGssIGFic0FqaywgQWtrLCBBaywgUGssIEFpO1xuICB2YXIgbWF4O1xuICB2YXIgbiA9IEEubGVuZ3RoLCBuMSA9IG4tMTtcbiAgdmFyIFAgPSBuZXcgQXJyYXkobik7XG4gIGlmKCFmYXN0KSBBID0gbnVtZXJpYy5jbG9uZShBKTtcblxuICBmb3IgKGsgPSAwOyBrIDwgbjsgKytrKSB7XG4gICAgUGsgPSBrO1xuICAgIEFrID0gQVtrXTtcbiAgICBtYXggPSBhYnMoQWtba10pO1xuICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgKytqKSB7XG4gICAgICBhYnNBamsgPSBhYnMoQVtqXVtrXSk7XG4gICAgICBpZiAobWF4IDwgYWJzQWprKSB7XG4gICAgICAgIG1heCA9IGFic0FqaztcbiAgICAgICAgUGsgPSBqO1xuICAgICAgfVxuICAgIH1cbiAgICBQW2tdID0gUGs7XG5cbiAgICBpZiAoUGsgIT0gaykge1xuICAgICAgQVtrXSA9IEFbUGtdO1xuICAgICAgQVtQa10gPSBBaztcbiAgICAgIEFrID0gQVtrXTtcbiAgICB9XG5cbiAgICBBa2sgPSBBa1trXTtcblxuICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgbjsgKytpKSB7XG4gICAgICBBW2ldW2tdIC89IEFraztcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBrICsgMTsgaSA8IG47ICsraSkge1xuICAgICAgQWkgPSBBW2ldO1xuICAgICAgZm9yIChqID0gayArIDE7IGogPCBuMTsgKytqKSB7XG4gICAgICAgIEFpW2pdIC09IEFpW2tdICogQWtbal07XG4gICAgICAgICsrajtcbiAgICAgICAgQWlbal0gLT0gQWlba10gKiBBa1tqXTtcbiAgICAgIH1cbiAgICAgIGlmKGo9PT1uMSkgQWlbal0gLT0gQWlba10gKiBBa1tqXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIExVOiBBLFxuICAgIFA6ICBQXG4gIH07XG59XG5cbm51bWVyaWMuTFVzb2x2ZSA9IGZ1bmN0aW9uIExVc29sdmUoTFVQLCBiKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgTFUgPSBMVVAuTFU7XG4gIHZhciBuICAgPSBMVS5sZW5ndGg7XG4gIHZhciB4ID0gbnVtZXJpYy5jbG9uZShiKTtcbiAgdmFyIFAgICA9IExVUC5QO1xuICB2YXIgUGksIExVaSwgTFVpaSwgdG1wO1xuXG4gIGZvciAoaT1uLTE7aSE9PS0xOy0taSkgeFtpXSA9IGJbaV07XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBQaSA9IFBbaV07XG4gICAgaWYgKFBbaV0gIT09IGkpIHtcbiAgICAgIHRtcCA9IHhbaV07XG4gICAgICB4W2ldID0geFtQaV07XG4gICAgICB4W1BpXSA9IHRtcDtcbiAgICB9XG5cbiAgICBMVWkgPSBMVVtpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgaTsgKytqKSB7XG4gICAgICB4W2ldIC09IHhbal0gKiBMVWlbal07XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgTFVpID0gTFVbaV07XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIHhbaV0gLT0geFtqXSAqIExVaVtqXTtcbiAgICB9XG5cbiAgICB4W2ldIC89IExVaVtpXTtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuXG5udW1lcmljLnNvbHZlID0gZnVuY3Rpb24gc29sdmUoQSxiLGZhc3QpIHsgcmV0dXJuIG51bWVyaWMuTFVzb2x2ZShudW1lcmljLkxVKEEsZmFzdCksIGIpOyB9XG5cbi8vIDEyLiBMaW5lYXIgcHJvZ3JhbW1pbmdcbm51bWVyaWMuZWNoZWxvbml6ZSA9IGZ1bmN0aW9uIGVjaGVsb25pemUoQSkge1xuICAgIHZhciBzID0gbnVtZXJpYy5kaW0oQSksIG0gPSBzWzBdLCBuID0gc1sxXTtcbiAgICB2YXIgSSA9IG51bWVyaWMuaWRlbnRpdHkobSk7XG4gICAgdmFyIFAgPSBBcnJheShtKTtcbiAgICB2YXIgaSxqLGssbCxBaSxJaSxaLGE7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBkaXZlcSA9IG51bWVyaWMuZGl2ZXE7XG4gICAgQSA9IG51bWVyaWMuY2xvbmUoQSk7XG4gICAgZm9yKGk9MDtpPG07KytpKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgICBBaSA9IEFbaV07XG4gICAgICAgIElpID0gSVtpXTtcbiAgICAgICAgZm9yKGo9MTtqPG47KytqKSBpZihhYnMoQWlba10pPGFicyhBaVtqXSkpIGs9ajtcbiAgICAgICAgUFtpXSA9IGs7XG4gICAgICAgIGRpdmVxKElpLEFpW2tdKTtcbiAgICAgICAgZGl2ZXEoQWksQWlba10pO1xuICAgICAgICBmb3Ioaj0wO2o8bTsrK2opIGlmKGohPT1pKSB7XG4gICAgICAgICAgICBaID0gQVtqXTsgYSA9IFpba107XG4gICAgICAgICAgICBmb3IobD1uLTE7bCE9PS0xOy0tbCkgWltsXSAtPSBBaVtsXSphO1xuICAgICAgICAgICAgWiA9IElbal07XG4gICAgICAgICAgICBmb3IobD1tLTE7bCE9PS0xOy0tbCkgWltsXSAtPSBJaVtsXSphO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7STpJLCBBOkEsIFA6UH07XG59XG5cbm51bWVyaWMuX19zb2x2ZUxQID0gZnVuY3Rpb24gX19zb2x2ZUxQKGMsQSxiLHRvbCxtYXhpdCx4LGZsYWcpIHtcbiAgICB2YXIgc3VtID0gbnVtZXJpYy5zdW0sIGxvZyA9IG51bWVyaWMubG9nLCBtdWwgPSBudW1lcmljLm11bCwgc3ViID0gbnVtZXJpYy5zdWIsIGRvdCA9IG51bWVyaWMuZG90LCBkaXYgPSBudW1lcmljLmRpdiwgYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgdmFyIG0gPSBjLmxlbmd0aCwgbiA9IGIubGVuZ3RoLHk7XG4gICAgdmFyIHVuYm91bmRlZCA9IGZhbHNlLCBjYixpMD0wO1xuICAgIHZhciBhbHBoYSA9IDEuMDtcbiAgICB2YXIgZjAsZGYwLEFUID0gbnVtZXJpYy50cmFuc3Bvc2UoQSksIHN2ZCA9IG51bWVyaWMuc3ZkLHRyYW5zcG9zZSA9IG51bWVyaWMudHJhbnNwb3NlLGxlcSA9IG51bWVyaWMubGVxLCBzcXJ0ID0gTWF0aC5zcXJ0LCBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgbXVsZXEgPSBudW1lcmljLm11bGVxO1xuICAgIHZhciBub3JtID0gbnVtZXJpYy5ub3JtaW5mLCBhbnkgPSBudW1lcmljLmFueSxtaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgYWxsID0gbnVtZXJpYy5hbGwsIGd0ID0gbnVtZXJpYy5ndDtcbiAgICB2YXIgcCA9IEFycmF5KG0pLCBBMCA9IEFycmF5KG4pLGU9bnVtZXJpYy5yZXAoW25dLDEpLCBIO1xuICAgIHZhciBzb2x2ZSA9IG51bWVyaWMuc29sdmUsIHogPSBzdWIoYixkb3QoQSx4KSksY291bnQ7XG4gICAgdmFyIGRvdGNjID0gZG90KGMsYyk7XG4gICAgdmFyIGc7XG4gICAgZm9yKGNvdW50PWkwO2NvdW50PG1heGl0OysrY291bnQpIHtcbiAgICAgICAgdmFyIGksaixkO1xuICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgQTBbaV0gPSBkaXYoQVtpXSx6W2ldKTtcbiAgICAgICAgdmFyIEExID0gdHJhbnNwb3NlKEEwKTtcbiAgICAgICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIHBbaV0gPSAoLyp4W2ldKyovc3VtKEExW2ldKSk7XG4gICAgICAgIGFscGhhID0gMC4yNSphYnMoZG90Y2MvZG90KGMscCkpO1xuICAgICAgICB2YXIgYTEgPSAxMDAqc3FydChkb3RjYy9kb3QocCxwKSk7XG4gICAgICAgIGlmKCFpc0Zpbml0ZShhbHBoYSkgfHwgYWxwaGE+YTEpIGFscGhhID0gYTE7XG4gICAgICAgIGcgPSBhZGQoYyxtdWwoYWxwaGEscCkpO1xuICAgICAgICBIID0gZG90KEExLEEwKTtcbiAgICAgICAgZm9yKGk9bS0xO2khPT0tMTstLWkpIEhbaV1baV0gKz0gMTtcbiAgICAgICAgZCA9IHNvbHZlKEgsZGl2KGcsYWxwaGEpLHRydWUpO1xuICAgICAgICB2YXIgdDAgPSBkaXYoeixkb3QoQSxkKSk7XG4gICAgICAgIHZhciB0ID0gMS4wO1xuICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgaWYodDBbaV08MCkgdCA9IG1pbih0LC0wLjk5OSp0MFtpXSk7XG4gICAgICAgIHkgPSBzdWIoeCxtdWwoZCx0KSk7XG4gICAgICAgIHogPSBzdWIoYixkb3QoQSx5KSk7XG4gICAgICAgIGlmKCFhbGwoZ3QoeiwwKSkpIHJldHVybiB7IHNvbHV0aW9uOiB4LCBtZXNzYWdlOiBcIlwiLCBpdGVyYXRpb25zOiBjb3VudCB9O1xuICAgICAgICB4ID0geTtcbiAgICAgICAgaWYoYWxwaGE8dG9sKSByZXR1cm4geyBzb2x1dGlvbjogeSwgbWVzc2FnZTogXCJcIiwgaXRlcmF0aW9uczogY291bnQgfTtcbiAgICAgICAgaWYoZmxhZykge1xuICAgICAgICAgICAgdmFyIHMgPSBkb3QoYyxnKSwgQWcgPSBkb3QoQSxnKTtcbiAgICAgICAgICAgIHVuYm91bmRlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IoaT1uLTE7aSE9PS0xOy0taSkgaWYocypBZ1tpXTwwKSB7IHVuYm91bmRlZCA9IGZhbHNlOyBicmVhazsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoeFttLTFdPj0wKSB1bmJvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgdW5ib3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih1bmJvdW5kZWQpIHJldHVybiB7IHNvbHV0aW9uOiB5LCBtZXNzYWdlOiBcIlVuYm91bmRlZFwiLCBpdGVyYXRpb25zOiBjb3VudCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzb2x1dGlvbjogeCwgbWVzc2FnZTogXCJtYXhpbXVtIGl0ZXJhdGlvbiBjb3VudCBleGNlZWRlZFwiLCBpdGVyYXRpb25zOmNvdW50IH07XG59XG5cbm51bWVyaWMuX3NvbHZlTFAgPSBmdW5jdGlvbiBfc29sdmVMUChjLEEsYix0b2wsbWF4aXQpIHtcbiAgICB2YXIgbSA9IGMubGVuZ3RoLCBuID0gYi5sZW5ndGgseTtcbiAgICB2YXIgc3VtID0gbnVtZXJpYy5zdW0sIGxvZyA9IG51bWVyaWMubG9nLCBtdWwgPSBudW1lcmljLm11bCwgc3ViID0gbnVtZXJpYy5zdWIsIGRvdCA9IG51bWVyaWMuZG90LCBkaXYgPSBudW1lcmljLmRpdiwgYWRkID0gbnVtZXJpYy5hZGQ7XG4gICAgdmFyIGMwID0gbnVtZXJpYy5yZXAoW21dLDApLmNvbmNhdChbMV0pO1xuICAgIHZhciBKID0gbnVtZXJpYy5yZXAoW24sMV0sLTEpO1xuICAgIHZhciBBMCA9IG51bWVyaWMuYmxvY2tNYXRyaXgoW1tBICAgICAgICAgICAgICAgICAgICwgICBKICBdXSk7XG4gICAgdmFyIGIwID0gYjtcbiAgICB2YXIgeSA9IG51bWVyaWMucmVwKFttXSwwKS5jb25jYXQoTWF0aC5tYXgoMCxudW1lcmljLnN1cChudW1lcmljLm5lZyhiKSkpKzEpO1xuICAgIHZhciB4MCA9IG51bWVyaWMuX19zb2x2ZUxQKGMwLEEwLGIwLHRvbCxtYXhpdCx5LGZhbHNlKTtcbiAgICB2YXIgeCA9IG51bWVyaWMuY2xvbmUoeDAuc29sdXRpb24pO1xuICAgIHgubGVuZ3RoID0gbTtcbiAgICB2YXIgZm9vID0gbnVtZXJpYy5pbmYoc3ViKGIsZG90KEEseCkpKTtcbiAgICBpZihmb288MCkgeyByZXR1cm4geyBzb2x1dGlvbjogTmFOLCBtZXNzYWdlOiBcIkluZmVhc2libGVcIiwgaXRlcmF0aW9uczogeDAuaXRlcmF0aW9ucyB9OyB9XG4gICAgdmFyIHJldCA9IG51bWVyaWMuX19zb2x2ZUxQKGMsIEEsIGIsIHRvbCwgbWF4aXQteDAuaXRlcmF0aW9ucywgeCwgdHJ1ZSk7XG4gICAgcmV0Lml0ZXJhdGlvbnMgKz0geDAuaXRlcmF0aW9ucztcbiAgICByZXR1cm4gcmV0O1xufTtcblxubnVtZXJpYy5zb2x2ZUxQID0gZnVuY3Rpb24gc29sdmVMUChjLEEsYixBZXEsYmVxLHRvbCxtYXhpdCkge1xuICAgIGlmKHR5cGVvZiBtYXhpdCA9PT0gXCJ1bmRlZmluZWRcIikgbWF4aXQgPSAxMDAwO1xuICAgIGlmKHR5cGVvZiB0b2wgPT09IFwidW5kZWZpbmVkXCIpIHRvbCA9IG51bWVyaWMuZXBzaWxvbjtcbiAgICBpZih0eXBlb2YgQWVxID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVtZXJpYy5fc29sdmVMUChjLEEsYix0b2wsbWF4aXQpO1xuICAgIHZhciBtID0gQWVxLmxlbmd0aCwgbiA9IEFlcVswXS5sZW5ndGgsIG8gPSBBLmxlbmd0aDtcbiAgICB2YXIgQiA9IG51bWVyaWMuZWNoZWxvbml6ZShBZXEpO1xuICAgIHZhciBmbGFncyA9IG51bWVyaWMucmVwKFtuXSwwKTtcbiAgICB2YXIgUCA9IEIuUDtcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgZmxhZ3NbUFtpXV0gPSAxO1xuICAgIGZvcihpPW4tMTtpIT09LTE7LS1pKSBpZihmbGFnc1tpXT09PTApIFEucHVzaChpKTtcbiAgICB2YXIgZyA9IG51bWVyaWMuZ2V0UmFuZ2U7XG4gICAgdmFyIEkgPSBudW1lcmljLmxpbnNwYWNlKDAsbS0xKSwgSiA9IG51bWVyaWMubGluc3BhY2UoMCxvLTEpO1xuICAgIHZhciBBZXEyID0gZyhBZXEsSSxRKSwgQTEgPSBnKEEsSixQKSwgQTIgPSBnKEEsSixRKSwgZG90ID0gbnVtZXJpYy5kb3QsIHN1YiA9IG51bWVyaWMuc3ViO1xuICAgIHZhciBBMyA9IGRvdChBMSxCLkkpO1xuICAgIHZhciBBNCA9IHN1YihBMixkb3QoQTMsQWVxMikpLCBiNCA9IHN1YihiLGRvdChBMyxiZXEpKTtcbiAgICB2YXIgYzEgPSBBcnJheShQLmxlbmd0aCksIGMyID0gQXJyYXkoUS5sZW5ndGgpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgYzFbaV0gPSBjW1BbaV1dO1xuICAgIGZvcihpPVEubGVuZ3RoLTE7aSE9PS0xOy0taSkgYzJbaV0gPSBjW1FbaV1dO1xuICAgIHZhciBjNCA9IHN1YihjMixkb3QoYzEsZG90KEIuSSxBZXEyKSkpO1xuICAgIHZhciBTID0gbnVtZXJpYy5fc29sdmVMUChjNCxBNCxiNCx0b2wsbWF4aXQpO1xuICAgIHZhciB4MiA9IFMuc29sdXRpb247XG4gICAgaWYoeDIhPT14MikgcmV0dXJuIFM7XG4gICAgdmFyIHgxID0gZG90KEIuSSxzdWIoYmVxLGRvdChBZXEyLHgyKSkpO1xuICAgIHZhciB4ID0gQXJyYXkoYy5sZW5ndGgpO1xuICAgIGZvcihpPVAubGVuZ3RoLTE7aSE9PS0xOy0taSkgeFtQW2ldXSA9IHgxW2ldO1xuICAgIGZvcihpPVEubGVuZ3RoLTE7aSE9PS0xOy0taSkgeFtRW2ldXSA9IHgyW2ldO1xuICAgIHJldHVybiB7IHNvbHV0aW9uOiB4LCBtZXNzYWdlOlMubWVzc2FnZSwgaXRlcmF0aW9uczogUy5pdGVyYXRpb25zIH07XG59XG5cbm51bWVyaWMuTVBTdG9MUCA9IGZ1bmN0aW9uIE1QU3RvTFAoTVBTKSB7XG4gICAgaWYoTVBTIGluc3RhbmNlb2YgU3RyaW5nKSB7IE1QUy5zcGxpdCgnXFxuJyk7IH1cbiAgICB2YXIgc3RhdGUgPSAwO1xuICAgIHZhciBzdGF0ZXMgPSBbJ0luaXRpYWwgc3RhdGUnLCdOQU1FJywnUk9XUycsJ0NPTFVNTlMnLCdSSFMnLCdCT1VORFMnLCdFTkRBVEEnXTtcbiAgICB2YXIgbiA9IE1QUy5sZW5ndGg7XG4gICAgdmFyIGksaix6LE49MCxyb3dzID0ge30sIHNpZ24gPSBbXSwgcmwgPSAwLCB2YXJzID0ge30sIG52ID0gMDtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgYyA9IFtdLCBBID0gW10sIGIgPSBbXTtcbiAgICBmdW5jdGlvbiBlcnIoZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ01QU3RvTFA6ICcrZSsnXFxuTGluZSAnK2krJzogJytNUFNbaV0rJ1xcbkN1cnJlbnQgc3RhdGU6ICcrc3RhdGVzW3N0YXRlXSsnXFxuJyk7IH1cbiAgICBmb3IoaT0wO2k8bjsrK2kpIHtcbiAgICAgICAgeiA9IE1QU1tpXTtcbiAgICAgICAgdmFyIHcwID0gei5tYXRjaCgvXFxTKi9nKTtcbiAgICAgICAgdmFyIHcgPSBbXTtcbiAgICAgICAgZm9yKGo9MDtqPHcwLmxlbmd0aDsrK2opIGlmKHcwW2pdIT09XCJcIikgdy5wdXNoKHcwW2pdKTtcbiAgICAgICAgaWYody5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgICBmb3Ioaj0wO2o8c3RhdGVzLmxlbmd0aDsrK2opIGlmKHouc3Vic3RyKDAsc3RhdGVzW2pdLmxlbmd0aCkgPT09IHN0YXRlc1tqXSkgYnJlYWs7XG4gICAgICAgIGlmKGo8c3RhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhdGUgPSBqO1xuICAgICAgICAgICAgaWYoaj09PTEpIHsgbmFtZSA9IHdbMV07IH1cbiAgICAgICAgICAgIGlmKGo9PT02KSByZXR1cm4geyBuYW1lOm5hbWUsIGM6YywgQTpudW1lcmljLnRyYW5zcG9zZShBKSwgYjpiLCByb3dzOnJvd3MsIHZhcnM6dmFycyB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgMDogY2FzZSAxOiBlcnIoJ1VuZXhwZWN0ZWQgbGluZScpO1xuICAgICAgICBjYXNlIDI6IFxuICAgICAgICAgICAgc3dpdGNoKHdbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOiBpZihOPT09MCkgTiA9IHdbMV07IGVsc2UgZXJyKCdUd28gb3IgbW9yZSBOIHJvd3MnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IDE7IGJbcmxdID0gMDsgKytybDsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IC0xO2JbcmxdID0gMDsgKytybDsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFJzogcm93c1t3WzFdXSA9IHJsOyBzaWduW3JsXSA9IDA7YltybF0gPSAwOyArK3JsOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGVycignUGFyc2UgZXJyb3IgJytudW1lcmljLnByZXR0eVByaW50KHcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZighdmFycy5oYXNPd25Qcm9wZXJ0eSh3WzBdKSkgeyB2YXJzW3dbMF1dID0gbnY7IGNbbnZdID0gMDsgQVtudl0gPSBudW1lcmljLnJlcChbcmxdLDApOyArK252OyB9XG4gICAgICAgICAgICB2YXIgcCA9IHZhcnNbd1swXV07XG4gICAgICAgICAgICBmb3Ioaj0xO2o8dy5sZW5ndGg7ais9Mikge1xuICAgICAgICAgICAgICAgIGlmKHdbal0gPT09IE4pIHsgY1twXSA9IHBhcnNlRmxvYXQod1tqKzFdKTsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICB2YXIgcSA9IHJvd3Nbd1tqXV07XG4gICAgICAgICAgICAgICAgQVtwXVtxXSA9IChzaWduW3FdPDA/LTE6MSkqcGFyc2VGbG9hdCh3W2orMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGZvcihqPTE7ajx3Lmxlbmd0aDtqKz0yKSBiW3Jvd3Nbd1tqXV1dID0gKHNpZ25bcm93c1t3W2pdXV08MD8tMToxKSpwYXJzZUZsb2F0KHdbaisxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OiAvKkZJWE1FKi8gYnJlYWs7XG4gICAgICAgIGNhc2UgNjogZXJyKCdJbnRlcm5hbCBlcnJvcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVycignUmVhY2hlZCBlbmQgb2YgZmlsZSB3aXRob3V0IEVOREFUQScpO1xufVxuLy8gc2VlZHJhbmRvbS5qcyB2ZXJzaW9uIDIuMC5cbi8vIEF1dGhvcjogRGF2aWQgQmF1IDQvMi8yMDExXG4vL1xuLy8gRGVmaW5lcyBhIG1ldGhvZCBNYXRoLnNlZWRyYW5kb20oKSB0aGF0LCB3aGVuIGNhbGxlZCwgc3Vic3RpdHV0ZXNcbi8vIGFuIGV4cGxpY2l0bHkgc2VlZGVkIFJDNC1iYXNlZCBhbGdvcml0aG0gZm9yIE1hdGgucmFuZG9tKCkuICBBbHNvXG4vLyBzdXBwb3J0cyBhdXRvbWF0aWMgc2VlZGluZyBmcm9tIGxvY2FsIG9yIG5ldHdvcmsgc291cmNlcyBvZiBlbnRyb3B5LlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vICAgPHNjcmlwdCBzcmM9aHR0cDovL2RhdmlkYmF1LmNvbS9lbmNvZGUvc2VlZHJhbmRvbS1taW4uanM+PC9zY3JpcHQ+XG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oJ3lpcGVlJyk7IFNldHMgTWF0aC5yYW5kb20gdG8gYSBmdW5jdGlvbiB0aGF0IGlzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIGdpdmVuIGV4cGxpY2l0IHNlZWQuXG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oKTsgICAgICAgIFNldHMgTWF0aC5yYW5kb20gdG8gYSBmdW5jdGlvbiB0aGF0IGlzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZGVkIHVzaW5nIHRoZSBjdXJyZW50IHRpbWUsIGRvbSBzdGF0ZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgb3RoZXIgYWNjdW11bGF0ZWQgbG9jYWwgZW50cm9weS5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZ2VuZXJhdGVkIHNlZWQgc3RyaW5nIGlzIHJldHVybmVkLlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKCd5b3d6YScsIHRydWUpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZWRzIHVzaW5nIHRoZSBnaXZlbiBleHBsaWNpdCBzZWVkIG1peGVkXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9nZXRoZXIgd2l0aCBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuLy9cbi8vICAgPHNjcmlwdCBzcmM9XCJodHRwOi8vYml0Lmx5L3NyYW5kb20tNTEyXCI+PC9zY3JpcHQ+XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlZHMgdXNpbmcgcGh5c2ljYWwgcmFuZG9tIGJpdHMgZG93bmxvYWRlZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gcmFuZG9tLm9yZy5cbi8vXG4vLyAgIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9qc29ubGliLmFwcHNwb3QuY29tL3VyYW5kb20/Y2FsbGJhY2s9TWF0aC5zZWVkcmFuZG9tXCI+XG4vLyAgIDwvc2NyaXB0PiAgICAgICAgICAgICAgICAgU2VlZHMgdXNpbmcgdXJhbmRvbSBiaXRzIGZyb20gY2FsbC5qc29ubGliLmNvbSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBpcyBmYXN0ZXIgdGhhbiByYW5kb20ub3JnLlxuLy9cbi8vIEV4YW1wbGVzOlxuLy9cbi8vICAgTWF0aC5zZWVkcmFuZG9tKFwiaGVsbG9cIik7ICAgICAgICAgICAgLy8gVXNlIFwiaGVsbG9cIiBhcyB0aGUgc2VlZC5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIEFsd2F5cyAwLjU0NjM2NjM3NjgxNDA3MzRcbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIEFsd2F5cyAwLjQzOTczNzkzNzcwNTkyMjM0XG4vLyAgIHZhciBybmcxID0gTWF0aC5yYW5kb207ICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgY3VycmVudCBwcm5nLlxuLy9cbi8vICAgdmFyIGF1dG9zZWVkID0gTWF0aC5zZWVkcmFuZG9tKCk7ICAgIC8vIE5ldyBwcm5nIHdpdGggYW4gYXV0b21hdGljIHNlZWQuXG4vLyAgIGRvY3VtZW50LndyaXRlKE1hdGgucmFuZG9tKCkpOyAgICAgICAvLyBQcmV0dHkgbXVjaCB1bnByZWRpY3RhYmxlLlxuLy9cbi8vICAgTWF0aC5yYW5kb20gPSBybmcxOyAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIFwiaGVsbG9cIiBwcm5nIHNlcXVlbmNlLlxuLy8gICBkb2N1bWVudC53cml0ZShNYXRoLnJhbmRvbSgpKTsgICAgICAgLy8gQWx3YXlzIDAuNTU0NzY5NDMyNDczNDU1XG4vL1xuLy8gICBNYXRoLnNlZWRyYW5kb20oYXV0b3NlZWQpOyAgICAgICAgICAgLy8gUmVzdGFydCBhdCB0aGUgcHJldmlvdXMgc2VlZC5cbi8vICAgZG9jdW1lbnQud3JpdGUoTWF0aC5yYW5kb20oKSk7ICAgICAgIC8vIFJlcGVhdCB0aGUgJ3VucHJlZGljdGFibGUnIHZhbHVlLlxuLy9cbi8vIE5vdGVzOlxuLy9cbi8vIEVhY2ggdGltZSBzZWVkcmFuZG9tKCdhcmcnKSBpcyBjYWxsZWQsIGVudHJvcHkgZnJvbSB0aGUgcGFzc2VkIHNlZWRcbi8vIGlzIGFjY3VtdWxhdGVkIGluIGEgcG9vbCB0byBoZWxwIGdlbmVyYXRlIGZ1dHVyZSBzZWVkcyBmb3IgdGhlXG4vLyB6ZXJvLWFyZ3VtZW50IGZvcm0gb2YgTWF0aC5zZWVkcmFuZG9tLCBzbyBlbnRyb3B5IGNhbiBiZSBpbmplY3RlZCBvdmVyXG4vLyB0aW1lIGJ5IGNhbGxpbmcgc2VlZHJhbmRvbSB3aXRoIGV4cGxpY2l0IGRhdGEgcmVwZWF0ZWRseS5cbi8vXG4vLyBPbiBzcGVlZCAtIFRoaXMgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBNYXRoLnJhbmRvbSgpIGlzIGFib3V0XG4vLyAzLTEweCBzbG93ZXIgdGhhbiB0aGUgYnVpbHQtaW4gTWF0aC5yYW5kb20oKSBiZWNhdXNlIGl0IGlzIG5vdCBuYXRpdmVcbi8vIGNvZGUsIGJ1dCB0aGlzIGlzIHR5cGljYWxseSBmYXN0IGVub3VnaCBhbnl3YXkuICBTZWVkaW5nIGlzIG1vcmUgZXhwZW5zaXZlLFxuLy8gZXNwZWNpYWxseSBpZiB5b3UgdXNlIGF1dG8tc2VlZGluZy4gIFNvbWUgZGV0YWlscyAodGltaW5ncyBvbiBDaHJvbWUgNCk6XG4vL1xuLy8gT3VyIE1hdGgucmFuZG9tKCkgICAgICAgICAgICAtIGF2ZyBsZXNzIHRoYW4gMC4wMDIgbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vLyBzZWVkcmFuZG9tKCdleHBsaWNpdCcpICAgICAgIC0gYXZnIGxlc3MgdGhhbiAwLjUgbWlsbGlzZWNvbmRzIHBlciBjYWxsXG4vLyBzZWVkcmFuZG9tKCdleHBsaWNpdCcsIHRydWUpIC0gYXZnIGxlc3MgdGhhbiAyIG1pbGxpc2Vjb25kcyBwZXIgY2FsbFxuLy8gc2VlZHJhbmRvbSgpICAgICAgICAgICAgICAgICAtIGF2ZyBhYm91dCAzOCBtaWxsaXNlY29uZHMgcGVyIGNhbGxcbi8vXG4vLyBMSUNFTlNFIChCU0QpOlxuLy9cbi8vIENvcHlyaWdodCAyMDEwIERhdmlkIEJhdSwgYWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuLy8gXG4vLyAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vXG4vLyAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vIFxuLy8gICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoaXMgbW9kdWxlIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXlcbi8vICAgICAgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbi8vICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vLyBcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vKipcbiAqIEFsbCBjb2RlIGlzIGluIGFuIGFub255bW91cyBjbG9zdXJlIHRvIGtlZXAgdGhlIGdsb2JhbCBuYW1lc3BhY2UgY2xlYW4uXG4gKlxuICogQHBhcmFtIHtudW1iZXI9fSBvdmVyZmxvdyBcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc3RhcnRkZW5vbVxuICovXG5cbi8vIFBhdGNoZWQgYnkgU2ViIHNvIHRoYXQgc2VlZHJhbmRvbS5qcyBkb2VzIG5vdCBwb2xsdXRlIHRoZSBNYXRoIG9iamVjdC5cbi8vIE15IHRlc3RzIHN1Z2dlc3QgdGhhdCBkb2luZyBNYXRoLnRyb3VibGUgPSAxIG1ha2VzIE1hdGggbG9va3VwcyBhYm91dCA1JVxuLy8gc2xvd2VyLlxubnVtZXJpYy5zZWVkcmFuZG9tID0geyBwb3c6TWF0aC5wb3csIHJhbmRvbTpNYXRoLnJhbmRvbSB9O1xuXG4oZnVuY3Rpb24gKHBvb2wsIG1hdGgsIHdpZHRoLCBjaHVua3MsIHNpZ25pZmljYW5jZSwgb3ZlcmZsb3csIHN0YXJ0ZGVub20pIHtcblxuXG4vL1xuLy8gc2VlZHJhbmRvbSgpXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbi8vXG5tYXRoWydzZWVkcmFuZG9tJ10gPSBmdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIHVzZV9lbnRyb3B5KSB7XG4gIHZhciBrZXkgPSBbXTtcbiAgdmFyIGFyYzQ7XG5cbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gIHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcbiAgICB1c2VfZW50cm9weSA/IFtzZWVkLCBwb29sXSA6XG4gICAgYXJndW1lbnRzLmxlbmd0aCA/IHNlZWQgOlxuICAgIFtuZXcgRGF0ZSgpLmdldFRpbWUoKSwgcG9vbCwgd2luZG93XSwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gIG1peGtleShhcmM0LlMsIHBvb2wpO1xuXG4gIC8vIE92ZXJyaWRlIE1hdGgucmFuZG9tXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcmFuZG9tIGRvdWJsZSBpbiBbMCwgMSkgdGhhdCBjb250YWluc1xuICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuXG4gIG1hdGhbJ3JhbmRvbSddID0gZnVuY3Rpb24gcmFuZG9tKCkgeyAgLy8gQ2xvc3VyZSB0byByZXR1cm4gYSByYW5kb20gZG91YmxlOlxuICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyk7ICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgIHZhciBkID0gc3RhcnRkZW5vbTsgICAgICAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgdmFyIHggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG4gICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XG4gICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXG4gICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG4gICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICB9XG4gICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHsgICAgICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgIG4gLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGxhc3QgYnl0ZSwgc2hpZnQgZXZlcnl0aGluZ1xuICAgICAgZCAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICB4ID4+Pj0gMTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICB9XG4gICAgcmV0dXJuIChuICsgeCkgLyBkOyAgICAgICAgICAgICAgICAgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzZWVkIHRoYXQgd2FzIHVzZWRcbiAgcmV0dXJuIHNlZWQ7XG59O1xuXG4vL1xuLy8gQVJDNFxuLy9cbi8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2Zcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuLy9cbi8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4vLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4vL1xuLyoqIEBjb25zdHJ1Y3RvciAqL1xuZnVuY3Rpb24gQVJDNChrZXkpIHtcbiAgdmFyIHQsIHUsIG1lID0gdGhpcywga2V5bGVuID0ga2V5Lmxlbmd0aDtcbiAgdmFyIGkgPSAwLCBqID0gbWUuaSA9IG1lLmogPSBtZS5tID0gMDtcbiAgbWUuUyA9IFtdO1xuICBtZS5jID0gW107XG5cbiAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cbiAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxuXG4gIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXG4gIHdoaWxlIChpIDwgd2lkdGgpIHsgbWUuU1tpXSA9IGkrKzsgfVxuICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgIHQgPSBtZS5TW2ldO1xuICAgIGogPSBsb3diaXRzKGogKyB0ICsga2V5W2kgJSBrZXlsZW5dKTtcbiAgICB1ID0gbWUuU1tqXTtcbiAgICBtZS5TW2ldID0gdTtcbiAgICBtZS5TW2pdID0gdDtcbiAgfVxuXG4gIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cbiAgbWUuZyA9IGZ1bmN0aW9uIGdldG5leHQoY291bnQpIHtcbiAgICB2YXIgcyA9IG1lLlM7XG4gICAgdmFyIGkgPSBsb3diaXRzKG1lLmkgKyAxKTsgdmFyIHQgPSBzW2ldO1xuICAgIHZhciBqID0gbG93Yml0cyhtZS5qICsgdCk7IHZhciB1ID0gc1tqXTtcbiAgICBzW2ldID0gdTtcbiAgICBzW2pdID0gdDtcbiAgICB2YXIgciA9IHNbbG93Yml0cyh0ICsgdSldO1xuICAgIHdoaWxlICgtLWNvdW50KSB7XG4gICAgICBpID0gbG93Yml0cyhpICsgMSk7IHQgPSBzW2ldO1xuICAgICAgaiA9IGxvd2JpdHMoaiArIHQpOyB1ID0gc1tqXTtcbiAgICAgIHNbaV0gPSB1O1xuICAgICAgc1tqXSA9IHQ7XG4gICAgICByID0gciAqIHdpZHRoICsgc1tsb3diaXRzKHQgKyB1KV07XG4gICAgfVxuICAgIG1lLmkgPSBpO1xuICAgIG1lLmogPSBqO1xuICAgIHJldHVybiByO1xuICB9O1xuICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHkgZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy5cbiAgLy8gU2VlIGh0dHA6Ly93d3cucnNhLmNvbS9yc2FsYWJzL25vZGUuYXNwP2lkPTIwMDlcbiAgbWUuZyh3aWR0aCk7XG59XG5cbi8vXG4vLyBmbGF0dGVuKClcbi8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbi8vXG4vKiogQHBhcmFtIHtPYmplY3Q9fSByZXN1bHQgXG4gICogQHBhcmFtIHtzdHJpbmc9fSBwcm9wXG4gICogQHBhcmFtIHtzdHJpbmc9fSB0eXAgKi9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCwgcmVzdWx0LCBwcm9wLCB0eXApIHtcbiAgcmVzdWx0ID0gW107XG4gIHR5cCA9IHR5cGVvZihvYmopO1xuICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgaWYgKHByb3AuaW5kZXhPZignUycpIDwgNSkgeyAgICAvLyBBdm9pZCBGRjMgYnVnIChsb2NhbC9zZXNzaW9uU3RvcmFnZSlcbiAgICAgICAgdHJ5IHsgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpOyB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiBvYmogKyAodHlwICE9ICdzdHJpbmcnID8gJ1xcMCcgOiAnJykpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbi8qKiBAcGFyYW0ge251bWJlcj19IHNtZWFyIFxuICAqIEBwYXJhbSB7bnVtYmVyPX0gaiAqL1xuZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSwgc21lYXIsIGopIHtcbiAgc2VlZCArPSAnJzsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBzZWVkIGlzIGEgc3RyaW5nXG4gIHNtZWFyID0gMDtcbiAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyBqKyspIHtcbiAgICBrZXlbbG93Yml0cyhqKV0gPVxuICAgICAgbG93Yml0cygoc21lYXIgXj0ga2V5W2xvd2JpdHMoaildICogMTkpICsgc2VlZC5jaGFyQ29kZUF0KGopKTtcbiAgfVxuICBzZWVkID0gJyc7XG4gIGZvciAoaiBpbiBrZXkpIHsgc2VlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleVtqXSk7IH1cbiAgcmV0dXJuIHNlZWQ7XG59XG5cbi8vXG4vLyBsb3diaXRzKClcbi8vIEEgcXVpY2sgXCJuIG1vZCB3aWR0aFwiIGZvciB3aWR0aCBhIHBvd2VyIG9mIDIuXG4vL1xuZnVuY3Rpb24gbG93Yml0cyhuKSB7IHJldHVybiBuICYgKHdpZHRoIC0gMSk7IH1cblxuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG5zdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyk7XG5zaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBzaWduaWZpY2FuY2UpO1xub3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyO1xuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlZmVyZSB3aXRoIGRldGVybWluc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxuLy8gc2VlZHJhbmRvbSB3aWxsIG5vdCBjYWxsIG1hdGgucmFuZG9tIG9uIGl0cyBvd24gYWdhaW4gYWZ0ZXJcbi8vIGluaXRpYWxpemF0aW9uLlxuLy9cbm1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcblxuLy8gRW5kIGFub255bW91cyBzY29wZSwgYW5kIHBhc3MgaW5pdGlhbCB2YWx1ZXMuXG59KFxuICBbXSwgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIG51bWVyaWMuc2VlZHJhbmRvbSwgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuICAyNTYsICAvLyB3aWR0aDogZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICA2LCAgICAvLyBjaHVua3M6IGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgNTIgICAgLy8gc2lnbmlmaWNhbmNlOiB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICkpO1xuLyogVGhpcyBmaWxlIGlzIGEgc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBxdWFkcHJvZy5qcyBmcm9tIEFsYmVydG8gU2FudGluaS5cbiAqIEl0IGhhcyBiZWVuIHNsaWdodGx5IG1vZGlmaWVkIGJ5IFPDqWJhc3RpZW4gTG9pc2VsIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IGhhbmRsZXNcbiAqIDAtYmFzZWQgQXJyYXlzIGluc3RlYWQgb2YgMS1iYXNlZCBBcnJheXMuXG4gKiBMaWNlbnNlIGlzIGluIHJlc291cmNlcy9MSUNFTlNFLnF1YWRwcm9nICovXG4oZnVuY3Rpb24oZXhwb3J0cykge1xuXG5mdW5jdGlvbiBiYXNlMHRvMShBKSB7XG4gICAgaWYodHlwZW9mIEEgIT09IFwib2JqZWN0XCIpIHsgcmV0dXJuIEE7IH1cbiAgICB2YXIgcmV0ID0gW10sIGksbj1BLmxlbmd0aDtcbiAgICBmb3IoaT0wO2k8bjtpKyspIHJldFtpKzFdID0gYmFzZTB0bzEoQVtpXSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGJhc2UxdG8wKEEpIHtcbiAgICBpZih0eXBlb2YgQSAhPT0gXCJvYmplY3RcIikgeyByZXR1cm4gQTsgfVxuICAgIHZhciByZXQgPSBbXSwgaSxuPUEubGVuZ3RoO1xuICAgIGZvcihpPTE7aTxuO2krKykgcmV0W2ktMV0gPSBiYXNlMXRvMChBW2ldKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkcG9yaShhLCBsZGEsIG4pIHtcbiAgICB2YXIgaSwgaiwgaywga3AxLCB0O1xuXG4gICAgZm9yIChrID0gMTsgayA8PSBuOyBrID0gayArIDEpIHtcbiAgICAgICAgYVtrXVtrXSA9IDEgLyBhW2tdW2tdO1xuICAgICAgICB0ID0gLWFba11ba107XG4gICAgICAgIC8vfiBkc2NhbChrIC0gMSwgdCwgYVsxXVtrXSwgMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBrOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGFbaV1ba10gPSB0ICogYVtpXVtrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtwMSA9IGsgKyAxO1xuICAgICAgICBpZiAobiA8IGtwMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0ga3AxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgdCA9IGFba11bal07XG4gICAgICAgICAgICBhW2tdW2pdID0gMDtcbiAgICAgICAgICAgIC8vfiBkYXhweShrLCB0LCBhWzFdW2tdLCAxLCBhWzFdW2pdLCAxKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgYVtpXVtqXSA9IGFbaV1bal0gKyAodCAqIGFbaV1ba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGRwb3NsKGEsIGxkYSwgbiwgYikge1xuICAgIHZhciBpLCBrLCBrYiwgdDtcblxuICAgIGZvciAoayA9IDE7IGsgPD0gbjsgayA9IGsgKyAxKSB7XG4gICAgICAgIC8vfiB0ID0gZGRvdChrIC0gMSwgYVsxXVtrXSwgMSwgYlsxXSwgMSk7XG4gICAgICAgIHQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgazsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB0ID0gdCArIChhW2ldW2tdICogYltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBiW2tdID0gKGJba10gLSB0KSAvIGFba11ba107XG4gICAgfVxuXG4gICAgZm9yIChrYiA9IDE7IGtiIDw9IG47IGtiID0ga2IgKyAxKSB7XG4gICAgICAgIGsgPSBuICsgMSAtIGtiO1xuICAgICAgICBiW2tdID0gYltrXSAvIGFba11ba107XG4gICAgICAgIHQgPSAtYltrXTtcbiAgICAgICAgLy9+IGRheHB5KGsgLSAxLCB0LCBhWzFdW2tdLCAxLCBiWzFdLCAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgYltpXSA9IGJbaV0gKyAodCAqIGFbaV1ba10pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcG9mYShhLCBsZGEsIG4sIGluZm8pIHtcbiAgICB2YXIgaSwgaiwgam0xLCBrLCB0LCBzO1xuXG4gICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgaW5mb1sxXSA9IGo7XG4gICAgICAgIHMgPSAwO1xuICAgICAgICBqbTEgPSBqIC0gMTtcbiAgICAgICAgaWYgKGptMSA8IDEpIHtcbiAgICAgICAgICAgIHMgPSBhW2pdW2pdIC0gcztcbiAgICAgICAgICAgIGlmIChzIDw9IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbal1bal0gPSBNYXRoLnNxcnQocyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAxOyBrIDw9IGptMTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgICAgICAgLy9+IHQgPSBhW2tdW2pdIC0gZGRvdChrIC0gMSwgYVsxXVtrXSwgMSwgYVsxXVtqXSwgMSk7XG4gICAgICAgICAgICAgICAgdCA9IGFba11bal07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGs7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdCAtIChhW2ldW2pdICogYVtpXVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSB0IC8gYVtrXVtrXTtcbiAgICAgICAgICAgICAgICBhW2tdW2pdID0gdDtcbiAgICAgICAgICAgICAgICBzID0gcyArIHQgKiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IGFbal1bal0gLSBzO1xuICAgICAgICAgICAgaWYgKHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqXVtqXSA9IE1hdGguc3FydChzKTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvWzFdID0gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHFwZ2VuMihkbWF0LCBkdmVjLCBmZGRtYXQsIG4sIHNvbCwgY3J2YWwsIGFtYXQsXG4gICAgYnZlYywgZmRhbWF0LCBxLCBtZXEsIGlhY3QsIG5hY3QsIGl0ZXIsIHdvcmssIGllcnIpIHtcblxuICAgIHZhciBpLCBqLCBsLCBsMSwgaW5mbywgaXQxLCBpd3p2LCBpd3J2LCBpd3JtLCBpd3N2LCBpd3V2LCBudmwsIHIsIGl3bmJ2LFxuICAgICAgICB0ZW1wLCBzdW0sIHQxLCB0dCwgZ2MsIGdzLCBudSxcbiAgICAgICAgdDFpbmYsIHQybWluLFxuICAgICAgICB2c21hbGwsIHRtcGEsIHRtcGIsXG4gICAgICAgIGdvO1xuXG4gICAgciA9IE1hdGgubWluKG4sIHEpO1xuICAgIGwgPSAyICogbiArIChyICogKHIgKyA1KSkgLyAyICsgMiAqIHEgKyAxO1xuXG4gICAgdnNtYWxsID0gMS4wZS02MDtcbiAgICBkbyB7XG4gICAgICAgIHZzbWFsbCA9IHZzbWFsbCArIHZzbWFsbDtcbiAgICAgICAgdG1wYSA9IDEgKyAwLjEgKiB2c21hbGw7XG4gICAgICAgIHRtcGIgPSAxICsgMC4yICogdnNtYWxsO1xuICAgIH0gd2hpbGUgKHRtcGEgPD0gMSB8fCB0bXBiIDw9IDEpO1xuXG4gICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgd29ya1tpXSA9IGR2ZWNbaV07XG4gICAgfVxuICAgIGZvciAoaSA9IG4gKyAxOyBpIDw9IGw7IGkgPSBpICsgMSkge1xuICAgICAgICB3b3JrW2ldID0gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgaWFjdFtpXSA9IDA7XG4gICAgfVxuXG4gICAgaW5mbyA9IFtdO1xuXG4gICAgaWYgKGllcnJbMV0gPT09IDApIHtcbiAgICAgICAgZHBvZmEoZG1hdCwgZmRkbWF0LCBuLCBpbmZvKTtcbiAgICAgICAgaWYgKGluZm9bMV0gIT09IDApIHtcbiAgICAgICAgICAgIGllcnJbMV0gPSAyO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRwb3NsKGRtYXQsIGZkZG1hdCwgbiwgZHZlYyk7XG4gICAgICAgIGRwb3JpKGRtYXQsIGZkZG1hdCwgbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIHNvbFtqXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGo7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHNvbFtqXSA9IHNvbFtqXSArIGRtYXRbaV1bal0gKiBkdmVjW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBkdmVjW2pdID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IGo7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgZHZlY1tqXSA9IGR2ZWNbal0gKyBkbWF0W2pdW2ldICogc29sW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3J2YWxbMV0gPSAwO1xuICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgIHNvbFtqXSA9IGR2ZWNbal07XG4gICAgICAgIGNydmFsWzFdID0gY3J2YWxbMV0gKyB3b3JrW2pdICogc29sW2pdO1xuICAgICAgICB3b3JrW2pdID0gMDtcbiAgICAgICAgZm9yIChpID0gaiArIDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICBkbWF0W2ldW2pdID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcnZhbFsxXSA9IC1jcnZhbFsxXSAvIDI7XG4gICAgaWVyclsxXSA9IDA7XG5cbiAgICBpd3p2ID0gbjtcbiAgICBpd3J2ID0gaXd6diArIG47XG4gICAgaXd1diA9IGl3cnYgKyByO1xuICAgIGl3cm0gPSBpd3V2ICsgciArIDE7XG4gICAgaXdzdiA9IGl3cm0gKyAociAqIChyICsgMSkpIC8gMjtcbiAgICBpd25idiA9IGl3c3YgKyBxO1xuXG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHN1bSArIGFtYXRbal1baV0gKiBhbWF0W2pdW2ldO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtbaXduYnYgKyBpXSA9IE1hdGguc3FydChzdW0pO1xuICAgIH1cbiAgICBuYWN0ID0gMDtcbiAgICBpdGVyWzFdID0gMDtcbiAgICBpdGVyWzJdID0gMDtcblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNTAoKSB7XG4gICAgICAgIGl0ZXJbMV0gPSBpdGVyWzFdICsgMTtcblxuICAgICAgICBsID0gaXdzdjtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIGwgPSBsICsgMTtcbiAgICAgICAgICAgIHN1bSA9IC1idmVjW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyBhbWF0W2pdW2ldICogc29sW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHN1bSkgPCB2c21hbGwpIHtcbiAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiBtZXEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2xdID0gc3VtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JrW2xdID0gLU1hdGguYWJzKHN1bSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1bSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtYXRbal1baV0gPSAtYW1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidmVjW2ldID0gLWJ2ZWNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHdvcmtbaXdzdiArIGlhY3RbaV1dID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG52bCA9IDA7XG4gICAgICAgIHRlbXAgPSAwO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgaWYgKHdvcmtbaXdzdiArIGldIDwgdGVtcCAqIHdvcmtbaXduYnYgKyBpXSkge1xuICAgICAgICAgICAgICAgIG52bCA9IGk7XG4gICAgICAgICAgICAgICAgdGVtcCA9IHdvcmtbaXdzdiArIGldIC8gd29ya1tpd25idiArIGldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudmwgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiA5OTk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzU1KCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgZG1hdFtqXVtpXSAqIGFtYXRbal1bbnZsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtbaV0gPSBzdW07XG4gICAgICAgIH1cblxuICAgICAgICBsMSA9IGl3enY7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB3b3JrW2wxICsgaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IG5hY3QgKyAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2wxICsgaV0gPSB3b3JrW2wxICsgaV0gKyBkbWF0W2ldW2pdICogd29ya1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHQxaW5mID0gdHJ1ZTtcbiAgICAgICAgZm9yIChpID0gbmFjdDsgaSA+PSAxOyBpID0gaSAtIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHdvcmtbaV07XG4gICAgICAgICAgICBsID0gaXdybSArIChpICogKGkgKyAzKSkgLyAyO1xuICAgICAgICAgICAgbDEgPSBsIC0gaTtcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDw9IG5hY3Q7IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSAtIHdvcmtbbF0gKiB3b3JrW2l3cnYgKyBqXTtcbiAgICAgICAgICAgICAgICBsID0gbCArIGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gPSBzdW0gLyB3b3JrW2wxXTtcbiAgICAgICAgICAgIHdvcmtbaXdydiArIGldID0gc3VtO1xuICAgICAgICAgICAgaWYgKGlhY3RbaV0gPCBtZXEpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGludWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0MWluZiA9IGZhbHNlO1xuICAgICAgICAgICAgaXQxID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdDFpbmYpIHtcbiAgICAgICAgICAgIHQxID0gd29ya1tpd3V2ICsgaXQxXSAvIHdvcmtbaXdydiArIGl0MV07XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChpYWN0W2ldIDwgbWVxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtbaXdydiArIGldIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRlbXAgPSB3b3JrW2l3dXYgKyBpXSAvIHdvcmtbaXdydiArIGldO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wIDwgdDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdDEgPSB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICBpdDEgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAoaSA9IGl3enYgKyAxOyBpIDw9IGl3enYgKyBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgIHN1bSA9IHN1bSArIHdvcmtbaV0gKiB3b3JrW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmFicyhzdW0pIDw9IHZzbWFsbCkge1xuICAgICAgICAgICAgaWYgKHQxaW5mKSB7XG4gICAgICAgICAgICAgICAgaWVyclsxXSA9IDE7XG4gICAgICAgICAgICAgICAgLy8gR09UTyA5OTlcbiAgICAgICAgICAgICAgICByZXR1cm4gOTk5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2l3dXYgKyBpXSA9IHdvcmtbaXd1diArIGldIC0gdDEgKiB3b3JrW2l3cnYgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd29ya1tpd3V2ICsgbmFjdCArIDFdID0gd29ya1tpd3V2ICsgbmFjdCArIDFdICsgdDE7XG4gICAgICAgICAgICAgICAgLy8gR09UTyA3MDBcbiAgICAgICAgICAgICAgICByZXR1cm4gNzAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgd29ya1tpd3p2ICsgaV0gKiBhbWF0W2ldW252bF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dCA9IC13b3JrW2l3c3YgKyBudmxdIC8gc3VtO1xuICAgICAgICAgICAgdDJtaW4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0MWluZikge1xuICAgICAgICAgICAgICAgIGlmICh0MSA8IHR0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR0ID0gdDE7XG4gICAgICAgICAgICAgICAgICAgIHQybWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHNvbFtpXSA9IHNvbFtpXSArIHR0ICogd29ya1tpd3p2ICsgaV07XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNvbFtpXSkgPCB2c21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNydmFsWzFdID0gY3J2YWxbMV0gKyB0dCAqIHN1bSAqICh0dCAvIDIgKyB3b3JrW2l3dXYgKyBuYWN0ICsgMV0pO1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuYWN0OyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB3b3JrW2l3dXYgKyBpXSA9IHdvcmtbaXd1diArIGldIC0gdHQgKiB3b3JrW2l3cnYgKyBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtbaXd1diArIG5hY3QgKyAxXSA9IHdvcmtbaXd1diArIG5hY3QgKyAxXSArIHR0O1xuXG4gICAgICAgICAgICBpZiAodDJtaW4pIHtcbiAgICAgICAgICAgICAgICBuYWN0ID0gbmFjdCArIDE7XG4gICAgICAgICAgICAgICAgaWFjdFtuYWN0XSA9IG52bDtcblxuICAgICAgICAgICAgICAgIGwgPSBpd3JtICsgKChuYWN0IC0gMSkgKiBuYWN0KSAvIDIgKyAxO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmFjdCAtIDE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2xdID0gd29ya1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGwgKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuYWN0ID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbbF0gPSB3b3JrW25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG47IGkgPj0gbmFjdCArIDE7IGkgPSBpIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtbaV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdjID0gTWF0aC5tYXgoTWF0aC5hYnMod29ya1tpIC0gMV0pLCBNYXRoLmFicyh3b3JrW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncyA9IE1hdGgubWluKE1hdGguYWJzKHdvcmtbaSAtIDFdKSwgTWF0aC5hYnMod29ya1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtbaSAtIDFdID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IC1NYXRoLmFicyhnYyAqIE1hdGguc3FydCgxICsgZ3MgKiBncyAvIChnYyAqIGdjKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2MgPSB3b3JrW2kgLSAxXSAvIHRlbXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBncyA9IHdvcmtbaV0gLyB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaSAtIDFdID0gZ3MgKiB0ZW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPD0gbjsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBkbWF0W2pdW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpIC0gMV0gPSBkbWF0W2pdW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWF0W2pdW2ldID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtbaSAtIDFdID0gdGVtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudSA9IGdzIC8gKDEgKyBnYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8PSBuOyBqID0gaiArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGdjICogZG1hdFtqXVtpIC0gMV0gKyBncyAqIGRtYXRbal1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtYXRbal1baV0gPSBudSAqIChkbWF0W2pdW2kgLSAxXSArIHRlbXApIC0gZG1hdFtqXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1hdFtqXVtpIC0gMV0gPSB0ZW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtbbF0gPSB3b3JrW25hY3RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VtID0gLWJ2ZWNbbnZsXTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyBzb2xbal0gKiBhbWF0W2pdW252bF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChudmwgPiBtZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya1tpd3N2ICsgbnZsXSA9IHN1bTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3b3JrW2l3c3YgKyBudmxdID0gLU1hdGguYWJzKHN1bSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDw9IG47IGogPSBqICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtYXRbal1bbnZsXSA9IC1hbWF0W2pdW252bF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBidmVjW252bF0gPSAtYnZlY1tudmxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdPVE8gNzAwXG4gICAgICAgICAgICAgICAgcmV0dXJuIDcwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZuX2dvdG9fNzk3KCkge1xuICAgICAgICBsID0gaXdybSArIChpdDEgKiAoaXQxICsgMSkpIC8gMiArIDE7XG4gICAgICAgIGwxID0gbCArIGl0MTtcbiAgICAgICAgaWYgKHdvcmtbbDFdID09PSAwKSB7XG4gICAgICAgICAgICAvLyBHT1RPIDc5OFxuICAgICAgICAgICAgcmV0dXJuIDc5ODtcbiAgICAgICAgfVxuICAgICAgICBnYyA9IE1hdGgubWF4KE1hdGguYWJzKHdvcmtbbDEgLSAxXSksIE1hdGguYWJzKHdvcmtbbDFdKSk7XG4gICAgICAgIGdzID0gTWF0aC5taW4oTWF0aC5hYnMod29ya1tsMSAtIDFdKSwgTWF0aC5hYnMod29ya1tsMV0pKTtcbiAgICAgICAgaWYgKHdvcmtbbDEgLSAxXSA+PSAwKSB7XG4gICAgICAgICAgICB0ZW1wID0gTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSAtTWF0aC5hYnMoZ2MgKiBNYXRoLnNxcnQoMSArIGdzICogZ3MgLyAoZ2MgKiBnYykpKTtcbiAgICAgICAgfVxuICAgICAgICBnYyA9IHdvcmtbbDEgLSAxXSAvIHRlbXA7XG4gICAgICAgIGdzID0gd29ya1tsMV0gLyB0ZW1wO1xuXG4gICAgICAgIGlmIChnYyA9PT0gMSkge1xuICAgICAgICAgICAgLy8gR09UTyA3OThcbiAgICAgICAgICAgIHJldHVybiA3OTg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBpdDEgKyAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSB3b3JrW2wxIC0gMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMSAtIDFdID0gd29ya1tsMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMV0gPSB0ZW1wO1xuICAgICAgICAgICAgICAgIGwxID0gbDEgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBuOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZG1hdFtpXVtpdDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxXSA9IGRtYXRbaV1baXQxICsgMV07XG4gICAgICAgICAgICAgICAgZG1hdFtpXVtpdDEgKyAxXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudSA9IGdzIC8gKDEgKyBnYyk7XG4gICAgICAgICAgICBmb3IgKGkgPSBpdDEgKyAxOyBpIDw9IG5hY3Q7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBnYyAqIHdvcmtbbDEgLSAxXSArIGdzICogd29ya1tsMV07XG4gICAgICAgICAgICAgICAgd29ya1tsMV0gPSBudSAqICh3b3JrW2wxIC0gMV0gKyB0ZW1wKSAtIHdvcmtbbDFdO1xuICAgICAgICAgICAgICAgIHdvcmtbbDEgLSAxXSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgbDEgPSBsMSArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgIHRlbXAgPSBnYyAqIGRtYXRbaV1baXQxXSArIGdzICogZG1hdFtpXVtpdDEgKyAxXTtcbiAgICAgICAgICAgICAgICBkbWF0W2ldW2l0MSArIDFdID0gbnUgKiAoZG1hdFtpXVtpdDFdICsgdGVtcCkgLSBkbWF0W2ldW2l0MSArIDFdO1xuICAgICAgICAgICAgICAgIGRtYXRbaV1baXQxXSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbl9nb3RvXzc5OCgpIHtcbiAgICAgICAgbDEgPSBsIC0gaXQxO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGl0MTsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICB3b3JrW2wxXSA9IHdvcmtbbF07XG4gICAgICAgICAgICBsID0gbCArIDE7XG4gICAgICAgICAgICBsMSA9IGwxICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtbaXd1diArIGl0MV0gPSB3b3JrW2l3dXYgKyBpdDEgKyAxXTtcbiAgICAgICAgaWFjdFtpdDFdID0gaWFjdFtpdDEgKyAxXTtcbiAgICAgICAgaXQxID0gaXQxICsgMTtcbiAgICAgICAgaWYgKGl0MSA8IG5hY3QpIHtcbiAgICAgICAgICAgIC8vIEdPVE8gNzk3XG4gICAgICAgICAgICByZXR1cm4gNzk3O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm5fZ290b183OTkoKSB7XG4gICAgICAgIHdvcmtbaXd1diArIG5hY3RdID0gd29ya1tpd3V2ICsgbmFjdCArIDFdO1xuICAgICAgICB3b3JrW2l3dXYgKyBuYWN0ICsgMV0gPSAwO1xuICAgICAgICBpYWN0W25hY3RdID0gMDtcbiAgICAgICAgbmFjdCA9IG5hY3QgLSAxO1xuICAgICAgICBpdGVyWzJdID0gaXRlclsyXSArIDE7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZ28gPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGdvID0gZm5fZ290b181MCgpO1xuICAgICAgICBpZiAoZ28gPT09IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBnbyA9IGZuX2dvdG9fNTUoKTtcbiAgICAgICAgICAgIGlmIChnbyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdvID09PSA5OTkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ28gPT09IDcwMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdDEgPT09IG5hY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTkoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvID0gZm5fZ290b183OTgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnbyAhPT0gNzk3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm5fZ290b183OTkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gc29sdmVRUChEbWF0LCBkdmVjLCBBbWF0LCBidmVjLCBtZXEsIGZhY3Rvcml6ZWQpIHtcbiAgICBEbWF0ID0gYmFzZTB0bzEoRG1hdCk7XG4gICAgZHZlYyA9IGJhc2UwdG8xKGR2ZWMpO1xuICAgIEFtYXQgPSBiYXNlMHRvMShBbWF0KTtcbiAgICB2YXIgaSwgbiwgcSxcbiAgICAgICAgbmFjdCwgcixcbiAgICAgICAgY3J2YWwgPSBbXSwgaWFjdCA9IFtdLCBzb2wgPSBbXSwgd29yayA9IFtdLCBpdGVyID0gW10sXG4gICAgICAgIG1lc3NhZ2U7XG5cbiAgICBtZXEgPSBtZXEgfHwgMDtcbiAgICBmYWN0b3JpemVkID0gZmFjdG9yaXplZCA/IGJhc2UwdG8xKGZhY3Rvcml6ZWQpIDogW3VuZGVmaW5lZCwgMF07XG4gICAgYnZlYyA9IGJ2ZWMgPyBiYXNlMHRvMShidmVjKSA6IFtdO1xuXG4gICAgLy8gSW4gRm9ydHJhbiB0aGUgYXJyYXkgaW5kZXggc3RhcnRzIGZyb20gMVxuICAgIG4gPSBEbWF0Lmxlbmd0aCAtIDE7XG4gICAgcSA9IEFtYXRbMV0ubGVuZ3RoIC0gMTtcblxuICAgIGlmICghYnZlYykge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IHE7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgYnZlY1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSBxOyBpID0gaSArIDEpIHtcbiAgICAgICAgaWFjdFtpXSA9IDA7XG4gICAgfVxuICAgIG5hY3QgPSAwO1xuICAgIHIgPSBNYXRoLm1pbihuLCBxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDw9IG47IGkgPSBpICsgMSkge1xuICAgICAgICBzb2xbaV0gPSAwO1xuICAgIH1cbiAgICBjcnZhbFsxXSA9IDA7XG4gICAgZm9yIChpID0gMTsgaSA8PSAoMiAqIG4gKyAociAqIChyICsgNSkpIC8gMiArIDIgKiBxICsgMSk7IGkgPSBpICsgMSkge1xuICAgICAgICB3b3JrW2ldID0gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8PSAyOyBpID0gaSArIDEpIHtcbiAgICAgICAgaXRlcltpXSA9IDA7XG4gICAgfVxuXG4gICAgcXBnZW4yKERtYXQsIGR2ZWMsIG4sIG4sIHNvbCwgY3J2YWwsIEFtYXQsXG4gICAgICAgIGJ2ZWMsIG4sIHEsIG1lcSwgaWFjdCwgbmFjdCwgaXRlciwgd29yaywgZmFjdG9yaXplZCk7XG5cbiAgICBtZXNzYWdlID0gXCJcIjtcbiAgICBpZiAoZmFjdG9yaXplZFsxXSA9PT0gMSkge1xuICAgICAgICBtZXNzYWdlID0gXCJjb25zdHJhaW50cyBhcmUgaW5jb25zaXN0ZW50LCBubyBzb2x1dGlvbiFcIjtcbiAgICB9XG4gICAgaWYgKGZhY3Rvcml6ZWRbMV0gPT09IDIpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwibWF0cml4IEQgaW4gcXVhZHJhdGljIGZ1bmN0aW9uIGlzIG5vdCBwb3NpdGl2ZSBkZWZpbml0ZSFcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzb2x1dGlvbjogYmFzZTF0bzAoc29sKSxcbiAgICAgICAgdmFsdWU6IGJhc2UxdG8wKGNydmFsKSxcbiAgICAgICAgdW5jb25zdHJhaW5lZF9zb2x1dGlvbjogYmFzZTF0bzAoZHZlYyksXG4gICAgICAgIGl0ZXJhdGlvbnM6IGJhc2UxdG8wKGl0ZXIpLFxuICAgICAgICBpYWN0OiBiYXNlMXRvMChpYWN0KSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH07XG59XG5leHBvcnRzLnNvbHZlUVAgPSBzb2x2ZVFQO1xufShudW1lcmljKSk7XG4vKlxyXG5TaGFudGkgUmFvIHNlbnQgbWUgdGhpcyByb3V0aW5lIGJ5IHByaXZhdGUgZW1haWwuIEkgaGFkIHRvIG1vZGlmeSBpdFxyXG5zbGlnaHRseSB0byB3b3JrIG9uIEFycmF5cyBpbnN0ZWFkIG9mIHVzaW5nIGEgTWF0cml4IG9iamVjdC5cclxuSXQgaXMgYXBwYXJlbnRseSB0cmFuc2xhdGVkIGZyb20gaHR0cDovL3N0aXRjaHBhbm9yYW1hLnNvdXJjZWZvcmdlLm5ldC9QeXRob24vc3ZkLnB5XHJcbiovXHJcblxyXG5udW1lcmljLnN2ZD0gZnVuY3Rpb24gc3ZkKEEpIHtcclxuICAgIHZhciB0ZW1wO1xyXG4vL0NvbXB1dGUgdGhlIHRoaW4gU1ZEIGZyb20gRy4gSC4gR29sdWIgYW5kIEMuIFJlaW5zY2gsIE51bWVyLiBNYXRoLiAxNCwgNDAzLTQyMCAoMTk3MClcclxuXHR2YXIgcHJlYz0gbnVtZXJpYy5lcHNpbG9uOyAvL01hdGgucG93KDIsLTUyKSAvLyBhc3N1bWVzIGRvdWJsZSBwcmVjXHJcblx0dmFyIHRvbGVyYW5jZT0gMS5lLTY0L3ByZWM7XHJcblx0dmFyIGl0bWF4PSA1MDtcclxuXHR2YXIgYz0wO1xyXG5cdHZhciBpPTA7XHJcblx0dmFyIGo9MDtcclxuXHR2YXIgaz0wO1xyXG5cdHZhciBsPTA7XHJcblx0XHJcblx0dmFyIHU9IG51bWVyaWMuY2xvbmUoQSk7XHJcblx0dmFyIG09IHUubGVuZ3RoO1xyXG5cdFxyXG5cdHZhciBuPSB1WzBdLmxlbmd0aDtcclxuXHRcclxuXHRpZiAobSA8IG4pIHRocm93IFwiTmVlZCBtb3JlIHJvd3MgdGhhbiBjb2x1bW5zXCJcclxuXHRcclxuXHR2YXIgZSA9IG5ldyBBcnJheShuKTtcclxuXHR2YXIgcSA9IG5ldyBBcnJheShuKTtcclxuXHRmb3IgKGk9MDsgaTxuOyBpKyspIGVbaV0gPSBxW2ldID0gMC4wO1xyXG5cdHZhciB2ID0gbnVtZXJpYy5yZXAoW24sbl0sMCk7XHJcbi8vXHR2Lnplcm8oKTtcclxuXHRcclxuIFx0ZnVuY3Rpb24gcHl0aGFnKGEsYilcclxuIFx0e1xyXG5cdFx0YSA9IE1hdGguYWJzKGEpXHJcblx0XHRiID0gTWF0aC5hYnMoYilcclxuXHRcdGlmIChhID4gYilcclxuXHRcdFx0cmV0dXJuIGEqTWF0aC5zcXJ0KDEuMCsoYipiL2EvYSkpXHJcblx0XHRlbHNlIGlmIChiID09IDAuMCkgXHJcblx0XHRcdHJldHVybiBhXHJcblx0XHRyZXR1cm4gYipNYXRoLnNxcnQoMS4wKyhhKmEvYi9iKSlcclxuXHR9XHJcblxyXG5cdC8vSG91c2Vob2xkZXIncyByZWR1Y3Rpb24gdG8gYmlkaWFnb25hbCBmb3JtXHJcblxyXG5cdHZhciBmPSAwLjA7XHJcblx0dmFyIGc9IDAuMDtcclxuXHR2YXIgaD0gMC4wO1xyXG5cdHZhciB4PSAwLjA7XHJcblx0dmFyIHk9IDAuMDtcclxuXHR2YXIgej0gMC4wO1xyXG5cdHZhciBzPSAwLjA7XHJcblx0XHJcblx0Zm9yIChpPTA7IGkgPCBuOyBpKyspXHJcblx0e1x0XHJcblx0XHRlW2ldPSBnO1xyXG5cdFx0cz0gMC4wO1xyXG5cdFx0bD0gaSsxO1xyXG5cdFx0Zm9yIChqPWk7IGogPCBtOyBqKyspIFxyXG5cdFx0XHRzICs9ICh1W2pdW2ldKnVbal1baV0pO1xyXG5cdFx0aWYgKHMgPD0gdG9sZXJhbmNlKVxyXG5cdFx0XHRnPSAwLjA7XHJcblx0XHRlbHNlXHJcblx0XHR7XHRcclxuXHRcdFx0Zj0gdVtpXVtpXTtcclxuXHRcdFx0Zz0gTWF0aC5zcXJ0KHMpO1xyXG5cdFx0XHRpZiAoZiA+PSAwLjApIGc9IC1nO1xyXG5cdFx0XHRoPSBmKmctc1xyXG5cdFx0XHR1W2ldW2ldPWYtZztcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzPSAwLjBcclxuXHRcdFx0XHRmb3IgKGs9aTsgayA8IG07IGsrKykgXHJcblx0XHRcdFx0XHRzICs9IHVba11baV0qdVtrXVtqXVxyXG5cdFx0XHRcdGY9IHMvaFxyXG5cdFx0XHRcdGZvciAoaz1pOyBrIDwgbTsgaysrKSBcclxuXHRcdFx0XHRcdHVba11bal0rPWYqdVtrXVtpXVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRxW2ldPSBnXHJcblx0XHRzPSAwLjBcclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBcclxuXHRcdFx0cz0gcyArIHVbaV1bal0qdVtpXVtqXVxyXG5cdFx0aWYgKHMgPD0gdG9sZXJhbmNlKVxyXG5cdFx0XHRnPSAwLjBcclxuXHRcdGVsc2VcclxuXHRcdHtcdFxyXG5cdFx0XHRmPSB1W2ldW2krMV1cclxuXHRcdFx0Zz0gTWF0aC5zcXJ0KHMpXHJcblx0XHRcdGlmIChmID49IDAuMCkgZz0gLWdcclxuXHRcdFx0aD0gZipnIC0gc1xyXG5cdFx0XHR1W2ldW2krMV0gPSBmLWc7XHJcblx0XHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBlW2pdPSB1W2ldW2pdL2hcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBtOyBqKyspXHJcblx0XHRcdHtcdFxyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0cyArPSAodVtqXVtrXSp1W2ldW2tdKVxyXG5cdFx0XHRcdGZvciAoaz1sOyBrIDwgbjsgaysrKSBcclxuXHRcdFx0XHRcdHVbal1ba10rPXMqZVtrXVxyXG5cdFx0XHR9XHRcclxuXHRcdH1cclxuXHRcdHk9IE1hdGguYWJzKHFbaV0pK01hdGguYWJzKGVbaV0pXHJcblx0XHRpZiAoeT54KSBcclxuXHRcdFx0eD15XHJcblx0fVxyXG5cdFxyXG5cdC8vIGFjY3VtdWxhdGlvbiBvZiByaWdodCBoYW5kIGd0cmFuc2Zvcm1hdGlvbnNcclxuXHRmb3IgKGk9bi0xOyBpICE9IC0xOyBpKz0gLTEpXHJcblx0e1x0XHJcblx0XHRpZiAoZyAhPSAwLjApXHJcblx0XHR7XHJcblx0XHQgXHRoPSBnKnVbaV1baSsxXVxyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKykgXHJcblx0XHRcdFx0dltqXVtpXT11W2ldW2pdL2hcclxuXHRcdFx0Zm9yIChqPWw7IGogPCBuOyBqKyspXHJcblx0XHRcdHtcdFxyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBuOyBrKyspIFxyXG5cdFx0XHRcdFx0cyArPSB1W2ldW2tdKnZba11bal1cclxuXHRcdFx0XHRmb3IgKGs9bDsgayA8IG47IGsrKykgXHJcblx0XHRcdFx0XHR2W2tdW2pdKz0ocyp2W2tdW2ldKVxyXG5cdFx0XHR9XHRcclxuXHRcdH1cclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKVxyXG5cdFx0e1xyXG5cdFx0XHR2W2ldW2pdID0gMDtcclxuXHRcdFx0dltqXVtpXSA9IDA7XHJcblx0XHR9XHJcblx0XHR2W2ldW2ldID0gMTtcclxuXHRcdGc9IGVbaV1cclxuXHRcdGw9IGlcclxuXHR9XHJcblx0XHJcblx0Ly8gYWNjdW11bGF0aW9uIG9mIGxlZnQgaGFuZCB0cmFuc2Zvcm1hdGlvbnNcclxuXHRmb3IgKGk9bi0xOyBpICE9IC0xOyBpKz0gLTEpXHJcblx0e1x0XHJcblx0XHRsPSBpKzFcclxuXHRcdGc9IHFbaV1cclxuXHRcdGZvciAoaj1sOyBqIDwgbjsgaisrKSBcclxuXHRcdFx0dVtpXVtqXSA9IDA7XHJcblx0XHRpZiAoZyAhPSAwLjApXHJcblx0XHR7XHJcblx0XHRcdGg9IHVbaV1baV0qZ1xyXG5cdFx0XHRmb3IgKGo9bDsgaiA8IG47IGorKylcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHM9MC4wXHJcblx0XHRcdFx0Zm9yIChrPWw7IGsgPCBtOyBrKyspIHMgKz0gdVtrXVtpXSp1W2tdW2pdO1xyXG5cdFx0XHRcdGY9IHMvaFxyXG5cdFx0XHRcdGZvciAoaz1pOyBrIDwgbTsgaysrKSB1W2tdW2pdKz1mKnVba11baV07XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChqPWk7IGogPCBtOyBqKyspIHVbal1baV0gPSB1W2pdW2ldL2c7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdGZvciAoaj1pOyBqIDwgbTsgaisrKSB1W2pdW2ldID0gMDtcclxuXHRcdHVbaV1baV0gKz0gMTtcclxuXHR9XHJcblx0XHJcblx0Ly8gZGlhZ29uYWxpemF0aW9uIG9mIHRoZSBiaWRpYWdvbmFsIGZvcm1cclxuXHRwcmVjPSBwcmVjKnhcclxuXHRmb3IgKGs9bi0xOyBrICE9IC0xOyBrKz0gLTEpXHJcblx0e1xyXG5cdFx0Zm9yICh2YXIgaXRlcmF0aW9uPTA7IGl0ZXJhdGlvbiA8IGl0bWF4OyBpdGVyYXRpb24rKylcclxuXHRcdHtcdC8vIHRlc3QgZiBzcGxpdHRpbmdcclxuXHRcdFx0dmFyIHRlc3RfY29udmVyZ2VuY2UgPSBmYWxzZVxyXG5cdFx0XHRmb3IgKGw9azsgbCAhPSAtMTsgbCs9IC0xKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRpZiAoTWF0aC5hYnMoZVtsXSkgPD0gcHJlYylcclxuXHRcdFx0XHR7XHR0ZXN0X2NvbnZlcmdlbmNlPSB0cnVlXHJcblx0XHRcdFx0XHRicmVhayBcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKE1hdGguYWJzKHFbbC0xXSkgPD0gcHJlYylcclxuXHRcdFx0XHRcdGJyZWFrIFxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghdGVzdF9jb252ZXJnZW5jZSlcclxuXHRcdFx0e1x0Ly8gY2FuY2VsbGF0aW9uIG9mIGVbbF0gaWYgbD4wXHJcblx0XHRcdFx0Yz0gMC4wXHJcblx0XHRcdFx0cz0gMS4wXHJcblx0XHRcdFx0dmFyIGwxPSBsLTFcclxuXHRcdFx0XHRmb3IgKGkgPWw7IGk8aysxOyBpKyspXHJcblx0XHRcdFx0e1x0XHJcblx0XHRcdFx0XHRmPSBzKmVbaV1cclxuXHRcdFx0XHRcdGVbaV09IGMqZVtpXVxyXG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKGYpIDw9IHByZWMpXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRnPSBxW2ldXHJcblx0XHRcdFx0XHRoPSBweXRoYWcoZixnKVxyXG5cdFx0XHRcdFx0cVtpXT0gaFxyXG5cdFx0XHRcdFx0Yz0gZy9oXHJcblx0XHRcdFx0XHRzPSAtZi9oXHJcblx0XHRcdFx0XHRmb3IgKGo9MDsgaiA8IG07IGorKylcclxuXHRcdFx0XHRcdHtcdFxyXG5cdFx0XHRcdFx0XHR5PSB1W2pdW2wxXVxyXG5cdFx0XHRcdFx0XHR6PSB1W2pdW2ldXHJcblx0XHRcdFx0XHRcdHVbal1bbDFdID0gIHkqYysoeipzKVxyXG5cdFx0XHRcdFx0XHR1W2pdW2ldID0gLXkqcysoeipjKVxyXG5cdFx0XHRcdFx0fSBcclxuXHRcdFx0XHR9XHRcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyB0ZXN0IGYgY29udmVyZ2VuY2VcclxuXHRcdFx0ej0gcVtrXVxyXG5cdFx0XHRpZiAobD09IGspXHJcblx0XHRcdHtcdC8vY29udmVyZ2VuY2VcclxuXHRcdFx0XHRpZiAoejwwLjApXHJcblx0XHRcdFx0e1x0Ly9xW2tdIGlzIG1hZGUgbm9uLW5lZ2F0aXZlXHJcblx0XHRcdFx0XHRxW2tdPSAtelxyXG5cdFx0XHRcdFx0Zm9yIChqPTA7IGogPCBuOyBqKyspXHJcblx0XHRcdFx0XHRcdHZbal1ba10gPSAtdltqXVtrXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRicmVhayAgLy9icmVhayBvdXQgb2YgaXRlcmF0aW9uIGxvb3AgYW5kIG1vdmUgb24gdG8gbmV4dCBrIHZhbHVlXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGl0ZXJhdGlvbiA+PSBpdG1heC0xKVxyXG5cdFx0XHRcdHRocm93ICdFcnJvcjogbm8gY29udmVyZ2VuY2UuJ1xyXG5cdFx0XHQvLyBzaGlmdCBmcm9tIGJvdHRvbSAyeDIgbWlub3JcclxuXHRcdFx0eD0gcVtsXVxyXG5cdFx0XHR5PSBxW2stMV1cclxuXHRcdFx0Zz0gZVtrLTFdXHJcblx0XHRcdGg9IGVba11cclxuXHRcdFx0Zj0gKCh5LXopKih5K3opKyhnLWgpKihnK2gpKS8oMi4wKmgqeSlcclxuXHRcdFx0Zz0gcHl0aGFnKGYsMS4wKVxyXG5cdFx0XHRpZiAoZiA8IDAuMClcclxuXHRcdFx0XHRmPSAoKHgteikqKHgreikraCooeS8oZi1nKS1oKSkveFxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0Zj0gKCh4LXopKih4K3opK2gqKHkvKGYrZyktaCkpL3hcclxuXHRcdFx0Ly8gbmV4dCBRUiB0cmFuc2Zvcm1hdGlvblxyXG5cdFx0XHRjPSAxLjBcclxuXHRcdFx0cz0gMS4wXHJcblx0XHRcdGZvciAoaT1sKzE7IGk8IGsrMTsgaSsrKVxyXG5cdFx0XHR7XHRcclxuXHRcdFx0XHRnPSBlW2ldXHJcblx0XHRcdFx0eT0gcVtpXVxyXG5cdFx0XHRcdGg9IHMqZ1xyXG5cdFx0XHRcdGc9IGMqZ1xyXG5cdFx0XHRcdHo9IHB5dGhhZyhmLGgpXHJcblx0XHRcdFx0ZVtpLTFdPSB6XHJcblx0XHRcdFx0Yz0gZi96XHJcblx0XHRcdFx0cz0gaC96XHJcblx0XHRcdFx0Zj0geCpjK2cqc1xyXG5cdFx0XHRcdGc9IC14KnMrZypjXHJcblx0XHRcdFx0aD0geSpzXHJcblx0XHRcdFx0eT0geSpjXHJcblx0XHRcdFx0Zm9yIChqPTA7IGogPCBuOyBqKyspXHJcblx0XHRcdFx0e1x0XHJcblx0XHRcdFx0XHR4PSB2W2pdW2ktMV1cclxuXHRcdFx0XHRcdHo9IHZbal1baV1cclxuXHRcdFx0XHRcdHZbal1baS0xXSA9IHgqYyt6KnNcclxuXHRcdFx0XHRcdHZbal1baV0gPSAteCpzK3oqY1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR6PSBweXRoYWcoZixoKVxyXG5cdFx0XHRcdHFbaS0xXT0gelxyXG5cdFx0XHRcdGM9IGYvelxyXG5cdFx0XHRcdHM9IGgvelxyXG5cdFx0XHRcdGY9IGMqZytzKnlcclxuXHRcdFx0XHR4PSAtcypnK2MqeVxyXG5cdFx0XHRcdGZvciAoaj0wOyBqIDwgbTsgaisrKVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHk9IHVbal1baS0xXVxyXG5cdFx0XHRcdFx0ej0gdVtqXVtpXVxyXG5cdFx0XHRcdFx0dVtqXVtpLTFdID0geSpjK3oqc1xyXG5cdFx0XHRcdFx0dVtqXVtpXSA9IC15KnMreipjXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVbbF09IDAuMFxyXG5cdFx0XHRlW2tdPSBmXHJcblx0XHRcdHFba109IHhcclxuXHRcdH0gXHJcblx0fVxyXG5cdFx0XHJcblx0Ly92dD0gdHJhbnNwb3NlKHYpXHJcblx0Ly9yZXR1cm4gKHUscSx2dClcclxuXHRmb3IgKGk9MDtpPHEubGVuZ3RoOyBpKyspIFxyXG5cdCAgaWYgKHFbaV0gPCBwcmVjKSBxW2ldID0gMFxyXG5cdCAgXHJcblx0Ly9zb3J0IGVpZ2VudmFsdWVzXHRcclxuXHRmb3IgKGk9MDsgaTwgbjsgaSsrKVxyXG5cdHtcdCBcclxuXHQvL3dyaXRlbG4ocSlcclxuXHQgZm9yIChqPWktMTsgaiA+PSAwOyBqLS0pXHJcblx0IHtcclxuXHQgIGlmIChxW2pdIDwgcVtpXSlcclxuXHQgIHtcclxuXHQvLyAgd3JpdGVsbihpLCctJyxqKVxyXG5cdCAgIGMgPSBxW2pdXHJcblx0ICAgcVtqXSA9IHFbaV1cclxuXHQgICBxW2ldID0gY1xyXG5cdCAgIGZvcihrPTA7azx1Lmxlbmd0aDtrKyspIHsgdGVtcCA9IHVba11baV07IHVba11baV0gPSB1W2tdW2pdOyB1W2tdW2pdID0gdGVtcDsgfVxyXG5cdCAgIGZvcihrPTA7azx2Lmxlbmd0aDtrKyspIHsgdGVtcCA9IHZba11baV07IHZba11baV0gPSB2W2tdW2pdOyB2W2tdW2pdID0gdGVtcDsgfVxyXG4vL1x0ICAgdS5zd2FwQ29scyhpLGopXHJcbi8vXHQgICB2LnN3YXBDb2xzKGksailcclxuXHQgICBpID0galx0ICAgXHJcblx0ICB9XHJcblx0IH1cdFxyXG5cdH1cclxuXHRcclxuXHRyZXR1cm4ge1U6dSxTOnEsVjp2fVxyXG59O1xyXG5cclxuIiwiZnVuY3Rpb24gU3ByZWFkU2hlZXRFcnJvcigpIHtcbiAgICB0aGlzLm5hbWUgPSAnU3ByZWFkU2hlZXRFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gJ+WPkeeUn+S6humUmeivryc7XG59XG5cblNwcmVhZFNoZWV0RXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5TcHJlYWRTaGVldEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcmVhZFNoZWV0RXJyb3I7XG5TcHJlYWRTaGVldEVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lICsgJyA9PiAnICsgdGhpcy5tZXNzYWdlO1xufTtcblxuZXhwb3J0IHtTcHJlYWRTaGVldEVycm9yfVxuXG4iLCJpbXBvcnQge2dsb2JhbFNldHRpbmdzLCBkZWZhdWx0U2V0dGluZ3N9IGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IFNwcmVhZFNoZWV0IGZyb20gJy4vY29yZSc7XG5pbXBvcnQgcG9seWZpbGwgZnJvbSAnLi9wb2x5ZmlsbCc7XG4vL25vaW5zcGVjdGlvbiBFUzZVbnVzZWRJbXBvcnRzIOi/meS4quWvvOWFpeaYr+S4uuS6huaehOW7uuaXtuWKoOi9veebuOW6lOeahOWMhVxuaW1wb3J0IFhGb3JtdWxhcyBmcm9tICcuL3BsdWdpbnMveGZvcm11bGFzL1hGb3JtdWxhcyc7XG5pbXBvcnQge1BsdWdpbiwgcmVnaXN0ZXJQbHVnaW59IGZyb20gJy4vcGx1Z2lucy9QbHVnaW4nO1xuaW1wb3J0IFBlcnNpc3RlbnQgZnJvbSAnLi9wbHVnaW5zL3BlcnNpc3RlbnQvUGVyc2lzdGVudCc7XG5cblxuU3ByZWFkU2hlZXQuZ2xvYmFsU2V0dGluZ3MgPSBnbG9iYWxTZXR0aW5ncztcblNwcmVhZFNoZWV0LmRlZmF1bHRTZXR0aW5ncyA9IGRlZmF1bHRTZXR0aW5ncztcblNwcmVhZFNoZWV0LnZlcnNpb24gPSAnQEBfdmVyc2lvbl9AQCc7XG5cblNwcmVhZFNoZWV0LnBsdWdpbnMgPSB7XG4gICAgUGx1Z2luOiBQbHVnaW4sXG4gICAgcmVnaXN0ZXJQbHVnaW46IHJlZ2lzdGVyUGx1Z2luXG59O1xuXG4vLyDlhoXnva7mj5Lku7ZcbnJlZ2lzdGVyUGx1Z2luKCdwZXJzaXN0ZW50JywgUGVyc2lzdGVudCk7XG5cblxuLy8g5rWP6KeI5Zmo546v5aKD5LiL55qE5YWo5bGA5Y+Y6YeP5ZCN44CCXG53aW5kb3cuQnJpY2tTcHJlYWRTaGVldCA9IFNwcmVhZFNoZWV0O1xud2luZG93Ll9VSVByb3ZpZGVyID0ge307XG5wb2x5ZmlsbCh3aW5kb3cpO1xuXG4vLyBUT0RPIOaPkOS+m+abtOaUueWFqOWxgOWPmOmHj+WQjeeahOaWueazle+8jOS7pemYsuatouWFqOWxgOWPmOmHj+WGsueqgeOAglxuXG4iLCJpbXBvcnQgRnJhbWUgZnJvbSAnLi9kZXNpZ25lci9GcmFtZSc7XG5pbXBvcnQgV29ya2Jvb2sgZnJvbSAnLi9kZXNpZ25lci9Xb3JrYm9vayc7XG5pbXBvcnQge2V4dGVuZCwgZW1wdHlGdW5jdGlvbiwgcmFuZG9tU3RyaW5nfSBmcm9tICcuL3V0aWxzL2NvbW1vbic7XG5pbXBvcnQge2dldEFsbFBsdWdpbnMsIHZhbGlkYXRlUGx1Z2lufSBmcm9tICcuL3BsdWdpbnMvUGx1Z2luJztcbmltcG9ydCBFbWl0dGVyIGZyb20gJy4vdXRpbHMvRW1pdHRlcic7XG5cbnZhciBBVVRPX0lEID0gMTtcblxuY2xhc3MgU3ByZWFkU2hlZXQgZXh0ZW5kcyBFbWl0dGVyIHtcblxuICAgIC8qKlxuICAgICAqIOexu+S8vCBFeGNlbCDnmoTnlLXlrZDooajmoLzjgIJcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSByb290RWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1c2VyU2V0dGluZ3MgLSDnlLXlrZDooajmoLznmoTnlKjmiLfphY3nva7kv6Hmga9cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdXNlclNldHRpbmdzLndvcmtib29rIC0gV29ya2Jvb2sg55qE6YWN572uXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gdXNlclNldHRpbmdzLnNoZWV0cyAtIOmFjee9ruaJgOacieWIneWniyBTaGVldCDpobXnmoTmlbDnu4RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbZGlzcGxheU1vZGU9ZmFsc2VdIC0g5bGV56S65qih5byP77yM5LiN5Y+v57yW6L6R44CCXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdEVsZW1lbnQsIHVzZXJTZXR0aW5ncywgZGlzcGxheU1vZGUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcbiAgICAgICAgdGhpcy5nZXRVc2VyU2V0dGluZ3ModXNlclNldHRpbmdzKTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0ge307XG4gICAgICAgIGV4dGVuZCh0aGlzLnNldHRpbmdzLCBTcHJlYWRTaGVldC5kZWZhdWx0U2V0dGluZ3MpO1xuICAgICAgICBleHRlbmQodGhpcy5zZXR0aW5ncywgdGhpcy51c2VyU2V0dGluZ3MpO1xuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLnNldHRpbmdzLmlkIHx8IHRoaXMuZ2V0SWQoKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5TW9kZSA9IGRpc3BsYXlNb2RlO1xuXG4gICAgICAgIHRoaXMuX2luaXRQbHVnaW4oKTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IG5ldyBGcmFtZSh0aGlzLCB0aGlzLnNldHRpbmdzLmZyYW1lKTtcbiAgICAgICAgdGhpcy53b3JrYm9vayA9IG5ldyBXb3JrYm9vayh0aGlzLCB0aGlzLnNldHRpbmdzLndvcmtib29rKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlUGx1Z2luKCk7XG4gICAgfVxuXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIC8vIOS4jeaMh+WumiBpZCDml7bvvIzlsL3ph4/nlJ/miJDkuI3lj6/ph43lpI3nmoQgaWTvvIjkvb/nlKjlvZPliY0gaWZyYW1lIOiHquWinuWPmOmHj+mFjeWQiOmaj+acuuWtl+espuS4sueahOaWueW8j++8iVxuICAgICAgICByZXR1cm4gdGhpcy5pZCB8fCBTcHJlYWRTaGVldC5nbG9iYWxTZXR0aW5ncy5pZFByZWZpeCArIChBVVRPX0lEKyspICsgJy0nICsgcmFuZG9tU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgZ2V0Um9vdEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50O1xuICAgIH1cblxuICAgIGdldERpc3BsYXlNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5TW9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5bnlKjmiLfkvKDlhaXnmoTliJ3lp4vphY3nva7jgIJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHMgLSDooajnpLrnlKjmiLfphY3nva7nmoQgSlNPTiDlrZfnrKbkuLJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFVzZXJTZXR0aW5ncyhzKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZXJTZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlclNldHRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzICYmIHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy51c2VyU2V0dGluZ3MgPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51c2VyU2V0dGluZ3MgPSBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJTZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5YgU3ByZWFkU2hlZXQg5a6e6ZmF55Sf5pWI55qE6YWN572u5L+h5oGv44CCXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5Y+v5Lqk5o2i55qE5Lit6Ze05pWw5o2u77yM55So5LqO5pWw5o2u5o+Q5Lqk44CB6Kej5p6Q6L2s5o2i562J44CCXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3JhZ2luPWZhbHNlXSAtIOS4uiBgdHJ1ZWAg5pe26I635Y+W5Y6f5aeLIEphdmFTY3JpcHQg5a+56LGhXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRFeGNoYW5nZURhdGEob3JhZ2luID0gZmFsc2UpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmtib29rLl9nZXRFeGNoYW5nZSgpO1xuICAgICAgICB2YXIgZiA9IHRoaXMuZnJhbWUuX2dldEV4Y2hhbmdlKCk7IC8vIFRPRE8gZnJhbWVcbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICB3b3JrYm9vazogdyxcbiAgICAgICAgICAgIGZyYW1lOiBmLFxuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SWQoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3JhZ2luID8gbyA6IEpTT04uc3RyaW5naWZ5KG8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjSBTcHJlYWRTaGVldCDlr7nlupTnmoQgV29ya2Jvb2sg5a6e5L6L44CCXG4gICAgICogQHJldHVybnMge1dvcmtib29rfVxuICAgICAqL1xuICAgIGdldFdvcmtib29rSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtib29rO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjSBTcHJlYWRTaGVldCDlr7nlupTnmoQgRnJhbWUg5a6e5L6L44CCXG4gICAgICogQHJldHVybnMge0ZyYW1lfVxuICAgICAqL1xuICAgIGdldEZyYW1lSW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1lO1xuICAgIH1cblxuXG4gICAgX2luaXRQbHVnaW4oKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZ2V0QWxsUGx1Z2lucygpLmZvckVhY2goUCA9PiB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQKHRoaXMpO1xuICAgICAgICAgICAgdmFsaWRhdGVQbHVnaW4ocCk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMuc2V0KHAuX19uYW1lX18sIHApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfZW5hYmxlUGx1Z2luKCkge1xuICAgICAgICB0aGlzLnBsdWdpbnMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgIGlmIChwLmlzRW5hYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBwLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwcmVhZFNoZWV0OyIsIi8qKlxuICog6YWN572u57+76K+R57G744CCXG4gKiDmoYbmnrblhoXpg6jkvb/nlKjvvIznlKjmiLfku6PnoIHkuI3lupTor6XosIPnlKjlroPjgIJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb25maWdUcmFuc2xhdG9yIHtcblxuICAgIC8qKlxuICAgICAqIOaehOmAoOWZqFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U2hlZXR9IHNoZWV0XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzaGVldCkge1xuICAgICAgICB0aGlzLmluaXRpYWxDb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIOe/u+ivkemFjee9ruOAglxuICAgICAqIOS4remXtOaVsOaNruagvOW8j+eahOiuvuiuoeS8muWwvemHj+WQjOaXtuS/neivgeWcqCBFeGNlbCDlj4ogV2ViIOmhtemdouS4reWdh+S+v+S6juWkhOeQhu+8jFxuICAgICAqIOS9huS4jeWFjeWtmOWcqOS4gOS6myBXZWIg5Lit6Zq+5Lul55u05o6l5L2/55So55qE5pWw5o2u5qC85byP77yM6K+l5pa55rOV5Y2z5piv5a6M5oiQ5q2k57G75pWw5o2u5qC85byPXG4gICAgICog55qE6YCC6YWN6L2s5o2i5bel5L2c44CCXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZSgpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge307XG4gICAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVtpXS5zdGFydHNXaXRoKCdfdHJhbnMnKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlbaV1dLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kc29udGFibGUg5Lit55qE5LiA5Lqb54q25oCB5peg5rOV6YCa6L+H5Yid5aeL6YWN572u5Y+C5pWw5o6n5Yi277yMXG4gICAgICog5Y+q6IO95Zyo5a6e5L6L5YyW5LmL5ZCO6LCD55So55u45bqU55qE5pa55rOV5p2l5oGi5aSN55u45bqU55qE54q25oCB77yM5q2k5pa55rOVXG4gICAgICog5Y2z5piv5a6M5oiQ6K+l5Yqf6IO944CCXG4gICAgICovXG4gICAgaW5pdFNoZWV0U3RhdGUoKSB7XG4gICAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVtpXS5zdGFydHNXaXRoKCdfaW5pdCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eVtpXV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB0cmFuc2xhdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBfdHJhbnNDZWxsKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5pbml0aWFsQ29uZmlnLmNlbGxNZXRhcztcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmNlbGwgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCByb3cgPSBtW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsTWV0YSA9IHJvd1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5yb3cgPSBjZWxsTWV0YS5yb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbCA9IGNlbGxNZXRhLmNvbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5kYXRhVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGR0IGluIGNlbGxNZXRhLmRhdGFUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5kYXRhVHlwZS5oYXNPd25Qcm9wZXJ0eShkdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbZHRdID0gY2VsbE1ldGEuZGF0YVR5cGVbZHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwudHlwZSA9IGNlbGxNZXRhLmRhdGFUeXBlLnR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsLnR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbE1ldGEuc3R5bGVzLmFsaWdubWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGMgPSBjZWxsTWV0YS5zdHlsZXMuYWxpZ25tZW50cy5qb2luKCcgaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jbGFzc05hbWUgPSBjZWxsLmNsYXNzTmFtZSA/IChjZWxsLmNsYXNzTmFtZSArPSAnIGh0JyArIGMpIDogJ2h0JyArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuZm9udEZhbWlseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLl9zdHlsZV9mb250RmFtaWx5ID0gY2VsbE1ldGEuc3R5bGVzLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuZm9udFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5fc3R5bGVfZm9udFNpemUgPSBjZWxsTWV0YS5zdHlsZXMuZm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5fc3R5bGVfY29sb3IgPSBjZWxsTWV0YS5zdHlsZXMuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuX3N0eWxlX2JhY2tncm91bmRDb2xvciA9IGNlbGxNZXRhLnN0eWxlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTWV0YS5zdHlsZXMuZm9udFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NOYW1lID0gY2VsbC5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGNlbGwuY2xhc3NOYW1lICs9ICcgc3NkLWZvbnQtJyArIGNlbGxNZXRhLnN0eWxlcy5mb250U3R5bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzc2QtZm9udC0nICsgY2VsbE1ldGEuc3R5bGVzLmZvbnRTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNZXRhLnN0eWxlcy5mb250V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NOYW1lID0gY2VsbC5jbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGNlbGwuY2xhc3NOYW1lICs9ICcgc3NkLWZvbnQtYm9sZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzc2QtZm9udC1ib2xkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNZXRhLnN0eWxlcy50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNsYXNzTmFtZSA9IGNlbGwuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChjZWxsLmNsYXNzTmFtZSArPSAnIHNzZC1mb250LXVuZGVybGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzc2QtZm9udC11bmRlcmxpbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNlbGwucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF90cmFuc0RhdGEoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmluaXRpYWxDb25maWcuZGF0YTtcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIC8vIGhvdFRhYmxlIOWcqOaciSBkYXRhIOeahOaDheWGteS4i+WPquiDveaYvuekuuacieaVsOaNrueahOihjOWIl++8jOi/meWvueS6juiuvuiuoeWZqOadpeivtOW5tuS4jeaWueS+v+S9v+eUqO+8jFxuICAgICAgICAgICAgLy8g5pWF5aGr5YWF56m65pWw5o2u5Lul5pKR6LW36KGo5qC86IezIGluaXRSb3dzICogaW5pdENvbHMg55qE5aSn5bCP44CCXG4gICAgICAgICAgICAvLyAgICBpZiAocy5sZW5ndGggPCB0aGlzLnNoZWV0LmluaXRSb3dzKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgbGV0IGZvcm1lckNvbCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gICAgICAgIHMubGVuZ3RoID0gdGhpcy5zaGVldC5pbml0Um93cztcbiAgICAgICAgICAgIC8vICAgICAgICBzLmZpbGwoW10sIGZvcm1lckNvbCk7XG4gICAgICAgICAgICAvLyAgICB9XG4gICAgICAgICAgICAvLyAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vICAgICAgICBsZXQgcm93ID0gc1tpXTtcbiAgICAgICAgICAgIC8vICAgICAgICBpZiAocm93Lmxlbmd0aCA8IHRoaXMuc2hlZXQuaW5pdENvbHMpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgbGV0IGZvcm1lclJvdyA9IHJvdy5sZW5ndGg7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgIHJvdy5sZW5ndGggPSB0aGlzLnNoZWV0LmluaXRDb2xzO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICByb3cuZmlsbCgnJywgZm9ybWVyUm93KTtcbiAgICAgICAgICAgIC8vICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICB9XG5cbiAgICAgICAgICAgIC8vIOS9v+eUqCBob3QgQVBJIOWujOaIkOS4iui/sOWKn+iDvVxuICAgICAgICAgICAgc2V0dGluZ3MubWluUm93cyA9IHRoaXMuc2hlZXQuaW5pdFJvd3M7XG4gICAgICAgICAgICBzZXR0aW5ncy5taW5Db2xzID0gdGhpcy5zaGVldC5pbml0Q29scztcblxuICAgICAgICAgICAgc2V0dGluZ3MuZGF0YSA9IHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDliJflrr1cbiAgICBfdHJhbnNDb2xXaWR0aHMoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmluaXRpYWxDb25maWcuY29sV2lkdGhzO1xuICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgc2V0dGluZ3MuY29sV2lkdGhzID0gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIOihjOmrmFxuICAgIF90cmFuc1Jvd0hlaWdodHMoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLmluaXRpYWxDb25maWcucm93SGVpZ2h0cztcbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnJvd0hlaWdodHMgPSBoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8g6L655qGGXG4gICAgX3RyYW5zQm9yZGVycyhzZXR0aW5ncykge1xuICAgICAgICB2YXIgcyA9IHRoaXMuaW5pdGlhbENvbmZpZy5ib3JkZXJzO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgc2V0dGluZ3MuY3VzdG9tQm9yZGVycyA9IHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyDlkIjlubbljZXlhYPmoLxcbiAgICBfdHJhbnNNZXJnZUNlbGxzKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5pbml0aWFsQ29uZmlnLm1lcmdlQ2VsbHM7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tZXJnZUNlbGxzID0gcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBpbml0U3RhdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyDpgInljLpcbiAgICBfaW5pdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmluaXRpYWxDb25maWcuc2VsZWN0aW9uO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgdGhpcy5zaGVldC5zZWxlY3Qocy5yb3csIHMuY29sLCBzLmVuZFJvdywgcy5lbmRDb2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaGVldC5zZWxlY3QoMCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29uZmlnVHJhbnNsYXRvcjsiLCJpbXBvcnQgQ29udGV4dE1lbnUgZnJvbSAnLi9mcmFtZS9Db250ZXh0TWVudSdcblxuLyoqXG4gKiDnlLXlrZDooajmoLzorr7orqHlmajkuK3vvIzpmaTkuoYgV29ya2Jvb2sg5aSW55qE57uE5Lu2566h55CG5Zmo77yMXG4gKiDljIXlkKvoj5zljZXmoI/jgIHlt6XlhbfmoI/jgIHkvqfovrnmoI/jgIHlj7PplK7oj5zljZXnrYnnrYnjgIJcbiAqL1xuY2xhc3MgRnJhbWUge1xuXG4gICAgY29uc3RydWN0b3IoaW5zdGFuY2UsIGNvbmZpZykge1xuICAgICAgICB0aGlzLnNwcmVhZFNoZWV0ID0gaW5zdGFuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Q29udGV4dE1lbnV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51ID0gbmV3IENvbnRleHRNZW51KGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBfZ2V0RXhjaGFuZ2UoKSB7XG5cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRnJhbWU7IiwiLyoqXG4gKiBIYW5kc29udGFibGUg57uE5Lu255qE6YCC6YWN57G7XG4gKi9cbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi91dGlscy9jb21tb24uanMnXG5pbXBvcnQgQ29uZmlnVHJhbnNsYXRvciBmcm9tICcuL0NvbmZpZ1RyYW5zbGF0b3IuanMnXG5cbmNsYXNzIEhvdFRhYmxlQWRhcHRvciBleHRlbmRzIEhhbmRzb250YWJsZSB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJvb3RFbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIOWOn+Wni+mFjee9ruS/oeaBr1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBleHRDb25maWcgLSDpmYTliqDnmoTphY3nva7kv6Hmga9cbiAgICAgKiBAcGFyYW0ge1NoZWV0fSBzaGVldCAtIOWvueW6lOeahCBzaGVldCDlrp7kvotcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihyb290RWxlbWVudCwgY29uZmlnLCBleHRDb25maWcsIHNoZWV0KSB7XG4gICAgICAgIGxldCBob3RTZXR0aW5ncyA9IHt9O1xuICAgICAgICBsZXQgdHJhbnNsYXRvciA9IG5ldyBDb25maWdUcmFuc2xhdG9yKGNvbmZpZywgc2hlZXQpO1xuICAgICAgICBsZXQgc2V0dGluZ3MgPSB0cmFuc2xhdG9yLnRyYW5zbGF0ZSgpO1xuXG4gICAgICAgIGxldCBmcmFtZSA9IHNoZWV0Lndvcmtib29rLnNwcmVhZFNoZWV0LmdldEZyYW1lSW5zdGFuY2UoKTtcbiAgICAgICAgbGV0IGRpc3BsYXlNb2RlID0gc2hlZXQud29ya2Jvb2suc3ByZWFkU2hlZXQuZ2V0RGlzcGxheU1vZGUoKTtcbiAgICAgICAgbGV0IG1lbnVJdGVtcyA9IGZyYW1lLmNvbnRleHRNZW51Lm1lbnVJdGVtcztcbiAgICAgICAgbGV0IGNvbnRleHRNZW51ID0ge307XG4gICAgICAgIGNvbnRleHRNZW51Lml0ZW1zID0gZnJhbWUuY29udGV4dE1lbnUuZ2V0TWVudUl0ZW1zNEhvdFRhYmxlKCk7XG4gICAgICAgIGNvbnRleHRNZW51LmNhbGxiYWNrID0gKGZ1bmN0aW9uIChzaGVldCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVudUl0ZW1zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbWVudUl0ZW1zLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmhhbmRsZXIuY2FsbCh0aGlzLCBzaGVldCwgb3B0aW9ucy5zdGFydCwgb3B0aW9ucy5lbmQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfShzaGVldCkpO1xuICAgICAgICBIb3RUYWJsZUFkYXB0b3IuX3ByZWZlcmVuY2UuY29udGV4dE1lbnUgPSBjb250ZXh0TWVudTtcblxuICAgICAgICBleHRlbmQoaG90U2V0dGluZ3MsIEhvdFRhYmxlQWRhcHRvci5fcHJlZmVyZW5jZSk7XG4gICAgICAgIGV4dGVuZChob3RTZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICBleHRlbmQoaG90U2V0dGluZ3MsIGV4dENvbmZpZyk7XG5cbiAgICAgICAgaWYgKGRpc3BsYXlNb2RlKSB7XG4gICAgICAgICAgICBob3RTZXR0aW5ncy5jb2xIZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICBob3RTZXR0aW5ncy5yb3dIZWFkZXJzID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlcihyb290RWxlbWVudCwgaG90U2V0dGluZ3MpO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zbGF0b3IgPSB0cmFuc2xhdG9yO1xuXG4gICAgICAgIC8vIGhhbmRvbnRhYmxlIOavj+asoSByZW5kZXIg55qE5pe25YCZ77yM5LiN5L+d55WZIHRkIOeahOeKtuaAge+8jOWboOatpOmAmui/h+ivpeS6i+S7tumHjeW7uuS4gOS6m+agt+W8j+OAglxuICAgICAgICAvL25vaW5zcGVjdGlvbiBFUzZNb2R1bGVzRGVwZW5kZW5jaWVzXG4gICAgICAgIEhhbmRzb250YWJsZS5ob29rcy5hZGQoJ2JlZm9yZVJlbmRlcmVyJywgZnVuY3Rpb24gKFRELCByb3csIGNvbCwgcHJvcCwgdmFsdWUsIGNlbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBURC5zdHlsZS5jb2xvciA9IGNlbGxQcm9wZXJ0aWVzLl9zdHlsZV9jb2xvciB8fCAnJztcbiAgICAgICAgICAgIFRELnN0eWxlLmZvbnRGYW1pbHkgPSBjZWxsUHJvcGVydGllcy5fc3R5bGVfZm9udEZhbWlseSB8fCAnJztcbiAgICAgICAgICAgIFRELnN0eWxlLmZvbnRTaXplID0gY2VsbFByb3BlcnRpZXMuX3N0eWxlX2ZvbnRTaXplIHx8ICcnO1xuICAgICAgICAgICAgVEQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY2VsbFByb3BlcnRpZXMuX3N0eWxlX2JhY2tncm91bmRDb2xvciB8fCAnJztcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICog5bCGIEhhbmRzb250YWJsZSDnmoTmiYDmnInkuovku7bpg73lp5TmiZjnu5kgU3ByZWFkU2hlZXQg5ZCO5Lya5pyJ5Lqb5Y2h44CCXG4gICAgICAgICAqIOWPquWlveWwhiBIYW5kc29udGFibGUuaG9va3MuZ2V0UmVnaXN0ZXJlZCgpIOaNouaIkCBFQ1Ag6aG555uu6ZyA6KaB55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBbJ2FmdGVyU2VsZWN0aW9uRW5kJ10uZm9yRWFjaChob29rID0+IHtcbiAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEVTNk1vZHVsZXNEZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIEhhbmRzb250YWJsZS5ob29rcy5hZGQoaG9vaywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGhvb2spO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChzaGVldCk7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgbGV0IGN4dCA9IHNoZWV0Lndvcmtib29rLnNwcmVhZFNoZWV0O1xuICAgICAgICAgICAgICAgIGN4dC5lbWl0LmFwcGx5KGN4dCwgYXJncyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdHJhbnNsYXRvcjtcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIOmihOiuvumFjee9ruOAglxuICogQHByaXZhdGVcbiAqL1xuSG90VGFibGVBZGFwdG9yLl9wcmVmZXJlbmNlID0ge1xuICAgIG91dHNpZGVDbGlja0Rlc2VsZWN0czogZmFsc2UsXG4gICAgY29udGV4dE1lbnU6IHRydWUsXG5cbiAgICByb3dIZWFkZXJzOiB0cnVlLFxuICAgIGNvbEhlYWRlcnM6IHRydWUsXG5cbiAgICBtYW51YWxDb2x1bW5SZXNpemU6IHRydWUsXG4gICAgbWFudWFsUm93UmVzaXplOiB0cnVlLFxuXG4gICAgdGFibGVDbGFzc05hbWU6ICdzc2QtaGFuZHNvbnRhYmxlJyxcblxuICAgIGN1c3RvbUJvcmRlcnM6IHRydWUsXG5cbiAgICB4Rm9ybXVsYXM6IHRydWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhvdFRhYmxlQWRhcHRvcjsiLCJpbXBvcnQgSGFuZHNvbnRhYmxlIGZyb20gJy4vSG90VGFibGVBZGFwdG9yJztcbmltcG9ydCB7U2hlZXRFcnJvcn0gZnJvbSAnLi9TaGVldEVycm9yJztcbmltcG9ydCB7RXhjaGFuZ2V9IGZyb20gJy4vZXh0L1NoZWV0X2V4Y2hhbmdlJztcbmltcG9ydCB7U2hlZXRIZWxwZXJ9IGZyb20gJy4vZXh0L1NoZWV0X2hlbHBlcic7XG5pbXBvcnQge0Nvb3JkaW5hdGUsIGV4dGVuZH0gZnJvbSAnLi4vdXRpbHMvY29tbW9uJztcbmltcG9ydCBFbWl0dGVyIGZyb20gJy4uL3V0aWxzL0VtaXR0ZXInO1xuXG5cbmNvbnN0IElOSVRfUk9XUyA9IDE1MDsgLy8gU2hlZXQg5Yid5aeL5Y+v5pi+56S655qE6KGM5pWwXG5jb25zdCBJTklUX0NPTFMgPSA1MDsgIC8vIFNoZWV0IOWIneWni+WPr+aYvuekuueahOWIl+aVsFxuXG4vLyBXZWJzdG9ybSBJREUg55qE6K+t5rOV5qOA5p+l5oiWIHNvdXJlbWFwIOino+aekOaXtuS4jeaUr+aMgeebtOaOpeWGmeWIsOexu+eahCBleHRlbmRzIOWQjuOAglxudmFyIE1peGluID0gU2hlZXRIZWxwZXIoRXhjaGFuZ2UoRW1pdHRlcikpO1xuXG4vKipcbiAqIOW3peS9nOihqFxuICpcbiAqIEBmaXJlcyBTaGVldCNhZnRlclJlbmFtZVxuICogQGZpcmVzIFNoZWV0I2FmdGVyUmVuYW1lQ2FuY2VsXG4gKi9cbmNsYXNzIFNoZWV0IGV4dGVuZHMgTWl4aW4ge1xuXG4gICAgLyoqXG4gICAgICog5p6E6YCgIFNoZWV0IOWunuS+i++8jOeUqOaIt+S7o+eggeS4jeW6lOivpeebtOaOpeiwg+eUqOWug++8jFxuICAgICAqIOiAjOaYr+S9v+eUqCBXb3JrYm9vay5jcmVhdGVTaGVldCgpIOaWueazleaehOmAoOOAglxuICAgICAqXG4gICAgICogQHBhcmFtIHtXb3JrYm9va30gd29ya2Jvb2tcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih3b3JrYm9vaywgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzaGVldCDmiYDlnKjnmoTlt6XkvZzooahcbiAgICAgICAgICogQHR5cGUge1dvcmtib29rfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53b3JrYm9vayA9IHdvcmtib29rO1xuICAgICAgICB0aGlzLiQkdmlldyA9IHdvcmtib29rLiQkdmlldztcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5zaGVldE5hbWUgPSBjb25maWcubmFtZTtcblxuICAgICAgICB0aGlzLmluaXRSb3dzID0gSU5JVF9ST1dTO1xuICAgICAgICB0aGlzLmluaXRDb2xzID0gSU5JVF9DT0xTO1xuXG4gICAgICAgIHRoaXMuZnggPSB7fTsgLy8gVE9ET1xuXG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlcigpIHtcbiAgICAgICAgdGhpcy4kJHZpZXcuYXBwZW5kVGFiKHRoaXMuc2hlZXROYW1lKTtcbiAgICAgICAgdmFyIHtjb250YWluZXIsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcy4kJHZpZXcuX2hvdFRhYmxlcy5nZXQodGhpcy5zaGVldE5hbWUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SGFuZHNvbnRhYmxlfVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmhhbmRzb250YWJsZSA9IG5ldyBIYW5kc29udGFibGUoY29udGFpbmVyLCB0aGlzLnNldHRpbmdzLCB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0aGlzLndvcmtib29rLnNwcmVhZFNoZWV0LmdldERpc3BsYXlNb2RlKCksXG4gICAgICAgICAgICBzdGFydFJvd3M6IHRoaXMuaW5pdFJvd3MsXG4gICAgICAgICAgICBzdGFydENvbHM6IHRoaXMuaW5pdENvbHMsXG4gICAgICAgICAgICBfaXNIb3RUYWJsZUFkYXB0b3I6IHRydWUsXG4gICAgICAgICAgICBfc2hlZXQ6IHRoaXNcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLl90cmFuc2xhdG9yLmluaXRTaGVldFN0YXRlKCk7XG4gICAgICAgIHRoaXMuJCR2aWV3LmhpZGVDb250ZW50KHRoaXMuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5blvZPliY0gc2hlZXQg55qE5ZCN5a2XXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGVldE5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5r+A5rS75b2T5YmNIHNoZWV0IOmhtVxuICAgICAqL1xuICAgIGFjdGl2ZSgpIHtcbiAgICAgICAgdGhpcy53b3JrYm9vay5hY3RpdmVTaGVldCA9IHRoaXMuZ2V0TmFtZSgpO1xuICAgICAgICB0aGlzLiQkdmlldy5hY3RpdmVUYWIodGhpcy5nZXROYW1lKCkpO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmo4DmtYvlvZPliY0gc2hlZXQg5piv5ZCm6KKr5r+A5rS7XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtib29rLmFjdGl2ZVNoZWV0ID09PSB0aGlzLmdldE5hbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlhbPpl60gc2hlZXQg6aG1XG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMud29ya2Jvb2suY2xvc2VTaGVldCh0aGlzLmdldE5hbWUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6ZSA5q+B5b2T5YmNIHNoZWV0XG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLndvcmtib29rLnNoZWV0cy5kZWxldGUodGhpcy5nZXROYW1lKCkpO1xuICAgICAgICBkZWxldGUgdGhpcy53b3JrYm9vaztcbiAgICAgICAgZGVsZXRlIHRoaXMuJCR2aWV3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe7mSBzaGVldCDpobXph43lkb3lkI1cbiAgICAgKiBAcGFyYW0gbmFtZSAtIOaWsOWQjeWtl1xuICAgICAqL1xuICAgIHJlbmFtZShuYW1lKSB7XG4gICAgICAgIHRoaXMud29ya2Jvb2sucmVuYW1lU2hlZXQodGhpcy5nZXROYW1lKCksIG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmAieS4rSBzaGVldCDkuK3nmoTmn5DljLrln5/jgIJcbiAgICAgKiDkuI3mjIflrpogdG9Sb3cg44CBdG9Db2wg5pe25YiZ6YCJ5Lit5a+55bqU55qE5Y2V5YWD5qC844CCXG4gICAgICogQHBhcmFtIHtpbnR9IGZyb21Sb3cgLSDotbflp4vooYxcbiAgICAgKiBAcGFyYW0ge2ludH0gZnJvbUNvbCAtIOi1t+Wni+WIl1xuICAgICAqIEBwYXJhbSB7aW50fSBbdG9Sb3ddIC0g57uI5q2i6KGMXG4gICAgICogQHBhcmFtIHtpbnR9IFt0b0NvbF0gLSDnu4jmraLliJdcbiAgICAgKi9cbiAgICBzZWxlY3QoZnJvbVJvdywgZnJvbUNvbCwgdG9Sb3csIHRvQ29sKSB7XG4gICAgICAgIHRvUm93ID0gdG9Sb3cgfHwgZnJvbVJvdztcbiAgICAgICAgdG9Db2wgPSB0b0NvbCB8fCBmcm9tQ29sO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5zZWxlY3RDZWxsKGZyb21Sb3csIGZyb21Db2wsIHRvUm93LCB0b0NvbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+W+l+W9k+WJjSBzaGVldCDnmoTpgInljLpcbiAgICAgKiBAcmV0dXJucyB7e3JvdywgY29sLCBlbmRSb3csIGVuZENvbH19XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5oYW5kc29udGFibGUuZ2V0U2VsZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogc2VsZWN0aW9uWzBdLFxuICAgICAgICAgICAgY29sOiBzZWxlY3Rpb25bMV0sXG4gICAgICAgICAgICBlbmRSb3c6IHNlbGVjdGlvblsyXSxcbiAgICAgICAgICAgIGVuZENvbDogc2VsZWN0aW9uWzNdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlkIjlubbljZXlhYPmoLxcbiAgICAgKiBUSVA6IGhhbmRzb250YWJsZSDlrpjmlrnlkIjlubblip/og73kuI3og73mraPnoa7lpITnkIblt7LmnInnmoTlkIjlubbljLrln5/vvIzmlYXlgZrph43mlrDorqHnrpfjgIJcbiAgICAgKiBAcGFyYW0ge2ludH0gcm93IC0g6LW35aeL6KGMXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbCAtIOi1t+Wni+WIl1xuICAgICAqIEBwYXJhbSB7aW50fSByb3dzcGFuIC0g5b6F5ZCI5bm255qE6KGM5pWwXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbHNwYW4gLSDlvoXlkIjlubbnmoTliJfmlbBcbiAgICAgKi9cbiAgICAvLyBUT0RPIOacgOWkp+ihjOWIl+aVsOmZkOWItlxuICAgIG1lcmdlQ2VsbHMocm93LCBjb2wsIHJvd3NwYW4sIGNvbHNwYW4pIHtcbiAgICAgICAgdmFyIHIgPSAwO1xuICAgICAgICB2YXIgY292ZXIgPSBbXTtcbiAgICAgICAgdmFyIG1lcmdlQ2VsbHMgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRTZXR0aW5ncygpLm1lcmdlQ2VsbHM7XG5cbiAgICAgICAgdmFyIHIxID0gW3JvdywgY29sLCByb3cgKyByb3dzcGFuIC0gMSwgY29sICsgY29sc3BhbiAtIDFdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBtZXJnZUNlbGxzLmxlbmd0aDsgaTsgLS1pKSB7XG4gICAgICAgICAgICBsZXQgZiA9IG1lcmdlQ2VsbHNbaSAtIDFdO1xuICAgICAgICAgICAgbGV0IHIyID0gW2Yucm93LCBmLmNvbCwgZi5yb3cgKyBmLnJvd3NwYW4gLSAxLCBmLmNvbCArIGYuY29sc3BhbiAtIDFdO1xuXG4gICAgICAgICAgICAvLyDkuI7ljp/ljLrln5/lrZjlnKjlrozlhajph43lj6BcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmlzRXF1YWwocjEsIHIyKSkge1xuICAgICAgICAgICAgICAgIHIgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5piv5Y6f5Yy65Z+f55qE5a2Q6ZuGXG4gICAgICAgICAgICBpZiAoQ29vcmRpbmF0ZS5pc1N1YnNldChyMSwgcjIpKSB7XG4gICAgICAgICAgICAgICAgciA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyDopobnm5bljp/ljLrln5/vvIjmraTml7blj6/og73kuI7lj6bkuIDkuKrljp/ljLrln5/kuqTpm4bmiJblrozlhajopobnm5bvvIlcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmlzU3VwZXJzZXQocjEsIHIyKSkge1xuICAgICAgICAgICAgICAgIGNvdmVyLnB1c2goaSAtIDEpO1xuICAgICAgICAgICAgICAgIHIgPSAzO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5LiO5Y6f5Yy65Z+f5a2Y5Zyo5Lqk6ZuGKOS4jeWQq+WtkOmbhuOAgei2hembhuaDheWGtSlcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmludGVyc2VjdGlvbihyMSwgcjIpKSB7XG4gICAgICAgICAgICAgICAgciA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAociA9PT0gMCB8fCByID09PSAzKSB7XG4gICAgICAgICAgICBpZiAociA9PT0gMykgeyAvLyDov5nnp43mg4XlhrXkuIvkuIDlrprlrZjlnKjlt7Lnu4/lkIjlubbov4fnmoTljZXlhYPmoLxcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlQ2VsbHMuc3BsaWNlKGNvdmVyW2ldLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZUNlbGxzID0gbWVyZ2VDZWxscyB8fCBbXTtcbiAgICAgICAgICAgIG1lcmdlQ2VsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgcm93c3Bhbjogcm93c3BhbixcbiAgICAgICAgICAgICAgICBjb2xzcGFuOiBjb2xzcGFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnVwZGF0ZVNldHRpbmdzKHtcbiAgICAgICAgICAgICAgICBtZXJnZUNlbGxzOiBtZXJnZUNlbGxzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChyID09PSAyIHx8IHIgPT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDnu5nlrprnmoTlkIjlubbljLrln5/kuI3lkIjms5U6IFske3Jvd30sICR7Y29sfSwgJHtyb3dzcGFufSwgJHtjb2xzcGFufV1gKVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDlj5bmtojljZXlhYPmoLzlkIjlubZcbiAgICAgKiBAcGFyYW0ge2ludH0gcm93IC0g6LW35aeL6KGMXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbCAtIOi1t+Wni+WIl1xuICAgICAqIEBwYXJhbSB7aW50fSByb3dzcGFuIC0g5b6F5ZCI5bm255qE6KGM5pWwXG4gICAgICogQHBhcmFtIHtpbnR9IGNvbHNwYW4gLSDlvoXlkIjlubbnmoTliJfmlbBcbiAgICAgKi9cbiAgICB1bk1lcmdlQ2VsbHMocm93LCBjb2wsIHJvd3NwYW4sIGNvbHNwYW4pIHtcbiAgICAgICAgdmFyIG1lcmdlZCA9IHRoaXMuaGFuZHNvbnRhYmxlLmdldFNldHRpbmdzKCkubWVyZ2VDZWxscztcbiAgICAgICAgdmFyIG1lcmdlQ2VsbHMgPSBbXTtcbiAgICAgICAgaWYgKG1lcmdlZCAmJiBtZXJnZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lcmdlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChDb29yZGluYXRlLmlzU3Vic2V0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFtpXS5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRbaV0uY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW2ldLnJvdyArIG1lcmdlZFtpXS5yb3dzcGFuIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFtpXS5jb2wgKyBtZXJnZWRbaV0uY29sc3BhbiAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSwgW3JvdywgY29sLCByb3cgKyByb3dzcGFuIC0gMSwgY29sICsgY29sc3BhbiAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWVyZ2VDZWxscy5wdXNoKG1lcmdlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICAgICAgbWVyZ2VDZWxsczogbWVyZ2VDZWxscy5sZW5ndGggPT09IDAgPyBmYWxzZSA6IG1lcmdlQ2VsbHNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3BsaWNlQ2xhc3Moc2VsZWN0aW9uLCBuZXdDbGFzc05hbWUsIC4uLmNsYXNzTmFtZXMpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKHJvdywgY29sLCBjZWxsTWV0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICh0aGlzLl9yZW1vdmVGb3JtZXJDbGFzcyhcbiAgICAgICAgICAgICAgICAgICAgY2VsbE1ldGEuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzXG4gICAgICAgICAgICAgICAgKSArICcgJyArIG5ld0NsYXNzTmFtZSkudHJpbSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7Y2xhc3NOYW1lOiBuZXdDbGFzc05hbWV9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7lrZfkvZPliqDnspdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZT10cnVlXSBgdHJ1ZWAg5Li65Yqg57KX77yMYGZhbHNlYCDlj5bmtojliqDnspdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VsZWN0aW9uIC0g5b6F6K6+572u55qE6YCJ5Yy6XG4gICAgICogQHBhcmFtIHtpbnR9IHNlbGVjdGlvbi5yb3dcbiAgICAgKiBAcGFyYW0ge2ludH0gc2VsZWN0aW9uLmNvbFxuICAgICAqIEBwYXJhbSB7aW50fSBbc2VsZWN0aW9uLmVuZFJvd11cbiAgICAgKiBAcGFyYW0ge2ludH0gW3NlbGVjdGlvbi5lbmRDb2xdXG4gICAgICovXG4gICAgc2V0Rm9udEJvbGQodmFsdWUgPSB0cnVlLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICdzc2QtZm9udC1ib2xkJywgJ3NzZC1mb250LWJvbGQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlQ2xhc3Moc2VsZWN0aW9uLCAnJywgJ3NzZC1mb250LWJvbGQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7mlpzkvZPlrZdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZT10cnVlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZWxlY3Rpb24gLSDlvoXorr7nva7nmoTpgInljLpcbiAgICAgKiBAcGFyYW0ge2ludH0gc2VsZWN0aW9uLnJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBzZWxlY3Rpb24uY29sXG4gICAgICogQHBhcmFtIHtpbnR9IFtzZWxlY3Rpb24uZW5kUm93XVxuICAgICAqIEBwYXJhbSB7aW50fSBbc2VsZWN0aW9uLmVuZENvbF1cbiAgICAgKi9cbiAgICBzZXRGb250SXRhbGljKHZhbHVlID0gdHJ1ZSwgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlQ2xhc3Moc2VsZWN0aW9uLCAnc3NkLWZvbnQtaXRhbGljJywgJ3NzZC1mb250LWl0YWxpYycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICcnLCAnc3NkLWZvbnQtaXRhbGljJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUucmVuZGVyKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDorr7nva7lrZfkvZPkuIvliJLnur9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZT10cnVlXVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb24gLSDlvoXorr7nva7nmoTpgInljLpcbiAgICAgKiBAcGFyYW0ge2ludH0gc2VsZWN0aW9uLnJvd1xuICAgICAqIEBwYXJhbSB7aW50fSBzZWxlY3Rpb24uY29sXG4gICAgICogQHBhcmFtIHtpbnR9IFtzZWxlY3Rpb24uZW5kUm93XVxuICAgICAqIEBwYXJhbSB7aW50fSBbc2VsZWN0aW9uLmVuZENvbF1cbiAgICAgKi9cbiAgICBzZXRGb250VW5kZXJsaW5lKHZhbHVlID0gdHJ1ZSwgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlQ2xhc3Moc2VsZWN0aW9uLCAnc3NkLWZvbnQtdW5kZXJsaW5lJywgJ3NzZC1mb250LXVuZGVybGluZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2VDbGFzcyhzZWxlY3Rpb24sICcnLCAnc3NkLWZvbnQtdW5kZXJsaW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u5a2X5L2T6aKc6ImyXG4gICAgICogVElQIOWmguaenCDigJxoYW5kb250YWJsZSDnm7TmjqXpgJrov4cgZ2V0Q2VsbCDojrflvpcgVEQg5ZCO6K6+572u5qC35byP4oCd77yM5b2T5YaN5qyhIHJlbmRlciDml7bkvJrlpLHmlYjjgIJcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2V0Rm9udENvbG9yKHZhbHVlID0gJycsIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfc3R5bGVfY29sb3I6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7X3N0eWxlX2NvbG9yOiB2YWx1ZX0pO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlrZfkvZPnsbvlnotcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2V0Rm9udEZhbWlseSh2YWx1ZSA9ICcnLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIHRoaXMuX3dhbGtvbkNlbGxNZXRhcyhzZWxlY3Rpb24sICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3N0eWxlX2ZvbnRGYW1pbHk6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7X3N0eWxlX2ZvbnRGYW1pbHk6IHZhbHVlfSk7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOWtl+S9k+Wkp+Wwj1xuICAgICAqIEBwYXJhbSB2YWx1ZSAtIOmcgOimgeaMh+WumuWNleS9je+8jOWmgiAxMnB4XG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNldEZvbnRTaXplKHZhbHVlLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIHRoaXMuX3dhbGtvbkNlbGxNZXRhcyhzZWxlY3Rpb24sICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3N0eWxlX2ZvbnRTaXplOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge19zdHlsZV9mb250U2l6ZTogdmFsdWV9KTtcbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u6IOM5pmv6ImyXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNldEJhY2tncm91bmRDb2xvcih2YWx1ZSA9ICcnLCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpKSB7XG4gICAgICAgIHRoaXMuX3dhbGtvbkNlbGxNZXRhcyhzZWxlY3Rpb24sICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3N0eWxlX2JhY2tncm91bmRDb2xvcjogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHtfc3R5bGVfYmFja2dyb3VuZENvbG9yOiB2YWx1ZX0pO1xuICAgICAgICB0aGlzLmhhbmRzb250YWJsZS5yZW5kZXIoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZJWE1FIGhhbmRzb250YWJsZSDnmoQgQlVHIOWwmuacquWkhOeQhu+8jOa6kOeggeWkjeadgu+8jOS4gOaXtuS5n+S4jeWlveaJqeWxleOAglxuICAgICAqIOiuvue9rui+ueahhlxuICAgICAqIEBwYXJhbSByYW5nZSAtIOi+ueahhuiMg+WbtO+8jOW9ouWmgiBge2Zvcm06IHtyb3c6IDEsIGNvbDogMX0sIHRvOiB7cm93OiAzLCBjb2w6IDR9fWAg55qE5a+56LGhXG4gICAgICogQHBhcmFtIHRvcCAtIOS4iui+ueahhu+8jOW9ouWmgiBge3dpZHRoOiAyLCBjb2xvcjogJyM1MjkyRjcnfWAg55qE5a+56LGhXG4gICAgICogQHBhcmFtIFtyaWdodF1cbiAgICAgKiBAcGFyYW0gW2JvdHRvbV1cbiAgICAgKiBAcGFyYW0gW2xlZnRdXG4gICAgICovXG4gICAgc2V0Qm9yZGVyKHJhbmdlLCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgIH07XG4gICAgICAgIGNvbmZpZy5yaWdodCA9IHJpZ2h0IHx8IHRvcDtcbiAgICAgICAgY29uZmlnLmJvdHRvbSA9IGJvdHRvbSB8fCB0b3A7XG4gICAgICAgIGNvbmZpZy5sZWZ0ID0gbGVmdCB8fCBjb25maWcucmlnaHQ7XG5cbiAgICAgICAgbGV0IGZvcm1lckJvcmRlcnMgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRTZXR0aW5ncygpLmN1c3RvbUJvcmRlcnM7XG4gICAgICAgIGlmIChmb3JtZXJCb3JkZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3JtZXJCb3JkZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWVyQm9yZGVycy5wdXNoKGNvbmZpZyk7XG5cbiAgICAgICAgLy8gVE9ETyBjdXN0b21Cb3JkZXJzIGNhbm5vdCBiZSB1cGRhdGVkIHZpYSB1cGRhdGVTZXR0aW5nc1xuICAgICAgICAvLyBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvMjAwMn1cbiAgICAgICAgdGhpcy5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICAgICAgY3VzdG9tQm9yZGVyczogZm9ybWVyQm9yZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgLy90aGlzLmhhbmRzb250YWJsZS5ydW5Ib29rcygnYWZ0ZXJJbml0Jyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDorr7nva7mlbDmja7moLzlvI9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gYHRleHRgIHwgYGRhdGVgIHwgYG51bWVyaWNgXG4gICAgICogQHBhcmFtIHNldHRpbmdzXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNldERhdGFGb3JtYXQodHlwZT0ndGV4dCcsIHNldHRpbmdzID0ge30sIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5fd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgKHJvdywgY29sLCBjZWxsTWV0YSkgPT4ge1xuICAgICAgICAgICAgbGV0IGZUeXBlID0gY2VsbE1ldGEudHlwZTtcblxuICAgICAgICAgICAgaWYgKGZUeXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2VsbE1ldGEuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2VsbE1ldGEuZGVmYXVsdERhdGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNlbGxNZXRhLmNvcnJlY3RGb3JtYXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZUeXBlID09PSAnbnVtZXJpYycpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2VsbE1ldGEuZm9ybWF0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsTWV0YS5sYW5ndWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxNZXRhLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvNDM2MFxuICAgICAgICAgICAgZGVsZXRlIGNlbGxNZXRhLnJlbmRlcmVyO1xuICAgICAgICAgICAgZGVsZXRlIGNlbGxNZXRhLmVkaXRvcjtcbiAgICAgICAgICAgIGRlbGV0ZSBjZWxsTWV0YS52YWxpZGF0b3I7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKGNlbGxNZXRhLCBzZXR0aW5ncyk7XG4gICAgICAgIH0sIHt0eXBlOiB0eXBlfSk7XG4gICAgICAgIHRoaXMuaGFuZHNvbnRhYmxlLnJlbmRlcigpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTaGVldDtcblxuXG4vKipcbiAqIGFmdGVyUmVuYW1lIOS6i+S7tuOAglxuICpcbiAqIEBldmVudCBTaGVldCNhZnRlclJlbmFtZVxuICogQHR5cGUge1NoZWV0fVxuICogQHR5cGUge3N0cmluZ31cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblxuLyoqXG4gKiBhZnRlclJlbmFtZUNhbmNlbCDkuovku7bjgIJcbiAqXG4gKiBAZXZlbnQgU2hlZXQjYWZ0ZXJSZW5hbWVDYW5jZWxcbiAqIEB0eXBlIHtTaGVldH1cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5cbiIsImltcG9ydCB7U3ByZWFkU2hlZXRFcnJvcn0gZnJvbSAnLi4vU3ByZWFkU2hlZXRFcnJvcidcblxuZXhwb3J0IGZ1bmN0aW9uIFNoZWV0RXJyb3IodmFsdWUpIHtcbiAgICB0aGlzLm5hbWUgPSAnU2hlZXRFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gdmFsdWU7XG59XG5TaGVldEVycm9yLnByb3RvdHlwZSA9IG5ldyBTcHJlYWRTaGVldEVycm9yKCk7XG5TaGVldEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoZWV0RXJyb3I7IiwiaW1wb3J0IFRhYnMgZnJvbSAgJy4vdmlld3MvVGFicydcbmltcG9ydCBTaGVldCBmcm9tICcuL1NoZWV0J1xuaW1wb3J0IHtTaGVldEVycm9yfSBmcm9tICcuL1NoZWV0RXJyb3InXG5pbXBvcnQge0Nhc2VJbnNlbnNpdGl2ZU1hcH0gZnJvbSAnLi4vdXRpbHMvZGF0YVN0cnVjdHVyZSdcbmltcG9ydCB7dXBwZXJDYXNlfSBmcm9tICcuLi91dGlscy9jb21tb24nXG5pbXBvcnQge2dsb2JhbFNldHRpbmdzfSBmcm9tICcuLi9zZXR0aW5ncydcblxuXG5jb25zdCByZWdFeHAgPSBnbG9iYWxTZXR0aW5ncy5zaGVldC5zaGVldE5hbWU7XG5cbi8qKlxuICog5bel5L2c57C/44CC5LiA5LiqIFdvcmtib29rIOWMheWQq+S4gOS4quaIluWkmuS4qiBTaGVldCAuXG4gKi9cbmNsYXNzIFdvcmtib29rIHtcblxuICAgIC8qKlxuICAgICAqIFdvcmtib29rIOaehOmAoOWZqFxuICAgICAqIEBwYXJhbSB7U3ByZWFkU2hlZXR9IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGluc3RhbmNlLCBjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTcHJlYWRTaGVldH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ByZWFkU2hlZXQgPSBpbnN0YW5jZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtDYXNlSW5zZW5zaXRpdmVNYXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoZWV0cyA9IG5ldyBDYXNlSW5zZW5zaXRpdmVNYXAoKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IGNvbmZpZztcblxuICAgICAgICB0aGlzLl9pbml0U2V0dGluZ3MoY29uZmlnKTtcbiAgICAgICAgdGhpcy4kJHZpZXcgPSBuZXcgVGFicyh0aGlzKTtcblxuICAgICAgICBjb25maWcuc2hlZXRzLmZvckVhY2godiA9PiB0aGlzLmNyZWF0ZVNoZWV0KHYpKTtcblxuICAgICAgICAvLyDmoLnmja7liJ3lp4vljJbmlbDmja7mv4DmtLsgc2hlZXQg6aG1XG4gICAgICAgIGxldCB0b0FjdGl2ZSA9IHRoaXMuZ2V0U2hlZXQodGhpcy5hY3RpdmVTaGVldCk7XG4gICAgICAgIGlmICghdG9BY3RpdmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDmjIflrprnmoQgYWN0aXZlU2hlZXQg5LiN5a2Y5ZyoOiAke3RoaXMuYWN0aXZlU2hlZXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9BY3RpdmUuYWN0aXZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoa2V5c1tpXSA9PT0gJ3NoZWV0cycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBzZXR0aW5nc1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPliBXb3JrYm9vayDmiYDlsZ7nmoTnlLXlrZDooajmoLznmoTnlKjmiLfliJ3lp4vphY3nva7jgIJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcHJlYWRTaGVldC5nZXRTZXR0aW5ncygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiOt+WPluW9k+WJjSBXb3JrYm9vayDnmoQgaWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZCB8fCAodGhpcy5pZCA9IHRoaXMuc3ByZWFkU2hlZXQuZ2V0SWQoKSArIGdsb2JhbFNldHRpbmdzLmlkU3VmZml4NFdvcmtib29rKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmoLnmja7mjIflrpogc2hlZXQg5ZCN6I635Y+WIHNoZWV0IOWunuS+i1xuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMge1NoZWV0fVxuICAgICAqL1xuICAgIGdldFNoZWV0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzLmdldChuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDojrflj5blvZPliY0gV29ya2Jvb2sg5LiL55qE5omA5pyJIHNoZWV0IOWunuS+i1xuICAgICAqIEByZXR1cm5zIHtDYXNlSW5zZW5zaXRpdmVNYXB9XG4gICAgICovXG4gICAgZ2V0U2hlZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGVldHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5omA5pyJIHNoZWV0IOeahOWQjeWtl1xuICAgICAqIEByZXR1cm5zIHtJdGVyYXRvci48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBnZXRTaGVldE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGVldHMua2V5cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOajgOmqjCBzaGVldCDmmK/lkKblt7LlrZjlnKhcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4YWN0bHk9ZmFsc2VdIC0g5piv5ZCm5L2/55So57K+56Gu5aSn5bCP5YaZ55qEIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1NoZWV0RXhpc3QobmFtZSwgZXhhY3RseSkge1xuICAgICAgICBpZiAoZXhhY3RseSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzLmhhc0V4YWN0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiAhIXRoaXMuZ2V0U2hlZXQobmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNoZWV0cy5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog55Sf5oiQIHNoZWV0IOe0ouW8lVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBfZ2V0QXV0b1NoZWV0SW5kZXgoKSB7XG4gICAgICAgIGlmICghdGhpcy4kJGF1dG9TaGVldEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLiQkYXV0b1NoZWV0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiArK3RoaXMuJCRhdXRvU2hlZXRJbmRleDsgLy8g5LuOIDEg5byA5aeLXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Ieq5Yqo55Sf5oiQIHNoZWV0IOWQjVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QXV0b1NoZWV0TmFtZSgpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gZ2xvYmFsU2V0dGluZ3Muc2hlZXQuYXV0b1ByZWZpeCArICcnOyAvLyDpmLLmraLlh7rnjrDmlbDlrZfnm7jliqBcbiAgICAgICAgbGV0IG5hbWUgPSBwcmVmaXggKyB0aGlzLl9nZXRBdXRvU2hlZXRJbmRleCgpO1xuICAgICAgICBpZiAodGhpcy5pc1NoZWV0RXhpc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRBdXRvU2hlZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5b2T5YmN5r+A5rS755qEIHNoZWV0IOmhtVxuICAgICAqIEByZXR1cm5zIHtTaGVldH1cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVTaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXRzLmdldCh0aGlzLmFjdGl2ZVNoZWV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliJvlu7rmlrDnmoQgc2hlZXQg6aG1XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb25maWddIC0gc2hlZXQg6aG155qE6YWN572u5L+h5oGvXG4gICAgICogQHJldHVybnMge1NoZWV0fSDmlrDliJvlu7rnmoTlt6XkvZzooahcbiAgICAgKi9cbiAgICBjcmVhdGVTaGVldChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZykgeyAgLy8g5qC55o2u5Yid5aeL6YWN572u5Yib5bu677yMbmFtZSDkuI3og73kuLrnqbpcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlU2hlZXROYW1lKGNvbmZpZy5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHsgLy8g55So5oi35pON5L2c5Yib5bu677yM5Yqo5oCB55Sf5oiQIG5hbWVcbiAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgY29uZmlnLm5hbWUgPSB0aGlzLl9nZXRBdXRvU2hlZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld09uZSA9IG5ldyBTaGVldCh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLnNoZWV0cy5zZXQoY29uZmlnLm5hbWUsIG5ld09uZSk7XG4gICAgICAgIHJldHVybiBuZXdPbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6ZSA5q+B5oyH5a6aIHNoZWV0IOmhtVxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgU2hlZXR9IHNoZWV0IC0gc2hlZXQg5ZCN56ew5oiW5a6e5L6LXG4gICAgICovXG4gICAgZGVzdHJveVNoZWV0KHNoZWV0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2hlZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoc2hlZXQpO1xuICAgICAgICB9XG4gICAgICAgIHNoZWV0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDnu5nmjIflrprnmoQgc2hlZXQg6aG16YeN5ZG95ZCNXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUxIC0g5b6F6YeN5ZG95ZCN55qEIHNoZWV0IOmhteWQjeWtl1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lMiAtIOaWsOWQjeWtl1xuICAgICAqL1xuICAgIC8vIEZJWE1FIOe8lui+kemUmeS9je+8mlxuICAgIC8vIGhhbmRzb250YWJsZSDlnKjpgInkuK3mn5DljZXlhYPmoLzkvYbmsqHov5vlhaXnvJbovpHml7bvvIzkvJrnm5HlkKwgZG9jdW1lbnQg5LiK55qEIGtleWRvd24g5LqL5Lu277yMXG4gICAgLy8g6YCg5oiQ5L+u5pS5IHNoZWV0IOWQjeaXtueahOaWh+acrOahhuaXoOazleato+ehruWkhOeQhu+8iOS8mui+k+WFpeWIsOihqOagvOS4re+8iVxuICAgIC8vIOaaguaXtuS9v+eUqCBpbnB1dCDnmoQgc2VsZWN0IOS7o+abvyBmb2N1c++8jOi/q+S9v+eUqOaIt+WGjeasoeeCueWHu3NoZWV05ZCN5pe25omN6IO95L+u5pS544CCXG4gICAgcmVuYW1lU2hlZXQobmFtZTEsIG5hbWUyKSB7XG4gICAgICAgIGxldCBzaGVldCA9IHRoaXMuZ2V0U2hlZXQobmFtZTEpO1xuICAgICAgICBpZiAoIXNoZWV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5bel5L2c6KGoIFwiJHtuYW1lMX1cIiDkuI3lrZjlnKhgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZTEgIT09IG5hbWUyKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVNoZWV0TmFtZShuYW1lMiwgdXBwZXJDYXNlKG5hbWUxKSA9PT0gdXBwZXJDYXNlKG5hbWUyKSk7XG4gICAgICAgICAgICBzaGVldC5zaGVldE5hbWUgPSBuYW1lMjtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVNoZWV0ID09PSBuYW1lMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlU2hlZXQgPSBuYW1lMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2V0U2hlZXRzKCkuZGVsZXRlKG5hbWUxKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2hlZXRzKCkuc2V0KG5hbWUyLCBzaGVldCk7XG4gICAgICAgICAgICB0aGlzLiQkdmlldy50YWJSZW5hbWUobmFtZTEsIG5hbWUyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCR2aWV3LnRhYlJlbmFtZUNhbmNlbChuYW1lMSwgbmFtZTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5YWz6Zet5oyH5a6aIHNoZWV0IOmhtVxuICAgICAqL1xuICAgIGNsb3NlU2hlZXQobmFtZSkge1xuICAgICAgICBsZXQgc2hlZXQgPSB0aGlzLmdldFNoZWV0KG5hbWUpO1xuICAgICAgICBpZiAoIXNoZWV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5peg5rOV5YWz6Zet5LiN5a2Y5Zyo55qE5bel5L2c6KGoIFwiJHtuYW1lfVwiIOOAgmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNoZWV0cy5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDml6Dms5XlhbPpl63ku4XmnInnmoTkuIDkuKrlt6XkvZzooaggXCIke25hbWV9XCIg44CCYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoZWV0LmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgb2YgdGhpcy5zaGVldHMua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsgJiYgayAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVNoZWV0ID0gaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTaGVldChrKS5hY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hlZXRzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgdGhpcy4kJHZpZXcucmVtb3ZlVGFiKG5hbWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lTaGVldChzaGVldCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDmv4DmtLvlvZPliY0gd29ya2Jvb2tcbiAgICAgKi9cbiAgICBhY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuZ2V0QWN0aXZlU2hlZXQoKS5hY3RpdmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmv4DmtLvmjIflrpogc2hlZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lXG4gICAgICovXG4gICAgYWN0aXZlU2hlZXQoc2hlZXROYW1lKSB7XG4gICAgICAgIGxldCBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoc2hlZXROYW1lKTtcbiAgICAgICAgaWYgKHNoZWV0KSB7XG4gICAgICAgICAgICBzaGVldC5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOmqjOivgSBzaGVldCDlkI3mmK/lkKblkIjms5VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhhY3RseVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlU2hlZXROYW1lKG5hbWUsIGV4YWN0bHkpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcign5bel5L2c6KGo55qE5ZCN56ew5LiN6IO95Li656m6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIOemgeatouS4gOS6m+eJueauiuWtl+esplxuICAgICAgICBpZiAocmVnRXhwLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGVldEVycm9yKGDlt6XkvZzooaggXCIke25hbWV9XCIg5YyF5ZCr6Z2e5rOV5a2X56ymYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTaGVldEV4aXN0KG5hbWUsIGV4YWN0bHkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hlZXRFcnJvcihg5bel5L2c6KGoIFwiJHtuYW1lfVwiIOW3suWtmOWcqGApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldEV4Y2hhbmdlKCkge1xuICAgICAgICBsZXQgc2hlZXRzID0gW107XG4gICAgICAgIGZvciAobGV0IFssc2hlZXRdIG9mIHRoaXMuZ2V0U2hlZXRzKCkudG9NYXAoKSkge1xuICAgICAgICAgICAgc2hlZXQgJiYgc2hlZXRzLnB1c2goc2hlZXQuX2dldEV4Y2hhbmdlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmVTaGVldDogdGhpcy5hY3RpdmVTaGVldCxcbiAgICAgICAgICAgIHNoZWV0czogc2hlZXRzXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgV29ya2Jvb2s7IiwiZXhwb3J0IGNvbnN0IEV4Y2hhbmdlID0gU3VwID0+IGNsYXNzIGV4dGVuZHMgU3VwIHtcblxuICAgIF9nZXRFeGNoYW5nZSgpIHtcbiAgICAgICAgdmFyIHtkYXRhLCBjZWxsc30gPSB0aGlzLl9nZXREYXRhTWV0YSgpO1xuICAgICAgICB2YXIge2hlaWdodHMsIHdpZHRoc30gPSB0aGlzLl9nZXRTaXplRXgoKTtcbiAgICAgICAgdmFyIG1lcmdlQ2VsbHMgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRTZXR0aW5ncygpLm1lcmdlQ2VsbHM7XG5cbiAgICAgICAgaWYgKG1lcmdlQ2VsbHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtZXJnZUNlbGxzID0gbnVsbDsgLy8g6YG/5YWN5by657G75Z6L6K+t6KiA6Kej5p6Q5pe25peg5rOV5aSE55CG5Yqo5oCB57G75Z6LXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBkYXRhOiBkYXRhLmxlbmd0aCA/IGRhdGEgOiBbXS5fLFxuICAgICAgICAgICAgcm93SGVpZ2h0czogaGVpZ2h0cyxcbiAgICAgICAgICAgIGNvbFdpZHRoczogd2lkdGhzLFxuICAgICAgICAgICAgbWVyZ2VDZWxsczogbWVyZ2VDZWxscyxcbiAgICAgICAgICAgIGNlbGxNZXRhczogY2VsbHNcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgX2dldFN0eWxlc0V4KG1ldGEpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICB2YXIgYWxpZ25tZW50cyA9IHRoaXMuX2dldEFsaWdubWVudEV4KG1ldGEuY2xhc3NOYW1lKTtcbiAgICAgICAgaWYgKGFsaWdubWVudHMpIHtcbiAgICAgICAgICAgIHJldC5hbGlnbm1lbnRzID0gYWxpZ25tZW50c1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dldEZvbnRFeChtZXRhLCByZXQpO1xuICAgICAgICB0aGlzLl9nZXRCZ0NvbG9yRXgobWV0YSwgcmV0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cblxuICAgIF9nZXRCZ0NvbG9yRXgobWV0YSwgcmV0KSB7XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIHJldC5iYWNrZ3JvdW5kQ29sb3IgPSBtZXRhLl9zdHlsZV9iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9nZXRGb250RXgobWV0YSwgcmV0KSB7XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9mb250RmFtaWx5KSB7XG4gICAgICAgICAgICByZXQuZm9udEZhbWlseSA9IG1ldGEuX3N0eWxlX2ZvbnRGYW1pbHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuX3N0eWxlX2ZvbnRTaXplKSB7XG4gICAgICAgICAgICByZXQuZm9udFNpemUgPSBtZXRhLl9zdHlsZV9mb250U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5jbGFzc05hbWUgJiYgbWV0YS5jbGFzc05hbWUuY29udGFpbnMoJ3NzZC1mb250LWl0YWxpYycpKSB7XG4gICAgICAgICAgICByZXQuZm9udFN0eWxlID0gJ2l0YWxpYyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuY2xhc3NOYW1lICYmIG1ldGEuY2xhc3NOYW1lLmNvbnRhaW5zKCdzc2QtZm9udC1ib2xkJykpIHtcbiAgICAgICAgICAgIHJldC5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmNsYXNzTmFtZSAmJiBtZXRhLmNsYXNzTmFtZS5jb250YWlucygnc3NkLWZvbnQtdW5kZXJsaW5lJykpIHtcbiAgICAgICAgICAgIHJldC50ZXh0RGVjb3JhdGlvbiA9ICd1bmRlcmxpbmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLl9zdHlsZV9jb2xvcikge1xuICAgICAgICAgICAgcmV0LmNvbG9yID0gbWV0YS5fc3R5bGVfY29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9nZXRBbGlnbm1lbnRFeChjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IFtdO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0TGVmdCcpICYmIGFsaWdubWVudC5wdXNoKCdMZWZ0Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0Q2VudGVyJykgJiYgYWxpZ25tZW50LnB1c2goJ0NlbnRlcicpO1xuICAgICAgICAgICAgY2xhc3NOYW1lLmNvbnRhaW5zKCdodFJpZ2h0JykgJiYgYWxpZ25tZW50LnB1c2goJ1JpZ2h0Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0SnVzdGlmeScpICYmIGFsaWdubWVudC5wdXNoKCdKdXN0aWZ5Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWUuY29udGFpbnMoJ2h0VG9wJykgJiYgYWxpZ25tZW50LnB1c2goJ1RvcCcpO1xuICAgICAgICAgICAgY2xhc3NOYW1lLmNvbnRhaW5zKCdodE1pZGRsZScpICYmIGFsaWdubWVudC5wdXNoKCdNaWRkbGUnKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZS5jb250YWlucygnaHRCb3R0b20nKSAmJiBhbGlnbm1lbnQucHVzaCgnQm90dG9tJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsaWdubWVudC5sZW5ndGggPyBhbGlnbm1lbnQgOiBmYWxzZTtcbiAgICB9XG5cblxuICAgIF9nZXRTaXplRXgoKSB7XG4gICAgICAgIHZhciBob3QgPSB0aGlzLmhhbmRzb250YWJsZTtcbiAgICAgICAgdmFyIGNvbHMgPSBNYXRoLm1heChob3QuY291bnRDb2xzKCkgLSBob3QuY291bnRFbXB0eUNvbHModHJ1ZSksIDIwKTtcbiAgICAgICAgdmFyIHJvd3MgPSBNYXRoLm1heChob3QuY291bnRSb3dzKCkgLSBob3QuY291bnRFbXB0eVJvd3ModHJ1ZSksIDUwKTtcbiAgICAgICAgdmFyIGhlaWdodHMgPSBbXTtcbiAgICAgICAgdmFyIHdpZHRocyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaCA9IGhvdC5nZXRSb3dIZWlnaHQoaSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiAhaCkgeyAvLyBoYW5kc29udGFibGUgYnVnXG4gICAgICAgICAgICAgICAgaCA9IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVpZ2h0cy5wdXNoKGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgKytpKSB7XG4gICAgICAgICAgICB3aWR0aHMucHVzaChob3QuZ2V0Q29sV2lkdGgoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7aGVpZ2h0cywgd2lkdGhzfTtcbiAgICB9XG5cblxuICAgIF9nZXREYXRhTWV0YSgpIHtcbiAgICAgICAgdmFyIGhvdCA9IHRoaXMuaGFuZHNvbnRhYmxlO1xuICAgICAgICB2YXIgY29scyA9IGhvdC5jb3VudENvbHMoKSAtIGhvdC5jb3VudEVtcHR5Q29scyh0cnVlKTtcbiAgICAgICAgdmFyIHJvd3MgPSBob3QuY291bnRSb3dzKCkgLSBob3QuY291bnRFbXB0eVJvd3ModHJ1ZSk7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIHZhciBjZWxscyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgKytpKSB7XG4gICAgICAgICAgICBsZXQgcm93UmVzdWx0ID0gW107XG4gICAgICAgICAgICBsZXQgcm93Q2VsbE1ldGEgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgX3NvdXJjZURhdGEgPSBob3QuZ2V0U291cmNlRGF0YUF0Q2VsbChpLCBqKTtcbiAgICAgICAgICAgICAgICBsZXQgX21ldGEgPSBob3QuZ2V0Q2VsbE1ldGEoaSwgaik7XG4gICAgICAgICAgICAgICAgbGV0IF9kYXRhID0gaG90LmdldERhdGFBdENlbGwoaSwgaik7XG4gICAgICAgICAgICAgICAgbGV0IF9jZWxsTWF0YSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnJvdyA9IGk7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLmNvbCA9IGo7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLmlzRm9ybXVsYSA9ICEhKF9zb3VyY2VEYXRhICYmIChfc291cmNlRGF0YSArICcnKS5jaGFyQXQoMCkgPT09ICc9Jyk7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnNvdXJjZVZhbHVlID0gX3NvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgX2NlbGxNYXRhLnZhbHVlID0gX2RhdGE7XG5cbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKG8sIG0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRMb2NhbFN5bWJvbHMsTG9vcFN0YXRlbWVudFRoYXREb2VzbnRMb29wSlNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCBpbiBvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnN0eWxlcyA9IG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KHRoaXMuX2dldFN0eWxlc0V4KF9tZXRhKSwgX2NlbGxNYXRhKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9nZXREYXRhVHlwZShfbWV0YSwgX2NlbGxNYXRhKTtcblxuICAgICAgICAgICAgICAgIHJvd1Jlc3VsdC5wdXNoKF9zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgICByb3dDZWxsTWV0YS5wdXNoKF9jZWxsTWF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnB1c2gocm93UmVzdWx0KTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2gocm93Q2VsbE1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ZGF0YSwgY2VsbHN9O1xuICAgIH1cblxuICAgIC8vIFRPRE9cbiAgICBfZ2V0Qm9yZGVyc0V4KCkge1xuXG4gICAgfVxuXG4gICAgLy8g5pWw5o2u5qC85byPIG51bWVyaWPjgIFkYXRlIOetiVxuICAgIF9nZXREYXRhVHlwZShfbWV0YSwgX2NlbGxNYXRhKSB7XG4gICAgICAgIGxldCB0ID0gX21ldGEudHlwZTtcbiAgICAgICAgX2NlbGxNYXRhLmRhdGFUeXBlID0ge307XG4gICAgICAgIF9jZWxsTWF0YS5kYXRhVHlwZS50eXBlTmFtZSA9IHQ7XG5cbiAgICAgICAgaWYgKHQgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgX2NlbGxNYXRhLmRhdGFUeXBlLmRhdGVGb3JtYXQgPSBfbWV0YS5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgX21ldGEuZGVmYXVsdERhdGUgJiYgKF9jZWxsTWF0YS5kYXRhVHlwZS5kZWZhdWx0RGF0ZSA9IF9tZXRhLmRlZmF1bHREYXRlKTtcbiAgICAgICAgICAgIF9tZXRhLmNvcnJlY3RGb3JtYXQgJiYgKF9jZWxsTWF0YS5kYXRhVHlwZS5jb3JyZWN0Rm9ybWF0ID0gX21ldGEuY29ycmVjdEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodCA9PT0gJ251bWVyaWMnKSB7XG4gICAgICAgICAgICBfY2VsbE1hdGEuZGF0YVR5cGUuZm9ybWF0ID0gX21ldGEuZm9ybWF0O1xuICAgICAgICAgICAgX21ldGEubGFuZ3VhZ2UgJiYgKF9jZWxsTWF0YS5kYXRhVHlwZS5sYW5ndWFnZSA9IF9tZXRhLmxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwiZXhwb3J0IGNvbnN0IFNoZWV0SGVscGVyID0gU3VwID0+IHtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBTdXAge1xuXG4gICAgICAgIC8vIOmAieWMuum7mOiupOWAvFxuICAgICAgICAvLyAgIDEuIOmAieWMuuWPr+iDveS7juWPs+S4i+W+gOW3puS4iumAie+8jOatpOaXtiByb3cgPiBlbmRSb3dcbiAgICAgICAgLy8gICAyLiBlbmRSb3cg5Y+KIGVuZENvbCDlj6/og73kuI3lrZjlnKhcbiAgICAgICAgLy/vvIjkuI3pnIDopoHlhbPms6jpgInljLrmlrnlkJHml7bosIPnlKjmraTmlrnms5Xov5vooYzpooTlpITnkIbvvIlcbiAgICAgICAgX2RlZmF1bHRTZWxlY3Rpb24ocykge1xuICAgICAgICAgICAgcy5yb3cgPiBzLmVuZFJvdyAmJiAocy5yb3c9W3MuZW5kUm93LCBzLmVuZFJvdz1zLnJvd11bMF0pO1xuICAgICAgICAgICAgcy5jb2wgPiBzLmVuZENvbCAmJiAocy5jb2w9W3MuZW5kQ29sLCBzLmVuZENvbD1zLmNvbF1bMF0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0Um93OiBzLnJvdyxcbiAgICAgICAgICAgICAgICBlbmRSb3c6IHMuZW5kUm93IHx8IHMucm93LFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sOiBzLmNvbCxcbiAgICAgICAgICAgICAgICBlbmRDb2w6IHMuZW5kQ29sIHx8IHMuY29sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgICAgIF9yZW1vdmVGb3JtZXJDbGFzcyhjdXJyZW50LCAuLi5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGNsYXp6IG9mIHN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNwbGl0KGNsYXp6KS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgICAgICBfd2Fsa29uQ2VsbE1ldGFzKHNlbGVjdGlvbiwgY2FsbGJhY2ssIHVuaG9sZCkge1xuICAgICAgICAgICAgbGV0IHtzdGFydFJvdywgZW5kUm93LCBzdGFydENvbCwgZW5kQ29sfSA9IHRoaXMuX2RlZmF1bHRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydENvbDsgaiA8PSBlbmRDb2w7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbE1ldGEgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRDZWxsTWV0YShpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TWV0YSA9IGNhbGxiYWNrLmNhbGwodGhpcywgaSwgaiwgY2VsbE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWV0YSAmJiB0aGlzLmhhbmRzb250YWJsZS5zZXRDZWxsTWV0YU9iamVjdChpLCBqLCBuZXdNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaG9sZCAmJiB0aGlzLmhhbmRzb250YWJsZS5zZXRDZWxsTWV0YU9iamVjdChpLCBqLCB1bmhvbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgICAgIF93YWxrb25DZWxscyhzZWxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQge3N0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sLCBlbmRDb2x9ID0gdGhpcy5fZGVmYXVsdFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0Um93OyBpIDw9IGVuZFJvdzsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0Q29sOyBqIDw9IGVuZENvbDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsVEQgPSB0aGlzLmhhbmRzb250YWJsZS5nZXRDZWxsKGksIGosIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbFREKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGksIGosIGNlbGxURCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIF93YWxrb25TZWxlY3Rpb24oc2VsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgbGV0IHtzdGFydFJvdywgZW5kUm93LCBzdGFydENvbCwgZW5kQ29sfSA9IHRoaXMuX2RlZmF1bHRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBzdGFydENvbDsgaiA8PSBlbmRDb2w7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGksIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcbn07IiwiaW1wb3J0IHthbGlnbm1lbnRJdGVtfSBmcm9tICcuL0NvbnRleHRNZW51X2FsaWdubWVudCdcbmltcG9ydCB7bWVyZ2VDZWxscywgbWVyZ2VDZWxsc0hhbmRsZXIsIGNhbmNlbE1lcmdlQ2VsbHMsIGNhbmNlbE1lcmdlQ2VsbHNIYW5kbGVyfSBmcm9tICcuL0NvbnRleHRNZW51X21lcmdlQ2VsbHMnXG5pbXBvcnQge3Jvd1Jlc2l6ZSwgcm93UmVzaXplSGFuZGxlciwgY29sUmVzaXplLCBjb2xSZXNpemVIYW5kbGVyfSBmcm9tICcuL0NvbnRleHRNZW51X3Jvd09yQ29sdW1uUmVzaXplJ1xuXG4vKipcbiAqIOeUteWtkOihqOagvOWPs+mUruiPnOWNleOAglxuICovXG5mdW5jdGlvbiBDb250ZXh0TWVudShzcHJlYWRTaGVldCkge1xuICAgIHRoaXMuc3ByZWFkU2hlZXQgPSBzcHJlYWRTaGVldDtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICovXG4gICAgdGhpcy5tZW51SXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5faW5pdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb250ZXh0TWVudTtcblxuQ29udGV4dE1lbnUucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGtleSwgY29uZmlnLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5tZW51SXRlbXMuc2V0KGtleSwge1xuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgIH0pO1xufTtcblxuLyoqXG4gKiDojrflj5YgaGFuZHNvbnRhYmxlIOmcgOimgeeahOiPnOWNlemFjee9rumhuVxuICovXG5Db250ZXh0TWVudS5wcm90b3R5cGUuZ2V0TWVudUl0ZW1zNEhvdFRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faG90VGFibGVJdGVtcykge1xuICAgICAgICB0aGlzLl9ob3RUYWJsZUl0ZW1zID0ge307XG4gICAgICAgIHRoaXMubWVudUl0ZW1zLmZvckVhY2goKHtjb25maWd9LCBrZXkpID0+IHRoaXMuX2hvdFRhYmxlSXRlbXNba2V5XSA9IGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ob3RUYWJsZUl0ZW1zO1xufTtcblxuXG4vKlxuICMjIyBoYW5kc29udGFibGUg6Ieq5bim5Y+z6ZSu5Yqf6IO977yaIyMjXG4gcm93X2Fib3ZlXG4gcm93X2JlbG93XG4gaHNlcDFcbiBjb2xfbGVmdFxuIGNvbF9yaWdodFxuIGhzZXAyXG4gcmVtb3ZlX3Jvd1xuIHJlbW92ZV9jb2xcbiBoc2VwM1xuIHVuZG9cbiByZWRvXG4gbWFrZV9yZWFkX29ubHlcbiBhbGlnbm1lbnRcbiBib3JkZXJzXG4gKi9cbkNvbnRleHRNZW51LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBTRVAgPSAnLS0tLS0tLS0tJztcblxuXG4gICAgdGhpcy5yZWdpc3Rlcigncm93X2Fib3ZlJywge1xuICAgICAgICBuYW1lOiAn5LiK5pa55o+S5YWl5LiA6KGMJyxcbiAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIOiwg+eUqOiAheimgeehruS/neatpOWkhCB0aGlzICDkuLrlvZPliY0gaG90VGFibGUg5a6e5L6LXG4gICAgICAgICAgICAvLyBUT0RPIOmZkOWItuacgOWkp+ihjOaVsFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyKCdyb3dfYmVsb3cnLCB7XG4gICAgICAgIG5hbWU6ICfkuIvmlrnmj5LlhaXkuIDooYwnXG4gICAgfSk7XG5cbiAgICB0aGlzLnJlZ2lzdGVyKCdjb2xfbGVmdCcsIHtcbiAgICAgICAgbmFtZTogJ+W3puS+p+aPkuWFpeS4gOWIlydcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXIoJ2NvbF9yaWdodCcsIHtcbiAgICAgICAgbmFtZTogJ+WPs+S+p+aPkuWFpeS4gOWIlydcbiAgICB9KTtcblxuICAgIHRoaXMucmVnaXN0ZXIoJ2hzZXBfYnRfaW5zZXJ0JywgU0VQKTtcblxuICAgIC8vIEZJWE1FIGhhbmRzb250YWJsZSDoh6rluKbnmoTliKDpmaTlip/og73vvIzlnKjlrZjlnKjljZXlhYPmoLzlkIjlubbml7bmnIlCVUfvvIzmlLnmiJDoh6rlrprkuYnpgLvovpHjgIJcbiAgICB0aGlzLnJlZ2lzdGVyKCdyZW1vdmVfcm93Jywge1xuICAgICAgICBuYW1lOiAn5Yig6Zmk6YCJ5Lit6KGMJyxcbiAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE8g6ZmQ5Yi25pyA5bCP6KGM5pWwXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKCdyZW1vdmVfY29sJywge1xuICAgICAgICBuYW1lOiAn5Yig6Zmk6YCJ5Lit5YiXJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlcignaHNlcF9idF9yZW1vdmUnLCBTRVApO1xuXG4gICAgdGhpcy5yZWdpc3RlcignYWxpZ25tZW50JywgYWxpZ25tZW50SXRlbSgpKTtcbiAgICB0aGlzLnJlZ2lzdGVyKCdyb3dfcmVzaXplJywgcm93UmVzaXplLCByb3dSZXNpemVIYW5kbGVyKTtcbiAgICB0aGlzLnJlZ2lzdGVyKCdjb2xfcmVzaXplJywgY29sUmVzaXplLCBjb2xSZXNpemVIYW5kbGVyKTtcblxuXG4gICAgdGhpcy5yZWdpc3RlcignaHNlcF9idF9mb3JtYXQnLCBTRVApO1xuXG4gICAgdGhpcy5yZWdpc3RlcigncV9tZXJnZV9jZWxscycsIG1lcmdlQ2VsbHMsIG1lcmdlQ2VsbHNIYW5kbGVyKTtcbiAgICB0aGlzLnJlZ2lzdGVyKCdxX2NhbmNlbF9tZXJnZV9jZWxscycsIGNhbmNlbE1lcmdlQ2VsbHMsIGNhbmNlbE1lcmdlQ2VsbHNIYW5kbGVyKTtcbn07XG4iLCJpbXBvcnQge01FTlV9IGZyb20gJy4uLy4uL2kxOG4nO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvMzgwN1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWdubWVudEl0ZW0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogTUVOVS5TNSxcbiAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpICYmICF0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZEhlYWRlci5jb3JuZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzdWJtZW51OiB7XG4gICAgICAgICAgICBpdGVtczogW3tcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGlnbm1lbnQ6bGVmdCcsXG4gICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmRleE9mKCdodExlZnQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNDbGFzcyA/IG1hcmtMYWJlbEFzU2VsZWN0ZWQoTUVOVS5TNikgOiBNRU5VLlM2O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGlnbm1lbnQgPSAnaHRMZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24ocmFuZ2UsIHR5cGUsIGFsaWdubWVudCwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGlnbm1lbnQ6Y2VudGVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0Q2VudGVyJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzQ2xhc3MgPyBtYXJrTGFiZWxBc1NlbGVjdGVkKE1FTlUuUzcpIDogTUVOVS5TNztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdGVCZWZvcmUgPSBnZXRBbGlnbm1lbnRDbGFzc2VzKHJhbmdlLCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0Q2VudGVyJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDpyaWdodGAsXG4gICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBNRU5VLlM4O1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0UmlnaHQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IG1hcmtMYWJlbEFzU2VsZWN0ZWQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGlnbm1lbnQgPSAnaHRSaWdodCc7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5Ib29rcygnYmVmb3JlQ2VsbEFsaWdubWVudCcsIHN0YXRlQmVmb3JlLCByYW5nZSwgdHlwZSwgYWxpZ25tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYWxpZ24ocmFuZ2UsIHR5cGUsIGFsaWdubWVudCwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IGBhbGlnbm1lbnQ6anVzdGlmeWAsXG4gICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBNRU5VLlM5O1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgY2xhc3NOYW1lLmluZGV4T2YoJ2h0SnVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbWFya0xhYmVsQXNTZWxlY3RlZChsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGVkUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXRlQmVmb3JlID0gZ2V0QWxpZ25tZW50Q2xhc3NlcyhyYW5nZSwgKHJvdywgY29sKSA9PiB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9ICdob3Jpem9udGFsJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9ICdodEp1c3RpZnknO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuSG9va3MoJ2JlZm9yZUNlbGxBbGlnbm1lbnQnLCBzdGF0ZUJlZm9yZSwgcmFuZ2UsIHR5cGUsIGFsaWdubWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduKHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogJy0tLS0tLS0tLSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IGBhbGlnbm1lbnQ6dG9wYCxcbiAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IE1FTlUuUzEwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzQ2xhc3MgPSBjaGVja1NlbGVjdGlvbkNvbnNpc3RlbmN5KHRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpLCAocm93LCBjb2wpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKS5jbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZS5pbmRleE9mKCdodFRvcCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbWFya0xhYmVsQXNTZWxlY3RlZChsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0VG9wJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDptaWRkbGVgLFxuICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gTUVOVS5TMTE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAmJiBjbGFzc05hbWUuaW5kZXhPZignaHRNaWRkbGUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IG1hcmtMYWJlbEFzU2VsZWN0ZWQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0TWlkZGxlJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogYGFsaWdubWVudDpib3R0b21gLFxuICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gTUVOVS5TMTI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNDbGFzcyA9IGNoZWNrU2VsZWN0aW9uQ29uc2lzdGVuY3kodGhpcy5nZXRTZWxlY3RlZFJhbmdlKCksIChyb3csIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLmNsYXNzTmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAmJiBjbGFzc05hbWUuaW5kZXhPZignaHRCb3R0b20nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IG1hcmtMYWJlbEFzU2VsZWN0ZWQobGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0ZUJlZm9yZSA9IGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIChyb3csIGNvbCkgPT4gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpZ25tZW50ID0gJ2h0Qm90dG9tJztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkhvb2tzKCdiZWZvcmVDZWxsQWxpZ25tZW50Jywgc3RhdGVCZWZvcmUsIHJhbmdlLCB0eXBlLCBhbGlnbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBhbGlnbihyYW5nZSwgdHlwZSwgYWxpZ25tZW50LCAocm93LCBjb2wpID0+IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuZnVuY3Rpb24gY2hlY2tTZWxlY3Rpb25Db25zaXN0ZW5jeShyYW5nZSwgY29tcGFyYXRvcikge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UuZm9yQWxsKGZ1bmN0aW9uIChyb3csIGNvbCkge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3Iocm93LCBjb2wpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYXJrTGFiZWxBc1NlbGVjdGVkKGxhYmVsKSB7XG4gICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInNlbGVjdGVkXCI+JyArIFN0cmluZy5mcm9tQ2hhckNvZGUoMTAwMDMpICsgJzwvc3Bhbj4nICsgbGFiZWw7XG59XG5cbmZ1bmN0aW9uIGdldEFsaWdubWVudENsYXNzZXMocmFuZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHt9O1xuICAgIGZvciAobGV0IHJvdyA9IHJhbmdlLmZyb20ucm93OyByb3cgPD0gcmFuZ2UudG8ucm93OyByb3crKykge1xuICAgICAgICBmb3IgKGxldCBjb2wgPSByYW5nZS5mcm9tLmNvbDsgY29sIDw9IHJhbmdlLnRvLmNvbDsgY29sKyspIHtcbiAgICAgICAgICAgIGlmICghY2xhc3Nlc1tyb3ddKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlc1tyb3ddID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzc2VzW3Jvd11bY29sXSA9IGNhbGxiYWNrKHJvdywgY29sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlcztcbn1cblxuZnVuY3Rpb24gYWxpZ24ocmFuZ2UsIHR5cGUsIGFsaWdubWVudCwgY2VsbERlc2NyaXB0b3IpIHtcbiAgICBpZiAocmFuZ2UuZnJvbS5yb3cgPT09IHJhbmdlLnRvLnJvdyAmJiByYW5nZS5mcm9tLmNvbCA9PT0gcmFuZ2UudG8uY29sKSB7XG4gICAgICAgIGFwcGx5QWxpZ25DbGFzc05hbWUocmFuZ2UuZnJvbS5yb3csIHJhbmdlLmZyb20uY29sLCB0eXBlLCBhbGlnbm1lbnQsIGNlbGxEZXNjcmlwdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCByb3cgPSByYW5nZS5mcm9tLnJvdzsgcm93IDw9IHJhbmdlLnRvLnJvdzsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHJhbmdlLmZyb20uY29sOyBjb2wgPD0gcmFuZ2UudG8uY29sOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGFwcGx5QWxpZ25DbGFzc05hbWUocm93LCBjb2wsIHR5cGUsIGFsaWdubWVudCwgY2VsbERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUFsaWduQ2xhc3NOYW1lKHJvdywgY29sLCB0eXBlLCBhbGlnbm1lbnQsIGNlbGxEZXNjcmlwdG9yKSB7XG4gICAgbGV0IGNlbGxNZXRhID0gY2VsbERlc2NyaXB0b3Iocm93LCBjb2wpO1xuICAgIGxldCBjbGFzc05hbWUgPSBhbGlnbm1lbnQ7XG5cbiAgICBpZiAoY2VsbE1ldGEuY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcmVwYXJlVmVydGljYWxBbGlnbkNsYXNzKGNlbGxNZXRhLmNsYXNzTmFtZSwgYWxpZ25tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZXBhcmVIb3Jpem9udGFsQWxpZ25DbGFzcyhjZWxsTWV0YS5jbGFzc05hbWUsIGFsaWdubWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2VsbE1ldGEuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xufVxuXG5cbmZ1bmN0aW9uIHByZXBhcmVWZXJ0aWNhbEFsaWduQ2xhc3MoY2xhc3NOYW1lLCBhbGlnbm1lbnQpIHtcbiAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoYWxpZ25tZW50KSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICB9XG4gICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lXG4gICAgICAgIC5yZXBsYWNlKCdodFRvcCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnaHRNaWRkbGUnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ2h0Qm90dG9tJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCcgICcsICcnKTtcblxuICAgIGNsYXNzTmFtZSArPSAnICcgKyBhbGlnbm1lbnQ7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUhvcml6b250YWxBbGlnbkNsYXNzKGNsYXNzTmFtZSwgYWxpZ25tZW50KSB7XG4gICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKGFsaWdubWVudCkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgfVxuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVxuICAgICAgICAucmVwbGFjZSgnaHRMZWZ0JywgJycpXG4gICAgICAgIC5yZXBsYWNlKCdodENlbnRlcicsICcnKVxuICAgICAgICAucmVwbGFjZSgnaHRSaWdodCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnaHRKdXN0aWZ5JywgJycpXG4gICAgICAgIC5yZXBsYWNlKCcgICcsICcnKTtcblxuICAgIGNsYXNzTmFtZSArPSAnICcgKyBhbGlnbm1lbnQ7XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufSIsImltcG9ydCB7Q29vcmRpbmF0ZX0gZnJvbSAnLi4vLi4vdXRpbHMvY29tbW9uJ1xuaW1wb3J0IHtNRU5VfSBmcm9tICcuLi8uLi9pMThuJztcblxuZXhwb3J0IHZhciBtZXJnZUNlbGxzID0ge1xuICAgIG5hbWU6IE1FTlUuUzMsXG4gICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IFtyMSwgYzEsIHIyLCBjMl0gPSB0aGlzLmdldFNlbGVjdGVkKCk7XG4gICAgICAgIGlmIChyMSA9PT0gcjIgJiYgYzEgPT09IGMyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW1lcmdlQ29tcGFyZS5jYWxsKHRoaXMsICdpc0VxdWFsJyk7XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ2VsbHNIYW5kbGVyKHNoZWV0LCBzdGFydCwgZW5kKSB7XG4gICAgc2hlZXQubWVyZ2VDZWxscyhcbiAgICAgICAgc3RhcnQucm93LFxuICAgICAgICBzdGFydC5jb2wsXG4gICAgICAgIGVuZC5yb3cgLSBzdGFydC5yb3cgKyAxLFxuICAgICAgICBlbmQuY29sIC0gc3RhcnQuY29sICsgMVxuICAgICk7XG59XG5cblxuZXhwb3J0IHZhciBjYW5jZWxNZXJnZUNlbGxzID0ge1xuICAgIG5hbWU6IE1FTlUuUzQsXG4gICAgZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlQ29tcGFyZS5jYWxsKHRoaXMsICdpc1N1YnNldCcpO1xuICAgIH1cbn07XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbE1lcmdlQ2VsbHNIYW5kbGVyKHNoZWV0LCBzdGFydCwgZW5kKSB7XG4gICAgc2hlZXQudW5NZXJnZUNlbGxzKFxuICAgICAgICBzdGFydC5yb3csXG4gICAgICAgIHN0YXJ0LmNvbCxcbiAgICAgICAgZW5kLnJvdyAtIHN0YXJ0LnJvdyArIDEsXG4gICAgICAgIGVuZC5jb2wgLSBzdGFydC5jb2wgKyAxXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDb21wYXJlKHR5cGUpIHtcbiAgICBsZXQgbWVyZ2VkID0gdGhpcy5nZXRTZXR0aW5ncygpLm1lcmdlQ2VsbHM7XG4gICAgaWYgKG1lcmdlZCAmJiBtZXJnZWQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVyZ2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQge3JvdywgY29sLCByb3dzcGFuLCBjb2xzcGFufSA9IG1lcmdlZFtpXTtcbiAgICAgICAgICAgIGlmIChDb29yZGluYXRlW3R5cGVdKFxuICAgICAgICAgICAgICAgICAgICBbcm93LCBjb2wsIHJvdyArIHJvd3NwYW4gLSAxLCBjb2wgKyBjb2xzcGFuIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRTZWxlY3Rpb24odGhpcy5nZXRTZWxlY3RlZCgpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTZWxlY3Rpb24ocykge1xuICAgIHNbMF0gPiBzWzJdICYmIChzWzBdID0gW3NbMl0sIHNbMl0gPSBzWzBdXVswXSk7XG4gICAgc1sxXSA+IHNbM10gJiYgKHNbMV0gPSBbc1szXSwgc1szXSA9IHNbMV1dWzBdKTtcbiAgICByZXR1cm4gcztcbn1cbiIsImltcG9ydCB7TUVOVX0gZnJvbSAnLi4vLi4vaTE4bic7XG5cbi8vIEZJWE1FIGhvdCDlpITnkIYgcm93SGVpZ2h0cy9jb2xXaWR0aHMg5LiOIG1hbnVhbFJvd1Jlc2l6ZS9tYW51YWxDb2x1bW5SZXNpemUg5pe25a2Y5Zyo57y66Zm3XG4vLyBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvMzMwMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2hhbmRzb250YWJsZS9oYW5kc29udGFibGUvaXNzdWVzLzQzNzFcbmV4cG9ydCB2YXIgcm93UmVzaXplID0ge1xuICAgIG5hbWU6IE1FTlUuUzEsXG4gICAgaGlkZGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nZXRTZWxlY3RlZFJhbmdlKCkgfHwgIXRoaXMuc2VsZWN0aW9uLnNlbGVjdGVkSGVhZGVyLnJvd3NcbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcm93UmVzaXplSGFuZGxlcihzaGVldCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBoZWlnaHQgPSBbXS5fO1xuXG4gICAgc3RhcnQucm93ID4gZW5kLnJvdyAmJiAoc3RhcnQucm93ID0gW2VuZC5yb3csIGVuZC5yb3cgPSBzdGFydC5yb3ddWzBdKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydC5yb3c7IGkgPD0gZW5kLnJvdzsgKytpKSB7XG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBzaGVldC5oYW5kc29udGFibGUuZ2V0Um93SGVpZ2h0KGkpO1xuICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCAhPT0gc2hlZXQuaGFuZHNvbnRhYmxlLmdldFJvd0hlaWdodChpKSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWwgPSBoZWlnaHQgPT09IGZhbHNlID8gJycgOiAoaGVpZ2h0IHx8IDI0KTtcblxuICAgIGlmIChfVUlQcm92aWRlci5wcm9tcHQpIHtcbiAgICAgICAgX1VJUHJvdmlkZXIucHJvbXB0KE1FTlUuUzEzLCB2YWwsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRSb3dIZWlnaHRzKHNoZWV0LCBzdGFydC5yb3csIGVuZC5yb3csIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb250ZXh0TWVudSA9IHNoZWV0LmhhbmRzb250YWJsZS5nZXRQbHVnaW4oJ2NvbnRleHRNZW51Jyk7XG4gICAgICAgIGNvbnRleHRNZW51LmNsb3NlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBwcm9tcHQoTUVOVS5TMTMsIHZhbCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFJvd0hlaWdodHMoc2hlZXQsIHN0YXJ0LnJvdywgZW5kLnJvdywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgdmFyIGNvbFJlc2l6ZSA9IHtcbiAgICBuYW1lOiBNRU5VLlMyLFxuICAgIGhpZGRlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZ2V0U2VsZWN0ZWRSYW5nZSgpIHx8ICF0aGlzLnNlbGVjdGlvbi5zZWxlY3RlZEhlYWRlci5jb2xzXG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbFJlc2l6ZUhhbmRsZXIoc2hlZXQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgd2lkdGggPSBbXS5fO1xuXG4gICAgc3RhcnQuY29sID4gZW5kLmNvbCAmJiAoc3RhcnQuY29sID0gW2VuZC5jb2wsIGVuZC5jb2wgPSBzdGFydC5jb2xdWzBdKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydC5jb2w7IGkgPD0gZW5kLmNvbDsgKytpKSB7XG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc2hlZXQuaGFuZHNvbnRhYmxlLmdldENvbFdpZHRoKGkpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBzaGVldC5oYW5kc29udGFibGUuZ2V0Q29sV2lkdGgoaSkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWwgPSB3aWR0aCA9PT0gZmFsc2UgPyAnJyA6ICh3aWR0aCB8fCA1MCk7XG5cbiAgICBpZiAoX1VJUHJvdmlkZXIucHJvbXB0KSB7XG4gICAgICAgIF9VSVByb3ZpZGVyLnByb21wdChNRU5VLlMxNCwgdmFsLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0Q29sV2lkdGhzKHNoZWV0LCBzdGFydC5jb2wsIGVuZC5jb2wsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb250ZXh0TWVudSA9IHNoZWV0LmhhbmRzb250YWJsZS5nZXRQbHVnaW4oJ2NvbnRleHRNZW51Jyk7XG4gICAgICAgIGNvbnRleHRNZW51LmNsb3NlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBwcm9tcHQoTUVOVS5TMTQsIHZhbCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldENvbFdpZHRocyhzaGVldCwgc3RhcnQuY29sLCBlbmQuY29sLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRSb3dIZWlnaHRzKHNoZWV0LCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuICAgIHZhbHVlID0gbnVtYnJvKCkudW5mb3JtYXQodmFsdWUpIHx8IDI0O1xuICAgIGxldCByb3dIZWlnaHRzID0gc2hlZXQuaGFuZHNvbnRhYmxlLmdldFNldHRpbmdzKCkucm93SGVpZ2h0cyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgcm93SGVpZ2h0c1tpXSA9IHZhbHVlO1xuICAgIH1cbiAgICBzaGVldC5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe3Jvd0hlaWdodHM6IHJvd0hlaWdodHN9KTtcbn1cblxuZnVuY3Rpb24gc2V0Q29sV2lkdGhzKHNoZWV0LCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuICAgIHZhbHVlID0gbnVtYnJvKCkudW5mb3JtYXQodmFsdWUpIHx8IDUwO1xuICAgIGxldCBjb2xXaWR0aHMgPSBzaGVldC5oYW5kc29udGFibGUuZ2V0U2V0dGluZ3MoKS5jb2xXaWR0aHMgfHwgW107XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgICAgIGNvbFdpZHRoc1tpXSA9IHZhbHVlO1xuICAgIH1cbiAgICBzaGVldC5oYW5kc29udGFibGUudXBkYXRlU2V0dGluZ3Moe2NvbFdpZHRoczogY29sV2lkdGhzfSk7XG59XG5cblxuIiwiaW1wb3J0IHtcbiAgICBpbm5lckhUTUwsIGluc2VydEFmdGVyLFxuICAgIGNsb3Nlc3QsIGVtcHR5LFxuICAgIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG59IGZyb20gJy4uLy4uL3V0aWxzL2RvbUhlbHBlci5qcyc7XG5pbXBvcnQge2lzRW1wdHlWYWx1ZSwgdXBwZXJDYXNlfSBmcm9tICcuLi8uLi91dGlscy9jb21tb24uanMnO1xuaW1wb3J0IHtDYXNlSW5zZW5zaXRpdmVNYXB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGFTdHJ1Y3R1cmUuanMnO1xuaW1wb3J0IHtzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb259IGZyb20gJy4uLy4uL3V0aWxzL2V2ZW50SGVscGVyLmpzJztcbmltcG9ydCB7Z2xvYmFsU2V0dGluZ3N9IGZyb20gJy4uLy4uL3NldHRpbmdzLmpzJztcbmltcG9ydCB7V0FSTlN9IGZyb20gJy4uLy4uL2kxOG4nO1xuaW1wb3J0IHtTaGVldEVycm9yfSBmcm9tICcuLi8uL1NoZWV0RXJyb3InXG5cbmNvbnN0IENMQVNTX0NVUlJFTlQgPSAnY3VycmVudCc7XG5jb25zdCBDTEFTU19UQUJTID0gJ3NzZC10YWJzJztcbmNvbnN0IENMQVNTX0NPTlRFTlQgPSAnc3NkLXRhYnMtY29udGVudCc7XG5jb25zdCBDTEFTU19TRUNUSU9OID0gJ3NzZC10YWJzLXNlY3Rpb24nO1xuY29uc3QgQ0xBU1NfTkFWID0gJ3NzZC10YWJzLW5hdic7XG5jb25zdCBDTEFTU19VTCA9ICdzc2QtdGFicy11bCc7XG5jb25zdCBDTEFTU19MSSA9ICdzc2QtdGFicy1saSc7XG5jb25zdCBDTEFTU19GWCA9ICdzc2QtdGFicy1meCc7XG5cbmNvbnN0IGFuaW1hdGVkID0gZ2xvYmFsU2V0dGluZ3Muc2hlZXQuYW5pbWF0ZWQ7XG5jb25zdCByZWdFeHAgPSBnbG9iYWxTZXR0aW5ncy5zaGVldC5zaGVldE5hbWU7XG5cbi8qKlxuICogd29ya2Jvb2sg5a+55bqU55qE6KeG5Zu+77yM5a6e6ZmF55qEIERPTSDmnoTmiJDjgIJcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1dvcmtib29rfSB3b3JrYm9va1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRhYnMod29ya2Jvb2spIHtcbiAgICB0aGlzLndvcmtib29rID0gd29ya2Jvb2s7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Nhc2VJbnNlbnNpdGl2ZU1hcH1cbiAgICAgKi9cbiAgICB0aGlzLmxpSXRlbXMgPSBuZXcgQ2FzZUluc2Vuc2l0aXZlTWFwKCk7XG4gICAgdGhpcy5zZWN0aW9uSXRlbXMgPSBuZXcgQ2FzZUluc2Vuc2l0aXZlTWFwKCk7XG4gICAgdGhpcy5faG90VGFibGVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucm9vdEVsZW1lbnQgPSB3b3JrYm9vay5zcHJlYWRTaGVldC5nZXRSb290RWxlbWVudCgpO1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSB3b3JrYm9vay5zcHJlYWRTaGVldC5nZXREaXNwbGF5TW9kZSgpO1xuXG4gICAgdGhpcy5pbml0RE9NKCk7XG4gICAgdGhpcy5pbml0Qm94KCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbn1cblxuVGFicy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5UQUJTKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuVGFicy5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLlRBQlMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLkNPTlRFTlQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLk5BViA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ25hdicpO1xuICAgIHRoaXMuVUwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgdGhpcy5UQUJTLmNsYXNzTGlzdC5hZGQoQ0xBU1NfVEFCUyk7XG4gICAgdGhpcy5UQUJTLmlkID0gdGhpcy53b3JrYm9vay5nZXRJZCgpO1xuICAgIHRoaXMuQ09OVEVOVC5jbGFzc0xpc3QuYWRkKENMQVNTX0NPTlRFTlQpO1xuICAgIHRoaXMuTkFWLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFWKTtcbiAgICB0aGlzLlVMLmNsYXNzTGlzdC5hZGQoQ0xBU1NfVUwpO1xuXG4gICAgdGhpcy5UQUJTLmFwcGVuZENoaWxkKHRoaXMuQ09OVEVOVCk7XG4gICAgdGhpcy5UQUJTLmFwcGVuZENoaWxkKHRoaXMuTkFWKTtcbiAgICB0aGlzLk5BVi5hcHBlbmRDaGlsZCh0aGlzLlVMKTtcblxuICAgIC8vIOWinuWKoCBzaGVldCDpobXnmoQgYnV0dG9uXG4gICAgdGhpcy5hcHBlbmRBZGRCdXR0b24oKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuVGFicy5wcm90b3R5cGUuaW5pdEJveCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdEVsID0gdGhpcy53b3JrYm9vay5zcHJlYWRTaGVldC5nZXRSb290RWxlbWVudCgpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLndvcmtib29rLndpZHRoIHx8IG91dGVyV2lkdGgocm9vdEVsLCBmYWxzZSk7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLndvcmtib29rLmhlaWdodCB8fCBvdXRlckhlaWdodChyb290RWwsIGZhbHNlKTtcblxuICAgIHRoaXMuVEFCUy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgIHRoaXMuVEFCUy5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG59O1xuXG5cbi8qKlxuICog5aKe5Yqg5LiA5LiqIHRhYiDpobVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWUgLSBzaGVldCDlkI3vvIwg5Y2zIHRhYiDpobXnmoTmoIfpophcbiAqL1xuVGFicy5wcm90b3R5cGUuYXBwZW5kVGFiID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIHZhciBjbGF6eiA9IHRoaXMuZGlzcGxheU1vZGUgPyAnJyA6ICdjbG9zZSBoYWlybGluZSc7XG5cbiAgICBsaS5pbm5lckhUTUwgPSBgXG4gICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OjtcIj5cbiAgICAgICAgICAgIDxzcGFuPiR7c2hlZXROYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtjbGF6en1cIj48L3NwYW4+XG4gICAgICAgIDwvYT5cbiAgICBgO1xuICAgIGxpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTEkpO1xuICAgIGxpLnNldEF0dHJpYnV0ZSgnZGF0YS1zaGVldCcsIHNoZWV0TmFtZSk7XG5cblxuICAgIHZhciBhY3RpdmVUYWIgPSB0aGlzLlRBQlMucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfQ1VSUkVOVH0uJHtDTEFTU19MSX1gKTtcbiAgICBpZiAoYWN0aXZlVGFiKSB7XG4gICAgICAgIGluc2VydEFmdGVyKGFjdGl2ZVRhYiwgbGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuVUwuYXBwZW5kQ2hpbGQobGkpO1xuICAgIH1cbiAgICB0aGlzLmxpSXRlbXMuc2V0KHNoZWV0TmFtZSwgbGkpO1xuXG4gICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgc2hlZXROYW1lID0gdGhpcy5kYXRhc2V0LnNoZWV0O1xuICAgICAgICB2YXIgc2hlZXQgPSB0aGF0Lndvcmtib29rLmdldFNoZWV0KHNoZWV0TmFtZSk7XG4gICAgICAgIHNoZWV0LmFjdGl2ZSgpO1xuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuZGlzcGxheU1vZGUpIHtcbiAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhhdC5fb25UYWJEYmxjbGljay5jYWxsKHRoYXQsIHRoaXMpO1xuICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsaS5xdWVyeVNlbGVjdG9yKCcuY2xvc2UnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgc2hlZXROYW1lID0gbGkuZGF0YXNldC5zaGVldDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhhdC53b3JrYm9vay5jbG9zZVNoZWV0KHNoZWV0TmFtZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTaGVldEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kQ29udGVudChzaGVldE5hbWUpO1xufTtcblxuXG4vKipcbiAqIOWinuWKoOS4gOS4qiB0YWIg6aG1XG4gKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lIC0gc2hlZXQg5ZCN77yMIOWNsyB0YWIg6aG155qE5qCH6aKYXG4gKi9cblRhYnMucHJvdG90eXBlLnJlbW92ZVRhYiA9IGZ1bmN0aW9uIChzaGVldE5hbWUpIHtcbiAgICB2YXIgbGkgPSB0aGlzLmxpSXRlbXMuZ2V0KHNoZWV0TmFtZSk7XG4gICAgdGhpcy5VTC5yZW1vdmVDaGlsZChsaSk7XG4gICAgdGhpcy5saUl0ZW1zLmRlbGV0ZShzaGVldE5hbWUpO1xuXG4gICAgdGhpcy5yZW1vdmVDb250ZW50KHNoZWV0TmFtZSk7XG59O1xuXG5UYWJzLnByb3RvdHlwZS5hcHBlbmRBZGRCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgdmFyIGlubmVySHRtbCA9IHRoaXMuZGlzcGxheU1vZGUgPyAnJm5ic3A7JyA6ICcrJztcblxuICAgIGxpLmlubmVySFRNTCA9IGA8YSBocmVmPVwiamF2YXNjcmlwdDo7XCI+PHNwYW4+JHtpbm5lckh0bWx9PC9zcGFuPjwvYT5gO1xuICAgIGxpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTEkpO1xuICAgIGlmICghdGhpcy5kaXNwbGF5TW9kZSkge1xuICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKCdhZGQtdGFiJyk7XG4gICAgfVxuICAgIHRoaXMuVUwuYXBwZW5kQ2hpbGQobGkpO1xuXG4gICAgaWYgKCF0aGlzLmRpc3BsYXlNb2RlKSB7XG4gICAgICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2hlZXQgPSB0aGF0Lndvcmtib29rLmNyZWF0ZVNoZWV0KCk7XG4gICAgICAgICAgICAgICAgbmV3U2hlZXQuYWN0aXZlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTaGVldEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbGlcbiAqIEBwcml2YXRlXG4gKi9cblRhYnMucHJvdG90eXBlLl9vblRhYkRibGNsaWNrID0gZnVuY3Rpb24gKGxpKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBzaGVldE5hbWUgPSBsaS5kYXRhc2V0LnNoZWV0O1xuICAgIHZhciBzcGFuID0gbGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NwYW4nKVswXTtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICBpbnB1dC52YWx1ZSA9IHNoZWV0TmFtZTtcbiAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdlZGl0b3JpYWwnKTtcbiAgICBpbnB1dC5zdHlsZS53aWR0aCA9IG91dGVyV2lkdGgoc3BhbikgKyAyMCArICdweCc7IC8vIOWQjeWtl+WkquefreaXtuS4jeWlvei+k+WFpe+8jOWinuihpTIwcHhcblxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGVjayA9IHRoYXQuX2NoZWNrVGFiTmFtZShzaGVldE5hbWUsIHRoaXMudmFsdWUpO1xuICAgICAgICBpZiAoY2hlY2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoYXQud29ya2Jvb2sucmVuYW1lU2hlZXQoc2hlZXROYW1lLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KGNoZWNrKTsgLy8gVE9ETyBhbGVydCDlpKrkuJFcbiAgICAgICAgICAgIHRoYXQudGFiUmVuYW1lQ2FuY2VsKHNoZWV0TmFtZSwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBlbXB0eShzcGFuKTtcbiAgICBzcGFuLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICBpbnB1dC5zZWxlY3QoKTtcbn07XG5cblRhYnMucHJvdG90eXBlLl9jaGVja1RhYk5hbWUgPSBmdW5jdGlvbiAobmFtZTEsIG5hbWUyKSB7XG4gICAgaWYgKGlzRW1wdHlWYWx1ZShuYW1lMikpIHtcbiAgICAgICAgcmV0dXJuIFdBUk5TLlMxO1xuICAgIH1cbiAgICBpZiAocmVnRXhwLnRlc3QobmFtZTIpKSB7XG4gICAgICAgIHJldHVybiBXQVJOUy5TMjtcbiAgICB9XG4gICAgLy8g5pS55oiQ5YW25a6D5bey5pyJ55qEc2hlZXTlkI1cbiAgICBpZiAodXBwZXJDYXNlKG5hbWUxKSAhPT0gdXBwZXJDYXNlKG5hbWUyKSAmJiB0aGlzLndvcmtib29rLmlzU2hlZXRFeGlzdChuYW1lMikpIHtcbiAgICAgICAgcmV0dXJuIFdBUk5TLlMzO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIOaUueWQjeaXtu+8jERPTeS4iueahOS4gOS6m+aTjeS9nO+8jOi/m+WFpeatpOaWueazleaXtuS7o+ihqOW3sue7j+WBmuS6huWQiOazlemqjOivgeOAglxuVGFicy5wcm90b3R5cGUudGFiUmVuYW1lID0gZnVuY3Rpb24gKG5hbWUxLCBuYW1lMikge1xuICAgIHZhciBsaSA9IHRoaXMubGlJdGVtcy5nZXQobmFtZTEpO1xuICAgIHZhciBzcGFuID0gbGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NwYW4nKVswXTtcbiAgICBpbm5lckhUTUwoc3BhbiwgbmFtZTIpO1xuICAgIGxpLmRhdGFzZXQuc2hlZXQgPSBuYW1lMjtcbiAgICB0aGlzLmxpSXRlbXMuc2V0KG5hbWUyLCBsaSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25JdGVtcy5nZXQobmFtZTEpO1xuICAgIHNlY3Rpb24uZGF0YXNldC5zaGVldCA9IG5hbWUyO1xuICAgIHRoaXMuc2VjdGlvbkl0ZW1zLmRlbGV0ZShuYW1lMSk7XG4gICAgdGhpcy5zZWN0aW9uSXRlbXMuc2V0KG5hbWUyLCBzZWN0aW9uKTtcblxuICAgIHZhciBzaGVldE5vdyA9IHRoaXMud29ya2Jvb2suZ2V0U2hlZXQobmFtZTIpO1xuICAgIHNoZWV0Tm93LmVtaXQoJ2FmdGVyUmVuYW1lJywgc2hlZXROb3csIG5hbWUxLCBuYW1lMik7XG59O1xuXG4vLyDmm7TlkI3lpLHotKXvvIzlsIblkI3lrZforr7kuLogbmFtZTEsIG5hbWUy5Li65aSx6LSl55qE5ZCN5a2XXG5UYWJzLnByb3RvdHlwZS50YWJSZW5hbWVDYW5jZWwgPSBmdW5jdGlvbiAobmFtZTEsIG5hbWUyKSB7XG4gICAgdmFyIGxpID0gdGhpcy5saUl0ZW1zLmdldChuYW1lMSk7XG4gICAgdmFyIHNwYW4gPSBsaS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3BhbicpWzBdO1xuICAgIGlubmVySFRNTChzcGFuLCBuYW1lMSk7XG5cbiAgICB2YXIgc2hlZXROb3cgPSB0aGlzLndvcmtib29rLmdldFNoZWV0KG5hbWUxKTtcbiAgICBzaGVldE5vdy5lbWl0KCdhZnRlclJlbmFtZUNhbmNlbCcsIHNoZWV0Tm93LCBuYW1lMSwgbmFtZTIpO1xufTtcblxuXG4vKipcbiAqIOWinuWKoOagh+etvumhteWvueW6lOeahOWGheWuuVxuICogQHBhcmFtIHtzdHJpbmd9IHNoZWV0TmFtZVxuICovXG5UYWJzLnByb3RvdHlwZS5hcHBlbmRDb250ZW50ID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciBzZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VjdGlvbicpO1xuICAgIHZhciBmeCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBob3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdkYXRhLXNoZWV0Jywgc2hlZXROYW1lKTtcbiAgICBzZWN0aW9uLmFwcGVuZENoaWxkKGZ4KTtcbiAgICBzZWN0aW9uLmFwcGVuZENoaWxkKGhvdCk7XG4gICAgc2VjdGlvbi5jbGFzc0xpc3QuYWRkKENMQVNTX1NFQ1RJT04pO1xuICAgIGFuaW1hdGVkICYmIHNlY3Rpb24uY2xhc3NMaXN0LmFkZCgnc3NkLWFuaW1hdGVkLWZhc3QnKTtcblxuICAgIHRoaXMuQ09OVEVOVC5hcHBlbmRDaGlsZChzZWN0aW9uKTtcbiAgICB0aGlzLnNlY3Rpb25JdGVtcy5zZXQoc2hlZXROYW1lLCBzZWN0aW9uKTtcblxuICAgIHRoaXMuYXBwZW5kRngoZngsIHNoZWV0TmFtZSk7XG4gICAgdGhpcy5hcHBlbmRUYWJsZShob3QsIHNoZWV0TmFtZSk7XG59O1xuXG5cblRhYnMucHJvdG90eXBlLnJlbW92ZUNvbnRlbnQgPSBmdW5jdGlvbiAoc2hlZXROYW1lKSB7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLnNlY3Rpb25JdGVtcy5nZXQoc2hlZXROYW1lKTtcbiAgICB0aGlzLkNPTlRFTlQucmVtb3ZlQ2hpbGQoc2VjdGlvbik7XG4gICAgdGhpcy5zZWN0aW9uSXRlbXMuZGVsZXRlKHNoZWV0TmFtZSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hlZXROYW1lXG4gKi9cblRhYnMucHJvdG90eXBlLmhpZGVDb250ZW50ID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5zZWN0aW9uSXRlbXMuZ2V0KHNoZWV0TmFtZSk7XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xufTtcblxuXG4vKipcbiAqIFRPRE8g5YWs5byP6L6T5YWl5qGGXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZnhcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWVcbiAqL1xuVGFicy5wcm90b3R5cGUuYXBwZW5kRnggPSBmdW5jdGlvbiAoZngsIHNoZWV0TmFtZSkge1xuICAgIGZ4LmNsYXNzTGlzdC5hZGQoQ0xBU1NfRlgpO1xuICAgIGZ4LmNsYXNzTGlzdC5hZGQoYCR7Q0xBU1NfRlh9LSR7c2hlZXROYW1lfWApO1xufTtcblxuLyoqXG4gKiDlgYfmuLLmn5MgSGFuc29udGFibGUg57uE5Lu244CCXG4gKiBoYW5kc29udGFibGUg55qE6K6+6K6h5peg5rOV5ZyoRE9N5Lit6K6h566X6KeG5Zu+77yM5b+F6aG75riy5p+Tcm9vdEVsZW1lbnTkuYvlkI7miY3og73nlJ/mlYjjgIJcbiAqIOWvvOiHtOW7tui/n+a4suafk+mavuS7peWunueOsO+8jOaciea4suafk+aAp+iDvemXrumimOaXtuWGjeino+WGs+OAglxuICog5Y+m5aSW77yM5riy5p+T5Yiw5YWI6ZqQ6JeP5ZCO5pi+56S655qE5YWD57Sg5Lit5pe277yM5Lmf5peg5rOV5q2j5bi45pi+56S644CCXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGhvdFxuICogQHBhcmFtIHNoZWV0TmFtZVxuICovXG5UYWJzLnByb3RvdHlwZS5hcHBlbmRUYWJsZSA9IGZ1bmN0aW9uIChob3QsIHNoZWV0TmFtZSkge1xuICAgIHRoaXMuX2hvdFRhYmxlcy5zZXQoc2hlZXROYW1lLCB7XG4gICAgICAgIGNvbnRhaW5lcjogaG90LFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiAoKSA9PiB0aGlzLmhlaWdodCAtIG91dGVySGVpZ2h0KHRoaXMuTkFWKVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiDmv4DmtLvmjIflrprnmoTmoIfnrb7pobVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWUgLSBzaGVldCDlkI1cbiAqL1xuVGFicy5wcm90b3R5cGUuYWN0aXZlVGFiID0gZnVuY3Rpb24gKHNoZWV0TmFtZSkge1xuICAgIHZhciBmb3JtZXIgPSB0aGlzLlRBQlMucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfQ1VSUkVOVH0uJHtDTEFTU19MSX1gKTtcbiAgICBmb3JtZXIgJiYgZm9ybWVyLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfQ1VSUkVOVCk7XG4gICAgdmFyIGxpID0gdGhpcy5saUl0ZW1zLmdldChzaGVldE5hbWUpO1xuICAgIGxpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfQ1VSUkVOVCk7XG4gICAgdGhpcy5hY3RpdmVDb250ZW50KHNoZWV0TmFtZSk7XG59O1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGVldE5hbWUgLSBzaGVldCDlkI1cbiAqL1xuVGFicy5wcm90b3R5cGUuYWN0aXZlQ29udGVudCA9IGZ1bmN0aW9uIChzaGVldE5hbWUpIHtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuc2VjdGlvbkl0ZW1zLmdldChzaGVldE5hbWUpO1xuICAgIHZhciBmb3JtZXIgPSB0aGlzLl9mb3JtZXJBY3RpdmVDb250ZW50O1xuICAgIGlmIChmb3JtZXIpIHtcbiAgICAgICAgYW5pbWF0ZWQgJiYgZm9ybWVyLmNsYXNzTGlzdC5yZW1vdmUoJ2ZhZGVJbicpO1xuICAgICAgICBmb3JtZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBhbmltYXRlZCAmJiBzZWN0aW9uLmNsYXNzTGlzdC5hZGQoJ2ZhZGVJbicpO1xuXG4gICAgdGhpcy5fZm9ybWVyQWN0aXZlQ29udGVudCA9IHNlY3Rpb247XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRhYnM7IiwiZXhwb3J0IGNvbnN0IFdBUk5TID0ge1xuICAgIFMxOiAn5bel5L2c6KGo5ZCN5LiN6IO95Li656m655m944CCJyxcbiAgICBTMjogYOW3peS9nOihqOWQjeensOWMheWQq+aXoOaViOWtl+espjogOiBcXCAvID8gKiBbIF3jgIJgLFxuICAgIFMzOiAn6K+l5ZCN56ew5bey6KKr5L2/55So77yM6K+35bCd6K+V5YW25LuW5ZCN56ew44CCJ1xufTtcblxuXG5leHBvcnQgY29uc3QgTUVOVSA9IHtcbiAgICBTMTogJ+ihjOmrmC4uLicsXG4gICAgUzI6ICfliJflrr0uLi4nLFxuICAgIFMzOiAn5Y2V5YWD5qC85ZCI5bm2JyxcbiAgICBTNDogJ+WPlua2iOWNleWFg+agvOWQiOW5ticsXG4gICAgUzU6ICflr7npvZAnLFxuICAgIFM2OiAn5bem5a+56b2QJyxcbiAgICBTNzogJ+awtOW5s+WxheS4rScsXG4gICAgUzg6ICflj7Plr7npvZAnLFxuICAgIFM5OiAn5Lik56uv5a+56b2QJyxcbiAgICBTMTA6ICfpobbpg6jlr7npvZAnLFxuICAgIFMxMTogJ+WeguebtOWxheS4rScsXG4gICAgUzEyOiAn5bqV6YOo5a+56b2QJyxcbiAgICBTMTM6ICfor7fovpPlhaXooYzpq5gnLFxuICAgIFMxNDogJ+ivt+i+k+WFpeWIl+WuvSdcbn07IiwiaW1wb3J0IHtQbHVnaW5FcnJvcn0gZnJvbSAnLi9QbHVnaW5FcnJvcidcblxudmFyIF9wbHVnaW5zID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIOaPkuS7tuWfuuexu1xuICovXG5jbGFzcyBQbHVnaW4ge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NwcmVhZFNoZWV0fSBzcHJlYWRTaGVldFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwcmVhZFNoZWV0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U3ByZWFkU2hlZXR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwcmVhZHNoZWV0ID0gc3ByZWFkU2hlZXQ7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIOaaguaXtuS4jeiAg+iZkeW8gOaUvui/meS4quaWueazle+8jOeUqOaIt+WumuS5ieeahOaPkuS7tuS4jeiDveaJqeWxlSBTcHJlYWRTaGVldCDnmoQgQVBJXG4gICAgX3JlZ2lzdGVyTWV0aG9kKG5hbWUpIHtcbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5zcHJlYWRzaGVldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgIHByb3RvW25hbWVdID0gKCkgPT4gdGhpc1tuYW1lXSgpO1xuICAgIH1cblxuICAgIGlzRW5hYmxlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZW5hYmxlKCkge1xuXG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcblxuICAgIH1cblxufVxuXG5leHBvcnQge1BsdWdpbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUGx1Z2luKHApIHtcbiAgICBpZiAoIXAuZW5hYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBQbHVnaW5FcnJvcign5o+S5Lu25b+F6aG75YyF5ZCr5ZCv55So5pa55rOV77yaZW5hYmxlJyk7XG4gICAgfVxuICAgIGlmICghcC5kZXN0cm95KSB7XG4gICAgICAgIHRocm93IG5ldyBQbHVnaW5FcnJvcign5o+S5Lu25b+F6aG75YyF5ZCr6ZSA5q+B5pa55rOV77yaZGVzdHJveScpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICAgIF9wbHVnaW5zLnNldChuYW1lLCBwbHVnaW4pO1xuICAgIHBsdWdpbi5wcm90b3R5cGUuX19uYW1lX18gPSBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICB2YXIgcCA9IF9wbHVnaW5zLmdldChuYW1lKTtcbiAgICBpZiAoIXApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBsdWdpbkVycm9yKCfmj5Lku7bkuI3lrZjlnKjvvJonICsgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG4vKipcbiAqIOiOt+WPluaJgOacieaPkuS7tlxuICogQHJldHVybnMge01hcH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIF9wbHVnaW5zO1xufVxuXG5cbiIsImltcG9ydCB7U3ByZWFkU2hlZXRFcnJvcn0gZnJvbSAnLi4vU3ByZWFkU2hlZXRFcnJvcidcblxuZXhwb3J0IGZ1bmN0aW9uIFBsdWdpbkVycm9yKHZhbHVlKSB7XG4gICAgdGhpcy5uYW1lID0gJ1BsdWdpbkVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbn1cblBsdWdpbkVycm9yLnByb3RvdHlwZSA9IG5ldyBTcHJlYWRTaGVldEVycm9yKCk7XG5QbHVnaW5FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnaW5FcnJvcjsiLCJpbXBvcnQge1BsdWdpbn0gZnJvbSAnLi4vUGx1Z2luJztcbmltcG9ydCB7U3RvcmFnZX0gZnJvbSAnLi9TdG9yYWdlJztcblxuY2xhc3MgUGVyc2lzdGVudCBleHRlbmRzIFBsdWdpbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcihzc2QpIHtcbiAgICAgICAgc3VwZXIoc3NkKTtcblxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNwcmVhZHNoZWV0LnNldHRpbmdzO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5wZXJzaXN0ZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBwZXJzaXN0ZW50IOS4uiBgdHJ1ZWAg5pe277yM5L2/55So6buY6K6k5pa55qGIXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOeUteWtkOihqOagvOacrOWcsOaMgeS5heWMluaXtuS9v+eUqOeahCBrZXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZW50S2V5ID0gc3NkLmdldElkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPIHBlcnNpc3RlbnQg5Li65a+56LGh5pe277yM5o+Q5L6bIGxvY2FsU3RvcmFnZeOAgXNlc3Npb24g562J5pa55qGI5Y+K6LaF5pe25pe26Ze0562J55u45YWz6YWN572uXG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbnRLZXkgPSBzZXR0aW5ncy5wZXJzaXN0ZW50LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ByZWFkc2hlZXQuc2V0dGluZ3MgPSBTdG9yYWdlLmxvYWQodGhpcy5wZXJzaXN0ZW50S2V5KSB8fCBzZXR0aW5ncztcblxuICAgICAgICB0aGlzLl9yZWdpc3Rlck1ldGhvZCgnc2F2ZVN0YXRlJyk7XG4gICAgfVxuXG4gICAgaXNFbmFibGUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3ByZWFkc2hlZXQuZ2V0U2V0dGluZ3MoKS5wZXJzaXN0ZW50O1xuICAgIH1cblxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgc3VwZXIuZW5hYmxlKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHNhdmVTdGF0ZSgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNwcmVhZHNoZWV0LmdldEV4Y2hhbmdlRGF0YSgpO1xuICAgICAgICBTdG9yYWdlLnNhdmUodGhpcy5wZXJzaXN0ZW50S2V5LCBkYXRhKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGVyc2lzdGVudDsiLCIvKipcbiAqIOWtmOWCqOaWueahiFxuICovXG5jbGFzcyBTdG9yYWdlIHtcblxuICAgIHN0YXRpYyBzYXZlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlLlBSRUZJWCArIGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2FkKGtleSkge1xuICAgICAgICB2YXIgdmFsID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2UuUFJFRklYICsga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmUoa2V5KSB7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlW1N0b3JhZ2UuUFJFRklYICsga2V5XSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFN0b3JhZ2UuUFJFRklYICsga2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjbGVhcigpIHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgIH1cblxufVxuXG5TdG9yYWdlLlBSRUZJWCA9ICckJGJyaWNrIXN0b3JhZ2UtJztcblxuZXhwb3J0IHtTdG9yYWdlfTsiLCJpbXBvcnQge0NlbGxWYWx1ZX0gZnJvbSAnLi9DZWxsVmFsdWUnO1xuaW1wb3J0IHtpc0Zvcm11bGFFeHByZXNzaW9ufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7RXhwcmVzc2lvbk1vZGlmaWVyfSBmcm9tICcuL2V4cHJlc3Npb25Nb2RpZmllcic7XG5pbXBvcnQgbG9jYWxIb29rcyBmcm9tICcuLi8uLi91dGlscy9sb2NhbEhvb2tzJztcblxudmFyIGFycmF5RWFjaCA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlFYWNoO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcblxuY2xhc3MgQWx0ZXJNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzaGVldCkge1xuXG4gICAgICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IHNoZWV0LmRhdGFQcm92aWRlcjtcblxuICAgICAgICB0aGlzLm1hdHJpeCA9IHNoZWV0Lm1hdHJpeDtcbiAgICB9XG5cbiAgICBpbnNlcnRSb3cocm93LCBhbW91bnQsIG1vZGlmeUZvcm11bGEpIHtcbiAgICAgICAgdGhpcy5fYWx0ZXIoJ2luc2VydCcsICdyb3cnLCByb3csIGFtb3VudCwgbW9kaWZ5Rm9ybXVsYSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlUm93KHJvdywgYW1vdW50LCBtb2RpZnlGb3JtdWxhKSB7XG4gICAgICAgIHRoaXMuX2FsdGVyKCdyZW1vdmUnLCAncm93Jywgcm93LCAtYW1vdW50LCBtb2RpZnlGb3JtdWxhKTtcbiAgICB9XG5cbiAgICBpbnNlcnRDb2x1bW4oY29sdW1uLCBhbW91bnQsIG1vZGlmeUZvcm11bGEpIHtcbiAgICAgICAgdGhpcy5fYWx0ZXIoJ2luc2VydCcsICdjb2x1bW4nLCBjb2x1bW4sIGFtb3VudCwgbW9kaWZ5Rm9ybXVsYSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlQ29sdW1uKGNvbHVtbiwgYW1vdW50LCBtb2RpZnlGb3JtdWxhKSB7XG4gICAgICAgIHRoaXMuX2FsdGVyKCdyZW1vdmUnLCAnY29sdW1uJywgY29sdW1uLCAtYW1vdW50LCBtb2RpZnlGb3JtdWxhKTtcbiAgICB9XG5cbiAgICBfYWx0ZXIoYWN0aW9uLCBheGlzLCBzdGFydCwgYW1vdW50LCBtb2RpZnlGb3JtdWxhID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBzdGFydENvb3JkID0gKGNlbGwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm93OiBheGlzID09PSAncm93JyA/IHN0YXJ0IDogY2VsbC5yb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBheGlzID09PSAnY29sdW1uJyA/IHN0YXJ0IDogY2VsbC5jb2x1bW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0cmFuc2xhdGVDZWxsUmVmcyA9IChyb3csIGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgYXJyYXlFYWNoKHRoaXMubWF0cml4LmNlbGxSZWZlcmVuY2VzLCAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsW2F4aXNdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwudHJhbnNsYXRlVG8ocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IFtdO1xuICAgICAgICBjb25zdCBpbmRleE9mZnNldCA9IE1hdGguYWJzKGFtb3VudCkgLSAxO1xuXG4gICAgICAgIGlmIChheGlzID09PSAncm93Jykge1xuICAgICAgICAgICAgdHJhbnNsYXRlLnB1c2goYW1vdW50LCAwKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGUucHVzaCgwLCBhbW91bnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgIGxldCByZW1vdmVkQ2VsbFJlZiA9IHRoaXMubWF0cml4LnJlbW92ZUNlbGxSZWZzQXRSYW5nZSh7W2F4aXNdOiBzdGFydH0sIHtbYXhpc106IHN0YXJ0ICsgaW5kZXhPZmZzZXR9KTtcbiAgICAgICAgICAgIGxldCB0b1JlbW92ZSA9IFtdO1xuXG4gICAgICAgICAgICBhcnJheUVhY2godGhpcy5tYXRyaXguZGF0YSwgKGNlbGwpID0+IHtcbiAgICAgICAgICAgICAgICBhcnJheUVhY2gocmVtb3ZlZENlbGxSZWYsIChjZWxsUmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2VsbC5oYXNQcmVjZWRlbnQoY2VsbFJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNlbGwucmVtb3ZlUHJlY2VkZW50KGNlbGxSZWYpO1xuICAgICAgICAgICAgICAgICAgICBjZWxsLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5RWFjaCh0aGlzLnNoZWV0LmdldENlbGxEZXBlbmRlbmNpZXMoY2VsbC5yb3csIGNlbGwuY29sdW1uKSwgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChjZWxsW2F4aXNdID49IHN0YXJ0ICYmIGNlbGxbYXhpc10gPD0gKHN0YXJ0ICsgaW5kZXhPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMubWF0cml4LnJlbW92ZSh0b1JlbW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2xhdGVDZWxsUmVmcyguLi50cmFuc2xhdGUpO1xuXG4gICAgICAgIGFycmF5RWFjaCh0aGlzLm1hdHJpeC5kYXRhLCAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1JvdyA9IGNlbGwucm93O1xuICAgICAgICAgICAgY29uc3Qgb3JpZ0NvbHVtbiA9IGNlbGwuY29sdW1uO1xuXG4gICAgICAgICAgICBpZiAoY2VsbFtheGlzXSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIGNlbGwudHJhbnNsYXRlVG8oLi4udHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgICBjZWxsLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kaWZ5Rm9ybXVsYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGNlbGwucm93O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNlbGwuY29sdW1uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwTW9kaWZpZXIgPSBuZXcgRXhwcmVzc2lvbk1vZGlmaWVyKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBleHBNb2RpZmllci50cmFuc2xhdGUoc3RhcnRDb29yZCh7cm93OiBvcmlnUm93LCBjb2x1bW46IG9yaWdDb2x1bW59KSwge1theGlzXTogYW1vdW50fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIudXBkYXRlU291cmNlRGF0YShyb3csIGNvbHVtbiwgZXhwTW9kaWZpZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5Mb2NhbEhvb2tzKCdhZnRlckFsdGVyJywgYWN0aW9uLCBheGlzLCBzdGFydCwgYW1vdW50KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNoZWV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gICAgfVxufVxuXG5taXhpbihBbHRlck1hbmFnZXIsIGxvY2FsSG9va3MpO1xuXG5leHBvcnQge0FsdGVyTWFuYWdlcn07XG4iLCJpbXBvcnQge3RvTGFiZWx9IGZyb20gJy4vcGFyc2VyL3V0aWxzJztcblxudmFyIGlzT2JqZWN0ID0gSGFuZHNvbnRhYmxlLmhlbHBlci5pc09iamVjdDtcblxuY2xhc3MgQmFzZUNlbGwge1xuICAgIGNvbnN0cnVjdG9yKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IHJvd09iamVjdCA9IGlzT2JqZWN0KHJvdyk7XG4gICAgICAgIGNvbnN0IGNvbHVtbk9iamVjdCA9IGlzT2JqZWN0KGNvbHVtbik7XG5cbiAgICAgICAgdGhpcy5fcm93ID0gcm93T2JqZWN0ID8gcm93LmluZGV4IDogcm93O1xuICAgICAgICB0aGlzLnJvd0Fic29sdXRlID0gcm93T2JqZWN0ID8gcm93LmlzQWJzb2x1dGUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29sdW1uID0gY29sdW1uT2JqZWN0ID8gY29sdW1uLmluZGV4IDogY29sdW1uO1xuICAgICAgICB0aGlzLmNvbHVtbkFic29sdXRlID0gY29sdW1uT2JqZWN0ID8gY29sdW1uLmlzQWJzb2x1dGUgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3dPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbk9mZnNldCA9IDA7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyb3cnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dPZmZzZXQgKyB0aGlzLl9yb3c7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29sdW1uJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uT2Zmc2V0ICsgdGhpcy5fY29sdW1uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZVRvKHJvd09mZnNldCwgY29sdW1uT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucm93ID0gdGhpcy5yb3cgKyByb3dPZmZzZXQ7XG4gICAgICAgIHRoaXMuY29sdW1uID0gdGhpcy5jb2x1bW4gKyBjb2x1bW5PZmZzZXQ7XG4gICAgfVxuXG4gICAgaXNFcXVhbChjZWxsKSB7XG4gICAgICAgIHJldHVybiBjZWxsLnJvdyA9PT0gdGhpcy5yb3cgJiYgY2VsbC5jb2x1bW4gPT09IHRoaXMuY29sdW1uO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdG9MYWJlbChcbiAgICAgICAgICAgIHtpbmRleDogdGhpcy5yb3csIGlzQWJzb2x1dGU6IHRoaXMucm93QWJzb2x1dGV9LFxuICAgICAgICAgICAge2luZGV4OiB0aGlzLmNvbHVtbiwgaXNBYnNvbHV0ZTogdGhpcy5jb2x1bW5BYnNvbHV0ZX1cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VDZWxsO1xuIiwiaW1wb3J0IEJhc2VDZWxsIGZyb20gJy4vQmFzZUNlbGwnO1xuaW1wb3J0IHt0b0xhYmVsfSBmcm9tICcuL3BhcnNlci91dGlscyc7XG5cbmNsYXNzIENlbGxSZWZlcmVuY2UgZXh0ZW5kcyBCYXNlQ2VsbCB7XG4gICAgY29uc3RydWN0b3Iocm93LCBjb2x1bW4pIHtcbiAgICAgICAgc3VwZXIocm93LCBjb2x1bW4pO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdG9MYWJlbChcbiAgICAgICAgICAgIHtpbmRleDogdGhpcy5yb3csIGlzQWJzb2x1dGU6IGZhbHNlfSxcbiAgICAgICAgICAgIHtpbmRleDogdGhpcy5jb2x1bW4sIGlzQWJzb2x1dGU6IGZhbHNlfVxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IHtDZWxsUmVmZXJlbmNlfTtcbiIsImltcG9ydCBCYXNlQ2VsbCBmcm9tICcuL0Jhc2VDZWxsJztcbmltcG9ydCB7RVJST1JfUkVGfSBmcm9tICcuL3BhcnNlci9lcnJvcic7XG5cbmNvbnN0IFNUQVRFX09VVF9PRkZfREFURSA9IDE7XG5jb25zdCBTVEFURV9DT01QVVRJTkcgPSAyO1xuY29uc3QgU1RBVEVfVVBfVE9fREFURSA9IDM7XG5jb25zdCBzdGF0ZXMgPSBbU1RBVEVfT1VUX09GRl9EQVRFLCBTVEFURV9DT01QVVRJTkcsIFNUQVRFX1VQX1RPX0RBVEVdO1xuXG52YXIgYXJyYXlGaWx0ZXIgPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5RmlsdGVyO1xuXG5cbmNsYXNzIENlbGxWYWx1ZSBleHRlbmRzIEJhc2VDZWxsIHtcblxuICAgIHN0YXRpYyBnZXQgU1RBVEVfT1VUX09GRl9EQVRFKCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IFNUQVRFX0NPTVBVVElORygpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBTVEFURV9VUF9UT19EQVRFKCkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihyb3csIGNvbHVtbikge1xuICAgICAgICBzdXBlcihyb3csIGNvbHVtbik7XG4gICAgICAgIHRoaXMucHJlY2VkZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDZWxsVmFsdWUuU1RBVEVfVVBfVE9fREFURTtcbiAgICB9XG5cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHNldEVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG5cbiAgICBnZXRFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3I7XG4gICAgfVxuXG4gICAgaGFzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yICE9PSBudWxsO1xuICAgIH1cblxuICAgIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZXMuaW5kZXhPZihzdGF0ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyhg5pyq55+l54q25oCBOiAke3N0YXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICBpc1N0YXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBzdGF0ZTtcbiAgICB9XG5cbiAgICBhZGRQcmVjZWRlbnQoY2VsbFJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJPUl9SRUYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oYXNQcmVjZWRlbnQoY2VsbFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJlY2VkZW50cy5wdXNoKGNlbGxSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlUHJlY2VkZW50KGNlbGxSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFcXVhbChjZWxsUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoRVJST1JfUkVGKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWNlZGVudHMgPSBhcnJheUZpbHRlcih0aGlzLnByZWNlZGVudHMsIChjZWxsKSA9PiAhY2VsbC5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKTtcbiAgICB9XG5cbiAgICBnZXRQcmVjZWRlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVjZWRlbnRzO1xuICAgIH1cblxuICAgIGhhc1ByZWNlZGVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWNlZGVudHMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBoYXNQcmVjZWRlbnQoY2VsbFJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gYXJyYXlGaWx0ZXIodGhpcy5wcmVjZWRlbnRzLCAoY2VsbCkgPT4gY2VsbC5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKS5sZW5ndGggPyB0cnVlIDogZmFsc2U7XG4gICAgfVxufVxuXG5leHBvcnQge0NlbGxWYWx1ZX07XG4iLCJpbXBvcnQge2lzRm9ybXVsYUV4cHJlc3Npb259IGZyb20gJy4vdXRpbHMnO1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgcmFuZ2VFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5yYW5nZUVhY2g7XG5cblxuY2xhc3MgRGF0YVByb3ZpZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGhvdCkge1xuICAgICAgICB0aGlzLmhvdCA9IGhvdDtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0ge307XG4gICAgfVxuXG4gICAgY29sbGVjdENoYW5nZXMocm93LCBjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlc1tEYXRhUHJvdmlkZXIuX2Nvb3JkSWQocm93LCBjb2x1bW4pXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSB7fTtcbiAgICB9XG5cbiAgICBpc0luRGF0YVJhbmdlKHJvdywgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiByb3cgPj0gMCAmJiByb3cgPCB0aGlzLmhvdC5jb3VudFJvd3MoKSAmJiBjb2x1bW4gPj0gMCAmJiBjb2x1bW4gPCB0aGlzLmhvdC5jb3VudENvbHMoKTtcbiAgICB9XG5cbiAgICBnZXREYXRhQXRDZWxsKHJvdywgY29sdW1uKSB7XG4gICAgICAgIGNvbnN0IGlkID0gRGF0YVByb3ZpZGVyLl9jb29yZElkKHJvdywgY29sdW1uKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICBpZiAodGhpcy5jaGFuZ2VzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jaGFuZ2VzW2lkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaG90LmdldERhdGFBdENlbGwocm93LCBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZ2V0RGF0YUF0Q2VsbEluU2hlZXQoc2hlZXROYW1lLCByb3csIGNvbHVtbikge1xuICAgICAgICB2YXIgc2hlZXQgPSB0aGlzLndvcmtib29rLmdldFNoZWV0KHNoZWV0TmFtZSk7XG4gICAgICAgIHZhciBmb3JtdWxhcyA9IHNoZWV0LmhhbmRzb250YWJsZS5nZXRQbHVnaW4oJ1hGb3JtdWxhcycpO1xuICAgICAgICByZXR1cm4gZm9ybXVsYXMuc2hlZXQuZGF0YVByb3ZpZGVyLmdldERhdGFBdENlbGwocm93LCBjb2x1bW4pO1xuICAgIH1cblxuICAgIGdldERhdGFCeVJhbmdlKHJvdzEsIGNvbHVtbjEsIHJvdzIsIGNvbHVtbjIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ob3QuZ2V0RGF0YShyb3cxLCBjb2x1bW4xLCByb3cyLCBjb2x1bW4yKTtcblxuICAgICAgICBhcnJheUVhY2gocmVzdWx0LCAocm93RGF0YSwgcm93SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGFycmF5RWFjaChyb3dEYXRhLCAodmFsdWUsIGNvbHVtbkluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBEYXRhUHJvdmlkZXIuX2Nvb3JkSWQocm93SW5kZXggKyByb3cxLCBjb2x1bW5JbmRleCArIGNvbHVtbjEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jvd0luZGV4XVtjb2x1bW5JbmRleF0gPSB0aGlzLmNoYW5nZXNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldFNvdXJjZURhdGFBdENlbGwocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG90LmdldFNvdXJjZURhdGFBdENlbGwocm93LCBjb2x1bW4pO1xuICAgIH1cblxuICAgIGdldFNvdXJjZURhdGFCeVJhbmdlKHJvdzEsIGNvbHVtbjEsIHJvdzIsIGNvbHVtbjIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG90LmdldFNvdXJjZURhdGFBcnJheShyb3cxLCBjb2x1bW4xLCByb3cyLCBjb2x1bW4yKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTb3VyY2VEYXRhKHJvdywgY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmhvdC5nZXRTb3VyY2VEYXRhKClbcm93XVt0aGlzLmhvdC5jb2xUb1Byb3AoY29sdW1uKV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2Nvb3JkSWQocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGAke3Jvd306JHtjb2x1bW59YDtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmhvdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQge0RhdGFQcm92aWRlcn07XG4iLCJpbXBvcnQge0NlbGxWYWx1ZX0gZnJvbSAnLi9DZWxsVmFsdWUnO1xuaW1wb3J0IHtFUlJPUl9SRUZ9IGZyb20gXCIuL3BhcnNlci9lcnJvclwiO1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgYXJyYXlGaWx0ZXIgPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5RmlsdGVyO1xudmFyIGFycmF5UmVkdWNlID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheVJlZHVjZTtcblxuY2xhc3MgTWF0cml4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuY2VsbFJlZmVyZW5jZXMgPSBbXTtcbiAgICB9XG5cbiAgICBnZXRDZWxsQXQocm93LCBjb2x1bW4pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgYXJyYXlFYWNoKHRoaXMuZGF0YSwgKGNlbGwpID0+IHtcbiAgICAgICAgICAgIGlmIChjZWxsLnJvdyA9PT0gcm93ICYmIGNlbGwuY29sdW1uID09PSBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjZWxsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldE91dE9mRGF0ZUNlbGxzKCkge1xuICAgICAgICByZXR1cm4gYXJyYXlGaWx0ZXIodGhpcy5kYXRhLCAoY2VsbCkgPT4gY2VsbC5pc1N0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpKTtcbiAgICB9XG5cbiAgICBhZGQoY2VsbFZhbHVlKSB7XG4gICAgICAgIGlmICghYXJyYXlGaWx0ZXIodGhpcy5kYXRhLCAoY2VsbCkgPT4gY2VsbC5pc0VxdWFsKGNlbGxWYWx1ZSkpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goY2VsbFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZShjZWxsVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY2VsbFZhbHVlKTtcbiAgICAgICAgY29uc3QgaXNFcXVhbCA9IChjZWxsLCBjZWxsVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheUVhY2goY2VsbFZhbHVlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuaXNFcXVhbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjZWxsLmlzRXF1YWwoY2VsbFZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhID0gYXJyYXlGaWx0ZXIodGhpcy5kYXRhLCAoY2VsbCkgPT4gIWlzRXF1YWwoY2VsbCwgY2VsbFZhbHVlKSk7XG4gICAgfVxuXG4gICAgZ2V0RGVwZW5kZW5jaWVzKGNlbGxWYWx1ZSkge1xuICAgICAgICBjb25zdCBnZXREZXBlbmRlbmNpZXMgPSAoY2VsbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHRoaXMuZGF0YSwgKGFjYywgY2VsbFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxWYWx1ZS5oYXNQcmVjZWRlbnQoY2VsbCkgJiYgYWNjLmluZGV4T2YoY2VsbFZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goY2VsbFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBnZXRUb3RhbERlcGVuZGVuY2llcyA9IChjZWxsKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGVwcyA9IGdldERlcGVuZGVuY2llcyhjZWxsKTtcblxuICAgICAgICAgICAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlFYWNoKGRlcHMsIChjZWxsVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxWYWx1ZS5oYXNQcmVjZWRlbnRzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMgPSBkZXBzLmNvbmNhdChnZXRUb3RhbERlcGVuZGVuY2llcyhjZWxsVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlcHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUb3RhbERlcGVuZGVuY2llcyhjZWxsVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBUT0RPIOWinuWKoOivpeS7o+eggeaYr+ino+WGs+S7peS4i+mXrumimOeahOadg+WunOS5i+etlu+8mlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2hhbmRzb250YWJsZS9oYW5kc29udGFibGUvaXNzdWVzLzQzNTdcbiAgICAgICAgICAgIGxldCBlcnJvclZhbHVlID0gbmV3IENlbGxWYWx1ZShjZWxsVmFsdWUucm93LCBjZWxsVmFsdWUuY29sdW1uKTtcbiAgICAgICAgICAgIGVycm9yVmFsdWUuc2V0RXJyb3IoRVJST1JfUkVGKTtcbiAgICAgICAgICAgIGVycm9yVmFsdWUuc2V0U3RhdGUoQ2VsbFZhbHVlLlNUQVRFX1VQX1RPX0RBVEUpO1xuICAgICAgICAgICAgcmV0dXJuIFtlcnJvclZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmVnaXN0ZXJDZWxsUmVmKGNlbGxSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKCFhcnJheUZpbHRlcih0aGlzLmNlbGxSZWZlcmVuY2VzLCAoY2VsbCkgPT4gY2VsbC5pc0VxdWFsKGNlbGxSZWZlcmVuY2UpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbFJlZmVyZW5jZXMucHVzaChjZWxsUmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUNlbGxSZWZzQXRSYW5nZSh7cm93OiBzdGFydFJvdywgY29sdW1uOiBzdGFydENvbHVtbn0sIHtyb3c6IGVuZFJvdywgY29sdW1uOiBlbmRDb2x1bW59KSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcblxuICAgICAgICBjb25zdCByb3dNYXRjaCA9IChjZWxsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRSb3cgPT09IHZvaWQgMCA/IHRydWUgOiBjZWxsLnJvdyA+PSBzdGFydFJvdyAmJiBjZWxsLnJvdyA8PSBlbmRSb3c7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbE1hdGNoID0gKGNlbGwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydENvbHVtbiA9PT0gdm9pZCAwID8gdHJ1ZSA6IGNlbGwuY29sdW1uID49IHN0YXJ0Q29sdW1uICYmIGNlbGwuY29sdW1uIDw9IGVuZENvbHVtbjtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNlbGxSZWZlcmVuY2VzID0gYXJyYXlGaWx0ZXIodGhpcy5jZWxsUmVmZXJlbmNlcywgKGNlbGwpID0+IHtcbiAgICAgICAgICAgIGlmIChyb3dNYXRjaChjZWxsKSAmJiBjb2xNYXRjaChjZWxsKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChjZWxsKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmRhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jZWxsUmVmZXJlbmNlcy5sZW5ndGggPSAwO1xuICAgIH1cbn1cblxuZXhwb3J0IHtNYXRyaXh9O1xuIiwiaW1wb3J0IHtDZWxsVmFsdWV9IGZyb20gJy4vQ2VsbFZhbHVlJztcbmltcG9ydCB7Q2VsbFJlZmVyZW5jZX0gZnJvbSAnLi9DZWxsUmVmZXJlbmNlJztcbmltcG9ydCB7aXNGb3JtdWxhRXhwcmVzc2lvbiwgdG9VcHBlckNhc2VGb3JtdWxhfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7TWF0cml4fSBmcm9tICcuL01hdHJpeCc7XG5pbXBvcnQge0FsdGVyTWFuYWdlcn0gZnJvbSAnLi9BbHRlck1hbmFnZXInO1xuaW1wb3J0IHtQYXJzZXJ9IGZyb20gJy4vcGFyc2VyL3BhcnNlcic7XG5pbXBvcnQge0VSUk9SX1JFRn0gZnJvbSAnLi9wYXJzZXIvZXJyb3InO1xuaW1wb3J0IGxvY2FsSG9va3MgZnJvbSAnLi4vLi4vdXRpbHMvbG9jYWxIb29rcyc7XG5cbmNvbnN0IFNUQVRFX1VQX1RPX0RBVEUgPSAxO1xuY29uc3QgU1RBVEVfTkVFRF9SRUJVSUxEID0gMjtcbmNvbnN0IFNUQVRFX05FRURfRlVMTF9SRUJVSUxEID0gMztcblxudmFyIGFycmF5RWFjaCA9IEhhbmRzb250YWJsZS5oZWxwZXIuYXJyYXlFYWNoO1xudmFyIGFycmF5TWFwID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheU1hcDtcbnZhciByYW5nZUVhY2ggPSBIYW5kc29udGFibGUuaGVscGVyLnJhbmdlRWFjaDtcbnZhciBvYmplY3RFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5vYmplY3RFYWNoO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcblxuXG5jbGFzcyBTaGVldCB7XG5cbiAgICBjb25zdHJ1Y3RvcihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBkYXRhUHJvdmlkZXI7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5hbHRlck1hbmFnZXIgPSBuZXcgQWx0ZXJNYW5hZ2VyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdDZWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURV9ORUVEX0ZVTExfUkVCVUlMRDtcblxuICAgICAgICB0aGlzLnBhcnNlci5vbignY2FsbENlbGxWYWx1ZScsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxDZWxsVmFsdWUoLi4uYXJncykpO1xuICAgICAgICB0aGlzLnBhcnNlci5vbignY2FsbFJhbmdlVmFsdWUnLCAoLi4uYXJncykgPT4gdGhpcy5fb25DYWxsUmFuZ2VWYWx1ZSguLi5hcmdzKSk7XG4gICAgICAgIHRoaXMucGFyc2VyLm9uKCdjYWxsQ2VsbFZhbHVlSW5TaGVldCcsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxDZWxsVmFsdWVJblNoZWV0KC4uLmFyZ3MpKTtcbiAgICAgICAgdGhpcy5wYXJzZXIub24oJ2NhbGxSYW5nZVZhbHVlSW5TaGVldCcsICguLi5hcmdzKSA9PiB0aGlzLl9vbkNhbGxSYW5nZVZhbHVlSW5TaGVldCguLi5hcmdzKSk7XG4gICAgICAgIHRoaXMuYWx0ZXJNYW5hZ2VyLmFkZExvY2FsSG9vaygnYWZ0ZXJBbHRlcicsICguLi5hcmdzKSA9PiB0aGlzLl9vbkFmdGVyQWx0ZXIoLi4uYXJncykpO1xuICAgIH1cblxuICAgIHJlY2FsY3VsYXRlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFNUQVRFX05FRURfRlVMTF9SRUJVSUxEOlxuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGVGdWxsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNUQVRFX05FRURfUkVCVUlMRDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlT3B0aW1pemVkKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZU9wdGltaXplZCgpIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSB0aGlzLm1hdHJpeC5nZXRPdXRPZkRhdGVDZWxscygpO1xuXG4gICAgICAgIGFycmF5RWFjaChjZWxscywgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRhdGFQcm92aWRlci5nZXRTb3VyY2VEYXRhQXRDZWxsKGNlbGxWYWx1ZS5yb3csIGNlbGxWYWx1ZS5jb2x1bW4pO1xuXG4gICAgICAgICAgICBpZiAoaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXhwcmVzc2lvbihjZWxsVmFsdWUsIHZhbHVlLnN1YnN0cigxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gU1RBVEVfVVBfVE9fREFURTtcbiAgICAgICAgdGhpcy5ydW5Mb2NhbEhvb2tzKCdhZnRlclJlY2FsY3VsYXRlJywgY2VsbHMsICdvcHRpbWl6ZWQnKTtcbiAgICB9XG5cbiAgICByZWNhbGN1bGF0ZUZ1bGwoKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gdGhpcy5kYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUJ5UmFuZ2UoKTtcbiAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcblxuICAgICAgICBhcnJheUVhY2goY2VsbHMsIChyb3dEYXRhLCByb3cpID0+IHtcbiAgICAgICAgICAgIGFycmF5RWFjaChyb3dEYXRhLCAodmFsdWUsIGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXhwcmVzc2lvbihuZXcgQ2VsbFZhbHVlKHJvdywgY29sdW1uKSwgdmFsdWUuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBTVEFURV9VUF9UT19EQVRFO1xuICAgICAgICB0aGlzLnJ1bkxvY2FsSG9va3MoJ2FmdGVyUmVjYWxjdWxhdGUnLCBjZWxscywgJ2Z1bGwnKTtcbiAgICB9XG5cbiAgICBzZXRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcnNlci5zZXRWYXJpYWJsZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG5cbiAgICBnZXRWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5nZXRWYXJpYWJsZShuYW1lKTtcbiAgICB9XG5cblxuICAgIGFwcGx5Q2hhbmdlcyhyb3csIGNvbHVtbiwgbmV3VmFsdWUpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIHJlY2FsY3VsYXRlKClcbiAgICAgICAgdGhpcy5tYXRyaXgucmVtb3ZlKHtyb3csIGNvbHVtbn0pO1xuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byByZWNhbGN1bGF0ZSgpXG4gICAgICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUV4cHJlc3Npb24obmV3IENlbGxWYWx1ZShyb3csIGNvbHVtbiksIG5ld1ZhbHVlLnN1YnN0cigxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXBzID0gdGhpcy5nZXRDZWxsRGVwZW5kZW5jaWVzKHJvdywgY29sdW1uKTtcblxuICAgICAgICBhcnJheUVhY2goZGVwcywgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY2VsbFZhbHVlLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IFNUQVRFX05FRURfUkVCVUlMRDtcbiAgICB9XG5cbiAgICBwYXJzZUV4cHJlc3Npb24oY2VsbFZhbHVlLCBmb3JtdWxhKSB7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRTdGF0ZShDZWxsVmFsdWUuU1RBVEVfQ09NUFVUSU5HKTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ0NlbGwgPSBjZWxsVmFsdWU7XG5cbiAgICAgICAgLy8gVE9ETyAgd3JhcHBlciBmb3JtdWxhXG4gICAgICAgIC8vIHZhciBzaGVldE5hbWVzID0gdGhpcy5kYXRhUHJvdmlkZXIud29ya2Jvb2suZ2V0U2hlZXROYW1lcygpO1xuXG4gICAgICAgIGNvbnN0IHtlcnJvciwgcmVzdWx0fSA9IHRoaXMucGFyc2VyLnBhcnNlKHRvVXBwZXJDYXNlRm9ybXVsYShmb3JtdWxhKSk7XG5cbiAgICAgICAgY2VsbFZhbHVlLnNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgIGNlbGxWYWx1ZS5zZXRTdGF0ZShDZWxsVmFsdWUuU1RBVEVfVVBfVE9fREFURSk7XG5cbiAgICAgICAgdGhpcy5tYXRyaXguYWRkKGNlbGxWYWx1ZSk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NpbmdDZWxsID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRDZWxsQXQocm93LCBjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldENlbGxBdChyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgZ2V0Q2VsbERlcGVuZGVuY2llcyhyb3csIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0RGVwZW5kZW5jaWVzKHtyb3csIGNvbHVtbn0pO1xuICAgIH1cblxuICAgIF9vbkNhbGxDZWxsVmFsdWUoe3JvdywgY29sdW1ufSwgZG9uZSkge1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGxSZWZlcmVuY2Uocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhUHJvdmlkZXIuaXNJbkRhdGFSYW5nZShjZWxsLnJvdywgY2VsbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJPUl9SRUYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXRyaXgucmVnaXN0ZXJDZWxsUmVmKGNlbGwpO1xuICAgICAgICB0aGlzLl9wcm9jZXNzaW5nQ2VsbC5hZGRQcmVjZWRlbnQoY2VsbCk7XG5cbiAgICAgICAgZG9uZSh0aGlzLmRhdGFQcm92aWRlci5nZXREYXRhQXRDZWxsKGNlbGwucm93LCBjZWxsLmNvbHVtbikpO1xuICAgIH1cblxuICAgIF9vbkNhbGxDZWxsVmFsdWVJblNoZWV0KHtzaGVldE5hbWUsIHJvdywgY29sdW1ufSwgZG9uZSkge1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IENlbGxSZWZlcmVuY2Uocm93LCBjb2x1bW4pO1xuXG4gICAgICAgIC8vIFRPRE8g5pu05pS55pWw5o2u5pe277yM5YWs5byP5byV55So55qE5pWw5o2u57qn6IGU5pu05pawXG5cbiAgICAgICAgZG9uZSh0aGlzLmRhdGFQcm92aWRlci5nZXREYXRhQXRDZWxsSW5TaGVldChzaGVldE5hbWUsIGNlbGwucm93LCBjZWxsLmNvbHVtbikpO1xuICAgIH1cblxuICAgIF9vbkNhbGxSYW5nZVZhbHVlKHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IHN0YXJ0Q29sdW1ufSwge3JvdzogZW5kUm93LCBjb2x1bW46IGVuZENvbHVtbn0sIGRvbmUpIHtcbiAgICAgICAgcmFuZ2VFYWNoKHN0YXJ0Um93LmluZGV4LCBlbmRSb3cuaW5kZXgsIChyb3cpID0+IHtcbiAgICAgICAgICAgIHJhbmdlRWFjaChzdGFydENvbHVtbi5pbmRleCwgZW5kQ29sdW1uLmluZGV4LCAoY29sdW1uKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGwgPSBuZXcgQ2VsbFJlZmVyZW5jZShyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5yZWdpc3RlckNlbGxSZWYoY2VsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc2luZ0NlbGwuYWRkUHJlY2VkZW50KGNlbGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb25lKHRoaXMuZGF0YVByb3ZpZGVyLmdldERhdGFCeVJhbmdlKHN0YXJ0Um93LmluZGV4LCBzdGFydENvbHVtbi5pbmRleCwgZW5kUm93LmluZGV4LCBlbmRDb2x1bW4uaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIOiwg+eUqOiMg+WbtOWFrOW8j1xuICAgIF9vbkNhbGxSYW5nZVZhbHVlSW5TaGVldChzaGVldE5hbWUsIHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IHN0YXJ0Q29sdW1ufSwge3JvdzogZW5kUm93LCBjb2x1bW46IGVuZENvbHVtbn0sIGRvbmUpIHtcblxuXG4gICAgICAgIGRvbmUoJ19vbkNhbGxSYW5nZVZhbHVlSW5TaGVldCcpO1xuICAgIH1cblxuICAgIF9vbkFmdGVyQWx0ZXIoKSB7XG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVPcHRpbWl6ZWQoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbHRlck1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmFsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICAgIH1cbn1cblxubWl4aW4oU2hlZXQsIGxvY2FsSG9va3MpO1xuXG5leHBvcnQge1NoZWV0fTtcbiIsImltcG9ydCB7Q2VsbFZhbHVlfSBmcm9tICcuL0NlbGxWYWx1ZSc7XG5pbXBvcnQge1N0YWNrfSBmcm9tICcuLi8uLi91dGlscy9kYXRhU3RydWN0dXJlJ1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgcmFuZ2VFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5yYW5nZUVhY2g7XG5cbmNsYXNzIFVuZG9SZWRvU25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKHNoZWV0KSB7XG4gICAgICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIH1cblxuICAgIHNhdmUoYXhpcywgaW5kZXgsIGFtb3VudCkge1xuICAgICAgICBjb25zdCB7bWF0cml4LCBkYXRhUHJvdmlkZXJ9ID0gdGhpcy5zaGVldDtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuXG4gICAgICAgIGFycmF5RWFjaChtYXRyaXguZGF0YSwgKGNlbGxWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge3JvdywgY29sdW1ufSA9IGNlbGxWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKGNlbGxWYWx1ZVtheGlzXSA8IGluZGV4IHx8IGNlbGxWYWx1ZVtheGlzXSA+IGluZGV4ICsgKGFtb3VudCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe3JvdywgY29sdW1uLCB2YWx1ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0YWNrLnB1c2goe2F4aXMsIGluZGV4LCBhbW91bnQsIGNoYW5nZXN9KTtcbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuICAgICAgICBjb25zdCB7bWF0cml4LCBkYXRhUHJvdmlkZXJ9ID0gdGhpcy5zaGVldDtcbiAgICAgICAgY29uc3Qge2F4aXMsIGluZGV4LCBhbW91bnQsIGNoYW5nZXN9ID0gdGhpcy5zdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgYXJyYXlFYWNoKGNoYW5nZXMsIChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlW2F4aXNdID4gaW5kZXggKyAoYW1vdW50IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlW2F4aXNdIC09IGFtb3VudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qge3JvdywgY29sdW1uLCB2YWx1ZX0gPSBjaGFuZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBkYXRhUHJvdmlkZXIuZ2V0U291cmNlRGF0YUF0Q2VsbChyb3csIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBpZiAocmF3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFQcm92aWRlci51cGRhdGVTb3VyY2VEYXRhKHJvdywgY29sdW1uLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXRDZWxsQXQocm93LCBjb2x1bW4pLnNldFN0YXRlKENlbGxWYWx1ZS5TVEFURV9PVVRfT0ZGX0RBVEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zaGVldCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IHtVbmRvUmVkb1NuYXBzaG90fTtcbiIsIi8qKlxuICog5omp5bGV5YWs5byP77ya5pSv5oyB6Leo5bel5L2c6KGo55qE5YWs5byP44CCXG4gKiDnpLrkvovvvJpcbiAqICsgd29ya3NoZWV0MuS4reafkOWNleWFg+agvOWAvOS4uiBgPXdvcmtzaGVldDEhQTIrQjJgXG4gKiArIOW3peS9nOihqDPkuK3mn5DljZXlhYPmoLzlgLzkuLogYD3lt6XkvZzooagxIUExK+W3peS9nOihqDJCMWBcbiAqICsgc2hlZXQ15Lit5p+Q5Y2V5YWD5qC85YC85Li6YD1TVU0oc2hlZXQzIUIxOkI1LCBzaGVldDQhQjYpYFxuICpcbiAqIFRPRE8g55uu5YmN5LuF5pSv5oyB4oCc55u45a+55byV55So4oCd55qE5Z2Q5qCH5b2i5byP77yM5L2G5rKh5pyJ5YWs5byP5aGr5YWF55qE5pWI5p6c77ybXG4gKiDnm67liY3kuI3mlK/mjIHigJznu53lr7nlvJXnlKjigJ3lkozigJzmt7flkIjlvJXnlKjigJ3mlrnlvI/jgIJcbiAqXG4gKiDmraTmj5Lku7bpnIDopoHnu5XlvIAgaGFuc29udGFibGUg5LiA5Liq5o+S5Lu25a+55bqU5LiA5Liq5a6e5L6L55qE6K6+6K6h5oCd6Lev77yM6ICM5ZCM5pe2566h55CG5aSa5Liq5a6e5L6L44CCXG4gKiDlrp7kvovnmoTnrqHnkIblt6XkvZzkuqTnu5kgV29ya2Jvb2sg5p2l5YGa77yM5Zug5q2k77yM5q2k5o+S5Lu25LiN5Y+v5L2c5Li654us56uL55qEIGhhbnNvbnRhYmxlIOaPkuS7tlxuICog5L2/55So77yM5Y+q6IO95L6d5omY5LqO6K+l55S15a2Q6KGo5qC86K6+6K6h5Zmo44CCXG4gKlxuICogQHBsdWdpbiBFeHRlcm5hbCBwbHVnaW4gWEZvcm11bGFzLlxuICogQHBhcmFtIGhvdEluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKi9cblxuLy8gVE9ETyDnpoHmraLlhazlvI/lvqrnjq/lvJXnlKggQTE9QjEsIEIxPUExXG5cbmltcG9ydCB7XG4gICAgaXNGb3JtdWxhRXhwcmVzc2lvbixcbiAgICB0b1VwcGVyQ2FzZUZvcm11bGEsXG4gICAgaXNGb3JtdWxhRXhwcmVzc2lvbkVzY2FwZWQsXG4gICAgdW5lc2NhcGVGb3JtdWxhRXhwcmVzc2lvblxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7U2hlZXR9IGZyb20gJy4vU2hlZXQnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4vRGF0YVByb3ZpZGVyJztcbmltcG9ydCB7VW5kb1JlZG9TbmFwc2hvdH0gZnJvbSAnLi9VbmRvUmVkb1NuYXBzaG90JztcblxuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgaXNPYmplY3QgPSBIYW5kc29udGFibGUuaGVscGVyLmlzT2JqZWN0O1xudmFyIG9iamVjdEVhY2ggPSBIYW5kc29udGFibGUuaGVscGVyLm9iamVjdEVhY2g7XG5cbmZ1bmN0aW9uIFhGb3JtdWxhcyhob3RJbnN0YW5jZSkge1xuICAgIEhhbmRzb250YWJsZS5wbHVnaW5zLkJhc2VQbHVnaW4uY2FsbCh0aGlzLCBob3RJbnN0YW5jZSk7XG4gICAgdGhpcy5fc3VwZXJDbGFzcyA9IEhhbmRzb250YWJsZS5wbHVnaW5zLkJhc2VQbHVnaW47XG5cbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG5ldyBIYW5kc29udGFibGUuRXZlbnRNYW5hZ2VyKCk7XG4gICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBuZXcgRGF0YVByb3ZpZGVyKHRoaXMuaG90KTtcbiAgICB0aGlzLnNoZWV0ID0gbmV3IFNoZWV0KHRoaXMuZGF0YVByb3ZpZGVyKTtcbiAgICB0aGlzLnVuZG9SZWRvU25hcHNob3QgPSBuZXcgVW5kb1JlZG9TbmFwc2hvdCh0aGlzLnNoZWV0KTtcblxuICAgIHRoaXMuX3NraXBSZW5kZXJpbmcgPSBmYWxzZTtcbn1cblxuWEZvcm11bGFzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSGFuZHNvbnRhYmxlLnBsdWdpbnMuQmFzZVBsdWdpbi5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogWEZvcm11bGFzXG4gICAgfVxufSk7XG5cblxuWEZvcm11bGFzLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5ob3QuZ2V0U2V0dGluZ3MoKS54Rm9ybXVsYXM7XG59O1xuXG4vKipcbiAqIOaPkuS7tuWIneWni+WMlui/h+eoi+OAglxuICogUFM6IGVuYWJsZVBsdWdpbiDmlrnms5XkvJrlnKggYmVmb3JlSW5pdCBob29rIOS4reinpuWPke+8jFxuICogICAgIOS7heW9kyBpc0VuYWJsZWQg5pa55rOV6L+U5ZueIHRydWUg5pe25omn6KGM44CCXG4gKi9cblhGb3JtdWxhcy5wcm90b3R5cGUuZW5hYmxlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy5ob3QuZ2V0U2V0dGluZ3MoKTtcbiAgICBpZiAoIXNldHRpbmdzLl9pc0hvdFRhYmxlQWRhcHRvcikge1xuICAgICAgICB0aHJvdygnWEZvcm11bGFzIOaPkuS7tuWQr+eUqOWksei0pScpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm11bGFzU2V0dGluZ3MgPSBzZXR0aW5ncy5mb3JtdWxhcztcbiAgICBpZiAoaXNPYmplY3QoZm9ybXVsYXNTZXR0aW5ncykpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGZvcm11bGFzU2V0dGluZ3MudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgb2JqZWN0RWFjaChmb3JtdWxhc1NldHRpbmdzLnZhcmlhYmxlcywgKHZhbHVlLCBuYW1lKSA9PiB0aGlzLnNldFZhcmlhYmxlKG5hbWUsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPIG1vdmUgdG8gRGF0YVByb3ZpZGVyXG4gICAgdmFyIHdvcmtzaGVldCA9IHRoaXMuZGF0YVByb3ZpZGVyLndvcmtzaGVldCA9IHRoaXMuaG90LmdldFNldHRpbmdzKCkuX3NoZWV0O1xuICAgIHRoaXMuZGF0YVByb3ZpZGVyLndvcmtib29rID0gd29ya3NoZWV0Lndvcmtib29rO1xuXG4gICAgdGhpcy5hZGRIb29rKCdhZnRlckNyZWF0ZUNvbCcsICguLi5hcmdzKSA9PiB0aGlzLm9uQWZ0ZXJDcmVhdGVDb2woLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnYWZ0ZXJDcmVhdGVSb3cnLCAoLi4uYXJncykgPT4gdGhpcy5vbkFmdGVyQ3JlYXRlUm93KC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2FmdGVyTG9hZERhdGEnLCAoKSA9PiB0aGlzLm9uQWZ0ZXJMb2FkRGF0YSgpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2FmdGVyUmVtb3ZlQ29sJywgKC4uLmFyZ3MpID0+IHRoaXMub25BZnRlclJlbW92ZUNvbCguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdhZnRlclJlbW92ZVJvdycsICguLi5hcmdzKSA9PiB0aGlzLm9uQWZ0ZXJSZW1vdmVSb3coLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnYWZ0ZXJTZXREYXRhQXRDZWxsJywgKC4uLmFyZ3MpID0+IHRoaXMub25BZnRlclNldERhdGFBdENlbGwoLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnYWZ0ZXJTZXREYXRhQXRSb3dQcm9wJywgKC4uLmFyZ3MpID0+IHRoaXMub25BZnRlclNldERhdGFBdENlbGwoLi4uYXJncykpO1xuICAgIC8vdGhpcy5hZGRIb29rKCdiZWZvcmVLZXlEb3duJywgKC4uLmFyZ3MpID0+IHRoaXMub25CZWZvcmVLZXlEb3duKC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZUNyZWF0ZUNvbCcsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlQ3JlYXRlQ29sKC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZUNyZWF0ZVJvdycsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlQ3JlYXRlUm93KC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZVJlbW92ZUNvbCcsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlUmVtb3ZlQ29sKC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZVJlbW92ZVJvdycsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlUmVtb3ZlUm93KC4uLmFyZ3MpKTtcbiAgICB0aGlzLmFkZEhvb2soJ2JlZm9yZVZhbGlkYXRlJywgKC4uLmFyZ3MpID0+IHRoaXMub25CZWZvcmVWYWxpZGF0ZSguLi5hcmdzKSk7XG4gICAgdGhpcy5hZGRIb29rKCdiZWZvcmVWYWx1ZVJlbmRlcicsICguLi5hcmdzKSA9PiB0aGlzLm9uQmVmb3JlVmFsdWVSZW5kZXIoLi4uYXJncykpO1xuICAgIHRoaXMuYWRkSG9vaygnbW9kaWZ5RGF0YScsICguLi5hcmdzKSA9PiB0aGlzLm9uTW9kaWZ5RGF0YSguLi5hcmdzKSk7XG5cbiAgICB0aGlzLnNoZWV0LmFkZExvY2FsSG9vaygnYWZ0ZXJSZWNhbGN1bGF0ZScsICguLi5hcmdzKSA9PiB0aGlzLm9uU2hlZXRBZnRlclJlY2FsY3VsYXRlKC4uLmFyZ3MpKTtcblxuICAgIHRoaXMuX3N1cGVyQ2xhc3MucHJvdG90eXBlLmVuYWJsZVBsdWdpbi5jYWxsKHRoaXMpO1xufTtcblxuXG4vKipcbiAqIOemgeeUqOaPkuS7tuOAglxuICogUFM6IOazqOaEj+WwhuaJgOacieWxnuaAp+mHjee9ruS4uum7mOiupOWAvFxuICovXG5YRm9ybXVsYXMucHJvdG90eXBlLmRpc2FibGVQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc3VwZXJDbGFzcy5wcm90b3R5cGUuZGlzYWJsZVBsdWdpbi5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiDph43nva4gSGFuZHNvbnRhYmxlIOeahCBzZXR0aW5ncyDml7bvvIznlKjmnaXph43nva4gWEZvcm11bGFzIOaPkuS7tueahOWxnuaAp+OAglxuICogUFM6IOWcqCBhZnRlclVwZGF0ZVNldHRpbmdzIGhvb2sg5Lit6LCD55So44CCXG4gKi9cblhGb3JtdWxhcy5wcm90b3R5cGUudXBkYXRlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzYWJsZVBsdWdpbigpO1xuICAgIHRoaXMuZW5hYmxlUGx1Z2luKCk7XG4gICAgdGhpcy5fc3VwZXJDbGFzcy5wcm90b3R5cGUudXBkYXRlUGx1Z2luLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIOmUgOavgeaPkuS7tlxuICovXG5YRm9ybXVsYXMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kYXRhUHJvdmlkZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICB0aGlzLnNoZWV0LmRlc3Ryb3koKTtcbiAgICB0aGlzLnNoZWV0ID0gbnVsbDtcbiAgICB0aGlzLl9zdXBlckNsYXNzLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG59O1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVtzdGFydF0gSG9va3NcblxuLy8gVE9ETyDlt6XkvZzooajmlLnlkI3ml7bvvIzlhbblroPlt6XkvZzooajlhbPogZTliLDlroPnmoTlhazlvI/lgLzopoHmlLlcblhGb3JtdWxhcy5wcm90b3R5cGUub25TaGVldFJlbmFtZSA9IGZ1bmN0aW9uIChzaGVldCwgbmFtZTEsIG5hbWUyKSB7XG5cblxufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vblNoZWV0QWZ0ZXJSZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChjZWxscykge1xuICAgIGlmICh0aGlzLl9za2lwUmVuZGVyaW5nKSB7XG4gICAgICAgIHRoaXMuX3NraXBSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob3QgPSB0aGlzLmhvdDtcblxuICAgIGFycmF5RWFjaChjZWxscywgKHtyb3csIGNvbHVtbn0pID0+IHtcbiAgICAgICAgaG90LnZhbGlkYXRlQ2VsbChcbiAgICAgICAgICAgIGhvdC5nZXREYXRhQXRDZWxsKHJvdywgY29sdW1uKSxcbiAgICAgICAgICAgIGhvdC5nZXRDZWxsTWV0YShyb3csIGNvbHVtbiksXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgaG90LnJlbmRlcigpO1xufTtcblxuXG4vKipcbiAqIFRPRE9cbiAqIENhdXRpb24gLSDosIPnlKggZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkg5Y+v5Lul6Zi75q2i6buY6K6k6KGM5Li644CCXG4gKiBAcGFyYW0gZXZlbnRcbiAqL1xuWEZvcm11bGFzLnByb3RvdHlwZS5vbkJlZm9yZUtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbk1vZGlmeURhdGEgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIHZhbHVlSG9sZGVyLCBpb01vZGUpIHtcbiAgICBpZiAoaW9Nb2RlID09PSAnZ2V0JyAmJiB0aGlzLmhhc0NvbXB1dGVkQ2VsbFZhbHVlKHJvdywgY29sdW1uKSkge1xuICAgICAgICB2YWx1ZUhvbGRlci52YWx1ZSA9IHRoaXMuZ2V0Q2VsbFZhbHVlKHJvdywgY29sdW1uKTtcbiAgICB9IGVsc2UgaWYgKGlvTW9kZSA9PT0gJ3NldCcgJiYgaXNGb3JtdWxhRXhwcmVzc2lvbih2YWx1ZUhvbGRlci52YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVIb2xkZXIudmFsdWUgPSB0b1VwcGVyQ2FzZUZvcm11bGEodmFsdWVIb2xkZXIudmFsdWUpO1xuICAgIH1cbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25CZWZvcmVWYWx1ZVJlbmRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChpc0Zvcm11bGFFeHByZXNzaW9uRXNjYXBlZCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB1bmVzY2FwZUZvcm11bGFFeHByZXNzaW9uKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkJlZm9yZVZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCByb3csIHByb3ApIHtcbiAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmhvdC5wcm9wVG9Db2wocHJvcCk7XG5cbiAgICBpZiAodGhpcy5oYXNDb21wdXRlZENlbGxWYWx1ZShyb3csIGNvbHVtbikpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmdldENlbGxWYWx1ZShyb3csIGNvbHVtbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkFmdGVyU2V0RGF0YUF0Q2VsbCA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAnbG9hZERhdGEnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFQcm92aWRlci5jbGVhckNoYW5nZXMoKTtcbiAgICBhcnJheUVhY2goY2hhbmdlcywgKFtyb3csIGNvbHVtbiwgb2xkVmFsdWUsIG5ld1ZhbHVlXSkgPT4ge1xuICAgICAgICBjb2x1bW4gPSB0aGlzLmhvdC5wcm9wVG9Db2woY29sdW1uKTtcbiAgICAgICAgaWYgKGlzRm9ybXVsYUV4cHJlc3Npb24obmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvVXBwZXJDYXNlRm9ybXVsYShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuY29sbGVjdENoYW5nZXMocm93LCBjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zaGVldC5hcHBseUNoYW5nZXMocm93LCBjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25CZWZvcmVDcmVhdGVSb3cgPSBmdW5jdGlvbiAocm93LCBhbW91bnQsIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09ICdVbmRvUmVkby51bmRvJykge1xuICAgICAgICB0aGlzLnVuZG9SZWRvU25hcHNob3QucmVzdG9yZSgpO1xuICAgIH1cbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25BZnRlckNyZWF0ZVJvdyA9IGZ1bmN0aW9uIChyb3csIGFtb3VudCwgc291cmNlKSB7XG4gICAgdGhpcy5zaGVldC5hbHRlck1hbmFnZXIuaW5zZXJ0Um93KHJvdywgYW1vdW50LCBzb3VyY2UgIT09ICdVbmRvUmVkby51bmRvJyk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQmVmb3JlUmVtb3ZlUm93ID0gZnVuY3Rpb24gKHJvdywgYW1vdW50KSB7XG4gICAgLy8gVE9ETyBTdG9yYWdlLnNhdmUoJ3JvdycsIHJvdywgYW1vdW50KTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUub25BZnRlclJlbW92ZVJvdyA9IGZ1bmN0aW9uIChyb3csIGFtb3VudCkge1xuICAgIHRoaXMuc2hlZXQuYWx0ZXJNYW5hZ2VyLnJlbW92ZVJvdyhyb3csIGFtb3VudCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQmVmb3JlQ3JlYXRlQ29sID0gZnVuY3Rpb24gKGNvbHVtbiwgYW1vdW50LCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlID09PSAnVW5kb1JlZG8udW5kbycpIHtcbiAgICAgICAgdGhpcy51bmRvUmVkb1NuYXBzaG90LnJlc3RvcmUoKTtcbiAgICB9XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQWZ0ZXJDcmVhdGVDb2wgPSBmdW5jdGlvbiAoY29sdW1uLCBhbW91bnQsIHNvdXJjZSkge1xuICAgIHRoaXMuc2hlZXQuYWx0ZXJNYW5hZ2VyLmluc2VydENvbHVtbihjb2x1bW4sIGFtb3VudCwgc291cmNlICE9PSAnVW5kb1JlZG8udW5kbycpO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkJlZm9yZVJlbW92ZUNvbCA9IGZ1bmN0aW9uIChjb2x1bW4sIGFtb3VudCkge1xuICAgIC8vIFRPRE8gU3RvcmFnZS5zYXZlKCdjb2x1bW4nLCBjb2x1bW4sIGFtb3VudCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLm9uQWZ0ZXJSZW1vdmVDb2wgPSBmdW5jdGlvbiAoY29sdW1uLCBhbW91bnQpIHtcbiAgICB0aGlzLnNoZWV0LmFsdGVyTWFuYWdlci5yZW1vdmVDb2x1bW4oY29sdW1uLCBhbW91bnQpO1xufTtcblxuWEZvcm11bGFzLnByb3RvdHlwZS5vbkFmdGVyTG9hZERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc2tpcFJlbmRlcmluZyA9IHRydWU7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUZ1bGwoKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVtlbmRdIEhvb2tzXG5cblhGb3JtdWxhcy5wcm90b3R5cGUuZ2V0Q2VsbFZhbHVlID0gZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuc2hlZXQuZ2V0Q2VsbEF0KHJvdywgY29sdW1uKTtcbiAgICByZXR1cm4gY2VsbCA/IChjZWxsLmdldEVycm9yKCkgfHwgY2VsbC5nZXRWYWx1ZSgpKSA6IHZvaWQgMDtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUuaGFzQ29tcHV0ZWRDZWxsVmFsdWUgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcbiAgICByZXR1cm4gISF0aGlzLnNoZWV0LmdldENlbGxBdChyb3csIGNvbHVtbik7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGUoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUucmVjYWxjdWxhdGVGdWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGVGdWxsKCk7XG59O1xuXG5YRm9ybXVsYXMucHJvdG90eXBlLnJlY2FsY3VsYXRlT3B0aW1pemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2hlZXQucmVjYWxjdWxhdGVPcHRpbWl6ZWQoKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUuc2V0VmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLnNoZWV0LnNldFZhcmlhYmxlKG5hbWUsIHZhbHVlKTtcbn07XG5cblhGb3JtdWxhcy5wcm90b3R5cGUuZ2V0VmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNoZWV0LmdldFZhcmlhYmxlKG5hbWUpO1xufTtcblxuSGFuZHNvbnRhYmxlLnBsdWdpbnMucmVnaXN0ZXJQbHVnaW4oJ3hGb3JtdWxhcycsIFhGb3JtdWxhcyk7XG5cbmV4cG9ydCB7WEZvcm11bGFzfTsiLCJpbXBvcnQge3RvVXBwZXJDYXNlRm9ybXVsYX0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge3RvTGFiZWwsIGV4dHJhY3RMYWJlbH0gZnJvbSAnLi9wYXJzZXIvdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGVycm9yLCBFUlJPUl9SRUZ9IGZyb20gJy4vcGFyc2VyL2Vycm9yJztcbmltcG9ydCBsb2NhbEhvb2tzIGZyb20gJy4uLy4uL3V0aWxzL2xvY2FsSG9va3MnO1xuXG52YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgYXJyYXlGaWx0ZXIgPSBIYW5kc29udGFibGUuaGVscGVyLmFycmF5RmlsdGVyO1xudmFyIG1peGluID0gSGFuZHNvbnRhYmxlLmhlbHBlci5taXhpbjtcblxuY29uc3QgQkFSRV9DRUxMX1NUUklDVF9SRUdFWCA9IC9eXFwkP1tBLVpdK1xcJD9cXGQrJC87XG5jb25zdCBCQVJFX0NFTExfUkVHRVggPSAvXFwkP1tBLVpdK1xcJD9cXGQrLztcbmNvbnN0IENFTExfUkVHRVggPSAvKD86W14wLTlBLVokOiBdfF4pXFxzKihcXCQ/W0EtWl0rXFwkP1xcZCspXFxzKig/IVswLTlBLVpfOiBdKS9nO1xuY29uc3QgUkFOR0VfUkVHRVggPSAvXFwkP1tBLVpdK1xcJD9cXGQrXFxzKjpcXHMqXFwkP1tBLVpdK1xcJD9cXGQrL2c7XG5jb25zdCBDRUxMX0FORF9SQU5HRV9SRUdFWCA9IC8oKD86W14wLTlBLVokOiBdfF4pXFxzKihcXCQ/W0EtWl0rXFwkP1xcZCspXFxzKig/IVswLTlBLVpfOiBdKSl8KFxcJD9bQS1aXStcXCQ/XFxkK1xccyo6XFxzKlxcJD9bQS1aXStcXCQ/XFxkKykvZztcblxuXG5jbGFzcyBFeHByZXNzaW9uTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb24pIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICog5b6F5L+u5pS555qE6KGo6L6+5byPXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSAnJztcblxuICAgICAgICB0aGlzLmNlbGxzID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0RXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuY2VsbHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gdG9VcHBlckNhc2VGb3JtdWxhKGV4cHJlc3Npb24pO1xuXG4gICAgICAgIHRoaXMuX2V4dHJhY3RDZWxscygpO1xuICAgICAgICB0aGlzLl9leHRyYWN0Q2VsbHNSYW5nZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZSh7cm93OiBiYXNlUm93LCBjb2x1bW46IGJhc2VDb2x1bW59LCB7cm93OiBkZWx0YVJvdywgY29sdW1uOiBkZWx0YUNvbHVtbn0pIHtcbiAgICAgICAgYXJyYXlFYWNoKHRoaXMuY2VsbHMsIChjZWxsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGVsdGFSb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIEV4cHJlc3Npb25Nb2RpZmllci5fdHJhbnNsYXRlQ2VsbChjZWxsLCAncm93JywgYmFzZVJvdywgZGVsdGFSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhQ29sdW1uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uTW9kaWZpZXIuX3RyYW5zbGF0ZUNlbGwoY2VsbCwgJ2NvbHVtbicsIGJhc2VDb2x1bW4sIGRlbHRhQ29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uLnJlcGxhY2UoQ0VMTF9BTkRfUkFOR0VfUkVHRVgsIChtYXRjaCwgcDEsIHAyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1NpbmdsZUNlbGwgPSBtYXRjaC5pbmRleE9mKCc6JykgPT09IC0xO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoO1xuICAgICAgICAgICAgbGV0IGNlbGxMYWJlbCA9IG1hdGNoO1xuICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZWRDZWxsTGFiZWwgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaXNTaW5nbGVDZWxsKSB7XG4gICAgICAgICAgICAgICAgY2VsbExhYmVsID0gQkFSRV9DRUxMX1NUUklDVF9SRUdFWC50ZXN0KHAxKSA/IHAxIDogcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5fc2VhcmNoQ2VsbChjZWxsTGFiZWwpO1xuXG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRDZWxsTGFiZWwgPSBjZWxsLnJlZkVycm9yID8gZXJyb3IoRVJST1JfUkVGKSA6IGNlbGwudG9MYWJlbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2luZ2xlQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRjaC5yZXBsYWNlKGNlbGxMYWJlbCwgdHJhbnNsYXRlZENlbGxMYWJlbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhbnNsYXRlZENlbGxMYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZXhwcmVzc2lvbi5zdGFydHNXaXRoKCc9JykpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSAnPScgKyBleHByZXNzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgc3RhdGljIF90cmFuc2xhdGVDZWxsKGNlbGwsIHByb3BlcnR5LCBiYXNlSW5kZXggPSAwLCBkZWx0YSA9IDApIHtcbiAgICAgICAgY29uc3Qge3R5cGUsIHN0YXJ0LCBlbmR9ID0gY2VsbDtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydFtwcm9wZXJ0eV0uaW5kZXg7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IGVuZFtwcm9wZXJ0eV0uaW5kZXg7XG4gICAgICAgIGxldCBkZWx0YVN0YXJ0ID0gZGVsdGE7XG4gICAgICAgIGxldCBkZWx0YUVuZCA9IGRlbHRhO1xuICAgICAgICBsZXQgcmVmRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaW5kZXhPZmZzZXQgPSBNYXRoLmFicyhkZWx0YSkgLSAxO1xuXG4gICAgICAgIC8vIOWinuWKoFxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBpZiAoYmFzZUluZGV4ID4gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGRlbHRhU3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhc2VJbmRleCA+IGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgZGVsdGFFbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyDliKDpmaRcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID49IGJhc2VJbmRleCAmJiBlbmRJbmRleCA8PSBiYXNlSW5kZXggKyBpbmRleE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJlZkVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVmRXJyb3IgJiYgdHlwZSA9PT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VJbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YUVuZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWZFcnJvciAmJiB0eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VJbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFzZUluZGV4ID4gZW5kSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFFbmQgPSAwO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRJbmRleCA8PSBiYXNlSW5kZXggKyBpbmRleE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YUVuZCAtPSBNYXRoLm1pbihlbmRJbmRleCAtIChiYXNlSW5kZXggKyBpbmRleE9mZnNldCksIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWx0YVN0YXJ0ICYmICFyZWZFcnJvcikge1xuICAgICAgICAgICAgc3RhcnRbcHJvcGVydHldLmluZGV4ID0gTWF0aC5tYXgoc3RhcnRJbmRleCArIGRlbHRhU3RhcnQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YUVuZCAmJiAhcmVmRXJyb3IpIHtcbiAgICAgICAgICAgIGVuZFtwcm9wZXJ0eV0uaW5kZXggPSBNYXRoLm1heChlbmRJbmRleCArIGRlbHRhRW5kLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRXJyb3IpIHtcbiAgICAgICAgICAgIGNlbGwucmVmRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2V4dHJhY3RDZWxscygpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuZXhwcmVzc2lvbi5tYXRjaChDRUxMX1JFR0VYKTtcblxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhcnJheUVhY2gobWF0Y2hlcywgKGNvb3JkKSA9PiB7XG4gICAgICAgICAgICBjb29yZCA9IGNvb3JkLm1hdGNoKEJBUkVfQ0VMTF9SRUdFWCk7XG5cbiAgICAgICAgICAgIGlmICghY29vcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbcm93LCBjb2x1bW5dID0gZXh0cmFjdExhYmVsKGNvb3JkWzBdKTtcblxuICAgICAgICAgICAgdGhpcy5jZWxscy5wdXNoKHRoaXMuX2NyZWF0ZUNlbGwoe3JvdywgY29sdW1ufSwge3JvdywgY29sdW1ufSwgY29vcmRbMF0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2V4dHJhY3RDZWxsc1JhbmdlKCkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5leHByZXNzaW9uLm1hdGNoKFJBTkdFX1JFR0VYKTtcblxuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhcnJheUVhY2gobWF0Y2hlcywgKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBtYXRjaC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgY29uc3QgW3N0YXJ0Um93LCBzdGFydENvbHVtbl0gPSBleHRyYWN0TGFiZWwoc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgW2VuZFJvdywgZW5kQ29sdW1uXSA9IGV4dHJhY3RMYWJlbChlbmQpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0ge1xuICAgICAgICAgICAgICAgIHJvdzogc3RhcnRSb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydENvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGVuZENlbGwgPSB7XG4gICAgICAgICAgICAgICAgcm93OiBlbmRSb3csXG4gICAgICAgICAgICAgICAgY29sdW1uOiBlbmRDb2x1bW5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuY2VsbHMucHVzaCh0aGlzLl9jcmVhdGVDZWxsKHN0YXJ0Q2VsbCwgZW5kQ2VsbCwgbWF0Y2gpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBfc2VhcmNoQ2VsbChsYWJlbCkge1xuICAgICAgICBjb25zdCBbY2VsbF0gPSBhcnJheUZpbHRlcih0aGlzLmNlbGxzLCAoY2VsbCkgPT4gY2VsbC5vcmlnTGFiZWwgPT09IGxhYmVsKTtcblxuICAgICAgICByZXR1cm4gY2VsbCB8fCBudWxsO1xuICAgIH1cblxuICAgIF9jcmVhdGVDZWxsKHN0YXJ0LCBlbmQsIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9yaWdMYWJlbDogbGFiZWwsXG4gICAgICAgICAgICB0eXBlOiBsYWJlbC5pbmRleE9mKCc6JykgPT09IC0xID8gJ2NlbGwnIDogJ3JhbmdlJyxcbiAgICAgICAgICAgIHJlZkVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIHRvTGFiZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSB0b0xhYmVsKHRoaXMuc3RhcnQucm93LCB0aGlzLnN0YXJ0LmNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAncmFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsICs9ICc6JyArIHRvTGFiZWwodGhpcy5lbmQucm93LCB0aGlzLmVuZC5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbm1peGluKEV4cHJlc3Npb25Nb2RpZmllciwgbG9jYWxIb29rcyk7XG5cbmV4cG9ydCB7RXhwcmVzc2lvbk1vZGlmaWVyfTsiLCJleHBvcnQgY29uc3QgRVJST1IgPSAnRVJST1InO1xuZXhwb3J0IGNvbnN0IEVSUk9SX0RJVl9aRVJPID0gJ0RJVi8wJztcbmV4cG9ydCBjb25zdCBFUlJPUl9OQU1FID0gJ05BTUUnO1xuZXhwb3J0IGNvbnN0IEVSUk9SX05FRURfVVBEQVRFID0gJ05FRURfVVBEQVRFJztcbmV4cG9ydCBjb25zdCBFUlJPUl9OT1RfQVZBSUxBQkxFID0gJ04vQSc7XG5leHBvcnQgY29uc3QgRVJST1JfTlVMTCA9ICdOVUxMJztcbmV4cG9ydCBjb25zdCBFUlJPUl9OVU0gPSAnTlVNJztcbmV4cG9ydCBjb25zdCBFUlJPUl9SRUYgPSAnUkVGJztcbmV4cG9ydCBjb25zdCBFUlJPUl9WQUxVRSA9ICdWQUxVRSc7XG5cbmNvbnN0IGVycm9ycyA9IHtcbiAgW0VSUk9SXTogJyNFUlJPUiEnLFxuICBbRVJST1JfRElWX1pFUk9dOiAnI0RJVi8wIScsXG4gIFtFUlJPUl9OQU1FXTogJyNOQU1FPycsXG4gIFtFUlJPUl9ORUVEX1VQREFURV06ICcjTkVFRF9VUERBVEUhJyxcbiAgW0VSUk9SX05PVF9BVkFJTEFCTEVdOiAnI04vQScsXG4gIFtFUlJPUl9OVUxMXTogJyNOVUxMIScsXG4gIFtFUlJPUl9OVU1dOiAnI05VTSEnLFxuICBbRVJST1JfUkVGXTogJyNSRUYhJyxcbiAgW0VSUk9SX1ZBTFVFXTogJyNWQUxVRSEnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG4gIGxldCBlcnJvcjtcbiAgdHlwZSA9ICh0eXBlICsgJycpLnJlcGxhY2UoLyN8IXxcXD8vZywgJycpO1xuXG4gIGlmIChlcnJvcnNbdHlwZV0pIHtcbiAgICBlcnJvciA9IGVycm9yc1t0eXBlXTtcbiAgfVxuICByZXR1cm4gZXJyb3IgPyBlcnJvciA6IG51bGw7XG59XG4iLCIvKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNC4xNyAqL1xuLypcbiAgUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5cbiAgUGFyc2VyOiB7XG4gICAgeXk6IHt9XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlOiB7XG4gICAgeXk6IHt9LFxuICAgIHRyYWNlOiBmdW5jdGlvbigpLFxuICAgIHN5bWJvbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gbnVtYmVyfSxcbiAgICB0ZXJtaW5hbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbnVtYmVyID09PiBuYW1lfSxcbiAgICBwcm9kdWN0aW9uc186IFsuLi5dLFxuICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlLCAkJCwgXyQpLFxuICAgIHRhYmxlOiBbLi4uXSxcbiAgICBkZWZhdWx0QWN0aW9uczogey4uLn0sXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQpLFxuXG4gICAgbGV4ZXI6IHtcbiAgICAgICAgRU9GOiAxLFxuICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQpLFxuICAgICAgICBpbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdW5wdXQ6IGZ1bmN0aW9uKHN0ciksXG4gICAgICAgIG1vcmU6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxlc3M6IGZ1bmN0aW9uKG4pLFxuICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24oKSxcbiAgICAgICAgdGVzdF9tYXRjaDogZnVuY3Rpb24ocmVnZXhfbWF0Y2hfYXJyYXksIHJ1bGVfaW5kZXgpLFxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpLFxuICAgICAgICBsZXg6IGZ1bmN0aW9uKCksXG4gICAgICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24oKSxcbiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICByYW5nZXM6IGJvb2xlYW4gICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIpXG4gICAgICAgICAgICBmbGV4OiBib29sZWFuICAgICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gZmxleC1saWtlIGxleGluZyBiZWhhdmlvdXIgd2hlcmUgdGhlIHJ1bGVzIGFyZSB0ZXN0ZWQgZXhoYXVzdGl2ZWx5IHRvIGZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gpXG4gICAgICAgICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW4gIChvcHRpb25hbDogdHJ1ZSA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgZWFjaCBtYXRjaGluZyByZWdleCB0aGUgYWN0aW9uIGNvZGUgaXMgaW52b2tlZDsgdGhlIGxleGVyIHRlcm1pbmF0ZXMgdGhlIHNjYW4gd2hlbiBhIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24gY29kZSlcbiAgICAgICAgfSxcblxuICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbih5eSwgeXlfLCAkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLCBZWV9TVEFSVCksXG4gICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAgICAgICAgY29uZGl0aW9uczoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IHNldH0sXG4gICAgfVxuICB9XG5cblxuICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gICAgZmlyc3RfbGluZTogbixcbiAgICBsYXN0X2xpbmU6IG4sXG4gICAgZmlyc3RfY29sdW1uOiBuLFxuICAgIGxhc3RfY29sdW1uOiBuLFxuICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXSAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCByZWd1bGFyIHplcm8tYmFzZWQpXG4gIH1cblxuXG4gIHRoZSBwYXJzZUVycm9yIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGFuZCBwYXJzZXIgZXJyb3JzOiB7XG4gICAgdGV4dDogICAgICAgIChtYXRjaGVkIHRleHQpXG4gICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAgICBsaW5lOiAgICAgICAgKHl5bGluZW5vKVxuICB9XG4gIHdoaWxlIHBhcnNlciAoZ3JhbW1hcikgZXJyb3JzIHdpbGwgYWxzbyBwcm92aWRlIHRoZXNlIG1lbWJlcnMsIGkuZS4gcGFyc2VyIGVycm9ycyBkZWxpdmVyIGEgc3VwZXJzZXQgb2YgYXR0cmlidXRlczoge1xuICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICAgIGV4cGVjdGVkOiAgICAoc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnMpXG4gICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBoYXMgYSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICB9XG4qL1xudmFyIGdyYW1tYXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSw1XSwkVjE9WzEsOF0sJFYyPVsxLDZdLCRWMz1bMSw3XSwkVjQ9WzEsOV0sJFY1PVsxLDE1XSwkVjY9WzEsMTZdLCRWNz1bMSwxN10sJFY4PVsxLDE4XSwkVjk9WzEsMTNdLCRWYT1bMSwxNF0sJFZiPVsxLDE5XSwkVmM9WzEsMjFdLCRWZD1bMSwyMl0sJFZlPVsxLDIzXSwkVmY9WzEsMjRdLCRWZz1bMSwyNV0sJFZoPVsxLDI2XSwkVmk9WzEsMjddLCRWaj1bMSwyOF0sJFZrPVsxLDI5XSwkVmw9WzEsMzBdLCRWbT1bNSw5LDEwLDExLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDMyLDMzXSwkVm49WzUsOSwxMCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwzMiwzMywzNV0sJFZvPVsxLDM5XSwkVnA9WzUsOSwxMCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwzMiwzMywzN10sJFZxPVs1LDEwLDExLDEzLDE0LDE1LDE2LDE3LDMyLDMzXSwkVnI9WzUsMTAsMTMsMTQsMTUsMTYsMzIsMzNdLCRWcz1bNSwxMCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwzMiwzM10sJFZ0PVsxMywzMiwzM10sJFZ1PVs1LDksMTAsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMzIsMzMsMzQsMzhdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiZXJyb3JcIjoyLFwiZXhwcmVzc2lvbnNcIjozLFwiZXhwcmVzc2lvblwiOjQsXCJFT0ZcIjo1LFwidmFyaWFibGVTZXF1ZW5jZVwiOjYsXCJudW1iZXJcIjo3LFwiU1RSSU5HXCI6OCxcIiZcIjo5LFwiPVwiOjEwLFwiK1wiOjExLFwiKFwiOjEyLFwiKVwiOjEzLFwiPFwiOjE0LFwiPlwiOjE1LFwiTk9UXCI6MTYsXCItXCI6MTcsXCIqXCI6MTgsXCIvXCI6MTksXCJeXCI6MjAsXCJGVU5DVElPTlwiOjIxLFwiZXhwc2VxXCI6MjIsXCJzaGVldFwiOjIzLFwiY2VsbFwiOjI0LFwiU0hFRVRfTkFNRVwiOjI1LFwiIVwiOjI2LFwiQUJTT0xVVEVfQ0VMTFwiOjI3LFwiUkVMQVRJVkVfQ0VMTFwiOjI4LFwiTUlYRURfQ0VMTFwiOjI5LFwiOlwiOjMwLFwiQVJSQVlcIjozMSxcIjtcIjozMixcIixcIjozMyxcIlZBUklBQkxFXCI6MzQsXCJERUNJTUFMXCI6MzUsXCJOVU1CRVJcIjozNixcIiVcIjozNyxcIiNcIjozOCxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezU6XCJFT0ZcIiw4OlwiU1RSSU5HXCIsOTpcIiZcIiwxMDpcIj1cIiwxMTpcIitcIiwxMjpcIihcIiwxMzpcIilcIiwxNDpcIjxcIiwxNTpcIj5cIiwxNjpcIk5PVFwiLDE3OlwiLVwiLDE4OlwiKlwiLDE5OlwiL1wiLDIwOlwiXlwiLDIxOlwiRlVOQ1RJT05cIiwyNTpcIlNIRUVUX05BTUVcIiwyNjpcIiFcIiwyNzpcIkFCU09MVVRFX0NFTExcIiwyODpcIlJFTEFUSVZFX0NFTExcIiwyOTpcIk1JWEVEX0NFTExcIiwzMDpcIjpcIiwzMTpcIkFSUkFZXCIsMzI6XCI7XCIsMzM6XCIsXCIsMzQ6XCJWQVJJQUJMRVwiLDM1OlwiREVDSU1BTFwiLDM2OlwiTlVNQkVSXCIsMzc6XCIlXCIsMzg6XCIjXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywyXSxbNCwxXSxbNCwxXSxbNCwxXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCw0XSxbNCw0XSxbNCw0XSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwzXSxbNCwyXSxbNCwyXSxbNCwzXSxbNCw0XSxbNCwxXSxbNCwxXSxbNCwxXSxbNCwyXSxbMjMsM10sWzIzLDNdLFsyMywzXSxbMjMsNV0sWzIzLDVdLFsyMyw1XSxbMjMsNV0sWzIzLDVdLFsyMyw1XSxbMjMsNV0sWzIzLDVdLFsyMyw1XSxbMjQsMV0sWzI0LDFdLFsyNCwxXSxbMjQsM10sWzI0LDNdLFsyNCwzXSxbMjQsM10sWzI0LDNdLFsyNCwzXSxbMjQsM10sWzI0LDNdLFsyNCwzXSxbMjIsMV0sWzIyLDFdLFsyMiwzXSxbMjIsM10sWzYsMV0sWzYsM10sWzcsMV0sWzcsM10sWzcsMl0sWzIsM10sWzIsNF1dLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCAkJCAvKiB2c3RhY2sgKi8sIF8kIC8qIGxzdGFjayAqLykge1xuLyogdGhpcyA9PSB5eXZhbCAqL1xuXG52YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDE6XG5cbiAgICAgICAgcmV0dXJuICQkWyQwLTFdO1xuICAgIFxuYnJlYWs7XG5jYXNlIDI6XG5cbiAgICAgICAgdGhpcy4kID0geXkuY2FsbFZhcmlhYmxlKCQkWyQwXVswXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAzOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LnRvTnVtYmVyKCQkWyQwXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSA0OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LnRyaW1FZGdlcygkJFskMF0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgNTpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJyYnLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgNjpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJz0nLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgNzpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJysnLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgODpcblxuICAgICAgICB0aGlzLiQgPSB5eS50b051bWJlcigkJFskMC0xXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSA5OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignPD0nLCBbJCRbJDAtM10sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTA6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCc+PScsIFskJFskMC0zXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxMTpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJzw+JywgWyQkWyQwLTNdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDEyOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignTk9UJywgWyQkWyQwLTJdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDEzOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignPicsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxNDpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJzwnLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTU6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCctJywgWyQkWyQwLTJdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDE2OlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmV2YWx1YXRlQnlPcGVyYXRvcignKicsIFskJFskMC0yXSwgJCRbJDBdXSk7XG4gICAgICBcbmJyZWFrO1xuY2FzZSAxNzpcblxuICAgICAgICB0aGlzLiQgPSB5eS5ldmFsdWF0ZUJ5T3BlcmF0b3IoJy8nLCBbJCRbJDAtMl0sICQkWyQwXV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMTg6XG5cbiAgICAgICAgdGhpcy4kID0geXkuZXZhbHVhdGVCeU9wZXJhdG9yKCdeJywgWyQkWyQwLTJdLCAkJFskMF1dKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDE5OlxuXG4gICAgICAgIHZhciBuMSA9IHl5LmludmVydE51bWJlcigkJFskMF0pO1xuICAgICAgICB0aGlzLiQgPSBuMTtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuJCkpIHtcbiAgICAgICAgICAgIHRoaXMuJCA9IDA7XG4gICAgICAgIH1cbiAgICAgIFxuYnJlYWs7XG5jYXNlIDIwOlxuXG4gICAgICAgIHZhciBuMSA9IHl5LnRvTnVtYmVyKCQkWyQwXSk7XG4gICAgICAgIHRoaXMuJCA9IG4xO1xuICAgICAgICBpZiAoaXNOYU4odGhpcy4kKSkge1xuICAgICAgICAgICAgdGhpcy4kID0gMDtcbiAgICAgICAgfVxuICAgICAgXG5icmVhaztcbmNhc2UgMjE6XG5cbiAgICAgICAgdGhpcy4kID0geXkuY2FsbEZ1bmN0aW9uKCQkWyQwLTJdKTtcbiAgICAgIFxuYnJlYWs7XG5jYXNlIDIyOlxuXG4gICAgICAgIHRoaXMuJCA9IHl5LmNhbGxGdW5jdGlvbigkJFskMC0zXSwgJCRbJDAtMV0pO1xuICAgICAgXG5icmVhaztcbmNhc2UgMjc6IGNhc2UgMjg6IGNhc2UgMjk6XG5cbiAgICAgIHRoaXMuJCA9IHl5LmNlbGxWYWx1ZUluU2hlZXQoJCRbJDAtMl0sICQkWyQwXSk7XG4gICAgXG5icmVhaztcbmNhc2UgMzA6IGNhc2UgMzE6IGNhc2UgMzI6IGNhc2UgMzM6IGNhc2UgMzQ6IGNhc2UgMzU6IGNhc2UgMzY6IGNhc2UgMzc6IGNhc2UgMzg6XG5cbiAgICAgIHRoaXMuJCA9IHl5LnJhbmdlVmFsdWVJblNoZWV0KCQkWyQwLTRdLCAkJFskMC0yXSwgJCRbJDBdKTtcbiAgICBcbmJyZWFrO1xuY2FzZSAzOTogY2FzZSA0MDogY2FzZSA0MTpcblxuICAgICAgdGhpcy4kID0geXkuY2VsbFZhbHVlKCQkWyQwXSk7XG4gICAgXG5icmVhaztcbmNhc2UgNDI6IGNhc2UgNDM6IGNhc2UgNDQ6IGNhc2UgNDU6IGNhc2UgNDY6IGNhc2UgNDc6IGNhc2UgNDg6IGNhc2UgNDk6IGNhc2UgNTA6XG5cbiAgICAgIHRoaXMuJCA9IHl5LnJhbmdlVmFsdWUoJCRbJDAtMl0sICQkWyQwXSk7XG4gICAgXG5icmVhaztcbmNhc2UgNTE6IGNhc2UgNTU6XG5cbiAgICAgIHRoaXMuJCA9IFskJFskMF1dO1xuICAgIFxuYnJlYWs7XG5jYXNlIDUyOlxuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgYXJyID0gZXZhbChcIltcIiArIHl5dGV4dCArIFwiXVwiKTtcblxuICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiQgPSByZXN1bHQ7XG4gICAgXG5icmVhaztcbmNhc2UgNTM6IGNhc2UgNTQ6XG5cbiAgICAgICQkWyQwLTJdLnB1c2goJCRbJDBdKTtcbiAgICAgIHRoaXMuJCA9ICQkWyQwLTJdO1xuICAgIFxuYnJlYWs7XG5jYXNlIDU2OlxuXG4gICAgICB0aGlzLiQgPSAoQXJyYXkuaXNBcnJheSgkJFskMC0yXSkgPyAkJFskMC0yXSA6IFskJFskMC0yXV0pO1xuICAgICAgdGhpcy4kLnB1c2goJCRbJDBdKTtcbiAgICBcbmJyZWFrO1xuY2FzZSA1NzpcblxuICAgICAgdGhpcy4kID0gJCRbJDBdO1xuICAgIFxuYnJlYWs7XG5jYXNlIDU4OlxuXG4gICAgICB0aGlzLiQgPSAoJCRbJDAtMl0gKyAnLicgKyAkJFskMF0pICogMTtcbiAgICBcbmJyZWFrO1xuY2FzZSA1OTpcblxuICAgICAgdGhpcy4kID0gJCRbJDAtMV0gKiAwLjAxO1xuICAgIFxuYnJlYWs7XG5jYXNlIDYwOiBjYXNlIDYxOlxuXG4gICAgICB0aGlzLiQgPSB5eS50aHJvd0Vycm9yKCQkWyQwLTJdICsgJCRbJDAtMV0gKyAkJFskMF0pO1xuICAgIFxuYnJlYWs7XG59XG59LFxudGFibGU6IFt7MjoxMiwzOjEsNDoyLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezE6WzNdfSx7NTpbMSwyMF0sOTokVmMsMTA6JFZkLDExOiRWZSwxNDokVmYsMTU6JFZnLDE2OiRWaCwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9LG8oJFZtLFsyLDJdLHszNTpbMSwzMV19KSxvKCRWbSxbMiwzXSx7Mzc6WzEsMzJdfSksbygkVm0sWzIsNF0pLHsyOjEyLDQ6MzMsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjM0LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDozNSw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsxMjpbMSwzNl19LG8oJFZtLFsyLDIzXSksbygkVm0sWzIsMjRdKSxvKCRWbSxbMiwyNV0sezI6MzcsMzQ6WzEsMzhdLDM4OiRWYn0pLG8oJFZuLFsyLDU1XSx7Mzg6JFZvfSksbygkVnAsWzIsNTddLHszNTpbMSw0MF19KSx7MjY6WzEsNDFdfSxvKCRWbSxbMiwzOV0sezMwOlsxLDQyXX0pLG8oJFZtLFsyLDQwXSx7MzA6WzEsNDNdfSksbygkVm0sWzIsNDFdLHszMDpbMSw0NF19KSx7MzQ6WzEsNDVdfSx7MTpbMiwxXX0sezI6MTIsNDo0Niw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6NDcsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjQ4LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1MSw2OjMsNzo0LDg6JFYwLDEwOlsxLDQ5XSwxMTokVjEsMTI6JFYyLDE1OlsxLDUwXSwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1Myw2OjMsNzo0LDg6JFYwLDEwOlsxLDUyXSwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjU0LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1NSw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6NTYsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSx7MjoxMiw0OjU3LDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo1OCw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHszNDpbMSw1OV19LG8oJFZwLFsyLDU5XSksezk6JFZjLDEwOiRWZCwxMTokVmUsMTM6WzEsNjBdLDE0OiRWZiwxNTokVmcsMTY6JFZoLDE3OiRWaSwxODokVmosMTk6JFZrLDIwOiRWbH0sbygkVnEsWzIsMTldLHs5OiRWYywxODokVmosMTk6JFZrLDIwOiRWbH0pLG8oJFZxLFsyLDIwXSx7OTokVmMsMTg6JFZqLDE5OiRWaywyMDokVmx9KSx7MjoxMiw0OjYzLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxMzpbMSw2MV0sMTc6JFYzLDIxOiRWNCwyMjo2MiwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzE6WzEsNjRdLDM0OiRWOSwzNjokVmEsMzg6JFZifSxvKCRWbSxbMiwyNl0pLHszODokVm99LHszNDpbMSw2NV19LHszNjpbMSw2Nl19LHsyNzpbMSw2N10sMjg6WzEsNjhdLDI5OlsxLDY5XX0sezI3OlsxLDcwXSwyODpbMSw3MV0sMjk6WzEsNzJdfSx7Mjc6WzEsNzNdLDI4OlsxLDc0XSwyOTpbMSw3NV19LHsyNzpbMSw3Nl0sMjg6WzEsNzddLDI5OlsxLDc4XX0sezI2OlsxLDc5XX0sbygkVm0sWzIsNV0pLG8oWzUsMTAsMTMsMzIsMzNdLFsyLDZdLHs5OiRWYywxMTokVmUsMTQ6JFZmLDE1OiRWZywxNjokVmgsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnEsWzIsN10sezk6JFZjLDE4OiRWaiwxOTokVmssMjA6JFZsfSksezI6MTIsNDo4MCw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LHsyOjEyLDQ6ODEsNjozLDc6NCw4OiRWMCwxMTokVjEsMTI6JFYyLDE3OiRWMywyMTokVjQsMjM6MTAsMjQ6MTEsMjU6JFY1LDI3OiRWNiwyODokVjcsMjk6JFY4LDM0OiRWOSwzNjokVmEsMzg6JFZifSxvKCRWcixbMiwxNF0sezk6JFZjLDExOiRWZSwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSx7MjoxMiw0OjgyLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sbygkVnIsWzIsMTNdLHs5OiRWYywxMTokVmUsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbyhbNSwxMCwxMywxNiwzMiwzM10sWzIsMTJdLHs5OiRWYywxMTokVmUsMTQ6JFZmLDE1OiRWZywxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWcSxbMiwxNV0sezk6JFZjLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnMsWzIsMTZdLHs5OiRWYywyMDokVmx9KSxvKCRWcyxbMiwxN10sezk6JFZjLDIwOiRWbH0pLG8oWzUsMTAsMTEsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMzIsMzNdLFsyLDE4XSx7OTokVmN9KSxvKCRWbixbMiw1Nl0pLG8oJFZtLFsyLDhdKSxvKCRWbSxbMiwyMV0pLHsxMzpbMSw4M10sMzI6WzEsODRdLDMzOlsxLDg1XX0sbygkVnQsWzIsNTFdLHs5OiRWYywxMDokVmQsMTE6JFZlLDE0OiRWZiwxNTokVmcsMTY6JFZoLDE3OiRWaSwxODokVmosMTk6JFZrLDIwOiRWbH0pLG8oJFZ0LFsyLDUyXSksezI2OlsxLDg2XX0sbygkVnAsWzIsNThdKSxvKCRWbSxbMiwyN10sezMwOlsxLDg3XX0pLG8oJFZtLFsyLDI4XSx7MzA6WzEsODhdfSksbygkVm0sWzIsMjldLHszMDpbMSw4OV19KSxvKCRWbSxbMiw0Ml0pLG8oJFZtLFsyLDQzXSksbygkVm0sWzIsNDRdKSxvKCRWbSxbMiw0NV0pLG8oJFZtLFsyLDQ2XSksbygkVm0sWzIsNDddKSxvKCRWbSxbMiw0OF0pLG8oJFZtLFsyLDQ5XSksbygkVm0sWzIsNTBdKSxvKCRWdSxbMiw2MF0pLG8oJFZyLFsyLDldLHs5OiRWYywxMTokVmUsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnIsWzIsMTFdLHs5OiRWYywxMTokVmUsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVnIsWzIsMTBdLHs5OiRWYywxMTokVmUsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVm0sWzIsMjJdKSx7MjoxMiw0OjkwLDY6Myw3OjQsODokVjAsMTE6JFYxLDEyOiRWMiwxNzokVjMsMjE6JFY0LDIzOjEwLDI0OjExLDI1OiRWNSwyNzokVjYsMjg6JFY3LDI5OiRWOCwzNDokVjksMzY6JFZhLDM4OiRWYn0sezI6MTIsNDo5MSw2OjMsNzo0LDg6JFYwLDExOiRWMSwxMjokVjIsMTc6JFYzLDIxOiRWNCwyMzoxMCwyNDoxMSwyNTokVjUsMjc6JFY2LDI4OiRWNywyOTokVjgsMzQ6JFY5LDM2OiRWYSwzODokVmJ9LG8oJFZ1LFsyLDYxXSksezI3OlsxLDkyXSwyODpbMSw5M10sMjk6WzEsOTRdfSx7Mjc6WzEsOTVdLDI4OlsxLDk2XSwyOTpbMSw5N119LHsyNzpbMSw5OF0sMjg6WzEsOTldLDI5OlsxLDEwMF19LG8oJFZ0LFsyLDUzXSx7OTokVmMsMTA6JFZkLDExOiRWZSwxNDokVmYsMTU6JFZnLDE2OiRWaCwxNzokVmksMTg6JFZqLDE5OiRWaywyMDokVmx9KSxvKCRWdCxbMiw1NF0sezk6JFZjLDEwOiRWZCwxMTokVmUsMTQ6JFZmLDE1OiRWZywxNjokVmgsMTc6JFZpLDE4OiRWaiwxOTokVmssMjA6JFZsfSksbygkVm0sWzIsMzBdKSxvKCRWbSxbMiwzMV0pLG8oJFZtLFsyLDMyXSksbygkVm0sWzIsMzNdKSxvKCRWbSxbMiwzNF0pLG8oJFZtLFsyLDM1XSksbygkVm0sWzIsMzZdKSxvKCRWbSxbMiwzN10pLG8oJFZtLFsyLDM4XSldLFxuZGVmYXVsdEFjdGlvbnM6IHsyMDpbMiwxXX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBfcGFyc2VFcnJvciAobXNnLCBoYXNoKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIF9wYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yO1xuXG4gICAgICAgIHRocm93IG5ldyBfcGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHN0YWNrID0gWzBdLFxuICAgICAgICB0c3RhY2sgPSBbXSwgLy8gdG9rZW4gc3RhY2tcbiAgICAgICAgdnN0YWNrID0gW251bGxdLCAvLyBzZW1hbnRpYyB2YWx1ZSBzdGFja1xuICAgICAgICBsc3RhY2sgPSBbXSwgLy8gbG9jYXRpb24gc3RhY2tcbiAgICAgICAgdGFibGUgPSB0aGlzLnRhYmxlLFxuICAgICAgICB5eXRleHQgPSAnJyxcbiAgICAgICAgeXlsaW5lbm8gPSAwLFxuICAgICAgICB5eWxlbmcgPSAwLFxuICAgICAgICByZWNvdmVyaW5nID0gMCxcbiAgICAgICAgVEVSUk9SID0gMixcbiAgICAgICAgRU9GID0gMTtcblxuICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIC8vdGhpcy5yZWR1Y3Rpb25Db3VudCA9IHRoaXMuc2hpZnRDb3VudCA9IDA7XG5cbiAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIHZhciBzaGFyZWRTdGF0ZSA9IHsgeXk6IHt9IH07XG4gICAgLy8gY29weSBzdGF0ZVxuICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnl5LCBrKSkge1xuICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV4ZXIueXlsbG9jID0ge307XG4gICAgfVxuICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG5cbiAgICB2YXIgcmFuZ2VzID0gbGV4ZXIub3B0aW9ucyAmJiBsZXhlci5vcHRpb25zLnJhbmdlcztcblxuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrIChuKSB7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIgKiBuO1xuICAgICAgICB2c3RhY2subGVuZ3RoID0gdnN0YWNrLmxlbmd0aCAtIG47XG4gICAgICAgIGxzdGFjay5sZW5ndGggPSBsc3RhY2subGVuZ3RoIC0gbjtcbiAgICB9XG5cbl90b2tlbl9zdGFjazpcbiAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHRva2VuID0gbGV4ZXIubGV4KCkgfHwgRU9GO1xuICAgICAgICAvLyBpZiB0b2tlbiBpc24ndCBpdHMgbnVtZXJpYyB2YWx1ZSwgY29udmVydFxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIHJldHJlaXZlIHN0YXRlIG51bWJlciBmcm9tIHRvcCBvZiBzdGFja1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIHVzZSBkZWZhdWx0IGFjdGlvbnMgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlYWQgYWN0aW9uIGZvciBjdXJyZW50IHN0YXRlIGFuZCBmaXJzdCBpbnB1dFxuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG5cbl9oYW5kbGVfZXJyb3I6XG4gICAgICAgIC8vIGhhbmRsZSBwYXJzZSBlcnJvclxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgdmFyIGVycm9yX3J1bGVfZGVwdGg7XG4gICAgICAgICAgICB2YXIgZXJyU3RyID0gJyc7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgcnVsZSBzdGFjayBkZXB0aCB3aGVyZSB0aGUgbmVhcmVzdCBlcnJvciBydWxlIGNhbiBiZSBmb3VuZC5cbiAgICAgICAgICAgIC8vIFJldHVybiBGQUxTRSB3aGVuIG5vIGVycm9yIHJlY292ZXJ5IHJ1bGUgd2FzIGZvdW5kLlxuICAgICAgICAgICAgZnVuY3Rpb24gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrX3Byb2JlID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHJlY292ZXIgZnJvbSBlcnJvclxuICAgICAgICAgICAgICAgIGZvcig7Oykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3IgcmVjb3ZlcnkgcnVsZSBpbiB0aGlzIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmICgoVEVSUk9SLnRvU3RyaW5nKCkpIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCB8fCBzdGFja19wcm9iZSA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gc3VpdGFibGUgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhY2tfcHJvYmUgLT0gMjsgLy8gcG9wU3RhY2soMSk6IFtzeW1ib2wsIGFjdGlvbl1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFja19wcm9iZV07XG4gICAgICAgICAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBzZWUgaWYgdGhlcmUncyBhbnkgY2hhbmNlIGF0IGhpdHRpbmcgYW4gZXJyb3IgcmVjb3ZlcnkgcnVsZTpcbiAgICAgICAgICAgICAgICBlcnJvcl9ydWxlX2RlcHRoID0gbG9jYXRlTmVhcmVzdEVycm9yUmVjb3ZlcnlSdWxlKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBlcnJvclxuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiBURVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goXCInXCIrdGhpcy50ZXJtaW5hbHNfW3BdK1wiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcrKHl5bGluZW5vKzEpK1wiOlxcblwiK2xleGVyLnNob3dQb3NpdGlvbigpK1wiXFxuRXhwZWN0aW5nIFwiK2V4cGVjdGVkLmpvaW4oJywgJykgKyBcIiwgZ290ICdcIiArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpKyBcIidcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnKyh5eWxpbmVubysxKStcIjogVW5leHBlY3RlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN5bWJvbCA9PSBFT0YgPyBcImVuZCBvZiBpbnB1dFwiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCInXCIrKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkrXCInXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgICAgIGxvYzogeXlsb2MsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmFibGU6IChlcnJvcl9ydWxlX2RlcHRoICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlRXJyb3JTeW1ib2wgIT09IEVPRikge1xuICAgICAgICAgICAgICAgIGVycm9yX3J1bGVfZGVwdGggPSBsb2NhdGVOZWFyZXN0RXJyb3JSZWNvdmVyeVJ1bGUoc3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBqdXN0IHJlY292ZXJlZCBmcm9tIGFub3RoZXIgZXJyb3JcbiAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sID09PSBFT0YgfHwgcHJlRXJyb3JTeW1ib2wgPT09IEVPRikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyIHx8ICdQYXJzaW5nIGhhbHRlZCB3aGlsZSBzdGFydGluZyB0byByZWNvdmVyIGZyb20gYW5vdGhlciBlcnJvci4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIGN1cnJlbnQgbG9va2FoZWFkIGFuZCBncmFiIGFub3RoZXJcbiAgICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRyeSB0byByZWNvdmVyIGZyb20gZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnJvcl9ydWxlX2RlcHRoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJTdHIgfHwgJ1BhcnNpbmcgaGFsdGVkLiBObyBzdWl0YWJsZSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcFN0YWNrKGVycm9yX3J1bGVfZGVwdGgpO1xuXG4gICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IChzeW1ib2wgPT0gVEVSUk9SID8gbnVsbCA6IHN5bWJvbCk7IC8vIHNhdmUgdGhlIGxvb2thaGVhZCB0b2tlblxuICAgICAgICAgICAgc3ltYm9sID0gVEVSUk9SOyAgICAgICAgIC8vIGluc2VydCBnZW5lcmljIGVycm9yIHN5bWJvbCBhcyBuZXcgbG9va2FoZWFkXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXTtcbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bVEVSUk9SXTtcbiAgICAgICAgICAgIHJlY292ZXJpbmcgPSAzOyAvLyBhbGxvdyAzIHJlYWwgc3ltYm9scyB0byBiZSBzaGlmdGVkIGJlZm9yZSByZXBvcnRpbmcgYSBuZXcgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgc2hvdWxkbid0IGhhcHBlbiwgdW5sZXNzIHJlc29sdmUgZGVmYXVsdHMgYXJlIG9mZlxuICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcrc3RhdGUrJywgdG9rZW46ICcrc3ltYm9sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICBjYXNlIDE6IC8vIHNoaWZ0XG4gICAgICAgICAgICAgICAgLy90aGlzLnNoaWZ0Q291bnQrKztcblxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlci55eXRleHQpO1xuICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pOyAvLyBwdXNoIHN0YXRlXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7IC8vIG5vcm1hbCBleGVjdXRpb24vbm8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY292ZXJpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIGp1c3Qgb2NjdXJyZWQsIHJlc3VtZSBvbGQgbG9va2FoZWFkIGYvIGJlZm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIC8vIHJlZHVjZVxuICAgICAgICAgICAgICAgIC8vdGhpcy5yZWR1Y3Rpb25Db3VudCsrO1xuXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcblxuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gc2VtYW50aWMgYWN0aW9uXG4gICAgICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoLWxlbl07IC8vIGRlZmF1bHQgdG8gJCQgPSAkMVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgbG9jYXRpb24sIHVzZXMgZmlyc3QgdG9rZW4gZm9yIGZpcnN0cywgbGFzdCBmb3IgbGFzdHNcbiAgICAgICAgICAgICAgICB5eXZhbC5fJCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGgtKGxlbnx8MSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGgtMV0ubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoLShsZW58fDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aC0xXS5sYXN0X2NvbHVtblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgeXl2YWwuXyQucmFuZ2UgPSBbbHN0YWNrW2xzdGFjay5sZW5ndGgtKGxlbnx8MSldLnJhbmdlWzBdLCBsc3RhY2tbbHN0YWNrLmxlbmd0aC0xXS5yYW5nZVsxXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFt5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHNoYXJlZFN0YXRlLnl5LCBhY3Rpb25bMV0sIHZzdGFjaywgbHN0YWNrXS5jb25jYXQoYXJncykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwb3Agb2ZmIHN0YWNrXG4gICAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsLTEqbGVuKjIpO1xuICAgICAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEqbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xKmxlbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTsgICAgLy8gcHVzaCBub250ZXJtaW5hbCAocmVkdWNlKVxuICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgICAgICAvLyBnb3RvIG5ldyBzdGF0ZSA9IHRhYmxlW1NUQVRFXVtOT05URVJNSU5BTF1cbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aC0yXV1bc3RhY2tbc3RhY2subGVuZ3RoLTFdXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIC8vIGFjY2VwdFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn19O1xuXG4vKiBnZW5lcmF0ZWQgYnkgamlzb24tbGV4IDAuMy40ICovXG52YXIgbGV4ZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBsZXhlciA9ICh7XG5cbkVPRjoxLFxuXG5wYXJzZUVycm9yOmZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuc2V0SW5wdXQ6ZnVuY3Rpb24gKGlucHV0LCB5eSkge1xuICAgICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2JhY2t0cmFjayA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwwXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG5pbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbi8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbnVucHV0OmZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47XG4gICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHRoaXMueXlsbG9jLnJhbmdlO1xuXG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMClcbiAgICAgICAgICAgICAgICAgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgY2FjaGVzIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kcyBpdCBvbiBuZXh0IGFjdGlvblxubW9yZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgc2lnbmFscyB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGUgbmV4dCBtYXRjaGluZyBydWxlIChyZWdleCkgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxucmVqZWN0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbmxlc3M6ZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5wYXN0SW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGUgbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMgKyBcIl5cIjtcbiAgICB9LFxuXG4vLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW5cbnRlc3RfbWF0Y2g6ZnVuY3Rpb24gKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBiYWNrdXA7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgY29udGV4dFxuICAgICAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHl5bGxvYzoge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgICAgICAgIG1hdGNoOiB0aGlzLm1hdGNoLFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgICAgICAgeXlsZW5nOiB0aGlzLnl5bGVuZyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgICAgICAgIF9pbnB1dDogdGhpcy5faW5wdXQsXG4gICAgICAgICAgICAgICAgeXk6IHRoaXMueXksXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICAgICAgZG9uZTogdGhpcy5kb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBiYWNrdXAueXlsbG9jLnJhbmdlID0gdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IG1hdGNoWzBdLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggLSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5tYXRjaCgvXFxyP1xcbj8vKVswXS5sZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIGluZGV4ZWRfcnVsZSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAvLyByZWNvdmVyIGNvbnRleHRcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYmFja3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIHRoZSBuZXh0IHJ1bGUgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxubmV4dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICB0ZW1wTWF0Y2gsXG4gICAgICAgICAgICBpbmRleDtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgICAgICB0aGlzLnl5dGV4dCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7XG4gICAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFVucmVjb2duaXplZCB0ZXh0LlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbmxleDpmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbmJlZ2luOmZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvbiBzdGFja1xucG9wU3RhdGU6ZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBwcm9kdWNlIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV0ucnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW1wiSU5JVElBTFwiXS5ydWxlcztcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXggYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLCBpZiBhdmFpbGFibGVcbnRvcFN0YXRlOmZ1bmN0aW9uIHRvcFN0YXRlKG4pIHtcbiAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG4gICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiSU5JVElBTFwiO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWxpYXMgZm9yIGJlZ2luKGNvbmRpdGlvbilcbnB1c2hTdGF0ZTpmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuc3RhdGVTdGFja1NpemU6ZnVuY3Rpb24gc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICB9LFxub3B0aW9uczoge30sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXkseXlfLCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsWVlfU1RBUlQpIHtcbnZhciBZWVNUQVRFPVlZX1NUQVJUO1xuc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbmNhc2UgMDovKiDot7Pov4fnqbrnmb3nrKYgKi9cbmJyZWFrO1xuY2FzZSAxOnJldHVybiAyNTtcbmJyZWFrO1xuY2FzZSAyOnJldHVybiA4O1xuYnJlYWs7XG5jYXNlIDM6cmV0dXJuIDg7XG5icmVhaztcbmNhc2UgNDpyZXR1cm4gMjE7XG5icmVhaztcbmNhc2UgNTpyZXR1cm4gMjU7XG5icmVhaztcbmNhc2UgNjpyZXR1cm4gMjc7XG5icmVhaztcbmNhc2UgNzpyZXR1cm4gMjk7XG5icmVhaztcbmNhc2UgODpyZXR1cm4gMjk7XG5icmVhaztcbmNhc2UgOTpyZXR1cm4gMjg7XG5icmVhaztcbmNhc2UgMTA6cmV0dXJuIDIxO1xuYnJlYWs7XG5jYXNlIDExOnJldHVybiAzNDtcbmJyZWFrO1xuY2FzZSAxMjpyZXR1cm4gMzQ7XG5icmVhaztcbmNhc2UgMTM6cmV0dXJuIDM2O1xuYnJlYWs7XG5jYXNlIDE0OnJldHVybiAzMTtcbmJyZWFrO1xuY2FzZSAxNTpcbmJyZWFrO1xuY2FzZSAxNjpyZXR1cm4gOTtcbmJyZWFrO1xuY2FzZSAxNzpyZXR1cm4gJyAnO1xuYnJlYWs7XG5jYXNlIDE4OnJldHVybiAzNTtcbmJyZWFrO1xuY2FzZSAxOTpyZXR1cm4gMzA7XG5icmVhaztcbmNhc2UgMjA6cmV0dXJuIDMyO1xuYnJlYWs7XG5jYXNlIDIxOnJldHVybiAzMztcbmJyZWFrO1xuY2FzZSAyMjpyZXR1cm4gMTg7XG5icmVhaztcbmNhc2UgMjM6cmV0dXJuIDE5O1xuYnJlYWs7XG5jYXNlIDI0OnJldHVybiAxNztcbmJyZWFrO1xuY2FzZSAyNTpyZXR1cm4gMTE7XG5icmVhaztcbmNhc2UgMjY6cmV0dXJuIDIwO1xuYnJlYWs7XG5jYXNlIDI3OnJldHVybiAxMjtcbmJyZWFrO1xuY2FzZSAyODpyZXR1cm4gMTM7XG5icmVhaztcbmNhc2UgMjk6cmV0dXJuIDE1O1xuYnJlYWs7XG5jYXNlIDMwOnJldHVybiAxNDtcbmJyZWFrO1xuY2FzZSAzMTpyZXR1cm4gMTY7XG5icmVhaztcbmNhc2UgMzI6cmV0dXJuICdcIic7XG5icmVhaztcbmNhc2UgMzM6cmV0dXJuIFwiJ1wiO1xuYnJlYWs7XG5jYXNlIDM0OnJldHVybiBcIiFcIjtcbmJyZWFrO1xuY2FzZSAzNTpyZXR1cm4gMTA7XG5icmVhaztcbmNhc2UgMzY6cmV0dXJuIDM3O1xuYnJlYWs7XG5jYXNlIDM3OnJldHVybiAzODtcbmJyZWFrO1xuY2FzZSAzODpyZXR1cm4gNTtcbmJyZWFrO1xufVxufSxcbnJ1bGVzOiBbL14oPzpcXHMrKS8sL14oPzonKFteXFxcXC9cXD9cXCpcXFtcXF1cXCEnXCJdKyknKD89WyFdKSkvLC9eKD86XCIoXFxcXFtcIl18W15cIl0pKlwiKS8sL14oPzonKFxcXFxbJ118W14nXSkqJykvLC9eKD86W0EtWmEtel17MSx9W0EtWmEtel8wLTlcXC5dKyg/PVsoXSkpLywvXig/OlteXFxcXC9cXD9cXCpcXFtcXF0nXCJcXCEsXFwpXSsoPz1bIV0pKS8sL14oPzpcXCRbQS1aYS16XStcXCRbMC05XSspLywvXig/OlxcJFtBLVphLXpdK1swLTldKykvLC9eKD86W0EtWmEtel0rXFwkWzAtOV0rKS8sL14oPzpbQS1aYS16XStbMC05XSspLywvXig/OltBLVphLXpcXC5dKyg/PVsoXSkpLywvXig/OltBLVphLXpdezEsfVtBLVphLXpfMC05XSspLywvXig/OltBLVphLXpfXSspLywvXig/OlswLTldKykvLC9eKD86XFxbKC4qKT9cXF0pLywvXig/OlxcJCkvLC9eKD86JikvLC9eKD86ICkvLC9eKD86Wy5dKS8sL14oPzo6KS8sL14oPzo7KS8sL14oPzosKS8sL14oPzpcXCopLywvXig/OlxcLykvLC9eKD86LSkvLC9eKD86XFwrKS8sL14oPzpcXF4pLywvXig/OlxcKCkvLC9eKD86XFwpKS8sL14oPzo+KS8sL14oPzo8KS8sL14oPzpOT1RcXGIpLywvXig/OlwiKS8sL14oPzonKS8sL14oPzohKS8sL14oPzo9KS8sL14oPzolKS8sL14oPzpbI10pLywvXig/OiQpL10sXG5jb25kaXRpb25zOiB7XCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOF0sXCJpbmNsdXNpdmVcIjp0cnVlfX1cbn0pO1xucmV0dXJuIGxleGVyO1xufSkoKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO1xuXG5leHBvcnQgdmFyIFBhcnNlciA9IGdyYW1tYXIuUGFyc2VyO1xuIiwiaW1wb3J0IHt0b051bWJlcn0gZnJvbSAnLi8uLi91dGlscyc7XG5pbXBvcnQge0VSUk9SX1ZBTFVFfSBmcm9tICcuLy4uL2Vycm9yJztcblxuZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICcrJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhmaXJzdCwgLi4ucmVzdCkge1xuICBjb25zdCByZXN1bHQgPSByZXN0LnJlZHVjZSgoYWNjLCB2YWx1ZSkgPT4gYWNjICsgdG9OdW1iZXIodmFsdWUpLCB0b051bWJlcihmaXJzdCkpO1xuXG4gIGlmIChOdW1iZXIuaXNOYU4ocmVzdWx0KSkge1xuICAgIHRocm93IEVycm9yKEVSUk9SX1ZBTFVFKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImV4cG9ydCBjb25zdCBTWU1CT0wgPSAnJic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoLi4ucGFyYW1zKSB7XG4gIHJldHVybiBwYXJhbXMucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgKyB2YWx1ZS50b1N0cmluZygpLCAnJyk7XG59O1xuXG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImltcG9ydCB7dG9OdW1iZXJ9IGZyb20gJy4vLi4vdXRpbHMnO1xuaW1wb3J0IHtFUlJPUl9ESVZfWkVSTywgRVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJy8nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGZpcnN0LCAuLi5yZXN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlc3QucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgLyB0b051bWJlcih2YWx1ZSksIHRvTnVtYmVyKGZpcnN0KSk7XG5cbiAgaWYgKHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9ESVZfWkVSTyk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihyZXN1bHQpKSB7XG4gICAgdGhyb3cgRXJyb3IoRVJST1JfVkFMVUUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICc9JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhleHAxLCBleHAyKSB7XG4gIHJldHVybiBleHAxID09PSBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCIvKipcbiAqIEV4Y2VsIOWFrOW8j+S4reeahOWHveaVsO+8jOeUsSBmb3JtdWxhanMg5a6e546w44CCXG4gKlxuICovXG5cbmltcG9ydCBTVVBQT1JURURfRk9STVVMQVMgZnJvbSAnLi8uLi9zdXBwb3J0ZWQtZm9ybXVsYXMnO1xuaW1wb3J0IHtFUlJPUl9OQU1FfSBmcm9tICcuLy4uL2Vycm9yJztcbmltcG9ydCAqIGFzIGZvcm11bGFqcyBmcm9tICdmb3JtdWxhanMnO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gU1VQUE9SVEVEX0ZPUk1VTEFTO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKHN5bWJvbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4ucGFyYW1zKSB7XG4gICAgICAgIHN5bWJvbCA9IHN5bWJvbC50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGNvbnN0IHN5bWJvbFBhcnRzID0gc3ltYm9sLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBmb3VuZEZvcm11bGEgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICBpZiAoc3ltYm9sUGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoZm9ybXVsYWpzW3N5bWJvbFBhcnRzWzBdXSkge1xuICAgICAgICAgICAgICAgIGZvdW5kRm9ybXVsYSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm9ybXVsYWpzW3N5bWJvbFBhcnRzWzBdXSguLi5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gc3ltYm9sUGFydHMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBuZXN0ZWRGb3JtdWxhID0gZm9ybXVsYWpzO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRGb3JtdWxhID0gbmVzdGVkRm9ybXVsYVtzeW1ib2xQYXJ0c1tpbmRleF1dO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5lc3RlZEZvcm11bGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkRm9ybXVsYSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXN0ZWRGb3JtdWxhKSB7XG4gICAgICAgICAgICAgICAgZm91bmRGb3JtdWxhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXN0ZWRGb3JtdWxhKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kRm9ybXVsYSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoRVJST1JfTkFNRSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG5mdW5jLmlzRmFjdG9yeSA9IHRydWU7XG5mdW5jLlNZTUJPTCA9IFNZTUJPTDtcbiIsImV4cG9ydCBjb25zdCBTWU1CT0wgPSAnPj0nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgcmV0dXJuIGV4cDEgPj0gZXhwMjtcbn07XG5cbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICc+JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhleHAxLCBleHAyKSB7XG4gIHJldHVybiBleHAxID4gZXhwMjtcbn07XG5cbmZ1bmMuU1lNQk9MID0gU1lNQk9MO1xuIiwiZXhwb3J0IGNvbnN0IFNZTUJPTCA9ICc8PSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMoZXhwMSwgZXhwMikge1xuICByZXR1cm4gZXhwMSA8PSBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJleHBvcnQgY29uc3QgU1lNQk9MID0gJzwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgcmV0dXJuIGV4cDEgPCBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJpbXBvcnQge3RvTnVtYmVyfSBmcm9tICcuLy4uL3V0aWxzJztcbmltcG9ydCB7RVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJy0nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGZpcnN0LCAuLi5yZXN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlc3QucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgLSB0b051bWJlcih2YWx1ZSksIHRvTnVtYmVyKGZpcnN0KSk7XG5cbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9WQUxVRSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJpbXBvcnQge3RvTnVtYmVyfSBmcm9tICcuLy4uL3V0aWxzJztcbmltcG9ydCB7RVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJyonO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGZpcnN0LCAuLi5yZXN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJlc3QucmVkdWNlKChhY2MsIHZhbHVlKSA9PiBhY2MgKiB0b051bWJlcih2YWx1ZSksIHRvTnVtYmVyKGZpcnN0KSk7XG5cbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9WQUxVRSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJleHBvcnQgY29uc3QgU1lNQk9MID0gJzw+JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZnVuYyhleHAxLCBleHAyKSB7XG4gIHJldHVybiBleHAxICE9PSBleHAyO1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJpbXBvcnQge3RvTnVtYmVyfSBmcm9tICcuLy4uL3V0aWxzJztcbmltcG9ydCB7RVJST1JfVkFMVUV9IGZyb20gJy4vLi4vZXJyb3InO1xuXG5leHBvcnQgY29uc3QgU1lNQk9MID0gJ14nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmdW5jKGV4cDEsIGV4cDIpIHtcbiAgY29uc3QgcmVzdWx0ID0gTWF0aC5wb3codG9OdW1iZXIoZXhwMSksIHRvTnVtYmVyKGV4cDIpKTtcblxuICBpZiAoTnVtYmVyLmlzTmFOKHJlc3VsdCkpIHtcbiAgICB0aHJvdyBFcnJvcihFUlJPUl9WQUxVRSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuYy5TWU1CT0wgPSBTWU1CT0w7XG4iLCJpbXBvcnQge2RlZmF1bHQgYXMgYWRkfSBmcm9tICcuL29wZXJhdG9yL2FkZCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgYW1wZXJzYW5kfSBmcm9tICcuL29wZXJhdG9yL2FtcGVyc2FuZCc7XG4vLyBpbXBvcnQge2RlZmF1bHQgYXMgY3Jvc3NTaGVldH0gZnJvbSAnLi9vcGVyYXRvci9jcm9zcy1zaGVldCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgZGl2aWRlfSBmcm9tICcuL29wZXJhdG9yL2RpdmlkZSc7XG5pbXBvcnQge2RlZmF1bHQgYXMgZXF1YWx9IGZyb20gJy4vb3BlcmF0b3IvZXF1YWwnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGZvcm11bGFGdW5jdGlvbn0gZnJvbSAnLi9vcGVyYXRvci9mb3JtdWxhLWZ1bmN0aW9uJztcbmltcG9ydCB7ZGVmYXVsdCBhcyBncmVhdGVyVGhhbn0gZnJvbSAnLi9vcGVyYXRvci9ncmVhdGVyLXRoYW4nO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGdyZWF0ZXJUaGFuT3JFcXVhbH0gZnJvbSAnLi9vcGVyYXRvci9ncmVhdGVyLXRoYW4tb3ItZXF1YWwnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGxlc3NUaGFufSBmcm9tICcuL29wZXJhdG9yL2xlc3MtdGhhbic7XG5pbXBvcnQge2RlZmF1bHQgYXMgbGVzc1RoYW5PckVxdWFsfSBmcm9tICcuL29wZXJhdG9yL2xlc3MtdGhhbi1vci1lcXVhbCc7XG5pbXBvcnQge2RlZmF1bHQgYXMgbWludXN9IGZyb20gJy4vb3BlcmF0b3IvbWludXMnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIG11bHRpcGx5fSBmcm9tICcuL29wZXJhdG9yL211bHRpcGx5JztcbmltcG9ydCB7ZGVmYXVsdCBhcyBub3RFcXVhbH0gZnJvbSAnLi9vcGVyYXRvci9ub3QtZXF1YWwnO1xuaW1wb3J0IHtkZWZhdWx0IGFzIHBvd2VyfSBmcm9tICcuL29wZXJhdG9yL3Bvd2VyJztcbmltcG9ydCB7RVJST1JfTkFNRX0gZnJvbSAnLi9lcnJvcic7XG5cbmNvbnN0IGF2YWlsYWJsZU9wZXJhdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbnJlZ2lzdGVyT3BlcmF0aW9uKGFkZC5TWU1CT0wsIGFkZCk7XG5yZWdpc3Rlck9wZXJhdGlvbihhbXBlcnNhbmQuU1lNQk9MLCBhbXBlcnNhbmQpO1xuLy8gcmVnaXN0ZXJPcGVyYXRpb24oY3Jvc3NTaGVldC5TWU1CT0wsIGNyb3NzU2hlZXQpO1xucmVnaXN0ZXJPcGVyYXRpb24oZGl2aWRlLlNZTUJPTCwgZGl2aWRlKTtcbnJlZ2lzdGVyT3BlcmF0aW9uKGVxdWFsLlNZTUJPTCwgZXF1YWwpO1xucmVnaXN0ZXJPcGVyYXRpb24ocG93ZXIuU1lNQk9MLCBwb3dlcik7XG5yZWdpc3Rlck9wZXJhdGlvbihmb3JtdWxhRnVuY3Rpb24uU1lNQk9MLCBmb3JtdWxhRnVuY3Rpb24pO1xucmVnaXN0ZXJPcGVyYXRpb24oZ3JlYXRlclRoYW4uU1lNQk9MLCBncmVhdGVyVGhhbik7XG5yZWdpc3Rlck9wZXJhdGlvbihncmVhdGVyVGhhbk9yRXF1YWwuU1lNQk9MLCBncmVhdGVyVGhhbk9yRXF1YWwpO1xucmVnaXN0ZXJPcGVyYXRpb24obGVzc1RoYW4uU1lNQk9MLCBsZXNzVGhhbik7XG5yZWdpc3Rlck9wZXJhdGlvbihsZXNzVGhhbk9yRXF1YWwuU1lNQk9MLCBsZXNzVGhhbk9yRXF1YWwpO1xucmVnaXN0ZXJPcGVyYXRpb24obXVsdGlwbHkuU1lNQk9MLCBtdWx0aXBseSk7XG5yZWdpc3Rlck9wZXJhdGlvbihub3RFcXVhbC5TWU1CT0wsIG5vdEVxdWFsKTtcbnJlZ2lzdGVyT3BlcmF0aW9uKG1pbnVzLlNZTUJPTCwgbWludXMpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBldmFsdWF0ZUJ5T3BlcmF0b3Iob3BlcmF0b3IsIHBhcmFtcyA9IFtdKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKCFhdmFpbGFibGVPcGVyYXRvcnNbb3BlcmF0b3JdKSB7XG4gICAgICAgIHRocm93IEVycm9yKEVSUk9SX05BTUUpO1xuICAgIH1cbiAgICByZXR1cm4gYXZhaWxhYmxlT3BlcmF0b3JzW29wZXJhdG9yXSguLi5wYXJhbXMpO1xufVxuXG4vKipcbiAqIOazqOWGjFxuICogQHBhcmFtIHN5bWJvbFxuICogQHBhcmFtIGZ1bmNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyT3BlcmF0aW9uKHN5bWJvbCwgZnVuYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzeW1ib2wpKSB7XG4gICAgICAgIHN5bWJvbCA9IFtzeW1ib2wudG9VcHBlckNhc2UoKV07XG4gICAgfVxuICAgIHN5bWJvbC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIGlmIChmdW5jLmlzRmFjdG9yeSkge1xuICAgICAgICAgICAgYXZhaWxhYmxlT3BlcmF0b3JzW3NdID0gZnVuYyhzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF2YWlsYWJsZU9wZXJhdG9yc1tzXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsIi8qKlxuICog5YWs5byP6Kej5p6Q5Zmo44CCXG4gKiDlupXlsYLnmoTor63ms5Xop6PmnpDlmajkvb/nlKggamlzb24g55Sf5oiQ77yM5Y+C6KeBIGh0dHA6Ly96YWEuY2gvamlzb24vXG4gKlxuICog5rOo5oSPOiBqaXNvbiDnlJ/miJDnmoTku6PnoIHkvb/nlKggQU1EIOaWueW8j+WvvOWHuuWPmOmHj++8jOmHjeaWsOeUn+aIkOWQjuiusOW+l+aUueaIkCBFUzYg55qE5pa55byPOlxuICogICAgICBgZXhwb3J0IHZhciBQYXJzZXIgPSBncmFtbWFyLlBhcnNlcjtgXG4gKlxuICogQGNsYXNzIFBhcnNlclxuICogQGZpcmVzIFBhcnNlciNjYWxsVmFyaWFibGVcbiAqIEBmaXJlcyBQYXJzZXIjY2FsbENlbGxWYWx1ZVxuICogQGZpcmVzIFBhcnNlciNjYWxsUmFuZ2VWYWx1ZVxuICovXG5cbmltcG9ydCBFbWl0dGVyIGZyb20gJy4uLy4uLy4uL3V0aWxzL0VtaXR0ZXInO1xuaW1wb3J0IGV2YWx1YXRlQnlPcGVyYXRvciBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQge1BhcnNlciBhcyBHcmFtbWFyUGFyc2VyfSBmcm9tICcuL2dyYW1tYXInO1xuaW1wb3J0IHt0cmltRWRnZXMsIHRvTnVtYmVyLCBpbnZlcnROdW1iZXIsIGV4dHJhY3RMYWJlbCwgdG9MYWJlbH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2RlZmF1bHQgYXMgZXJyb3JQYXJzZXIsIEVSUk9SLCBFUlJPUl9OQU1FfSBmcm9tICcuL2Vycm9yJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTVVBQT1JURURfRk9STVVMQVN9IGZyb20gJy4vc3VwcG9ydGVkLWZvcm11bGFzJztcblxuY2xhc3MgUGFyc2VyIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gbmV3IEdyYW1tYXJQYXJzZXIoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIueXkgPSB7XG4gICAgICAgICAgICB0b051bWJlcixcbiAgICAgICAgICAgIHRyaW1FZGdlcyxcbiAgICAgICAgICAgIGludmVydE51bWJlcixcbiAgICAgICAgICAgIHRocm93RXJyb3I6IChlcnJvck5hbWUpID0+IFBhcnNlci5fdGhyb3dFcnJvcihlcnJvck5hbWUpLFxuICAgICAgICAgICAgY2FsbFZhcmlhYmxlOiAodmFyaWFibGUpID0+IHRoaXMuX2NhbGxWYXJpYWJsZSh2YXJpYWJsZSksXG4gICAgICAgICAgICBldmFsdWF0ZUJ5T3BlcmF0b3IsXG4gICAgICAgICAgICBjYWxsRnVuY3Rpb246IGV2YWx1YXRlQnlPcGVyYXRvcixcbiAgICAgICAgICAgIGNlbGxWYWx1ZTogKHZhbHVlKSA9PiB0aGlzLl9jYWxsQ2VsbFZhbHVlKHZhbHVlKSxcbiAgICAgICAgICAgIHJhbmdlVmFsdWU6IChzdGFydCwgZW5kKSA9PiB0aGlzLl9jYWxsUmFuZ2VWYWx1ZShzdGFydCwgZW5kKSxcbiAgICAgICAgICAgIGNlbGxWYWx1ZUluU2hlZXQ6IChzaGVldE5hbWUsIHZhbHVlKSA9PiB0aGlzLl9jYWxsQ2VsbFZhbHVlSW5TaGVldChzaGVldE5hbWUsIHZhbHVlKSxcbiAgICAgICAgICAgIHJhbmdlVmFsdWVJblNoZWV0OiAoc2hlZXROYW1lLCBzdGFydCwgZW5kKSA9PiB0aGlzLl9jYWxsUmFuZ2VWYWx1ZUluU2hlZXQoc2hlZXROYW1lLCBzdGFydCwgZW5kKSxcbiAgICAgICAgICAgIHBhcnNlRXJyb3I6ICguLi5hcmdzKSA9PiBQYXJzZXIuX3BhcnNlRXJyb3IoLi4uYXJncylcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIHRoaXMuc2V0VmFyaWFibGUoJ1RSVUUnLCB0cnVlKVxuICAgICAgICAgICAgLnNldFZhcmlhYmxlKCdGQUxTRScsIGZhbHNlKVxuICAgICAgICAgICAgLnNldFZhcmlhYmxlKCdOVUxMJywgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6Kej5p6Q6KGo6L6+5byPXG4gICAgICogQHBhcmFtIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJucyB7e2Vycm9yOiAqLCByZXN1bHQ6ICp9fVxuICAgICAqL1xuICAgIHBhcnNlKGV4cHJlc3Npb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGxldCBlcnJvciA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VyLnBhcnNlKGV4cHJlc3Npb24pO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yUGFyc2VyKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyb3JQYXJzZXIoRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycm9yUGFyc2VyKHJlc3VsdC5tZXNzYWdlKSB8fCBlcnJvclBhcnNlcihFUlJPUik7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u5Y+Y6YePXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7UGFyc2VyfVxuICAgICAqL1xuICAgIHNldFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFyaWFibGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiwg+eUqOWPmOmHj+WAvFxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsbFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRWYXJpYWJsZShuYW1lKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxWYXJpYWJsZScsIG5hbWUsIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoRVJST1JfTkFNRSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6LCD55So5Y2V5YWD5qC855qE5YC8XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0g5L6L5aaCIGBCM2AsIGBCJDNgLCBgQiQzYCwgYCRCJDNgXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsbENlbGxWYWx1ZShsYWJlbCkge1xuICAgICAgICBjb25zdCBbcm93LCBjb2x1bW5dID0gZXh0cmFjdExhYmVsKGxhYmVsKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdm9pZCAwO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbENlbGxWYWx1ZScsIHtsYWJlbCwgcm93LCBjb2x1bW59LCAoX3ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiwg+eUqOaMh+WumiBzaGVldCDkuK3ljZXlhYPmoLznmoTlgLxcbiAgICAgKiBAcGFyYW0gc2hlZXROYW1lXG4gICAgICogQHBhcmFtIGxhYmVsXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsbENlbGxWYWx1ZUluU2hlZXQoc2hlZXROYW1lLCBsYWJlbCkge1xuICAgICAgICBjb25zdCBbcm93LCBjb2x1bW5dID0gZXh0cmFjdExhYmVsKGxhYmVsKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdm9pZCAwO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbENlbGxWYWx1ZUluU2hlZXQnLCB7c2hlZXROYW1lLCBsYWJlbCwgcm93LCBjb2x1bW59LCAoX3ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2V4cGxhaW5DZWxsKHN0YXJ0TGFiZWwsIGVuZExhYmVsKSB7XG4gICAgICAgIGNvbnN0IFtzdGFydFJvdywgc3RhcnRDb2x1bW5dID0gZXh0cmFjdExhYmVsKHN0YXJ0TGFiZWwpO1xuICAgICAgICBjb25zdCBbZW5kUm93LCBlbmRDb2x1bW5dID0gZXh0cmFjdExhYmVsKGVuZExhYmVsKTtcbiAgICAgICAgbGV0IHN0YXJ0Q2VsbCA9IHt9O1xuICAgICAgICBsZXQgZW5kQ2VsbCA9IHt9O1xuXG4gICAgICAgIGlmIChzdGFydFJvdy5pbmRleCA8PSBlbmRSb3cuaW5kZXgpIHtcbiAgICAgICAgICAgIHN0YXJ0Q2VsbC5yb3cgPSBzdGFydFJvdztcbiAgICAgICAgICAgIGVuZENlbGwucm93ID0gZW5kUm93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRDZWxsLnJvdyA9IGVuZFJvdztcbiAgICAgICAgICAgIGVuZENlbGwucm93ID0gc3RhcnRSb3c7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRDb2x1bW4uaW5kZXggPD0gZW5kQ29sdW1uLmluZGV4KSB7XG4gICAgICAgICAgICBzdGFydENlbGwuY29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgICAgICBlbmRDZWxsLmNvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Q2VsbC5jb2x1bW4gPSBlbmRDb2x1bW47XG4gICAgICAgICAgICBlbmRDZWxsLmNvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRDZWxsLmxhYmVsID0gdG9MYWJlbChzdGFydENlbGwucm93LCBzdGFydENlbGwuY29sdW1uKTtcbiAgICAgICAgZW5kQ2VsbC5sYWJlbCA9IHRvTGFiZWwoZW5kQ2VsbC5yb3csIGVuZENlbGwuY29sdW1uKTtcbiAgICAgICAgcmV0dXJuIHtzdGFydENlbGwsIGVuZENlbGx9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiwg+eUqOafkOiMg+WbtOeahOWNleWFg+agvOWAvO+8jOWmgiBgQjM6QTFgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0TGFiZWwgLSDotbflp4vmoIfnrb7vvIzlpoIgYEIzYFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRMYWJlbCAtIOe7k+adn+agh+etvu+8jOWmgiBgQTFgXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGxSYW5nZVZhbHVlKHN0YXJ0TGFiZWwsIGVuZExhYmVsKSB7XG4gICAgICAgIHZhciB7c3RhcnRDZWxsLCBlbmRDZWxsfSA9IFBhcnNlci5fZXhwbGFpbkNlbGwoc3RhcnRMYWJlbCwgZW5kTGFiZWwpO1xuICAgICAgICBsZXQgdmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5lbWl0KCdjYWxsUmFuZ2VWYWx1ZScsIHN0YXJ0Q2VsbCwgZW5kQ2VsbCwgKF92YWx1ZSA9IFtdKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDosIPnlKjmjIflrpogc2hlZXQg5Lit5p+Q6IyD5Zu055qE5Y2V5YWD5qC85YC877yM5aaCIGDlt6XkvZzooagxIUIzOkExYFxuICAgICAqIEBwYXJhbSBzaGVldE5hbWVcbiAgICAgKiBAcGFyYW0gc3RhcnRMYWJlbFxuICAgICAqIEBwYXJhbSBlbmRMYWJlbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxsUmFuZ2VWYWx1ZUluU2hlZXQoc2hlZXROYW1lLCBzdGFydExhYmVsLCBlbmRMYWJlbCkge1xuICAgICAgICB2YXIge3N0YXJ0Q2VsbCwgZW5kQ2VsbH0gPSBQYXJzZXIuX2V4cGxhaW5DZWxsKHN0YXJ0TGFiZWwsIGVuZExhYmVsKTtcbiAgICAgICAgbGV0IHZhbHVlID0gW107XG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbFJhbmdlVmFsdWVJblNoZWV0Jywgc2hlZXROYW1lLCBzdGFydENlbGwsIGVuZENlbGwsIChfdmFsdWUgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JOYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3Rocm93RXJyb3IoZXJyb3JOYW1lKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEVycm9yID0gZXJyb3JQYXJzZXIoZXJyb3JOYW1lKTtcbiAgICAgICAgaWYgKHBhcnNlZEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihwYXJzZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yTmFtZTtcbiAgICB9XG5cblxuICAgIC8vIFRPRE8g6Kej5p6Q5aSx6LSl5pe277yM57uZ55So5oi35o+Q5L6b5ZCI6YCC55qE6ZSZ6K+v5L+h5oGv44CCXG4gICAgc3RhdGljIF9wYXJzZUVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coYXJncyk7XG4gICAgfVxufVxuXG5leHBvcnQge1BhcnNlcn07XG4iLCJjb25zdCBTVVBQT1JURURfRk9STVVMQVMgPSBbXG4gICdBQlMnLFxuICAnQUNDUklOVCcsXG4gICdBQ09TJyxcbiAgJ0FDT1NIJyxcbiAgJ0FDT1QnLFxuICAnQUNPVEgnLFxuICAnQUREJyxcbiAgJ0FHR1JFR0FURScsXG4gICdBTkQnLFxuICAnQVJBQklDJyxcbiAgJ0FSR1MyQVJSQVknLFxuICAnQVNJTicsXG4gICdBU0lOSCcsXG4gICdBVEFOJyxcbiAgJ0FUQU4yJyxcbiAgJ0FUQU5IJyxcbiAgJ0FWRURFVicsXG4gICdBVkVSQUdFJyxcbiAgJ0FWRVJBR0VBJyxcbiAgJ0FWRVJBR0VJRicsXG4gICdBVkVSQUdFSUZTJyxcbiAgJ0JBU0UnLFxuICAnQkVTU0VMSScsXG4gICdCRVNTRUxKJyxcbiAgJ0JFU1NFTEsnLFxuICAnQkVTU0VMWScsXG4gICdCRVRBLkRJU1QnLFxuICAnQkVUQS5JTlYnLFxuICAnQkVUQURJU1QnLFxuICAnQkVUQUlOVicsXG4gICdCSU4yREVDJyxcbiAgJ0JJTjJIRVgnLFxuICAnQklOMk9DVCcsXG4gICdCSU5PTS5ESVNUJyxcbiAgJ0JJTk9NLkRJU1QuUkFOR0UnLFxuICAnQklOT00uSU5WJyxcbiAgJ0JJTk9NRElTVCcsXG4gICdCSVRBTkQnLFxuICAnQklUTFNISUZUJyxcbiAgJ0JJVE9SJyxcbiAgJ0JJVFJTSElGVCcsXG4gICdCSVRYT1InLFxuICAnQ0VJTElORycsXG4gICdDRUlMSU5HTUFUSCcsXG4gICdDRUlMSU5HUFJFQ0lTRScsXG4gICdDSEFSJyxcbiAgJ0NISVNRLkRJU1QnLFxuICAnQ0hJU1EuRElTVC5SVCcsXG4gICdDSElTUS5JTlYnLFxuICAnQ0hJU1EuSU5WLlJUJyxcbiAgJ0NIT09TRScsXG4gICdDSE9PU0UnLFxuICAnQ0xFQU4nLFxuICAnQ09ERScsXG4gICdDT0xVTU4nLFxuICAnQ09MVU1OUycsXG4gICdDT01CSU4nLFxuICAnQ09NQklOQScsXG4gICdDT01QTEVYJyxcbiAgJ0NPTkNBVEVOQVRFJyxcbiAgJ0NPTkZJREVOQ0UnLFxuICAnQ09ORklERU5DRS5OT1JNJyxcbiAgJ0NPTkZJREVOQ0UuVCcsXG4gICdDT05WRVJUJyxcbiAgJ0NPUlJFTCcsXG4gICdDT1MnLFxuICAnQ09TSCcsXG4gICdDT1QnLFxuICAnQ09USCcsXG4gICdDT1VOVCcsXG4gICdDT1VOVEEnLFxuICAnQ09VTlRCTEFOSycsXG4gICdDT1VOVElGJyxcbiAgJ0NPVU5USUZTJyxcbiAgJ0NPVU5USU4nLFxuICAnQ09VTlRVTklRVUUnLFxuICAnQ09WQVJJQU5DRS5QJyxcbiAgJ0NPVkFSSUFOQ0UuUycsXG4gICdDU0MnLFxuICAnQ1NDSCcsXG4gICdDVU1JUE1UJyxcbiAgJ0NVTVBSSU5DJyxcbiAgJ0RBVEUnLFxuICAnREFURVZBTFVFJyxcbiAgJ0RBWScsXG4gICdEQVlTJyxcbiAgJ0RBWVMzNjAnLFxuICAnREInLFxuICAnRERCJyxcbiAgJ0RFQzJCSU4nLFxuICAnREVDMkhFWCcsXG4gICdERUMyT0NUJyxcbiAgJ0RFQ0lNQUwnLFxuICAnREVHUkVFUycsXG4gICdERUxUQScsXG4gICdERVZTUScsXG4gICdESVZJREUnLFxuICAnRE9MTEFSJyxcbiAgJ0RPTExBUkRFJyxcbiAgJ0RPTExBUkZSJyxcbiAgJ0UnLFxuICAnRURBVEUnLFxuICAnRUZGRUNUJyxcbiAgJ0VPTU9OVEgnLFxuICAnRVEnLFxuICAnRVJGJyxcbiAgJ0VSRkMnLFxuICAnRVZFTicsXG4gICdFWEFDVCcsXG4gICdFWFBPTi5ESVNUJyxcbiAgJ0VYUE9ORElTVCcsXG4gICdGLkRJU1QnLFxuICAnRi5ESVNULlJUJyxcbiAgJ0YuSU5WJyxcbiAgJ0YuSU5WLlJUJyxcbiAgJ0ZBQ1QnLFxuICAnRkFDVERPVUJMRScsXG4gICdGQUxTRScsXG4gICdGRElTVCcsXG4gICdGRElTVFJUJyxcbiAgJ0ZJTkQnLFxuICAnRklOVicsXG4gICdGSU5WUlQnLFxuICAnRklTSEVSJyxcbiAgJ0ZJU0hFUklOVicsXG4gICdGSVhFRCcsXG4gICdGTEFUVEVOJyxcbiAgJ0ZMT09SJyxcbiAgJ0ZPUkVDQVNUJyxcbiAgJ0ZSRVFVRU5DWScsXG4gICdGVicsXG4gICdGVlNDSEVEVUxFJyxcbiAgJ0dBTU1BJyxcbiAgJ0dBTU1BLkRJU1QnLFxuICAnR0FNTUEuSU5WJyxcbiAgJ0dBTU1BRElTVCcsXG4gICdHQU1NQUlOVicsXG4gICdHQU1NQUxOJyxcbiAgJ0dBTU1BTE4uUFJFQ0lTRScsXG4gICdHQVVTUycsXG4gICdHQ0QnLFxuICAnR0VPTUVBTicsXG4gICdHRVNURVAnLFxuICAnR1JPV1RIJyxcbiAgJ0dURScsXG4gICdIQVJNRUFOJyxcbiAgJ0hFWDJCSU4nLFxuICAnSEVYMkRFQycsXG4gICdIRVgyT0NUJyxcbiAgJ0hPVVInLFxuICAnSFRNTDJURVhUJyxcbiAgJ0hZUEdFT00uRElTVCcsXG4gICdIWVBHRU9NRElTVCcsXG4gICdJRicsXG4gICdJTUFCUycsXG4gICdJTUFHSU5BUlknLFxuICAnSU1BUkdVTUVOVCcsXG4gICdJTUNPTkpVR0FURScsXG4gICdJTUNPUycsXG4gICdJTUNPU0gnLFxuICAnSU1DT1QnLFxuICAnSU1DU0MnLFxuICAnSU1DU0NIJyxcbiAgJ0lNRElWJyxcbiAgJ0lNRVhQJyxcbiAgJ0lNTE4nLFxuICAnSU1MT0cxMCcsXG4gICdJTUxPRzInLFxuICAnSU1QT1dFUicsXG4gICdJTVBST0RVQ1QnLFxuICAnSU1SRUFMJyxcbiAgJ0lNU0VDJyxcbiAgJ0lNU0VDSCcsXG4gICdJTVNJTicsXG4gICdJTVNJTkgnLFxuICAnSU1TUVJUJyxcbiAgJ0lNU1VCJyxcbiAgJ0lNU1VNJyxcbiAgJ0lNVEFOJyxcbiAgJ0lOVCcsXG4gICdJTlRFUkNFUFQnLFxuICAnSU5URVJWQUwnLFxuICAnSVBNVCcsXG4gICdJUlInLFxuICAnSVNCSU5BUlknLFxuICAnSVNCTEFOSycsXG4gICdJU0VWRU4nLFxuICAnSVNMT0dJQ0FMJyxcbiAgJ0lTTk9OVEVYVCcsXG4gICdJU05VTUJFUicsXG4gICdJU09ERCcsXG4gICdJU09ERCcsXG4gICdJU09XRUVLTlVNJyxcbiAgJ0lTUE1UJyxcbiAgJ0lTVEVYVCcsXG4gICdKT0lOJyxcbiAgJ0tVUlQnLFxuICAnTEFSR0UnLFxuICAnTENNJyxcbiAgJ0xFRlQnLFxuICAnTEVOJyxcbiAgJ0xJTkVTVCcsXG4gICdMTicsXG4gICdMT0cnLFxuICAnTE9HMTAnLFxuICAnTE9HRVNUJyxcbiAgJ0xPR05PUk0uRElTVCcsXG4gICdMT0dOT1JNLklOVicsXG4gICdMT0dOT1JNRElTVCcsXG4gICdMT0dOT1JNSU5WJyxcbiAgJ0xPV0VSJyxcbiAgJ0xUJyxcbiAgJ0xURScsXG4gICdNQVRDSCcsXG4gICdNQVgnLFxuICAnTUFYQScsXG4gICdNRURJQU4nLFxuICAnTUlEJyxcbiAgJ01JTicsXG4gICdNSU5BJyxcbiAgJ01JTlVTJyxcbiAgJ01JTlVURScsXG4gICdNSVJSJyxcbiAgJ01PRCcsXG4gICdNT0RFLk1VTFQnLFxuICAnTU9ERS5TTkdMJyxcbiAgJ01PREVNVUxUJyxcbiAgJ01PREVTTkdMJyxcbiAgJ01PTlRIJyxcbiAgJ01ST1VORCcsXG4gICdNVUxUSU5PTUlBTCcsXG4gICdNVUxUSVBMWScsXG4gICdORScsXG4gICdORUdCSU5PTS5ESVNUJyxcbiAgJ05FR0JJTk9NRElTVCcsXG4gICdORVRXT1JLREFZUycsXG4gICdOT01JTkFMJyxcbiAgJ05PUk0uRElTVCcsXG4gICdOT1JNLklOVicsXG4gICdOT1JNLlMuRElTVCcsXG4gICdOT1JNLlMuSU5WJyxcbiAgJ05PUk1ESVNUJyxcbiAgJ05PUk1JTlYnLFxuICAnTk9STVNESVNUJyxcbiAgJ05PUk1TSU5WJyxcbiAgJ05PVCcsXG4gICdOT1cnLFxuICAnTlBFUicsXG4gICdOUFYnLFxuICAnTlVNQkVSUycsXG4gICdOVU1FUkFMJyxcbiAgJ09DVDJCSU4nLFxuICAnT0NUMkRFQycsXG4gICdPQ1QySEVYJyxcbiAgJ09ERCcsXG4gICdPUicsXG4gICdQRFVSQVRJT04nLFxuICAnUEVBUlNPTicsXG4gICdQRVJDRU5USUxFRVhDJyxcbiAgJ1BFUkNFTlRJTEVJTkMnLFxuICAnUEVSQ0VOVFJBTktFWEMnLFxuICAnUEVSQ0VOVFJBTktJTkMnLFxuICAnUEVSTVVUJyxcbiAgJ1BFUk1VVEFUSU9OQScsXG4gICdQSEknLFxuICAnUEknLFxuICAnUE1UJyxcbiAgJ1BPSVNTT04uRElTVCcsXG4gICdQT0lTU09ORElTVCcsXG4gICdQT1cnLFxuICAnUE9XRVInLFxuICAnUFBNVCcsXG4gICdQUk9CJyxcbiAgJ1BST0RVQ1QnLFxuICAnUFJPUEVSJyxcbiAgJ1BWJyxcbiAgJ1FVQVJUSUxFLkVYQycsXG4gICdRVUFSVElMRS5JTkMnLFxuICAnUVVBUlRJTEVFWEMnLFxuICAnUVVBUlRJTEVJTkMnLFxuICAnUVVPVElFTlQnLFxuICAnUkFESUFOUycsXG4gICdSQU5EJyxcbiAgJ1JBTkRCRVRXRUVOJyxcbiAgJ1JBTksuQVZHJyxcbiAgJ1JBTksuRVEnLFxuICAnUkFOS0FWRycsXG4gICdSQU5LRVEnLFxuICAnUkFURScsXG4gICdSRUZFUkVOQ0UnLFxuICAnUkVHRVhFWFRSQUNUJyxcbiAgJ1JFR0VYTUFUQ0gnLFxuICAnUkVHRVhSRVBMQUNFJyxcbiAgJ1JFUExBQ0UnLFxuICAnUkVQVCcsXG4gICdSSUdIVCcsXG4gICdST01BTicsXG4gICdST1VORCcsXG4gICdST1VORERPV04nLFxuICAnUk9VTkRVUCcsXG4gICdST1cnLFxuICAnUk9XUycsXG4gICdSUkknLFxuICAnUlNRJyxcbiAgJ1NFQVJDSCcsXG4gICdTRUMnLFxuICAnU0VDSCcsXG4gICdTRUNPTkQnLFxuICAnU0VSSUVTU1VNJyxcbiAgJ1NJR04nLFxuICAnU0lOJyxcbiAgJ1NJTkgnLFxuICAnU0tFVycsXG4gICdTS0VXLlAnLFxuICAnU0tFV1AnLFxuICAnU0xOJyxcbiAgJ1NMT1BFJyxcbiAgJ1NNQUxMJyxcbiAgJ1NQTElUJyxcbiAgJ1NQTElUJyxcbiAgJ1NRUlQnLFxuICAnU1FSVFBJJyxcbiAgJ1NUQU5EQVJESVpFJyxcbiAgJ1NUREVWLlAnLFxuICAnU1RERVYuUycsXG4gICdTVERFVkEnLFxuICAnU1RERVZQJyxcbiAgJ1NUREVWUEEnLFxuICAnU1RERVZTJyxcbiAgJ1NURVlYJyxcbiAgJ1NVQlNUSVRVVEUnLFxuICAnU1VCVE9UQUwnLFxuICAnU1VNJyxcbiAgJ1NVTUlGJyxcbiAgJ1NVTUlGUycsXG4gICdTVU1QUk9EVUNUJyxcbiAgJ1NVTVNRJyxcbiAgJ1NVTVgyTVkyJyxcbiAgJ1NVTVgyUFkyJyxcbiAgJ1NVTVhNWTInLFxuICAnU1dJVENIJyxcbiAgJ1NZRCcsXG4gICdUJyxcbiAgJ1QuRElTVCcsXG4gICdULkRJU1QuMlQnLFxuICAnVC5ESVNULlJUJyxcbiAgJ1QuSU5WJyxcbiAgJ1QuSU5WLjJUJyxcbiAgJ1RBTicsXG4gICdUQU5IJyxcbiAgJ1RCSUxMRVEnLFxuICAnVEJJTExQUklDRScsXG4gICdUQklMTFlJRUxEJyxcbiAgJ1RESVNUJyxcbiAgJ1RESVNUMlQnLFxuICAnVERJU1RSVCcsXG4gICdURVhUJyxcbiAgJ1RJTUUnLFxuICAnVElNRVZBTFVFJyxcbiAgJ1RJTlYnLFxuICAnVElOVjJUJyxcbiAgJ1RPREFZJyxcbiAgJ1RSQU5TUE9TRScsXG4gICdUUkVORCcsXG4gICdUUklNJyxcbiAgJ1RSSU1NRUFOJyxcbiAgJ1RSVUUnLFxuICAnVFJVTkMnLFxuICAnVU5JQ0hBUicsXG4gICdVTklDT0RFJyxcbiAgJ1VOSVFVRScsXG4gICdVUFBFUicsXG4gICdWQUxVRScsXG4gICdWQVIuUCcsXG4gICdWQVIuUycsXG4gICdWQVJBJyxcbiAgJ1ZBUlAnLFxuICAnVkFSUEEnLFxuICAnVkFSUycsXG4gICdXRUVLREFZJyxcbiAgJ1dFRUtOVU0nLFxuICAnV0VJQlVMTC5ESVNUJyxcbiAgJ1dFSUJVTExESVNUJyxcbiAgJ1dPUktEQVknLFxuICAnWElSUicsXG4gICdYTlBWJyxcbiAgJ1hPUicsXG4gICdZRUFSJyxcbiAgJ1lFQVJGUkFDJ1xuXTtcblxuZXhwb3J0IHtTVVBQT1JURURfRk9STVVMQVMgYXMgZGVmYXVsdH07XG4iLCIvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKlxcXG4gKiAgICAgICAgICAgICAgICAgIOWNleWFg+agvOebuOWFs1xuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbmNvbnN0IExBQkVMX0VYVFJBQ1RfUkVHRVhQID0gL14oWyRdKT8oW0EtWmEtel0rKShbJF0pPyhbMC05XSspJC87XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0TGFiZWwobGFiZWwpIHtcbiAgICBpZiAoIUxBQkVMX0VYVFJBQ1RfUkVHRVhQLnRlc3QobGFiZWwpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgWywgY29sdW1uQWJzLCBjb2x1bW4sIHJvd0Ficywgcm93XSA9IGxhYmVsLm1hdGNoKExBQkVMX0VYVFJBQ1RfUkVHRVhQKTtcblxuICAgIHJldHVybiBbe1xuICAgICAgICBpbmRleDogcm93TGFiZWxUb0luZGV4KHJvdyksXG4gICAgICAgIGxhYmVsOiByb3csXG4gICAgICAgIGlzQWJzb2x1dGU6IHJvd0FicyA9PT0gJyQnXG4gICAgfSwge1xuICAgICAgICBpbmRleDogY29sdW1uTGFiZWxUb0luZGV4KGNvbHVtbiksXG4gICAgICAgIGxhYmVsOiBjb2x1bW4sXG4gICAgICAgIGlzQWJzb2x1dGU6IGNvbHVtbkFicyA9PT0gJyQnXG4gICAgfV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0xhYmVsKHJvdywgY29sdW1uKSB7XG4gICAgY29uc3Qgcm93TGFiZWwgPSAocm93LmlzQWJzb2x1dGUgPyAnJCcgOiAnJykgKyByb3dJbmRleFRvTGFiZWwocm93LmluZGV4KTtcbiAgICBjb25zdCBjb2x1bW5MYWJlbCA9IChjb2x1bW4uaXNBYnNvbHV0ZSA/ICckJyA6ICcnKSArIGNvbHVtbkluZGV4VG9MYWJlbChjb2x1bW4uaW5kZXgpO1xuICAgIHJldHVybiBjb2x1bW5MYWJlbCArIHJvd0xhYmVsO1xufVxuXG5jb25zdCBDT0xVTU5fTEFCRUxfQkFTRSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7XG5jb25zdCBDT0xVTU5fTEFCRUxfQkFTRV9MRU5HVEggPSBDT0xVTU5fTEFCRUxfQkFTRS5sZW5ndGg7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2x1bW5MYWJlbFRvSW5kZXgobGFiZWwpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGxhYmVsLmxlbmd0aCAtIDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkgKz0gMSwgaiAtPSAxKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5wb3coQ09MVU1OX0xBQkVMX0JBU0VfTEVOR1RILCBqKSAqIChDT0xVTU5fTEFCRUxfQkFTRS5pbmRleE9mKGxhYmVsW2ldKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC0tcmVzdWx0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY29sdW1uSW5kZXhUb0xhYmVsKGNvbHVtbikge1xuICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgIHdoaWxlIChjb2x1bW4gPj0gMCkge1xuICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvbHVtbiAlIENPTFVNTl9MQUJFTF9CQVNFX0xFTkdUSCArIDk3KSArIHJlc3VsdDtcbiAgICAgICAgY29sdW1uID0gTWF0aC5mbG9vcihjb2x1bW4gLyBDT0xVTU5fTEFCRUxfQkFTRV9MRU5HVEgpIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHJvd0xhYmVsVG9JbmRleChsYWJlbCkge1xuICAgIGxldCByZXN1bHQgPSBwYXJzZUludChsYWJlbCwgMTApO1xuXG4gICAgaWYgKE51bWJlci5pc05hTihyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgubWF4KHJlc3VsdCAtIDEsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvd0luZGV4VG9MYWJlbChyb3cpIHtcbiAgICByZXR1cm4gcm93ID49IDAgPyBgJHtyb3cgKyAxfWAgOiAnJztcbn1cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKlxcXG4gKiAgICAgICAgICAgICAgICAgIG51bWJlclxuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcihudW1iZXIpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSBudW1iZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbnVtYmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXN1bHQgPSBudW1iZXIuaW5kZXhPZignLicpID4gLTEgPyBwYXJzZUZsb2F0KG51bWJlcikgOiBwYXJzZUludChudW1iZXIsIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiDlj5botJ/mlbBcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnROdW1iZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIC0xICogdG9OdW1iZXIobnVtYmVyKTtcbn1cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKlxcXG4gKiAgICAgICAgICAgICAgICAgIHN0cmluZ1xuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmltRWRnZXMoc3RyaW5nLCBtYXJnaW4gPSAxKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZyhtYXJnaW4sIHN0cmluZy5sZW5ndGggLSBtYXJnaW4pO1xuICAgIHJldHVybiBzdHJpbmc7XG59IiwiXG4vKipcbiAqIENoZWNrIGlmIHByb3ZpZGVkIGV4cHJlc3Npb24gaXMgdmFsaWQgZm9ybXVsYSBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gZXhwcmVzc2lvbiBFeHByZXNzaW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Zvcm11bGFFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbiAmJiAoZXhwcmVzc2lvbiArICcnKS5jaGFyQXQoMCkgPT09ICc9JyA/IHRydWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwcm92aWRlZCBmb3JtdWxhIGV4cHJlc3Npb24gaXMgZXNjYXBlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV4cHJlc3Npb24gRXhwcmVzc2lvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGb3JtdWxhRXhwcmVzc2lvbkVzY2FwZWQoZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uICYmICgoZXhwcmVzc2lvbiArICcnKS5jaGFyQXQoMCkgPT09ICdcXCcnICYmICgoZXhwcmVzc2lvbiArICcnKS5jaGFyQXQoMSkgPT09ICc9JykpID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgZXNjYXBlZCBmb3JtdWxhIGV4cHJlc3Npb24gaW50byB2YWxpZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb24gRXhwcmVzc2lvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlRm9ybXVsYUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBpc0Zvcm11bGFFeHByZXNzaW9uRXNjYXBlZChleHByZXNzaW9uKSA/IGV4cHJlc3Npb24uc3Vic3RyKDEpIDogZXhwcmVzc2lvbjtcbn1cblxuLyoqXG4gKiBVcHBlciBjYXNlIGZvcm11bGEgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBGb3JtdWxhIGV4cHJlc3Npb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VcHBlckNhc2VGb3JtdWxhKGV4cHJlc3Npb24pIHtcbiAgICBjb25zdCBQQVRURVJOID0gLyhcXFxcXCJ8XCIoPzpcXFxcXCJ8W15cIl0pKlwifChcXCspKXwoXFxcXCd8Jyg/OlxcXFwnfFteJ10pKid8KFxcKykpL2c7XG4gICAgY29uc3Qgc3RyaW5ncyA9IGV4cHJlc3Npb24ubWF0Y2goUEFUVEVSTikgfHwgW107XG4gICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbi50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoUEFUVEVSTiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZ3NbaW5kZXhdO1xuICAgIH0pO1xufVxuIiwiLyoqXG4gKlxuICogQHBhcmFtIF9nIOWFqOWxgOWPmOmHj++8iOWNs+a1j+iniOWZqOeOr+Wig+S4i+eahCB3aW5kb3cg5a+56LGh77yJXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvbHlmaWxsKF9nKSB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZXM2IHBvbHlmaWxsXG5cbiAgICAvLyBOdW1iZXIuaXNOYU4oKVxuICAgIGlmICghX2cuTnVtYmVyLmlzTmFOKSB7XG4gICAgICAgIF9nLk51bWJlci5pc05hTiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCAhPT0geDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0cmluZy5jb250YWlucygpXG4gICAgaWYgKHR5cGVvZiBfZy5TdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZy5TdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuICEhfnRoaXMuaW5kZXhPZihzdHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RyaW5nLnN0YXJ0c1dpdGgoKVxuICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSB7XG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzdHIocG9zaXRpb24sIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSUUgcG9seWZpbGxcblxuICAgIC8vIEhUTUxFbGVtZW50LmNsYXNzTGlzdFxuICAgIGlmICghKCdjbGFzc0xpc3QnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2NsYXNzTGlzdCcsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNlbGYuY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm4oY2xhc3NlcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhZGQ6IHVwZGF0ZShmdW5jdGlvbiAoY2xhc3NlcywgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIX5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZTogdXBkYXRlKGZ1bmN0aW9uIChjbGFzc2VzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlOiB1cGRhdGUoZnVuY3Rpb24gKGNsYXNzZXMsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhfnNlbGYuY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbGFzc05hbWUuc3BsaXQoL1xccysvZylbaV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5cblxuXG5cbiIsIi8qKlxuICog5YWo5bGA6YWN572u44CCXG4gKi9cbnZhciBnbG9iYWxTZXR0aW5ncyA9IHtcbiAgICBpZFByZWZpeDogJ2JyaWNrLXNzZC0nLFxuICAgIGlkU3VmZml4NFdvcmtib29rOiAnLXdvcmtib29rJyxcblxuICAgIHNoZWV0OiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiHquWKqOeUn+aIkOW3peS9nOihqOWQjeensOaXtueahOWJjee8gCjlt6XkvZzooagxLCDlt6XkvZzooagyLi4uKVxuICAgICAgICAgKi9cbiAgICAgICAgYXV0b1ByZWZpeDogJ+W3peS9nOihqCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNoZWV0IOWQjeensOS4reeahOmdnuazleWtl+espuOAguW+rui9r+ayoeacieebuOWFs+aWh+aho++8jOS7peS4i+aYryBBcGFjaGUgUE9JIOeahOivtOaYju+8mlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgc2hlZXQgbmFtZSBpbiBFeGNlbCBtdXN0IG5vdCBleGNlZWQgMzEgY2hhcmFjdGVyc1xuICAgICAgICAgKiBhbmQgbXVzdCBub3QgY29udGFpbiBhbnkgb2YgdGhlIGFueSBvZiB0aGUgZm9sbG93aW5nIGNoYXJhY3RlcnM6XG4gICAgICAgICAqICAgIC0gMHgwMDAwXG4gICAgICAgICAqICAgIC0gMHgwMDAzXG4gICAgICAgICAqICAgIC0gY29sb24gKDopXG4gICAgICAgICAqICAgIC0gYmFja3NsYXNoIChcXClcbiAgICAgICAgICogICAgLSBhc3RlcmlzayAoKilcbiAgICAgICAgICogICAgLSBxdWVzdGlvbiBtYXJrICg/KVxuICAgICAgICAgKiAgICAtIGZvcndhcmQgc2xhc2ggKC8pXG4gICAgICAgICAqICAgIC0gb3BlbmluZyBzcXVhcmUgYnJhY2tldCAoWylcbiAgICAgICAgICogICAgLSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IChdKVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgc2hlZXROYW1lOiAvW1xcXFwvXFw/XFwqOlxcW1xcXSdcIl0vLFxuXG4gICAgICAgIGFuaW1hdGVkOiBmYWxzZVxuICAgIH1cblxufTtcblxuXG4vKipcbiAqIOm7mOiupOmFjee9rlxuICovXG52YXIgZGVmYXVsdFNldHRpbmdzID0ge1xuXG4gICAgd29ya2Jvb2s6IHtcbiAgICAgICAgYWN0aXZlU2hlZXQ6ICflt6XkvZzooagxJyxcbiAgICAgICAgc2hlZXRzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ+W3peS9nOihqDEnXG4gICAgICAgIH1dXG4gICAgfSxcblxuICAgIHBlcnNpc3RlbnQ6IHRydWVcblxufTtcblxuZXhwb3J0IHtnbG9iYWxTZXR0aW5ncywgZGVmYXVsdFNldHRpbmdzfTsiLCIvKipcbiAqIOS6i+S7tuWPkeWwhOWZqFxuICpcbiAqIFBTOiBub2RlanMg55qE57O757uf57G75bqTIEVtaXR0ZXIg6L+H5aSn77yM5LiN6YCC5ZCI5Zyo5rWP6KeI5Zmo546v5aKD5L2/55So44CC5pWF5byV5YWl5LiA5Liq566A5piT5a6e546w44CCXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICAvLyDkv53mjIHmraTlh73mlbDkuLrnqbrvvIzku6Xkvr/kuo7nu6fmib9cbn1cblxuRW1pdHRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiDorqLpmIXkuovku7ZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0g5LqL5Lu25Zue6LCD5Ye95pWwXG4gICAgICogQHBhcmFtIFtjdHhdIC0g6K6+572u6LCD55SoIGNhbGxiYWNrIOaXtueahOS4iuS4i+aWh1xuICAgICAqIEByZXR1cm5zIHtFbWl0dGVyfVxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuZSB8fCAodGhpcy5lID0ge30pO1xuXG4gICAgICAgIChlW25hbWVdIHx8IChlW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDorqLpmIXkuIDmrKHmgKfkuovku7ZcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIOS6i+S7tuWQjVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0g5LqL5Lu25Zue6LCD5Ye95pWwXG4gICAgICogQHBhcmFtIGN0eCAtIOiuvue9ruiwg+eUqCBjYWxsYmFjayDml7bnmoTkuIrkuIvmlodcbiAgICAgKiBAcmV0dXJucyB7KnxFbWl0dGVyfVxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIHNlbGYub2ZmKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVyLl8gPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgbGlzdGVuZXIsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOWPkeWwhOaMh+WumuS6i+S7tlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCNXG4gICAgICogQHJldHVybnMge0VtaXR0ZXJ9XG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciBldnRBcnIgPSAoKHRoaXMuZSB8fCAodGhpcy5lID0ge30pKVtuYW1lXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gZXZ0QXJyLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZXZ0QXJyW2ldLmZuLmFwcGx5KGV2dEFycltpXS5jdHgsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOazqOmUgOS6i+S7tlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g5LqL5Lu25ZCNXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSAtIOe7keWumuS6i+S7tuaXtueahOWbnuiwg+WHveaVsO+8jOWmguaenOS4jeaMh+WumuWImeazqOmUgOaJgOaciSBgbmFtZWAg5LqL5Lu2XG4gICAgICogQHJldHVybnMge0VtaXR0ZXJ9XG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcbiAgICAgICAgdmFyIGV2dHMgPSBlW25hbWVdO1xuICAgICAgICB2YXIgbGl2ZUV2ZW50cyA9IFtdO1xuXG4gICAgICAgIGlmIChldnRzICYmIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChldnRzW2ldLmZuICE9PSBjYWxsYmFjayAmJiBldnRzW2ldLmZuLl8gIT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpdmVFdmVudHMucHVzaChldnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyDpmLLmraLlhoXlrZjmuqLlh7pcbiAgICAgICAgKGxpdmVFdmVudHMubGVuZ3RoKVxuICAgICAgICAgICAgPyBlW25hbWVdID0gbGl2ZUV2ZW50c1xuICAgICAgICAgICAgOiBkZWxldGUgZVtuYW1lXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog6I635Y+W5YWo5bGA5ZSv5LiA5LqL5Lu25Y+R5bCE5ZmoXG4gICAgICovXG4gICAgZ2V0R2xvYmFsRW1pdHRlcjogIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBpbnN0YW5jZTtcbiAgICB9KCkpXG59O1xuXG5leHBvcnQgZGVmYXVsdCBFbWl0dGVyO1xuXG4vKipcbiAqIOWFqOWxgOWUr+S4gOS6i+S7tuWPkeWwhOWZqFxuICovXG5leHBvcnQgY29uc3QgR2xvYmFsRW1pdHRlciA9IEVtaXR0ZXIucHJvdG90eXBlLmdldEdsb2JhbEVtaXR0ZXIoKTsiLCJcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBvYmplY3RcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIGV4dGVuc2lvbikge1xuICAgIG9iamVjdEVhY2goZXh0ZW5zaW9uLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RFYWNoKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmICghb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IChvYmplY3QuaGFzT3duUHJvcGVydHkgJiYgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGZ1bmN0aW9uXG5cbnZhciBfZW1wdHlGbiA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbi8qKlxuICog6I635Y+W56m65Ye95pWw44CCXG4gKiBAcGFyYW0gbmV3T25lIOm7mOiupCBgZmFsc2Vg77yM5b2T5Li6IGB0cnVlYCDml7blsIbov5Tlm57kuIDkuKrmlrDnmoTnqbrlh73mlbDjgIJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24obmV3T25lID0gZmFsc2UpIHtcbiAgICBpZiAobmV3T25lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZW1wdHlGbjtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHN0cmluZ1xuXG5cbmV4cG9ydCBmdW5jdGlvbiB1cHBlckNhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1cHBlckNhc2VGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXFMvZywgZiA9PiB1cHBlckNhc2UoZikpO1xufVxuXG5cblxuXG4vKipcbiAqIOeUn+aIkOS4gOS4qumVv+W6puS4uiAxNiDnmoTpmo/mnLrlrZfnrKbkuLJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nKCkge1xuICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiBzNCgpICsgczQoKSArIHM0KCkgKyBzNCgpO1xufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gbWl4ZWRcblxuLyoqXG4gKiDliKTmlq3mmK/lkKbkuLpg56m6YOWAvOOAglxuICogUFPvvJrmraTmlrnms5XnmoTliKTmlq3pgLvovpHkvZzkuLrljZXlhYPmoLzmmK/lkKbkuLrnqbrnmoTkvp3mja7jgIJcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKTtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGNvb3JkaW5hdGVcblxuXG52YXIgY19pc0VxdWFsID0gZnVuY3Rpb24gKHIxLCByMikge1xuICAgIHJldHVybiByMVswXSA9PT0gcjJbMF0gJiYgcjFbMV0gPT09IHIyWzFdICYmIHIxWzJdID09PSByMlsyXSAmJiByMVszXSA9PT0gcjJbM107XG59O1xuXG52YXIgY19pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgdmFyIHgxID0gTWF0aC5tYXgocjFbMF0sIHIyWzBdKTtcbiAgICB2YXIgeTEgPSBNYXRoLm1heChyMVsxXSwgcjJbMV0pO1xuICAgIHZhciB4MiA9IE1hdGgubWluKHIxWzJdLCByMlsyXSk7XG4gICAgdmFyIHkyID0gTWF0aC5taW4ocjFbM10sIHIyWzNdKTtcblxuICAgIGlmICh4MSA8PSB4MiAmJiB5MSA8PSB5Mikge1xuICAgICAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGNfc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHIxLCByMikge1xuICAgICAgICB2YXIgaW5zID0gY19pbnRlcnNlY3Rpb24ocjEsIHIyKTtcbiAgICAgICAgaWYgKGlucykge1xuICAgICAgICAgICAgcmV0dXJuIGNfaXNFcXVhbChpbnMsIHQgPT09ICdzdWInID8gcjEgOiByMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59O1xuXG5leHBvcnQgdmFyIENvb3JkaW5hdGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3lnZDmoIfojIPlm7QgcjEg5piv5ZCm5LiOIHIyIOebuOetieOAglxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHIxXG4gICAgICogQHBhcmFtIHtpbnR9IHIxWzBdIC0g5Z2Q5qCH6IyD5Zu0IHIxIOeahOi1t+Wni+ihjOWdkOagh1xuICAgICAqIEBwYXJhbSB7aW50fSByMVsxXSAtIOWdkOagh+iMg+WbtCByMSDnmoTotbflp4vliJflnZDmoIdcbiAgICAgKiBAcGFyYW0ge2ludH0gcjFbMl0gLSDlnZDmoIfojIPlm7QgcjEg55qE57uI5q2i6KGM5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtpbnR9IHIxWzNdIC0g5Z2Q5qCH6IyD5Zu0IHIxIOeahOe7iOatouWIl+WdkOagh1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHIyXG4gICAgICogQHBhcmFtIHtpbnR9IHIyWzBdIC0g5Z2Q5qCH6IyD5Zu0IHIyIOeahOi1t+Wni+ihjOWdkOagh1xuICAgICAqIEBwYXJhbSB7aW50fSByMlsxXSAtIOWdkOagh+iMg+WbtCByMiDnmoTotbflp4vliJflnZDmoIdcbiAgICAgKiBAcGFyYW0ge2ludH0gcjJbMl0gLSDlnZDmoIfojIPlm7QgcjIg55qE57uI5q2i6KGM5Z2Q5qCHXG4gICAgICogQHBhcmFtIHtpbnR9IHIyWzNdIC0g5Z2Q5qCH6IyD5Zu0IHIyIOeahOe7iOatouWIl+WdkOagh1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRXF1YWw6IGNfaXNFcXVhbCxcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbkuI4gcjIg5a2Y5Zyo5Lqk6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaW50ZXJzZWN0aW9uOiBjX2ludGVyc2VjdGlvbixcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbmmK8gcjIg55qE5a2Q6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdWJzZXQ6IGNfc2V0KCdzdWInKSxcblxuICAgIC8qKlxuICAgICAqIOWIpOaWreWdkOagh+iMg+WbtCByMSDmmK/lkKbmmK8gcjIg55qE6LaF6ZuG44CCXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdXBlcnNldDogY19zZXQoJ3N1cCcpXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIiwiaW1wb3J0IHt1cHBlckNhc2V9IGZyb20gJy4vY29tbW9uLmpzJ1xuXG4vKipcbiAqIOWkp+Wwj+WGmeS4jeaVj+aEn+eahCBNYXBcbiAqL1xuY2xhc3MgQ2FzZUluc2Vuc2l0aXZlTWFwIHtcblxuICAgIGNvbnN0cnVjdG9yKGl0ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoaXRlcmFibGUpO1xuICAgICAgICB0aGlzLl9rZXlzID0ge307XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICB2YXIgYWNLZXkgPSB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoYWNLZXkpO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2tleXNbdXBwZXJDYXNlKGtleSldID0ga2V5O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICB9XG5cbiAgICBoYXNFeGFjdChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fa2V5cyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICB2YXIgYWNLZXkgPSB0aGlzLl9rZXlzW3VwcGVyQ2FzZShrZXkpXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2tleXNbdXBwZXJDYXNlKGtleSldO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmRlbGV0ZShhY0tleSk7XG4gICAgfVxuXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gICAgfVxuXG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtJdGVyYXRvci48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgICB9XG5cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudmFsdWVzKCk7XG4gICAgfVxuXG4gICAgdG9NYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFN0YWNrXG4gKi9cbmNsYXNzIFN0YWNrIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsID0gW10pIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGluaXRpYWw7XG4gICAgfVxuXG4gICAgcHVzaCguLi5pdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgfVxuXG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdm9pZCAwIDogdGhpcy5pdGVtc1t0aGlzLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5zaXplKCk7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cblxufVxuXG5leHBvcnQge0Nhc2VJbnNlbnNpdGl2ZU1hcCwgU3RhY2t9O1xuXG4iLCJ2YXIgdGV4dENvbnRleHRTdXBwb3J0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKS50ZXh0Q29udGVudCA/IHRydWUgOiBmYWxzZTtcblxudmFyIFJFR19IVE1MX0NIQVJBQ1RFUlMgPSAvKDwoLiopPnwmKC4qKTspLztcblxuLyoqXG4gKiDog73lkIzml7blhbzlrrnmlofmnKzoioLngrnnmoQgaW5uZXJIVE1MIOaWueazleOAglxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5uZXJIVE1MKGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICBpZiAoUkVHX0hUTUxfQ0hBUkFDVEVSUy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gY29udGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBjaGlsZC5uZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRleHRDb250ZXh0U3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbXB0eShlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIOWcqOaMh+WumuiKgueCueWQjuaPkuWFpeiKgueCuVxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEBwYXJhbSBjb250ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRBZnRlcihlbGVtZW50LCBjb250ZW50KSB7XG4gICAgaWYgKFJFR19IVE1MX0NIQVJBQ1RFUlMudGVzdChjb250ZW50KSkge1xuICAgICAgICBlbGVtZW50Lmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJlbmQnLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29udGVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0O1xuICAgIGRvIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgKHJldCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiDmuIXnqbrmjIflrprlhYPntKDnmoTmiYDmnInlrZDoioLngrnjgIJcbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbGVtZW50KSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCA9IGVsZW1lbnQubGFzdENoaWxkKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8g5pqC5pe26L+Z5qC35aSE55CGIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU1OTU2MVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIOi/lOWbnuaMh+WumuWFg+e0oOeahOWklumrmOW6pu+8iOWMheaLrCBwYWRkaW5n44CBYm9yZGVyIOWPiuWPr+mAieeahCBtYXJnaW4g5YC877yJ44CCXG4gKlxuICogQHBhcmFtIGVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhNYXJnaW4gLSDpq5jluqbkuK3mmK/lkKbljIXmi6wgbWFyZ2luIOWAvFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVySGVpZ2h0KGVsLCB3aXRoTWFyZ2luID0gdHJ1ZSkge1xuICAgIHZhciBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIHN0eWxlO1xuXG4gICAgaWYgKHdpdGhNYXJnaW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgIHJldHVybiBoZWlnaHQ7XG59XG5cblxuLyoqXG4gKiDov5Tlm57mjIflrprlhYPntKDnmoTlpJblrr3luqbvvIjljIXmi6wgcGFkZGluZ+OAgWJvcmRlciDlj4rlj6/pgInnmoQgbWFyZ2luIOWAvO+8ieOAglxuICpcbiAqIEBwYXJhbSBlbFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoTWFyZ2luIC0g5a695bqm5Lit5piv5ZCm5YyF5ousIG1hcmdpbiDlgLxcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlcldpZHRoKGVsLCB3aXRoTWFyZ2luID0gdHJ1ZSkge1xuICAgIHZhciB3aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgIHZhciBzdHlsZTtcblxuICAgIGlmICh3aXRoTWFyZ2luID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgd2lkdGggKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCk7XG4gICAgcmV0dXJuIHdpZHRoO1xufVxuXG4iLCIvKipcbiAqIOmYu+atouWFtuWug+ebkeWQrOiiq+iwg+eUqOOAglxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCkge1xuICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiDpmLvmraLkuovku7blhpLms6HjgIJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cbn0iLCJ2YXIgYXJyYXlFYWNoID0gSGFuZHNvbnRhYmxlLmhlbHBlci5hcnJheUVhY2g7XG52YXIgZGVmaW5lR2V0dGVyID0gSGFuZHNvbnRhYmxlLmhlbHBlci5kZWZpbmVHZXR0ZXI7XG5cbmNvbnN0IE1JWElOX05BTUUgPSAnbG9jYWxIb29rcyc7XG5cbi8qKlxuICog55So5p2l5YGa5a+56LGh5o665ZKM55qEIGhvb2tzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmNvbnN0IGxvY2FsSG9va3MgPSB7XG5cbiAgICBfbG9jYWxIb29rczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIC8qKlxuICAgICAqIOWinuWKoCBob29rXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gaG9vayDlkI1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIOWbnuiwg1xuICAgICAqL1xuICAgIGFkZExvY2FsSG9vazogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEhvb2tzW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsSG9va3Nba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvY2FsSG9va3Nba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICog5omn6KGMIGhvb2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gaG9vayDlkI1cbiAgICAgKiBAcGFyYW0geyp9IHBhcmFtc1xuICAgICAqL1xuICAgIHJ1bkxvY2FsSG9va3M6IGZ1bmN0aW9uIChrZXksIC4uLnBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxIb29rc1trZXldKSB7XG4gICAgICAgICAgICBhcnJheUVhY2godGhpcy5fbG9jYWxIb29rc1trZXldLCAoY2FsbGJhY2spID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOa4heepuiBob29rc1xuICAgICAqL1xuICAgIGNsZWFyTG9jYWxIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2NhbEhvb2tzID0ge307XG4gICAgfVxufTtcblxuZGVmaW5lR2V0dGVyKGxvY2FsSG9va3MsICdNSVhJTl9OQU1FJywgTUlYSU5fTkFNRSwge1xuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGxvY2FsSG9va3M7Il19
